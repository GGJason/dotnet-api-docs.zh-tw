<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3cc03d2b251007a09fa2c78bb363cc33a277f8d" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52244807" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f1118-101">表示應用程式定義域，也就是應用程式執行的獨立環境。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f1118-101">Represents an application domain, which is an isolated environment where applications execute.</span>
      </span>
      <span data-ttu-id="f1118-102">這個類別無法被繼承。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f1118-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-103">應用程式定義域，由<xref:System.AppDomain>物件，可協助提供隔離、 卸載和安全性界限執行 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-103">Application domains, which are represented by <xref:System.AppDomain> objects, help provide isolation, unloading, and security boundaries for executing managed code.</span></span>  
  
-   <span data-ttu-id="f1118-104">您可以使用應用程式定義域來隔離可能會使處理序的工作。</span><span class="sxs-lookup"><span data-stu-id="f1118-104">Use application domains to isolate tasks that might bring down a process.</span></span> <span data-ttu-id="f1118-105">如果狀態<xref:System.AppDomain>，正在執行的工作變得不穩定，<xref:System.AppDomain>即可予以卸載而不會影響此程序。</span><span class="sxs-lookup"><span data-stu-id="f1118-105">If the state of the <xref:System.AppDomain> that's executing a task becomes unstable, the <xref:System.AppDomain> can be unloaded without affecting the process.</span></span> <span data-ttu-id="f1118-106">當長時間執行的處理序，必須將它不需要重新啟動時，這很重要。</span><span class="sxs-lookup"><span data-stu-id="f1118-106">This is important when a process must run for long periods without restarting.</span></span> <span data-ttu-id="f1118-107">您也可以使用應用程式定義域來隔離不應共用資料的工作。</span><span class="sxs-lookup"><span data-stu-id="f1118-107">You can also use application domains to isolate tasks that should not share data.</span></span>  
  
-   <span data-ttu-id="f1118-108">如果組件載入至預設應用程式定義域時，它不能從記憶體卸載的情況，而處理序正在執行。</span><span class="sxs-lookup"><span data-stu-id="f1118-108">If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</span></span> <span data-ttu-id="f1118-109">不過，如果您開啟以載入和執行組件的第二個應用程式定義域時，組件會卸載該應用程式定義域卸載時。</span><span class="sxs-lookup"><span data-stu-id="f1118-109">However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</span></span> <span data-ttu-id="f1118-110">您可以使用這項技巧來減少有時候使用大型的 Dll 的長時間執行處理序的工作集。</span><span class="sxs-lookup"><span data-stu-id="f1118-110">Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</span></span>  
  
 <span data-ttu-id="f1118-111">多個應用程式定義域可以單一處理序中執行;不過，沒有應用程式定義域和執行緒之間的一對一關聯性。</span><span class="sxs-lookup"><span data-stu-id="f1118-111">Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="f1118-112">數個執行緒可以隸屬於單一應用程式網域，而且雖然之給定的執行緒並不侷限於單一應用程式網域，在任何時候，執行緒會執行單一應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-112">Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</span></span>  
  
 <span data-ttu-id="f1118-113">使用建立應用程式定義域<xref:System.AppDomain.CreateDomain%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-113">Application domains are created using the <xref:System.AppDomain.CreateDomain%2A> method.</span></span> <span data-ttu-id="f1118-114"><xref:System.AppDomain> 執行個體用來載入和執行組件 (<xref:System.Reflection.Assembly>)。</span><span class="sxs-lookup"><span data-stu-id="f1118-114"><xref:System.AppDomain> instances are used to load and execute assemblies (<xref:System.Reflection.Assembly>).</span></span> <span data-ttu-id="f1118-115">當<xref:System.AppDomain>已不再使用中，它可以卸載。</span><span class="sxs-lookup"><span data-stu-id="f1118-115">When an <xref:System.AppDomain> is no longer in use, it can be unloaded.</span></span>  
  
 <span data-ttu-id="f1118-116"><xref:System.AppDomain>類別會實作一組可讓應用程式在載入組件，應用程式定義域將會卸載，或擲回未處理的例外狀況時回應的事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-116">The <xref:System.AppDomain> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</span></span>  
  
 <span data-ttu-id="f1118-117">如需有關如何使用應用程式定義域的詳細資訊，請參閱 <<c0> [ 應用程式定義域](~/docs/framework/app-domains/application-domains.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-117">For more information on using application domains, see [Application Domains](~/docs/framework/app-domains/application-domains.md).</span></span>  
  
 <span data-ttu-id="f1118-118">這個類別會實作<xref:System.MarshalByRefObject>， <xref:System._AppDomain>，和<xref:System.Security.IEvidenceFactory>介面。</span><span class="sxs-lookup"><span data-stu-id="f1118-118">This class implements the <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, and <xref:System.Security.IEvidenceFactory> interfaces.</span></span>  
  
 <span data-ttu-id="f1118-119">您應該永遠不會建立可遠端處理包裝函式<xref:System.AppDomain>物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-119">You should never create a remotable wrapper for an <xref:System.AppDomain> object.</span></span> <span data-ttu-id="f1118-120">如此一來，無法發行的遠端參考<xref:System.AppDomain>，例如公開方法<xref:System.AppDomain.CreateInstance%2A>遠端存取並有效地終結該的 程式碼存取安全性<xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="f1118-120">Doing so could publish a remote reference to that <xref:System.AppDomain>, exposing methods such as <xref:System.AppDomain.CreateInstance%2A> to remote access and effectively destroying code access security for that <xref:System.AppDomain>.</span></span> <span data-ttu-id="f1118-121">惡意用戶端連接到遠端<xref:System.AppDomain>無法存取任何資源<xref:System.AppDomain>本身具有存取權。</span><span class="sxs-lookup"><span data-stu-id="f1118-121">Malicious clients connecting to the remoted <xref:System.AppDomain> could obtain access to any resource the <xref:System.AppDomain> itself has access to.</span></span> <span data-ttu-id="f1118-122">不會建立可遠端處理的包裝函式延伸任何型別的<xref:System.MarshalByRefObject>和實作可能遭到惡意用戶端用來略過安全性系統的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-122">Do not create remotable wrappers for any type that extends <xref:System.MarshalByRefObject> and that implements methods that could be used by malicious clients to bypass the security system.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f1118-123">預設值<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>屬性是`false`。</span><span class="sxs-lookup"><span data-stu-id="f1118-123">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> property is `false`.</span></span> <span data-ttu-id="f1118-124">此設定是不安全的服務。</span><span class="sxs-lookup"><span data-stu-id="f1118-124">This setting is unsafe for services.</span></span> <span data-ttu-id="f1118-125">若要避免服務下載部分信任程式碼，請將此屬性設定為`true`。</span><span class="sxs-lookup"><span data-stu-id="f1118-125">To prevent services from downloading partially trusted code, set this property to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-126">此範例示範如何建立新<xref:System.AppDomain>，具現化型別中的新<xref:System.AppDomain>，並與該類型的物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-126">This example shows how to create a new <xref:System.AppDomain>, instantiate a type in that new <xref:System.AppDomain>, and communicate with that type’s object.</span></span> <span data-ttu-id="f1118-127">此外，此範例示範如何卸載<xref:System.AppDomain>造成要進行記憶體回收的物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-127">In addition, this example shows how to unload the <xref:System.AppDomain> causing the object to be garbage collected.</span></span>  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">
      <span data-ttu-id="f1118-128">如何： 設定應用程式定義域</span>
      <span class="sxs-lookup">
        <span data-stu-id="f1118-128">How To: Configure an Application Domain</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba">
      <span data-ttu-id="f1118-129">如何： 建立應用程式定義域</span>
      <span class="sxs-lookup">
        <span data-stu-id="f1118-129">How To: Create an Application Domain</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9">
      <span data-ttu-id="f1118-130">如何：將組件載入應用程式定義域</span>
      <span class="sxs-lookup">
        <span data-stu-id="f1118-130">How to: Load Assemblies into an Application Domain</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192">
      <span data-ttu-id="f1118-131">如何：卸載應用程式定義域</span>
      <span class="sxs-lookup">
        <span data-stu-id="f1118-131">How to: Unload an Application Domain</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-132">取得目前應用程式定義域的啟動內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-132">Gets the activation context for the current application domain.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-133">物件，表示目前應用程式定義域的啟動內容，如果此定義域沒有任何啟動內容，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-133">An object that represents the activation context for the current application domain, or <see langword="null" /> if the domain has no activation context.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-134">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-134">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-135">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-135">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f1118-136">要附加到私用路徑的目錄名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-136">The name of the directory to be appended to the private path.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-137">將指定的目錄名稱附加至私用 (Private) 路徑清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-137">Appends the specified directory name to the private path list.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-138">不建議使用這個屬性，因為它們已經被載入之後，它可能會針對組件變更探查的路徑。</span><span class="sxs-lookup"><span data-stu-id="f1118-138">The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</span></span> <span data-ttu-id="f1118-139">請改用 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-139">Use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="f1118-140">私用的路徑或相對搜尋路徑是相對於組件解析程式其中探查私用組件的基底目錄路徑。</span><span class="sxs-lookup"><span data-stu-id="f1118-140">The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-141">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-141">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-142">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-142">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-143">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-143">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-144">取得應用程式定義域中的應用程式之識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-144">Gets the identity of the application in the application domain.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-145">物件，可識別應用程式定義域中的應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-145">An object that identifies the application in the application domain.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-146">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-146">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-147">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-147">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-148">取得資訊，以描述授與應用程式的權限，以及該應用程式是否有允許其執行的信任層級。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-148">Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-149">物件，可針對應用程式定義域中的應用程式來封裝使用權限和信任資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-149">An object that encapsulates permission and trust information for the application in the application domain.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-150">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-150">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-151">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-151">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-152">組件的顯示名稱，其格式為 <see cref="P:System.Reflection.Assembly.FullName" /> 屬性所提供。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-152">The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-153">在套用原則之後傳回組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-153">Returns the assembly display name after policy has been applied.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-154">一個字串，其中包含套用原則之後的組件顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-154">A string containing the assembly display name after policy has been applied.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-155"><xref:System.AppDomain.ApplyPolicy%2A>方法會採用組件的顯示名稱，並傳回原則後顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-155">The <xref:System.AppDomain.ApplyPolicy%2A> method takes an assembly display name and returns the post-policy display name.</span></span> <span data-ttu-id="f1118-156">這非常有用，如果您要載入組件使用 「 原則 」，因為僅限反映的內容不會套用原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-156">This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-157">發生於載入組件時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-157">Occurs when an assembly is loaded.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-158"><xref:System.AssemblyLoadEventHandler>委派這個事件表示哪些組件已載入。</span><span class="sxs-lookup"><span data-stu-id="f1118-158">The <xref:System.AssemblyLoadEventHandler> delegate for this event indicates what assembly was loaded.</span></span>  
  
 <span data-ttu-id="f1118-159">若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-159">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="f1118-160">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-160">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-161">下列範例會示範<xref:System.AppDomain.AssemblyLoad>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-161">The following sample demonstrates the <xref:System.AppDomain.AssemblyLoad> event.</span></span>  
  
 <span data-ttu-id="f1118-162">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-162">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-163">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-163">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-164">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-164">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-165">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-165">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-166">發生於組件解析失敗時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-166">Occurs when the resolution of an assembly fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-167">它負責<xref:System.ResolveEventHandler>傳回組件中所指定此事件<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性，或傳回 null，如果無法辨識的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-167">It is the responsibility of the <xref:System.ResolveEventHandler> for this event to return the assembly that is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property, or to return null if the assembly is not recognized.</span></span> <span data-ttu-id="f1118-168">組件必須載入到執行內容;如果載入僅限反映的內容時，會引發這個事件的負載將會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-168">The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</span></span>  
  
 <span data-ttu-id="f1118-169">如需使用這個事件的指引，請參閱 <<c0> [ 解析組件載入](~/docs/framework/app-domains/resolve-assembly-loads.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-169">For guidance on the use of this event, see [Resolving Assembly Loads](~/docs/framework/app-domains/resolve-assembly-loads.md).</span></span>  
  
 <span data-ttu-id="f1118-170">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性會傳回要求無法解析組件載入的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-170">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="f1118-171">例如，載入器可能無法載入要求的組件的相依性，因為要求的組件和其相依性不在探查路徑。</span><span class="sxs-lookup"><span data-stu-id="f1118-171">For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</span></span> <span data-ttu-id="f1118-172">了解要求的組件的識別可能有助於在尋找相依性，或找出正確的版本中，如果使用多個版本的相依性。</span><span class="sxs-lookup"><span data-stu-id="f1118-172">Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</span></span> <span data-ttu-id="f1118-173">如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-173">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f1118-174">開頭[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，則<xref:System.ResolveEventHandler>所有組件，包括資源組件都會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-174">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the <xref:System.ResolveEventHandler> event is raised for all assemblies, including resource assemblies.</span></span> <span data-ttu-id="f1118-175">在舊版中，資源組件不引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-175">In earlier versions, the event was not raised for resource assemblies.</span></span> <span data-ttu-id="f1118-176">如果當地語系化的作業系統，可能會呼叫處理常式多次： 每個文化特性後援鏈結中的一次。</span><span class="sxs-lookup"><span data-stu-id="f1118-176">If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</span></span>  
  
 <span data-ttu-id="f1118-177">對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>套用原則之前，屬性會傳回組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-177">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f1118-178">如果此事件註冊一個以上的事件處理常式，事件 handlersarecalled，直到事件處理常式的傳回值的順序，不是`null`。</span><span class="sxs-lookup"><span data-stu-id="f1118-178">If more than one event handler is registered for this event, the event handlersarecalled in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="f1118-179">後續的事件處理常式會被忽略。</span><span class="sxs-lookup"><span data-stu-id="f1118-179">Subsequent event handlers are ignored.</span></span>  
  
 <span data-ttu-id="f1118-180">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-180">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-181">下列範例會示範<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-181">The following sample demonstrates the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-182">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-182">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-183">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-183">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-184">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-184">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-185">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-185">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a">
          <span data-ttu-id="f1118-186">解析組件載入</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-186">Resolving Assembly Loads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-187">取得組件解析程式 (Resolver) 用來探查組件的基底目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-187">Gets the base directory that the assembly resolver uses to probe for assemblies.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-188">組件解析程式用來探查組件的基底目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-188">The base directory that the assembly resolver uses to probe for assemblies.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-189">此屬性會對應至<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-189">This property corresponds to the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f1118-190">它也可以擷取使用<xref:System.AppDomain.GetData%2A>與字串"APPBASE"的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-190">It can also be retrieved using the <xref:System.AppDomain.GetData%2A> method with the string "APPBASE".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-191">下列程式碼範例會建立新的應用程式定義域，指定要載入定義域時搜尋組件使用的基底目錄。</span><span class="sxs-lookup"><span data-stu-id="f1118-191">The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</span></span> <span data-ttu-id="f1118-192">然後此範例使用<xref:System.AppDomain.BaseDirectory%2A>屬性取得的基底目錄路徑，顯示到主控台。</span><span class="sxs-lookup"><span data-stu-id="f1118-192">The example then uses the <xref:System.AppDomain.BaseDirectory%2A> property to obtain the base directory path, for display to the console.</span></span>  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-193">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-193">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-194">存取路徑本身中的資訊，包括如果路徑的格式為"file:// 或\\\UNC\dir 或"c:\\"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-194">for access to the information in the path itself, including if the path is in the form "file://" or \\\UNC\dir or "c:\\".</span>
          </span>
          <span data-ttu-id="f1118-195">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-195">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-196">將指定私用組件位置的路徑重設為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-196">Resets the path that specifies the location of private assemblies to the empty string ("").</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-197">私用路徑是相對於 common language runtime 會搜尋來尋找私用組件的基底目錄路徑。</span><span class="sxs-lookup"><span data-stu-id="f1118-197">The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</span></span>  
  
 <span data-ttu-id="f1118-198">如需詳細資訊，請參閱<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-198">For more information, see <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-199">下列程式碼範例示範如何使用<xref:System.AppDomain.ClearPrivatePath%2A>方法，以從載入的組件時所要搜尋的私用路徑的清單中移除所有項目。</span><span class="sxs-lookup"><span data-stu-id="f1118-199">The following code example demonstrates how to use the <xref:System.AppDomain.ClearPrivatePath%2A> method to remove all entries from the list of private paths to search when assemblies are loaded.</span></span>  
  
 <span data-ttu-id="f1118-200">此方法現已淘汰，並不應該用於新的開發。</span><span class="sxs-lookup"><span data-stu-id="f1118-200">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-201">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-201">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-202">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-202">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-203">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-203">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-204">將含有陰影複製的組件目錄清單重設為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-204">Resets the list of directories containing shadow copied assemblies to the empty string ("").</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-205">陰影複製路徑是儲存的陰影複製組件的所在的目錄清單。</span><span class="sxs-lookup"><span data-stu-id="f1118-205">The shadow copy path is a list of directories where shadow copied assemblies are stored.</span></span>  
  
 <span data-ttu-id="f1118-206">如需詳細資訊，請參閱 <<c0> <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> 並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-206">For more information, see <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-207">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-207">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-208">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-208">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-209">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-209">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">
          <span data-ttu-id="f1118-210">陰影複製組件</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-210">Shadow Copying Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-211">建立指定 COM 類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-211">Creates a new instance of a specified COM type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-212">檔案的名稱，此檔案包含定義要求類型的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-212">The name of a file containing an assembly that defines the requested type.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-213">要求類型的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-213">The name of the requested type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-214">建立指定 COM 類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-214">Creates a new instance of a specified COM type.</span>
          </span>
          <span data-ttu-id="f1118-215">指定包含組件 (包含類型和類型名稱) 之檔案名稱的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-215">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-216">物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-216">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span>
          </span>
          <span data-ttu-id="f1118-217">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-217">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-218">使用這個方法，從遠端建立物件，而不需要載入在本機的型別。</span><span class="sxs-lookup"><span data-stu-id="f1118-218">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="f1118-219">傳回的值必須解除包裝以存取實際物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-219">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="f1118-220">A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須套用明確或預設為 COM 型別，此方法來建立該類型; 的執行個體，否則為<xref:System.TypeLoadException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-220">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-221">下列範例會示範</span><span class="sxs-lookup"><span data-stu-id="f1118-221">The following sample demonstrates</span></span>  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-222">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-222">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-223">無法載入這個類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-223">The type cannot be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-224">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-224">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-225">找不到無參數的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-225">No public parameterless constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-226">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-226">
              <paramref name="assemblyName" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="f1118-227">
            <paramref name="typeName" />這是抽象類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-227">
              <paramref name="typeName" /> is an abstract class.</span>
          </span>
          <span data-ttu-id="f1118-228">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-228">-or-</span>
          </span>
          <span data-ttu-id="f1118-229">這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-229">This member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-230">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-230">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-231">
            <paramref name="assemblyName" /> 為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-231">
              <paramref name="assemblyName" /> is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-232">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-232">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-233">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-233">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-234">所要參考的 COM 物件為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-234">The COM object that is being referred to is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-235">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-235">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-236">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-236">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-237">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-237">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-238">檔案的名稱，此檔案包含定義要求類型的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-238">The name of a file containing an assembly that defines the requested type.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-239">要求類型的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-239">The name of the requested type.</span>
          </span>
        </param>
        <param name="hashValue">
          <span data-ttu-id="f1118-240">表示計算出來的雜湊碼的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-240">Represents the value of the computed hash code.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="f1118-241">表示組件資訊清單所使用的雜湊演算法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-241">Represents the hash algorithm used by the assembly manifest.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-242">建立指定 COM 類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-242">Creates a new instance of a specified COM type.</span>
          </span>
          <span data-ttu-id="f1118-243">指定包含組件 (包含類型和類型名稱) 之檔案名稱的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-243">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-244">物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-244">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span>
          </span>
          <span data-ttu-id="f1118-245">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-245">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-246">使用這個方法，從遠端建立物件，而不需要載入在本機的型別。</span><span class="sxs-lookup"><span data-stu-id="f1118-246">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="f1118-247">傳回的值必須解除包裝以存取實際物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-247">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="f1118-248">A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>屬性的值`true`必須套用明確或預設為 COM 型別，此方法來建立該類型; 的執行個體，否則為<xref:System.TypeLoadException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-248">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-249">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-249">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-250">無法載入這個類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-250">The type cannot be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-251">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-251">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-252">找不到無參數的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-252">No public parameterless constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-253">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-253">
              <paramref name="assemblyFile" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="f1118-254">
            <paramref name="typeName" />這是抽象類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-254">
              <paramref name="typeName" /> is an abstract class.</span>
          </span>
          <span data-ttu-id="f1118-255">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-255">-or-</span>
          </span>
          <span data-ttu-id="f1118-256">這個成員曾被晚期繫結機制叫用過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-256">This member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-257">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-257">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-258">
            <paramref name="assemblyFile" /> 為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-258">
              <paramref name="assemblyFile" /> is the empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-259">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-259">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-260">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-260">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-261">所要參考的 COM 物件為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-261">The COM object that is being referred to is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-262">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-262">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-263">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-263">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-264">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-264">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-265">建立新的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-265">Creates a new application domain.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">
          <span data-ttu-id="f1118-266">定義域的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-266">The friendly name of the domain.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-267">建立具有指定名稱的新應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-267">Creates a new application domain with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-268">新建立的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-268">The newly created application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-269">`friendlyName`參數要識別網域是讓人有意義的方式。</span><span class="sxs-lookup"><span data-stu-id="f1118-269">The `friendlyName` parameter is intended to identify the domain in a manner that is meaningful to humans.</span></span> <span data-ttu-id="f1118-270">此字串應該是適合在使用者介面中顯示。</span><span class="sxs-lookup"><span data-stu-id="f1118-270">This string should be suitable for display in user interfaces.</span></span>  
  
 <span data-ttu-id="f1118-271">這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。</span><span class="sxs-lookup"><span data-stu-id="f1118-271">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-272">下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-272">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-273">
            <paramref name="friendlyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-273">
              <paramref name="friendlyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-274">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-274">to provide evidence.</span>
          </span>
          <span data-ttu-id="f1118-275">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-275">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">
          <span data-ttu-id="f1118-276">定義域的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-276">The friendly name of the domain.</span>
          </span>
          <span data-ttu-id="f1118-277">這個易記名稱可以在使用者介面中顯示以識別該定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-277">This friendly name can be displayed in user interfaces to identify the domain.</span>
          </span>
          <span data-ttu-id="f1118-278">如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-278">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span>
          </span>
        </param>
        <param name="securityInfo">
          <span data-ttu-id="f1118-279">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-279">Evidence that establishes the identity of the code that runs in the application domain.</span>
          </span>
          <span data-ttu-id="f1118-280">傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-280">Pass <see langword="null" /> to use the evidence of the current application domain.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-281">使用提供的辨識項，建立具有指定名稱的新應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-281">Creates a new application domain with the given name using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-282">新建立的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-282">The newly created application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-283">這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。</span><span class="sxs-lookup"><span data-stu-id="f1118-283">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="f1118-284">如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。</span><span class="sxs-lookup"><span data-stu-id="f1118-284">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f1118-285">請勿使用這個方法多載來建立沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-285">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="f1118-286">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。</span><span class="sxs-lookup"><span data-stu-id="f1118-286">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="f1118-287">使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-287">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-288">下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-288">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-289">
            <paramref name="friendlyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-289">
              <paramref name="friendlyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-290">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-290">to provide evidence.</span>
          </span>
          <span data-ttu-id="f1118-291">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-291">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">
          <span data-ttu-id="f1118-292">定義域的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-292">The friendly name of the domain.</span>
          </span>
          <span data-ttu-id="f1118-293">這個易記名稱可以在使用者介面中顯示以識別該定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-293">This friendly name can be displayed in user interfaces to identify the domain.</span>
          </span>
          <span data-ttu-id="f1118-294">如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-294">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span>
          </span>
        </param>
        <param name="securityInfo">
          <span data-ttu-id="f1118-295">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-295">Evidence that establishes the identity of the code that runs in the application domain.</span>
          </span>
          <span data-ttu-id="f1118-296">傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-296">Pass <see langword="null" /> to use the evidence of the current application domain.</span>
          </span>
        </param>
        <param name="info">
          <span data-ttu-id="f1118-297">物件，包含應用程式定義域初始化資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-297">An object that contains application domain initialization information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-298">使用指定名稱、辨識項和應用程式定義域安裝資訊，建立新的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-298">Creates a new application domain using the specified name, evidence, and application domain setup information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-299">新建立的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-299">The newly created application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-300">如果`info`是未提供，這個方法多載會使用<xref:System.AppDomainSetup>從預設應用程式定義域的資訊。</span><span class="sxs-lookup"><span data-stu-id="f1118-300">If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="f1118-301">如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。</span><span class="sxs-lookup"><span data-stu-id="f1118-301">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f1118-302">請勿使用這個方法多載來建立沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-302">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="f1118-303">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。</span><span class="sxs-lookup"><span data-stu-id="f1118-303">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="f1118-304">使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-304">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-305">下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-305">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-306">
            <paramref name="friendlyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-306">
              <paramref name="friendlyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-307">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-307">to provide evidence.</span>
          </span>
          <span data-ttu-id="f1118-308">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-308">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">
          <span data-ttu-id="f1118-309">定義域的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-309">The friendly name of the domain.</span>
          </span>
          <span data-ttu-id="f1118-310">這個易記名稱可以在使用者介面中顯示以識別該定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-310">This friendly name can be displayed in user interfaces to identify the domain.</span>
          </span>
          <span data-ttu-id="f1118-311">如需詳細資訊，請參閱 <see cref="P:System.AppDomain.FriendlyName" /> 的說明。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-311">For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</span>
          </span>
        </param>
        <param name="securityInfo">
          <span data-ttu-id="f1118-312">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-312">Evidence that establishes the identity of the code that runs in the application domain.</span>
          </span>
          <span data-ttu-id="f1118-313">傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-313">Pass <see langword="null" /> to use the evidence of the current application domain.</span>
          </span>
        </param>
        <param name="info">
          <span data-ttu-id="f1118-314">物件，包含應用程式定義域初始化資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-314">An object that contains application domain initialization information.</span>
          </span>
        </param>
        <param name="grantSet">
          <span data-ttu-id="f1118-315">預設使用權限集合，其授與給載入無特定授權的新應用程式定義域中的所有組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-315">A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</span>
          </span>
        </param>
        <param name="fullTrustAssemblies">
          <span data-ttu-id="f1118-316">強式名稱的陣列，表示在新的應用程式定義域中視為完全信任的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-316">An array of strong names representing assemblies to be considered fully trusted in the new application domain.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-317">使用指定之名稱、辨識項、應用程式定義域設定資訊、預設權限集合及完全信任的組件陣列，建立新的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-317">Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-318">新建立的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-318">The newly created application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-319">您必須設定<xref:System.AppDomainSetup.ApplicationBase%2A>的屬性<xref:System.AppDomainSetup>物件，為您提供`info`。</span><span class="sxs-lookup"><span data-stu-id="f1118-319">You must set the <xref:System.AppDomainSetup.ApplicationBase%2A> property of the <xref:System.AppDomainSetup> object that you supply for `info`.</span></span> <span data-ttu-id="f1118-320">否則，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-320">Otherwise, an exception is thrown.</span></span>  
  
 <span data-ttu-id="f1118-321">如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。</span><span class="sxs-lookup"><span data-stu-id="f1118-321">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="f1118-322">提供的資訊`grantSet`並`fullTrustAssemblies`用來建立<xref:System.Security.Policy.ApplicationTrust>新的應用程式定義域的物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-322">The information provided for `grantSet` and `fullTrustAssemblies` is used to create an <xref:System.Security.Policy.ApplicationTrust> object for the new application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-323">
            <paramref name="friendlyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-323">
              <paramref name="friendlyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f1118-324">應用程式定義域為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-324">The application domain is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-325">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-325">-or-</span>
          </span>
          <span data-ttu-id="f1118-326">未在提供給 <paramref name="info" /> 的 <see cref="P:System.AppDomainSetup.ApplicationBase" /> 物件上設定 <see cref="T:System.AppDomainSetup" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-326">The <see cref="P:System.AppDomainSetup.ApplicationBase" /> property is not set on the <see cref="T:System.AppDomainSetup" /> object that is supplied for <paramref name="info" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-327">提供建立及管理應用程式定義域的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-327">for the ability to create and manipulate an application domain.</span>
          </span>
          <span data-ttu-id="f1118-328">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-328">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span>
          </span>
          <span data-ttu-id="f1118-329">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-329">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">
          <span data-ttu-id="f1118-330">定義域的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-330">The friendly name of the domain.</span>
          </span>
          <span data-ttu-id="f1118-331">這個易記名稱可以在使用者介面中顯示以識別該定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-331">This friendly name can be displayed in user interfaces to identify the domain.</span>
          </span>
          <span data-ttu-id="f1118-332">如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-332">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span>
          </span>
        </param>
        <param name="securityInfo">
          <span data-ttu-id="f1118-333">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-333">Evidence that establishes the identity of the code that runs in the application domain.</span>
          </span>
          <span data-ttu-id="f1118-334">傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-334">Pass <see langword="null" /> to use the evidence of the current application domain.</span>
          </span>
        </param>
        <param name="appBasePath">
          <span data-ttu-id="f1118-335">組件解析程式用來探查組件的基底目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-335">The base directory that the assembly resolver uses to probe for assemblies.</span>
          </span>
          <span data-ttu-id="f1118-336">如需詳細資訊，請參閱<see cref="P:System.AppDomain.BaseDirectory" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-336">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span>
          </span>
        </param>
        <param name="appRelativeSearchPath">
          <span data-ttu-id="f1118-337">相對於組件解析程式應該探查私用組件之基底目錄的路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-337">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span>
          </span>
          <span data-ttu-id="f1118-338">如需詳細資訊，請參閱<see cref="P:System.AppDomain.RelativeSearchPath" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-338">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span>
          </span>
        </param>
        <param name="shadowCopyFiles">
          <span data-ttu-id="f1118-339">如果為 <see langword="true" />，則會將組件的陰影複本載入這個應用程式定義域中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-339">If <see langword="true" />, a shadow copy of an assembly is loaded into this application domain.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-340">使用辨識項、應用程式基底路徑、相對搜尋路徑和指定是否要將組件的陰影複本載入應用程式定義域的參數，建立具有指定名稱的新應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-340">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-341">新建立的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-341">The newly created application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-342">如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。</span><span class="sxs-lookup"><span data-stu-id="f1118-342">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="f1118-343">如需陰影複製的詳細資訊，請參閱<xref:System.AppDomain.ShadowCopyFiles%2A>並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-343">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f1118-344">請勿使用這個方法多載來建立沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-344">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="f1118-345">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。</span><span class="sxs-lookup"><span data-stu-id="f1118-345">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="f1118-346">使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-346">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-347">下列範例示範，在一般情況下，如何建立使用其中一種網域<xref:System.AppDomain.CreateDomain%2A>多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-347">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-348">
            <paramref name="friendlyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-348">
              <paramref name="friendlyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-349">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-349">to provide evidence.</span>
          </span>
          <span data-ttu-id="f1118-350">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-350">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">
          <span data-ttu-id="f1118-351">定義域的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-351">The friendly name of the domain.</span>
          </span>
          <span data-ttu-id="f1118-352">這個易記名稱可以在使用者介面中顯示以識別該定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-352">This friendly name can be displayed in user interfaces to identify the domain.</span>
          </span>
          <span data-ttu-id="f1118-353">如需詳細資訊，請參閱<see cref="P:System.AppDomain.FriendlyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-353">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span>
          </span>
        </param>
        <param name="securityInfo">
          <span data-ttu-id="f1118-354">辨識項，可建立能在應用程式定義域內執行之程式碼的識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-354">Evidence that establishes the identity of the code that runs in the application domain.</span>
          </span>
          <span data-ttu-id="f1118-355">傳遞 <see langword="null" /> 可使用目前應用程式定義域的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-355">Pass <see langword="null" /> to use the evidence of the current application domain.</span>
          </span>
        </param>
        <param name="appBasePath">
          <span data-ttu-id="f1118-356">組件解析程式用來探查組件的基底目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-356">The base directory that the assembly resolver uses to probe for assemblies.</span>
          </span>
          <span data-ttu-id="f1118-357">如需詳細資訊，請參閱<see cref="P:System.AppDomain.BaseDirectory" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-357">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span>
          </span>
        </param>
        <param name="appRelativeSearchPath">
          <span data-ttu-id="f1118-358">相對於組件解析程式應該探查私用組件之基底目錄的路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-358">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span>
          </span>
          <span data-ttu-id="f1118-359">如需詳細資訊，請參閱<see cref="P:System.AppDomain.RelativeSearchPath" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-359">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span>
          </span>
        </param>
        <param name="shadowCopyFiles">
          <span data-ttu-id="f1118-360">
            <see langword="true" /> 表示將組件的陰影複本載入到應用程式定義域中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-360">
              <see langword="true" /> to load a shadow copy of an assembly into the application domain.</span>
          </span>
        </param>
        <param name="adInit">
          <span data-ttu-id="f1118-361">
            <see cref="T:System.AppDomainInitializer" /> 委派，表示當初始化新的 <see cref="T:System.AppDomain" /> 物件時所叫用的回呼方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-361">An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</span>
          </span>
        </param>
        <param name="adInitArgs">
          <span data-ttu-id="f1118-362">當初始化新的 <see cref="T:System.AppDomain" /> 物件時，要傳遞給由 <paramref name="adInit" /> 代表的回呼之字串引數陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-362">An array of string arguments to be passed to the callback represented by <paramref name="adInit" />, when the new <see cref="T:System.AppDomain" /> object is initialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-363">使用辨識項、應用程式基底路徑、相對搜尋路徑和指定是否要將組件的陰影複本載入應用程式定義域的參數，建立具有指定名稱的新應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-363">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span>
          </span>
          <span data-ttu-id="f1118-364">指定當初始化應用程式定義域時所叫用的回呼方法，以及要傳遞給該回呼方法的字串引數陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-364">Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-365">新建立的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-365">The newly created application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-366">所表示之方法`adInit`新建立的應用程式定義域的內容中執行。</span><span class="sxs-lookup"><span data-stu-id="f1118-366">The method represented by `adInit` is executed in the context of the newly created application domain.</span></span>  
  
 <span data-ttu-id="f1118-367">如果`securityInfo`是未提供，會使用目前的應用程式定義域的辨識項。</span><span class="sxs-lookup"><span data-stu-id="f1118-367">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="f1118-368">如需陰影複製的詳細資訊，請參閱<xref:System.AppDomain.ShadowCopyFiles%2A>並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-368">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f1118-369">請勿使用這個方法多載來建立沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-369">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="f1118-370">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，所提供的辨識項`securityInfo`不會再影響應用程式定義域的授權集。</span><span class="sxs-lookup"><span data-stu-id="f1118-370">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="f1118-371">使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>方法多載來建立沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-371">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-372">
            <paramref name="friendlyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-372">
              <paramref name="friendlyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-373">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-373">to provide evidence.</span>
          </span>
          <span data-ttu-id="f1118-374">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-374">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-375">建立在指定組件中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-375">Creates a new instance of a specified type defined in a specified assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-376">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-376">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-377">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-377">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-378">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-378">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-379">建立指定組件中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-379">Creates a new instance of the specified type defined in the specified assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-380">物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-380">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span>
          </span>
          <span data-ttu-id="f1118-381">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-381">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-382">這個方法會呼叫預設建構函式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-382">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="f1118-383">請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-383">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="f1118-384">嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-384">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="f1118-385">由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-385">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="f1118-386">載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-386">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-387">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-387">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-388">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-388">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-389">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-389">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-390">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-390">-or-</span>
          </span>
          <span data-ttu-id="f1118-391">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-391">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-392">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-392">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-393">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-393">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-394">呼叫端沒有呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-394">The caller does not have permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-395">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-395">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-396">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-396">
              <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-397">這個執行個體是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-397">This instance is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-398">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-398">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-399">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-399">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-400">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-400">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-401">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-401">for the ability to call unmanaged code when creating an instance of a delegate.</span>
          </span>
          <span data-ttu-id="f1118-402">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-402">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-403">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-403">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-404">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-404">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-405">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-405">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-406">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-406">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-407">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-407">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-408">此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-408">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-409">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-409">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-410">建立指定組件中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-410">Creates a new instance of the specified type defined in the specified assembly.</span>
          </span>
          <span data-ttu-id="f1118-411">參數會指定啟動屬性的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-411">A parameter specifies an array of activation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-412">物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-412">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span>
          </span>
          <span data-ttu-id="f1118-413">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-413">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-414">這個方法會呼叫預設建構函式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-414">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="f1118-415">請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-415">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="f1118-416">嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-416">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="f1118-417">由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-417">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="f1118-418">載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-418">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-419">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-419">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-420">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-420">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-421">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-421">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-422">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-422">-or-</span>
          </span>
          <span data-ttu-id="f1118-423">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-423">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-424">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-424">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-425">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-425">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-426">呼叫端沒有呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-426">The caller does not have permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-427">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-427">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-428">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-428">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-429">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-429">
              <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-430">這個執行個體是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-430">This instance is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-431">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-431">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-432">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-432">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-433">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-433">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-434">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-434">for the ability to call unmanaged code when creating an instance of a delegate.</span>
          </span>
          <span data-ttu-id="f1118-435">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-435">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="f1118-436">提供所有型別成員上叫用作業的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-436">for the ability to invoke operations on all type members.</span>
          </span>
          <span data-ttu-id="f1118-437">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-437">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-438">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-438">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-439">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-439">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-440">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-440">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f1118-441">布林值，指出是否執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-441">A Boolean value specifying whether to perform a case-sensitive search or not.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f1118-442">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-442">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-443">如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-443">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f1118-444">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-444">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="f1118-445">如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-445">If <paramref name="binder" /> is null, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-446">要傳遞到建構函式的引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-446">The arguments to pass to the constructor.</span>
          </span>
          <span data-ttu-id="f1118-447">這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-447">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span>
          </span>
          <span data-ttu-id="f1118-448">如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-448">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f1118-449">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-449">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-450">如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-450">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-451">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-451">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-452">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-452">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-453">此參數與啟動了用戶端的物件相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-453">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="f1118-454">用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-454">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-455">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-455">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-456">建立指定組件中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-456">Creates a new instance of the specified type defined in the specified assembly.</span>
          </span>
          <span data-ttu-id="f1118-457">參數會指定繫結器、繫結旗標、建構函式引數、用來解譯引數的特定文化特性資訊，以及選擇性的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-457">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-458">物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-458">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span>
          </span>
          <span data-ttu-id="f1118-459">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-459">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-460">請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-460">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="f1118-461">嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-461">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="f1118-462">由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-462">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="f1118-463">載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-463">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-464">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-464">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-465">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-465">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-466">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-466">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-467">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-467">-or-</span>
          </span>
          <span data-ttu-id="f1118-468">用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-468">
              <paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-469">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-469">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-470">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-470">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-471">呼叫端沒有呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-471">The caller does not have permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-472">找不到相符的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-472">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-473">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-473">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-474">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-474">
              <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-475">這個執行個體是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-475">This instance is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-476">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-476">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-477">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-477">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-478">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-478">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-479">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-479">for the ability to call unmanaged code when creating an instance of a delegate.</span>
          </span>
          <span data-ttu-id="f1118-480">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-480">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="f1118-481">提供所有型別成員上叫用作業的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-481">for the ability to invoke operations on all type members.</span>
          </span>
          <span data-ttu-id="f1118-482">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-482">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-483">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-483">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-484">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-484">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-485">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-485">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f1118-486">布林值，指出是否執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-486">A Boolean value specifying whether to perform a case-sensitive search or not.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f1118-487">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-487">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-488">如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-488">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f1118-489">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-489">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="f1118-490">如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-490">If <paramref name="binder" /> is null, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-491">要傳遞到建構函式的引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-491">The arguments to pass to the constructor.</span>
          </span>
          <span data-ttu-id="f1118-492">這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-492">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span>
          </span>
          <span data-ttu-id="f1118-493">如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-493">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f1118-494">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-494">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-495">如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-495">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-496">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-496">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-497">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-497">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-498">此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-498">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-499">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-499">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <param name="securityAttributes">
          <span data-ttu-id="f1118-500">用來授權建立 <paramref name="typeName" /> 的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-500">Information used to authorize creation of <paramref name="typeName" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-501">建立指定組件中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-501">Creates a new instance of the specified type defined in the specified assembly.</span>
          </span>
          <span data-ttu-id="f1118-502">參數會指定繫結器 (Binder)、繫結旗標、建構函式引數、用來解譯引數的特定文化特性資訊、啟動屬性，以及建立類型的授權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-502">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-503">物件，是 <paramref name="typeName" /> 所指定的新執行個體之包裝函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-503">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span>
          </span>
          <span data-ttu-id="f1118-504">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-504">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-505">請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-505">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="f1118-506">嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標上，不是目前的應用程式定義域的應用程式定義域會導致成功的載入目標應用程式定義域中的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-506">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="f1118-507">由於<xref:System.Reflection.Assembly>不是<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>針對至目前的應用程式定義域載入的組件，common language runtime 會嘗試將組件載入目前的應用程式定義域和負載可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-507">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="f1118-508">載入至目前的應用程式定義域的組件可能不同於已在不同的兩個應用程式定義域的路徑設定是否先載入的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-508">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-509">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-509">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-510">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-510">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-511">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-511">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-512">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-512">-or-</span>
          </span>
          <span data-ttu-id="f1118-513">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-513">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-514">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-514">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-515">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-515">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-516">呼叫端沒有呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-516">The caller does not have permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-517">找不到相符的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-517">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-518">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-518">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
          <span data-ttu-id="f1118-519">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-519">-or-</span>
          </span>
          <span data-ttu-id="f1118-520">
            <paramref name="securityAttributes" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-520">
              <paramref name="securityAttributes" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-521">不啟用舊版的 CAS 原則時，<paramref name="securityAttributes" /> 應該是 <see langword="null." />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-521">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null." /></span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-522">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-522">
              <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-523">這個執行個體是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-523">This instance is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-524">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-524">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-525">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-525">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-526">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-526">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-527">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-527">to provide evidence.</span>
          </span>
          <span data-ttu-id="f1118-528">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-528">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="f1118-529">提供所有型別成員上叫用作業的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-529">for the ability to invoke operations on all type members.</span>
          </span>
          <span data-ttu-id="f1118-530">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-530">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-531">建立指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-531">Creates a new instance of a specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-532">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-532">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-533">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-533">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-534">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-534">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-535">建立指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-535">Creates a new instance of the specified type.</span>
          </span>
          <span data-ttu-id="f1118-536">參數會指定定義類型所在的組件和類型的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-536">Parameters specify the assembly where the type is defined, and the name of the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-537">
            <paramref name="typeName" /> 指定之物件的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-537">An instance of the object specified by <paramref name="typeName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-538">這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-538">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1118-539">這個方法會呼叫預設建構函式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-539">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="f1118-540">請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-540">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="f1118-541">請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-541">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-542">若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-542">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="f1118-543">即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-543">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="f1118-544">如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。</span><span class="sxs-lookup"><span data-stu-id="f1118-544">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="f1118-545">如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-545">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-546">下列程式碼範例示範另一個應用程式定義域中執行程式碼最簡單的方式。</span><span class="sxs-lookup"><span data-stu-id="f1118-546">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="f1118-547">此範例會定義名為類別`Worker`繼承自<xref:System.MarshalByRefObject>。</span><span class="sxs-lookup"><span data-stu-id="f1118-547">The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="f1118-548">`Worker`類別會定義方法，以顯示其執行所在之應用程式定義域的名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-548">The `Worker` class defines a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="f1118-549">此範例會建立的執行個體`Worker`在預設應用程式定義域和新的應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-549">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-550">包含的組件`Worker`必須載入到兩個應用程式定義域，但它可以載入新的應用程式定義域只存在於其他組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-550">The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-551">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-551">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-552">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-552">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-553">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-553">
              <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-554">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-554">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-555">呼叫端沒有呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-555">The caller does not have permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-556">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-556">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-557">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-557">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-558">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-558">-or-</span>
          </span>
          <span data-ttu-id="f1118-559">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-559">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-560">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-560">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-561">能夠讀取檔案包含組件資訊清單中，或如果您要建立從模組資訊清單檔以外的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-561">for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</span>
          </span>
          <span data-ttu-id="f1118-562">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-562">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-563">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-563">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-564">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-564">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-565">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-565">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-566">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-566">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-567">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-567">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-568">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-568">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-569">此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-569">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-570">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-570">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-571">建立指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-571">Creates a new instance of the specified type.</span>
          </span>
          <span data-ttu-id="f1118-572">參數會指定定義類型所在的組件、類型的名稱和啟動屬性的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-572">Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-573">
            <paramref name="typeName" /> 指定之物件的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-573">An instance of the object specified by <paramref name="typeName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-574">這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-574">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1118-575">這個方法會呼叫預設建構函式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-575">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="f1118-576">請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-576">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="f1118-577">請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-577">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-578">若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-578">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="f1118-579">即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-579">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="f1118-580">如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。</span><span class="sxs-lookup"><span data-stu-id="f1118-580">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="f1118-581">如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-581">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-582">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-582">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-583">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-583">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-584">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-584">
              <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-585">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-585">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-586">呼叫端沒有呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-586">The caller does not have permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-587">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-587">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-588">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-588">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-589">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-589">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-590">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-590">-or-</span>
          </span>
          <span data-ttu-id="f1118-591">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-591">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-592">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-592">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-593">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-593">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-594">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-594">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-595">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-595">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-596">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-596">for the ability to call unmanaged code when creating an instance of a delegate.</span>
          </span>
          <span data-ttu-id="f1118-597">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-597">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="f1118-598">提供所有型別成員上叫用作業的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-598">for the ability to invoke operations on all type members.</span>
          </span>
          <span data-ttu-id="f1118-599">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-599">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-600">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-600">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-601">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-601">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-602">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-602">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f1118-603">布林值，指出是否執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-603">A Boolean value specifying whether to perform a case-sensitive search or not.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f1118-604">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-604">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-605">如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-605">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f1118-606">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-606">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="f1118-607">如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-607">If <paramref name="binder" /> is null, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-608">要傳遞到建構函式的引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-608">The arguments to pass to the constructor.</span>
          </span>
          <span data-ttu-id="f1118-609">這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-609">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span>
          </span>
          <span data-ttu-id="f1118-610">如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-610">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f1118-611">用來控制類型強制的特定文化特性物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-611">A culture-specific object used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="f1118-612">如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see langword="CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-612">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-613">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-613">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-614">一般來說，就是包含單一 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-614">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object.</span>
          </span>
          <span data-ttu-id="f1118-615">會指定啟動遠端物件所需的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-615">that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-616">此參數與啟動了用戶端的物件相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-616">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="f1118-617">用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-617">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-618">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-618">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-619">藉由指定是否忽略類型名稱的大小寫、用於選取要建立之類型的繫結屬性和繫結器、建構函式的引數、文化特性，以及啟動屬性，為指定之組件中定義的指定類型，建立新的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-619">Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-620">
            <paramref name="typeName" /> 指定之物件的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-620">An instance of the object specified by <paramref name="typeName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-621">這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-621">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f1118-622">請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-622">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="f1118-623">請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-623">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-624">若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-624">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="f1118-625">即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-625">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="f1118-626">如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。</span><span class="sxs-lookup"><span data-stu-id="f1118-626">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="f1118-627">如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-627">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-628">下列範例示範如何使用`ignoreCase`參數。</span><span class="sxs-lookup"><span data-stu-id="f1118-628">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-629">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-629">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-630">找不到相符的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-630">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-631">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-631">
              <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-632">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-632">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-633">呼叫端沒有呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-633">The caller does not have permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-634">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-634">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-635">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-635">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-636">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-636">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-637">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-637">-or-</span>
          </span>
          <span data-ttu-id="f1118-638">用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-638">
              <paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-639">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-639">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-640">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-640">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-641">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-641">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-642">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-642">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-643">提供建立委派的執行個體時，呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-643">for the ability to call unmanaged code when creating an instance of a delegate.</span>
          </span>
          <span data-ttu-id="f1118-644">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-644">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="f1118-645">提供所有型別成員上叫用作業的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-645">for the ability to invoke operations on all type members.</span>
          </span>
          <span data-ttu-id="f1118-646">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-646">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-647">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-647">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-648">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-648">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-649">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-649">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f1118-650">布林值，指出是否執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-650">A Boolean value specifying whether to perform a case-sensitive search or not.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f1118-651">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-651">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-652">如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-652">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f1118-653">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-653">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="f1118-654">如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-654">If <paramref name="binder" /> is null, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-655">要傳遞到建構函式的引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-655">The arguments to pass to the constructor.</span>
          </span>
          <span data-ttu-id="f1118-656">這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-656">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span>
          </span>
          <span data-ttu-id="f1118-657">如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-657">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f1118-658">用來控制類型強制的特定文化特性物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-658">A culture-specific object used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="f1118-659">如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see langword="CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-659">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-660">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-660">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-661">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-661">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-662">此參數與啟動了用戶端的物件相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-662">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="f1118-663">用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-663">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-664">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-664">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <param name="securityAttributes">
          <span data-ttu-id="f1118-665">用來授權建立 <paramref name="typeName" /> 的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-665">Information used to authorize creation of <paramref name="typeName" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-666">建立指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-666">Creates a new instance of the specified type.</span>
          </span>
          <span data-ttu-id="f1118-667">參數會指定類型的名稱，以及如何尋找和建立它。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-667">Parameters specify the name of the type, and how it is found and created.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-668">
            <paramref name="typeName" /> 指定之物件的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-668">An instance of the object specified by <paramref name="typeName" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-669">這是很便利的方法，結合了<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-669">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f1118-670">請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-670">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="f1118-671">請參閱<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性的格式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-671">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-672">若要呼叫的方法的早期繫結`M`類型的物件`T1`所傳回的<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，方法會進行早期繫結呼叫的型別物件的方法和`T2`組件中`C`以外目前的組件或包含的組件`T1`，組件`C`載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-672">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="f1118-673">即使早期繫結呼叫，就會發生此載入`T1.M()`的主體中所做<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-673">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="f1118-674">如果目前的網域是預設網域，組件`C`程序結束之前無法卸載。</span><span class="sxs-lookup"><span data-stu-id="f1118-674">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="f1118-675">如果目前的網域稍後嘗試載入組件`C`，負載可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1118-675">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-676">下列範例示範如何使用`ignoreCase`參數。</span><span class="sxs-lookup"><span data-stu-id="f1118-676">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-677">
            <paramref name="assemblyName" /> 或 <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-677">
              <paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-678">找不到相符的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-678">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-679">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typename" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-679">
              <paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-680">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-680">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-681">呼叫端沒有呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-681">The caller does not have permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-682">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-682">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-683">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-683">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-684">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-684">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-685">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-685">-or-</span>
          </span>
          <span data-ttu-id="f1118-686">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-686">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-687">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-687">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-688">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-688">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-689">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-689">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-690">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-690">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-691">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-691">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-692">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-692">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="f1118-693">提供所有型別成員上叫用作業的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-693">for the ability to invoke operations on all type members.</span>
          </span>
          <span data-ttu-id="f1118-694">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-694">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-695">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-695">Creates a new instance of a specified type defined in the specified assembly file.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-696">檔案的名稱 (包括路徑)，此檔案包含會定義要求之類型的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-696">The name, including the path, of a file that contains an assembly that defines the requested type.</span>
          </span>
          <span data-ttu-id="f1118-697">此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-697">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-698">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-698">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-699">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-699">Creates a new instance of the specified type defined in the specified assembly file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-700">對新執行個體而言是包裝函式的物件，但如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-700">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="f1118-701">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-701">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-702">預設建構函式`typeName`叫用。</span><span class="sxs-lookup"><span data-stu-id="f1118-702">The default constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="f1118-703">如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-703">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f1118-704">當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。</span><span class="sxs-lookup"><span data-stu-id="f1118-704">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="f1118-705">不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-705">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="f1118-706">例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="f1118-706">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="f1118-707">當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-707">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="f1118-708">如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。</span><span class="sxs-lookup"><span data-stu-id="f1118-708">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="f1118-709">如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-709">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-710">下列範例示範如何使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法多載來建立目標應用程式定義域中的物件的執行個體，並呼叫其方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-710">The following example shows how to use the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to create an instance of an object in a target application domain and call its methods.</span></span>  
  
 <span data-ttu-id="f1118-711">此範例會定義`MarshallableExample`類別，可以跨應用程式定義域界限封送處理。</span><span class="sxs-lookup"><span data-stu-id="f1118-711">The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="f1118-712">範例會建置目前執行的組件的路徑、 建立目標應用程式定義域，並使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法多載來載入目標應用程式定義域中的範例組件和建立的執行個體`MarshallableExample`。</span><span class="sxs-lookup"><span data-stu-id="f1118-712">The example builds a path to the currently executing assembly, creates a target application domain, and uses the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-713">路徑是在此範例中，絕對路徑，但相對路徑也可以運作，因為<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法用來載入組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-713">The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method is used to load the assembly.</span></span>  
  
 <span data-ttu-id="f1118-714">如果之後解除包裝的物件控制代碼，此範例會示範三種方式可使用目標應用程式定義域中的物件：</span><span class="sxs-lookup"><span data-stu-id="f1118-714">After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</span></span>  
  
-   <span data-ttu-id="f1118-715">叫用方法，以使用反映的晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="f1118-715">Invoking a method with late binding, using reflection.</span></span> <span data-ttu-id="f1118-716">這需要型別資訊，這會導致要載入至呼叫端的應用程式定義域的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-716">This requires type information, which causes the assembly to be loaded into the application domain of the caller.</span></span> <span data-ttu-id="f1118-717">（在此範例中，已經載入也是。）</span><span class="sxs-lookup"><span data-stu-id="f1118-717">(In this example, it is already loaded.)</span></span>  
  
-   <span data-ttu-id="f1118-718">呼叫端和被呼叫端知道介面將物件轉型。</span><span class="sxs-lookup"><span data-stu-id="f1118-718">Casting the object to an interface known to both the caller and the callee.</span></span> <span data-ttu-id="f1118-719">如果呼叫的組件或呼叫端和被呼叫端所參考的第三個組件中定義的介面，則呼叫的組件不載入至呼叫端的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-719">If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</span></span>  
  
-   <span data-ttu-id="f1118-720">直接呼叫端知道它的型別時，請使用物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-720">Using the object directly when its type is known to the caller.</span></span> <span data-ttu-id="f1118-721">組件必須載入到呼叫端的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-721">The assembly must be loaded into the application domain of the caller.</span></span>  
  
 <span data-ttu-id="f1118-722">若要避免被呼叫的組件載入至呼叫端的應用程式定義域的另一個方法是呼叫者是衍生自<xref:System.MarshalByRefObject>類別，以及定義可以在目標應用程式定義域中執行的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-722">Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain.</span></span> <span data-ttu-id="f1118-723">該方法可以使用反映來檢查目標組件，因為目標組件已載入至目標應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-723">That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</span></span> <span data-ttu-id="f1118-724">範例，請參閱<xref:System.AppDomain.DynamicDirectory%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-724">See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-725">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-725">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-726">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-726">-or-</span>
          </span>
          <span data-ttu-id="f1118-727">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-727">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-728">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-728">
              <paramref name="assemblyFile" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-729">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-729">
              <paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-730">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-730">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-731">找不到無參數的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-731">No parameterless public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-732">呼叫端沒有足以呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-732">The caller does not have sufficient permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-733">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-733">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-734">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-734">-or-</span>
          </span>
          <span data-ttu-id="f1118-735">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-735">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-736">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-736">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-737">這個執行個體是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-737">This instance is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-738">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-738">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-739">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-739">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-740">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-740">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-741">檔案的名稱 (包括路徑)，此檔案包含會定義要求之類型的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-741">The name, including the path, of a file that contains an assembly that defines the requested type.</span>
          </span>
          <span data-ttu-id="f1118-742">此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-742">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-743">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-743">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-744">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-744">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-745">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-745">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-746">此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-746">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-747">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-747">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-748">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-748">Creates a new instance of the specified type defined in the specified assembly file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-749">對新執行個體而言是包裝函式的物件，但如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-749">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="f1118-750">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-750">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-751">預設建構函式`typeName`叫用。</span><span class="sxs-lookup"><span data-stu-id="f1118-751">The default constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="f1118-752">如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-752">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f1118-753">當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。</span><span class="sxs-lookup"><span data-stu-id="f1118-753">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="f1118-754">不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-754">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="f1118-755">例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="f1118-755">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="f1118-756">當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-756">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="f1118-757">如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。</span><span class="sxs-lookup"><span data-stu-id="f1118-757">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="f1118-758">如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-758">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-759">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-759">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-760">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-760">
              <paramref name="assemblyFile" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-761">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-761">
              <paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-762">呼叫端沒有足以呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-762">The caller does not have sufficient permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-763">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-763">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-764">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-764">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-765">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-765">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-766">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-766">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-767">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-767">-or-</span>
          </span>
          <span data-ttu-id="f1118-768">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-768">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-769">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-769">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-770">這個執行個體是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-770">This instance is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-771">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-771">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-772">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-772">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-773">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-773">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-774">檔案的名稱 (包括路徑)，此檔案包含會定義要求之類型的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-774">The name, including the path, of a file that contains an assembly that defines the requested type.</span>
          </span>
          <span data-ttu-id="f1118-775">此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-775">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-776">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-776">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f1118-777">布林值，指出是否執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-777">A Boolean value specifying whether to perform a case-sensitive search or not.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f1118-778">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-778">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-779">如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-779">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f1118-780">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-780">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span>
          </span>
          <span data-ttu-id="f1118-781">如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-781">If <paramref name="binder" /> is null, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-782">要傳遞到建構函式的引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-782">The arguments to pass to the constructor.</span>
          </span>
          <span data-ttu-id="f1118-783">這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-783">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span>
          </span>
          <span data-ttu-id="f1118-784">如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-784">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f1118-785">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-785">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-786">如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-786">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-787">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-787">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-788">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-788">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-789">此參數與啟動了用戶端的物件相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-789">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="f1118-790">用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-790">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-791">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-791">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-792">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-792">Creates a new instance of the specified type defined in the specified assembly file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-793">對新執行個體而言是包裝函式的物件，但如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-793">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="f1118-794">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-794">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-795">如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-795">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f1118-796">當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。</span><span class="sxs-lookup"><span data-stu-id="f1118-796">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="f1118-797">不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-797">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="f1118-798">例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="f1118-798">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="f1118-799">當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-799">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="f1118-800">如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。</span><span class="sxs-lookup"><span data-stu-id="f1118-800">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="f1118-801">如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-801">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-802">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-802">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-803">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-803">-or-</span>
          </span>
          <span data-ttu-id="f1118-804">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-804">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-805">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-805">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-806">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-806">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-807">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-807">
              <paramref name="assemblyFile" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-808">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-808">
              <paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-809">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-809">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-810">呼叫端沒有足以呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-810">The caller does not have sufficient permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-811">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-811">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-812">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-812">-or-</span>
          </span>
          <span data-ttu-id="f1118-813">用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-813">
              <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-814">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-814">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-815">這個執行個體是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-815">This instance is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-816">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-816">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-817">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-817">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-818">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-818">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-819">檔案的名稱 (包括路徑)，此檔案包含會定義要求之類型的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-819">The name, including the path, of a file that contains an assembly that defines the requested type.</span>
          </span>
          <span data-ttu-id="f1118-820">此組件使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-820">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-821">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-821">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f1118-822">布林值，指出是否執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-822">A Boolean value specifying whether to perform a case-sensitive search or not.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f1118-823">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-823">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-824">如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-824">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f1118-825">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-825">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span>
          </span>
          <span data-ttu-id="f1118-826">如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-826">If <paramref name="binder" /> is null, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-827">要傳遞到建構函式的引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-827">The arguments to pass to the constructor.</span>
          </span>
          <span data-ttu-id="f1118-828">這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-828">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span>
          </span>
          <span data-ttu-id="f1118-829">如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-829">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f1118-830">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-830">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-831">如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-831">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-832">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-832">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-833">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-833">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-834">此參數與啟動了用戶端的物件相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-834">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="f1118-835">用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-835">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-836">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-836">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <param name="securityAttributes">
          <span data-ttu-id="f1118-837">用來授權建立 <paramref name="typeName" /> 的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-837">Information used to authorize creation of <paramref name="typeName" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-838">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-838">Creates a new instance of the specified type defined in the specified assembly file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-839">對新執行個體而言是包裝函式的物件，但如果沒有找到 <paramref name="typeName" />，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-839">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="f1118-840">傳回值需要解除包裝以存取實際物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-840">The return value needs to be unwrapped to access the real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-841">如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-841">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f1118-842">當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域中，進行呼叫的應用程式定義域以外的執行個體，在目標應用程式定義域中載入的組件時。</span><span class="sxs-lookup"><span data-stu-id="f1118-842">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="f1118-843">不過，如果呼叫的應用程式定義域中執行個體未包裝，以特定方式使用的未包裝的執行個體可能會導致要載入至呼叫的應用程式定義域的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-843">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="f1118-844">例如，未包裝的執行個體之後，可能會要求其型別資訊，以便呼叫其方法晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="f1118-844">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="f1118-845">當組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-845">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="f1118-846">如果另一個版本相同的組件的先前已載入至呼叫的應用程式定義域中，或如果呼叫的應用程式定義域的載入路徑為不同的目標應用程式定義域，例外狀況<xref:System.MissingMethodException>可能會發生。</span><span class="sxs-lookup"><span data-stu-id="f1118-846">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="f1118-847">如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>嘗試轉型執行個體時，可能會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-847">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-848">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-848">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-849">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-849">-or-</span>
          </span>
          <span data-ttu-id="f1118-850">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-850">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-851">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-851">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
          <span data-ttu-id="f1118-852">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-852">-or-</span>
          </span>
          <span data-ttu-id="f1118-853">
            <paramref name="securityAttributes" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-853">
              <paramref name="securityAttributes" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-854">若未啟用舊版 CAS 原則，<paramref name="securityAttributes" /> 應為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-854">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-855">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-855">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-856">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-856">
              <paramref name="assemblyFile" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-857">在 <paramref name="assemblyFile" /> 中找不到 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-857">
              <paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-858">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-858">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-859">呼叫端沒有足以呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-859">The caller does not have sufficient permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-860">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-860">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-861">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-861">-or-</span>
          </span>
          <span data-ttu-id="f1118-862">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-862">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-863">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-863">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="f1118-864">這個執行個體是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-864">This instance is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-865">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-865">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-866">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-866">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-867">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-867">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-868">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-868">to provide evidence.</span>
          </span>
          <span data-ttu-id="f1118-869">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-869">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-870">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-870">Creates a new instance of a specified type defined in the specified assembly file.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-871">定義所要求類型之組件的檔案名稱與路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-871">The file name and path of the assembly that defines the requested type.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-872">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-872">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-873">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-873">Creates a new instance of the specified type defined in the specified assembly file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-874">要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-874">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-875">這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-875">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1118-876">這個方法會呼叫預設建構函式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-876">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="f1118-877">如需詳細資訊，請參閱 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-877">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-878">
            <paramref name="assemblyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-878">
              <paramref name="assemblyName" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-879">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-879">-or-</span>
          </span>
          <span data-ttu-id="f1118-880">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-880">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-881">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-881">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-882">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-882">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-883">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-883">
              <paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-884">找不到無參數的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-884">No parameterless public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-885">呼叫端沒有足以呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-885">The caller does not have sufficient permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-886">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-886">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-887">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-887">-or-</span>
          </span>
          <span data-ttu-id="f1118-888">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-888">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-889">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-889">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-890">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-890">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-891">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-891">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-892">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-892">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-893">定義所要求類型之組件的檔案名稱與路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-893">The file name and path of the assembly that defines the requested type.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-894">所要求類型的完整名稱，包括命名空間，但不包括組件 (請參閱 <see cref="P:System.Type.FullName" /> 屬性)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-894">The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property).</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-895">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-895">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-896">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-896">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-897">此參數與 client-activated 物件有關。用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-897">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-898">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-898">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-899">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-899">Creates a new instance of the specified type defined in the specified assembly file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-900">要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-900">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-901">這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-901">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1118-902">這個方法會呼叫預設建構函式`typeName`。</span><span class="sxs-lookup"><span data-stu-id="f1118-902">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="f1118-903">如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-903">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-904">
            <paramref name="assemblyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-904">
              <paramref name="assemblyName" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-905">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-905">-or-</span>
          </span>
          <span data-ttu-id="f1118-906">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-906">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-907">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-907">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-908">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-908">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-909">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-909">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-910">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-910">
              <paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-911">找不到無參數的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-911">No parameterless public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-912">呼叫端沒有足以呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-912">The caller does not have sufficient permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-913">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-913">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-914">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-914">-or-</span>
          </span>
          <span data-ttu-id="f1118-915">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-915">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-916">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-916">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-917">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-917">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-918">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-918">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-919">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-919">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-920">定義所要求類型之組件的檔案名稱與路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-920">The file name and path of the assembly that defines the requested type.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-921">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-921">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f1118-922">布林值，指出是否執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-922">A Boolean value specifying whether to perform a case-sensitive search or not.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f1118-923">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-923">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-924">如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-924">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f1118-925">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-925">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span>
          </span>
          <span data-ttu-id="f1118-926">如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-926">If <paramref name="binder" /> is null, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-927">要傳遞到建構函式的引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-927">The arguments to pass to the constructor.</span>
          </span>
          <span data-ttu-id="f1118-928">這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-928">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span>
          </span>
          <span data-ttu-id="f1118-929">如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-929">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f1118-930">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-930">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-931">如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-931">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-932">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-932">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-933">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-933">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-934">此參數與啟動了用戶端的物件相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-934">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="f1118-935">用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-935">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-936">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-936">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-937">藉由指定是否忽略類型名稱的大小寫、用於選取要建立之類型的繫結屬性和繫結器、建構函式的引數、文化特性，以及啟動屬性，為指定之組件檔中定義的指定類型，建立新的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-937">Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-938">要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-938">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-939">這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-939">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f1118-940">如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-940">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-941">
            <paramref name="assemblyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-941">
              <paramref name="assemblyName" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-942">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-942">-or-</span>
          </span>
          <span data-ttu-id="f1118-943">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-943">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-944">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-944">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-945">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-945">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-946">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-946">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-947">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-947">
              <paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-948">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-948">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-949">呼叫端沒有足以呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-949">The caller does not have sufficient permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-950">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-950">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-951">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-951">-or-</span>
          </span>
          <span data-ttu-id="f1118-952">用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-952">
              <paramref name="assemblyName" /> was compiled with a later version of the common language runtime that the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-953">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-953">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-954">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-954">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-955">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-955">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-956">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-956">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-957">定義所要求類型之組件的檔案名稱與路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-957">The file name and path of the assembly that defines the requested type.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="f1118-958">
            <see cref="P:System.Type.FullName" /> 屬性傳回的要求類型之完整名稱 (包括命名空間，但不包括組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-958">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="f1118-959">布林值，指出是否執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-959">A Boolean value specifying whether to perform a case-sensitive search or not.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="f1118-960">零或多個位元旗標的組合，此位元旗標會影響 <paramref name="typeName" /> 建構函式的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-960">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-961">如果 <paramref name="bindingAttr" /> 為零，則會針對公用建構函式執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-961">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="f1118-962">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-962">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span>
          </span>
          <span data-ttu-id="f1118-963">如果 <paramref name="binder" /> 為 null，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-963">If <paramref name="binder" /> is null, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-964">要傳遞到建構函式的引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-964">The arguments to pass to the constructor.</span>
          </span>
          <span data-ttu-id="f1118-965">這個引數陣列必須在數目、順序和類型上符合要叫用之建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-965">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span>
          </span>
          <span data-ttu-id="f1118-966">如果慣用預設的建構函式，則 <paramref name="args" /> 必須是空陣列或 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-966">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="f1118-967">特定文化特性的資訊，其可控制 <paramref name="args" /> 到型式類型 (為 <paramref name="typeName" /> 建構函式宣告) 的強制轉型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-967">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span>
          </span>
          <span data-ttu-id="f1118-968">如果 <paramref name="culture" /> 為 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-968">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="f1118-969">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-969">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="f1118-970">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-970">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="f1118-971">此參數與啟動了用戶端的物件相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-971">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="f1118-972">用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-972">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="f1118-973">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-973">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <param name="securityAttributes">
          <span data-ttu-id="f1118-974">用來授權建立 <paramref name="typeName" /> 的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-974">Information used to authorize creation of <paramref name="typeName" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-975">建立指定組件檔案中所定義之指定類型的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-975">Creates a new instance of the specified type defined in the specified assembly file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-976">要求的物件；當找不到 <paramref name="typeName" /> 時，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-976">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-977">這是很便利的方法，結合了<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-977">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f1118-978">如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-978">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-979">
            <paramref name="assemblyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-979">
              <paramref name="assemblyName" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-980">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-980">-or-</span>
          </span>
          <span data-ttu-id="f1118-981">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-981">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-982">呼叫者無法提供非繼承自 <see cref="T:System.MarshalByRefObject" /> 之物件的啟動屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-982">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-983">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-983">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-984">找不到 <paramref name="assemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-984">
              <paramref name="assemblyName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="f1118-985">在 <paramref name="assemblyName" /> 中找不到 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-985">
              <paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-986">找不到相符的公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-986">No matching public constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="f1118-987">呼叫端沒有足以呼叫這個建構函式的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-987">The caller does not have sufficient permission to call this constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-988">
            <paramref name="assemblyName" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-988">
              <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-989">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-989">-or-</span>
          </span>
          <span data-ttu-id="f1118-990">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyName" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-990">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-991">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-991">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">
          <span data-ttu-id="f1118-992">提供讀取包含組件資訊清單檔案的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-992">for the ability to read the file containing the assembly manifest.</span>
          </span>
          <span data-ttu-id="f1118-993">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-993">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-994">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-994">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-995">取得目前 <see cref="T:System.Threading.Thread" /> 的目前應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-995">Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-996">目前的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-996">The current application domain.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f1118-997">下列程式碼範例會建立新的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-997">The following code example creates a new application domain.</span></span> <span data-ttu-id="f1118-998"><xref:System.AppDomain.CurrentDomain%2A>屬性用來取得<xref:System.AppDomain>物件，表示目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-998">The <xref:System.AppDomain.CurrentDomain%2A> property is used to obtain an <xref:System.AppDomain> object that represents the current application domain.</span></span> <span data-ttu-id="f1118-999"><xref:System.AppDomain.FriendlyName%2A>屬性會提供目前的應用程式定義域，然後在命令列顯示的名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-999">The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1000">在目前的應用程式定義域中定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1000">Defines a dynamic assembly in the current application domain.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1001">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1001">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1002">提供給動態組件的存取模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1002">The access mode for the dynamic assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1003">使用指定的名稱和存取模式定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1003">Defines a dynamic assembly with the specified name and access mode.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1004">使用指定名稱和存取模式的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1004">A dynamic assembly with the specified name and access mode.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1005">這個方法應該只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1005">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1006">如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1006">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1007">在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="f1118-1007">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1008">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1008">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1009">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1009">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1010">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1010">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1011">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1011">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1012">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1012">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1013">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1013">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1014">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1014">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1015">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1015">-or-</span>
          </span>
          <span data-ttu-id="f1118-1016">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1016">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1017">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1017">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1018">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1018">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1019">提供給動態組件的存取模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1019">The access mode for the dynamic assembly.</span>
          </span>
        </param>
        <param name="assemblyAttributes">
          <span data-ttu-id="f1118-1020">要套用到組件的可列舉屬性清單，如果沒有任何屬性，則是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1020">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1021">使用指定的名稱、存取模式及自訂屬性來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1021">Defines a dynamic assembly with the specified name, access mode, and custom attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1022">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1022">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1023">您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1023">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="f1118-1024">比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。</span><span class="sxs-lookup"><span data-stu-id="f1118-1024">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="f1118-1025">這個方法應只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1025">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1026">如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1026">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 <span data-ttu-id="f1118-1027">中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="f1118-1027">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1028">下列程式碼範例示範如何建立動態組件具有<xref:System.Security.SecurityTransparentAttribute>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1028">The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>.</span></span> <span data-ttu-id="f1118-1029">屬性必須指定為陣列的項目<xref:System.Reflection.Emit.CustomAttributeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1029">The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.</span></span>  
  
 <span data-ttu-id="f1118-1030">建立第一個步驟<xref:System.Reflection.Emit.CustomAttributeBuilder>是取得屬性的建構函式。</span><span class="sxs-lookup"><span data-stu-id="f1118-1030">The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute.</span></span> <span data-ttu-id="f1118-1031">建構函式沒有任何參數，因此<xref:System.Type.GetConstructor%2A>方法呼叫的空陣列<xref:System.Type>物件，以表示參數的類型。</span><span class="sxs-lookup"><span data-stu-id="f1118-1031">The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters.</span></span> <span data-ttu-id="f1118-1032">第二個步驟是將產生<xref:System.Reflection.ConstructorInfo>物件的建構函式<xref:System.Reflection.Emit.CustomAttributeBuilder>類別，以及類型的空陣列<xref:System.Object>來表示引數。</span><span class="sxs-lookup"><span data-stu-id="f1118-1032">The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.</span></span>  
  
 <span data-ttu-id="f1118-1033">產生<xref:System.Reflection.Emit.CustomAttributeBuilder>接著會傳遞給<xref:System.AppDomain.DefineDynamicAssembly%2A>做為唯一的項目陣列的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1033">The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the <xref:System.AppDomain.DefineDynamicAssembly%2A> method as the only element of an array.</span></span>  
  
 <span data-ttu-id="f1118-1034">範例程式碼定義的模組，然後輸入新的動態組件，並接著會顯示組件的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1034">The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</span></span>  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1035">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1035">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1036">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1036">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1037">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1037">-or-</span>
          </span>
          <span data-ttu-id="f1118-1038">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1038">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1039">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1039">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1040">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1040">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1041">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1041">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="evidence">
          <span data-ttu-id="f1118-1042">提供給動態組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1042">The evidence supplied for the dynamic assembly.</span>
          </span>
          <span data-ttu-id="f1118-1043">此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1043">The evidence is used unaltered as the final set of evidence used for policy resolution.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1044">使用指定的名稱、存取模式和辨識項來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1044">Defines a dynamic assembly using the specified name, access mode, and evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1045">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1045">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1046">只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1046">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="f1118-1047">執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。</span><span class="sxs-lookup"><span data-stu-id="f1118-1047">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="f1118-1048">部分信任的呼叫端必須提供 null `evidence`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1048">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="f1118-1049">如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-1049">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="f1118-1050">如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</span><span class="sxs-lookup"><span data-stu-id="f1118-1050">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="f1118-1051">這個方法應該只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1051">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1052">如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1052">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1053">在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="f1118-1053">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1054">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1054">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1055">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1055">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1056">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1056">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1057">首先，程式碼範例會嘗試建立的執行個體`MyDynamicType`藉由呼叫<xref:System.AppDomain.CreateInstance%2A>方法具有無效的組件名稱，並攔截產生的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-1057">First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.</span></span>  
  
 <span data-ttu-id="f1118-1058">程式碼範例接著會新增事件處理常式<xref:System.AppDomain.AssemblyResolve>事件，然後再次嘗試建立的執行個體`MyDynamicType`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1058">The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`.</span></span> <span data-ttu-id="f1118-1059">在呼叫期間<xref:System.AppDomain.CreateInstance%2A>，則<xref:System.AppDomain.AssemblyResolve>無效的組件都會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1059">During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly.</span></span> <span data-ttu-id="f1118-1060">事件處理常式會建立動態組件，其中包含名為的型別`MyDynamicType`、 提供的類型的無參數建構函式，並傳回新的動態組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1060">The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly.</span></span> <span data-ttu-id="f1118-1061">在呼叫<xref:System.AppDomain.CreateInstance%2A>成功，然後完成的建構函式和`MyDynamicType`在主控台上顯示一則訊息。</span><span class="sxs-lookup"><span data-stu-id="f1118-1061">The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1062">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1062">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1063">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1063">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1064">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1064">-or-</span>
          </span>
          <span data-ttu-id="f1118-1065">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1065">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1066">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1066">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1067">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1067">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1068">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1068">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1069">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1069">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1070">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1070">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="dir">
          <span data-ttu-id="f1118-1071">將儲存組件的目錄名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1071">The name of the directory where the assembly will be saved.</span>
          </span>
          <span data-ttu-id="f1118-1072">如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1072">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1073">使用指定的名稱、存取模式和儲存目錄來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1073">Defines a dynamic assembly using the specified name, access mode, and storage directory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1074">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1074">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1075">這個方法應該只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1075">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1076">如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1076">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1077">在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="f1118-1077">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1078">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1078">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1079">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1079">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1080">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1080">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1081">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1081">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1082">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1082">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1083">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1083">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1084">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1084">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1085">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1085">-or-</span>
          </span>
          <span data-ttu-id="f1118-1086">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1086">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1087">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1087">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1088">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1088">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1089">提供給動態組件的存取模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1089">The access mode for the dynamic assembly.</span>
          </span>
        </param>
        <param name="assemblyAttributes">
          <span data-ttu-id="f1118-1090">要套用到組件的可列舉屬性清單，如果沒有任何屬性，則是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1090">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span>
          </span>
        </param>
        <param name="securityContextSource">
          <span data-ttu-id="f1118-1091">安全性內容的來源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1091">The source of the security context.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1092">定義動態組件，這個動態組件具有指定的名稱、存取模式和自訂模式，並且使用指定的來源做為安全性內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1092">Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1093">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1093">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1094">您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1094">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="f1118-1095">比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。</span><span class="sxs-lookup"><span data-stu-id="f1118-1095">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="f1118-1096">這個方法應只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1096">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1097">如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1097">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1098">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1098">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1099">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1099">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1100">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1100">-or-</span>
          </span>
          <span data-ttu-id="f1118-1101">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1101">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1102">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1102">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f1118-1103">
            <paramref name="securityContextSource" /> 的值不是其中一個列舉值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1103">The value of <paramref name="securityContextSource" /> was not one of the enumeration values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1104">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1104">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1105">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1105">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="dir">
          <span data-ttu-id="f1118-1106">將儲存組件的目錄名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1106">The name of the directory where the assembly will be saved.</span>
          </span>
          <span data-ttu-id="f1118-1107">如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1107">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span>
          </span>
        </param>
        <param name="evidence">
          <span data-ttu-id="f1118-1108">提供給動態組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1108">The evidence supplied for the dynamic assembly.</span>
          </span>
          <span data-ttu-id="f1118-1109">此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1109">The evidence is used unaltered as the final set of evidence used for policy resolution.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1110">使用指定的名稱、存取模式、儲存目錄和辨識項來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1110">Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1111">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1111">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1112">只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1112">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="f1118-1113">執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。</span><span class="sxs-lookup"><span data-stu-id="f1118-1113">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="f1118-1114">部分信任的呼叫端必須提供 null `evidence`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1114">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="f1118-1115">如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-1115">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="f1118-1116">如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</span><span class="sxs-lookup"><span data-stu-id="f1118-1116">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="f1118-1117">這個方法應該只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1117">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1118">如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1118">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1119">在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="f1118-1119">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1120">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1120">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1121">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1121">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1122">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1122">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1123">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1123">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1124">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1124">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1125">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1125">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1126">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1126">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1127">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1127">-or-</span>
          </span>
          <span data-ttu-id="f1118-1128">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1128">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1129">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1129">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1130">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1130">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1131">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1131">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1132">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1132">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1133">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1133">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="requiredPermissions">
          <span data-ttu-id="f1118-1134">必要的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1134">The required permissions request.</span>
          </span>
        </param>
        <param name="optionalPermissions">
          <span data-ttu-id="f1118-1135">選擇性的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1135">The optional permissions request.</span>
          </span>
        </param>
        <param name="refusedPermissions">
          <span data-ttu-id="f1118-1136">拒絕的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1136">The refused permissions request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1137">使用指定的名稱、存取模式和權限要求來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1137">Defines a dynamic assembly using the specified name, access mode, and permission requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1138">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1138">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1139">針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並重新載入到記憶體的動態組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1139">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="f1118-1140">若要指定不會儲存到磁碟，請使用的多載的暫時性組件的權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，也會為要求的權限，並提供為指定的辨識項<xref:System.Security.Policy.Evidence>物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1140">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1141">在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="f1118-1141">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1142">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1142">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1143">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1143">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="f1118-1144">這個方法應該只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1144">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1145">如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1145">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1146">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1146">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1147">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1147">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1148">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1148">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1149">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1149">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1150">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1150">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1151">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1151">-or-</span>
          </span>
          <span data-ttu-id="f1118-1152">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1152">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1153">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1153">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1154">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1154">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1155">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1155">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="dir">
          <span data-ttu-id="f1118-1156">將儲存動態組件的目錄名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1156">The name of the directory where the dynamic assembly will be saved.</span>
          </span>
          <span data-ttu-id="f1118-1157">如果 <paramref name="dir" /> 是 <see langword="null" />，就會使用目前的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1157">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span>
          </span>
        </param>
        <param name="isSynchronized">
          <span data-ttu-id="f1118-1158">若要在動態組件中同步建立模組、類型和成員，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1158">
              <see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="assemblyAttributes">
          <span data-ttu-id="f1118-1159">要套用到組件的可列舉屬性清單，如果沒有任何屬性，則是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1159">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1160">使用指定的名稱、存取模式、儲存目錄和同步處理選項來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1160">Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1161">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1161">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1162">您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1162">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="f1118-1163">比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。</span><span class="sxs-lookup"><span data-stu-id="f1118-1163">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="f1118-1164">如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1164">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="f1118-1165">其中兩種方法會呼叫不同的執行緒上，如果其中一個會封鎖直到另完成為止。</span><span class="sxs-lookup"><span data-stu-id="f1118-1165">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1166">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1166">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1167">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1167">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1168">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1168">-or-</span>
          </span>
          <span data-ttu-id="f1118-1169">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1169">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1170">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1170">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1171">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1171">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1172">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1172">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="evidence">
          <span data-ttu-id="f1118-1173">提供給動態組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1173">The evidence supplied for the dynamic assembly.</span>
          </span>
          <span data-ttu-id="f1118-1174">此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1174">The evidence is used unaltered as the final set of evidence used for policy resolution.</span>
          </span>
        </param>
        <param name="requiredPermissions">
          <span data-ttu-id="f1118-1175">必要的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1175">The required permissions request.</span>
          </span>
        </param>
        <param name="optionalPermissions">
          <span data-ttu-id="f1118-1176">選擇性的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1176">The optional permissions request.</span>
          </span>
        </param>
        <param name="refusedPermissions">
          <span data-ttu-id="f1118-1177">拒絕的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1177">The refused permissions request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1178">使用指定的名稱、存取模式、辨識項和權限要求來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1178">Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1179">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1179">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1180">針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。</span><span class="sxs-lookup"><span data-stu-id="f1118-1180">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1181">在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1181">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1182">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1182">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1183">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1183">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="f1118-1184">只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1184">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="f1118-1185">執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。</span><span class="sxs-lookup"><span data-stu-id="f1118-1185">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="f1118-1186">部分信任的呼叫端必須提供 null `evidence`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1186">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="f1118-1187">如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-1187">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="f1118-1188">如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</span><span class="sxs-lookup"><span data-stu-id="f1118-1188">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="f1118-1189">這個方法應該只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1189">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1190">如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1190">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1191">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1191">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1192">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1192">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1193">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1193">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1194">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1194">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1195">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1195">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1196">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1196">-or-</span>
          </span>
          <span data-ttu-id="f1118-1197">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1197">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1198">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1198">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1199">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1199">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1200">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1200">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1201">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1201">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1202">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1202">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="dir">
          <span data-ttu-id="f1118-1203">將儲存組件的目錄名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1203">The name of the directory where the assembly will be saved.</span>
          </span>
          <span data-ttu-id="f1118-1204">如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1204">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span>
          </span>
        </param>
        <param name="requiredPermissions">
          <span data-ttu-id="f1118-1205">必要的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1205">The required permissions request.</span>
          </span>
        </param>
        <param name="optionalPermissions">
          <span data-ttu-id="f1118-1206">選擇性的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1206">The optional permissions request.</span>
          </span>
        </param>
        <param name="refusedPermissions">
          <span data-ttu-id="f1118-1207">拒絕的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1207">The refused permissions request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1208">使用指定的名稱、存取模式、儲存目錄和權限要求來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1208">Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1209">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1209">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1210">針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並重新載入到記憶體的動態組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1210">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="f1118-1211">若要指定不會儲存到磁碟，請使用的多載的暫時性組件的權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法，也會為要求的權限，並提供為指定的辨識項<xref:System.Security.Policy.Evidence>物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1211">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1212">在開發期間會發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並將包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>中`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="f1118-1212">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1213">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1213">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1214">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1214">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="f1118-1215">這個方法應該只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1215">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1216">如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1216">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1217">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1217">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1218">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1218">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1219">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1219">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1220">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1220">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1221">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1221">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1222">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1222">-or-</span>
          </span>
          <span data-ttu-id="f1118-1223">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1223">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1224">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1224">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1225">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1225">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1226">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1226">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="dir">
          <span data-ttu-id="f1118-1227">將儲存組件的目錄名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1227">The name of the directory where the assembly will be saved.</span>
          </span>
          <span data-ttu-id="f1118-1228">如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1228">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span>
          </span>
        </param>
        <param name="evidence">
          <span data-ttu-id="f1118-1229">提供給動態組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1229">The evidence supplied for the dynamic assembly.</span>
          </span>
          <span data-ttu-id="f1118-1230">此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1230">The evidence is used unaltered as the final set of evidence used for policy resolution.</span>
          </span>
        </param>
        <param name="requiredPermissions">
          <span data-ttu-id="f1118-1231">必要的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1231">The required permissions request.</span>
          </span>
        </param>
        <param name="optionalPermissions">
          <span data-ttu-id="f1118-1232">選擇性的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1232">The optional permissions request.</span>
          </span>
        </param>
        <param name="refusedPermissions">
          <span data-ttu-id="f1118-1233">拒絕的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1233">The refused permissions request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1234">使用指定的名稱、存取模式、儲存目錄、辨識項和權限要求來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1234">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1235">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1235">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1236">針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。</span><span class="sxs-lookup"><span data-stu-id="f1118-1236">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1237">在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1237">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1238">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1238">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1239">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1239">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="f1118-1240">只有完全受信任的呼叫端可以提供他們`evidence`定義動態時<xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1240">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="f1118-1241">執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。</span><span class="sxs-lookup"><span data-stu-id="f1118-1241">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="f1118-1242">部分信任的呼叫端必須提供 null `evidence`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1242">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="f1118-1243">如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-1243">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="f1118-1244">如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</span><span class="sxs-lookup"><span data-stu-id="f1118-1244">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="f1118-1245">這個方法應該只用來定義動態組件中目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1245">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="f1118-1246">如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1246">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1247">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1247">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1248">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1248">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1249">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1249">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1250">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1250">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1251">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1251">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1252">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1252">-or-</span>
          </span>
          <span data-ttu-id="f1118-1253">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1253">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1254">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1254">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1255">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1255">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1256">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1256">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1257">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1257">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1258">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1258">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="dir">
          <span data-ttu-id="f1118-1259">將儲存動態組件的目錄名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1259">The name of the directory where the dynamic assembly will be saved.</span>
          </span>
          <span data-ttu-id="f1118-1260">如果 <paramref name="dir" /> 為 <see langword="null" />，目錄會預設為目前的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1260">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span>
          </span>
        </param>
        <param name="evidence">
          <span data-ttu-id="f1118-1261">提供給動態組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1261">The evidence supplied for the dynamic assembly.</span>
          </span>
          <span data-ttu-id="f1118-1262">此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1262">The evidence is used unaltered as the final set of evidence used for policy resolution.</span>
          </span>
        </param>
        <param name="requiredPermissions">
          <span data-ttu-id="f1118-1263">必要的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1263">The required permissions request.</span>
          </span>
        </param>
        <param name="optionalPermissions">
          <span data-ttu-id="f1118-1264">選擇性的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1264">The optional permissions request.</span>
          </span>
        </param>
        <param name="refusedPermissions">
          <span data-ttu-id="f1118-1265">拒絕的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1265">The refused permissions request.</span>
          </span>
        </param>
        <param name="isSynchronized">
          <span data-ttu-id="f1118-1266">若要在動態組件中同步建立模組、類型和成員，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1266">
              <see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1267">使用指定的名稱、存取模式、儲存目錄、辨識項、權限要求和同步選項來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1267">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1268">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1268">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1269">針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，而且重新載入到記憶體。</span><span class="sxs-lookup"><span data-stu-id="f1118-1269">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1270">在開發期間會發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1270">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="f1118-1271">包括<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>在`refusedPermissions`參數可確保會驗證 MSIL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1271">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="f1118-1272">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1272">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="f1118-1273">只有完全受信任的呼叫端可以提供其辨識項，當定義動態<xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1273">Only fully trusted callers can supply their evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="f1118-1274">執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。</span><span class="sxs-lookup"><span data-stu-id="f1118-1274">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="f1118-1275">部分信任的呼叫端必須提供`null`針對`evidence`參數。</span><span class="sxs-lookup"><span data-stu-id="f1118-1275">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="f1118-1276">如果`evidence`已`null`，執行階段會將複製的權限集合，也就是目前授與和拒絕呼叫端的集<xref:System.Reflection.Assembly>至動態<xref:System.Reflection.Assembly>所定義，並標示為已解決的原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-1276">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="f1118-1277">如果動態<xref:System.Reflection.Assembly>是儲存至磁碟，後續的載入將會取得位置相關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</span><span class="sxs-lookup"><span data-stu-id="f1118-1277">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="f1118-1278">如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1278">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="f1118-1279">如果這些方法的兩個不同的執行緒上呼叫，其中將會封鎖其他作業完成之前。</span><span class="sxs-lookup"><span data-stu-id="f1118-1279">If two of these methods are called on different threads, one will block until the other completes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1280">下列範例會示範<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1280">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-1281">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1281">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1282">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1282">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1283">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1283">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1284">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1284">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1285">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1285">-or-</span>
          </span>
          <span data-ttu-id="f1118-1286">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以空白字元開頭，或者包含正斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1286">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1287">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1287">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1288">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1288">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1289">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1289">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1290">動態組件的唯一識別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1290">The unique identity of the dynamic assembly.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="f1118-1291">將用來存取動態組件的模式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1291">The mode in which the dynamic assembly will be accessed.</span>
          </span>
        </param>
        <param name="dir">
          <span data-ttu-id="f1118-1292">將儲存動態組件的目錄名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1292">The name of the directory where the dynamic assembly will be saved.</span>
          </span>
          <span data-ttu-id="f1118-1293">如果 <paramref name="dir" /> 是 <see langword="null" />，就會使用目前的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1293">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span>
          </span>
        </param>
        <param name="evidence">
          <span data-ttu-id="f1118-1294">提供給動態組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1294">The evidence that is supplied for the dynamic assembly.</span>
          </span>
          <span data-ttu-id="f1118-1295">此辨識項的使用不變，與用於原則解析的最終辨識項集合相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1295">The evidence is used unaltered as the final set of evidence used for policy resolution.</span>
          </span>
        </param>
        <param name="requiredPermissions">
          <span data-ttu-id="f1118-1296">必要的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1296">The required permissions request.</span>
          </span>
        </param>
        <param name="optionalPermissions">
          <span data-ttu-id="f1118-1297">選擇性的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1297">The optional permissions request.</span>
          </span>
        </param>
        <param name="refusedPermissions">
          <span data-ttu-id="f1118-1298">拒絕的權限要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1298">The refused permissions request.</span>
          </span>
        </param>
        <param name="isSynchronized">
          <span data-ttu-id="f1118-1299">若要在動態組件中同步建立模組、類型和成員，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1299">
              <see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="assemblyAttributes">
          <span data-ttu-id="f1118-1300">要套用到組件的可列舉屬性清單，如果沒有任何屬性，則是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1300">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1301">使用指定的名稱、存取模式、儲存目錄、辨識項、權限要求、同步選項及自訂屬性來定義動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1301">Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1302">使用指定名稱和功能的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1302">A dynamic assembly with the specified name and features.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1303">您可以使用這個方法多載來指定將無法正常運作除非建立動態組件時，它們會套用的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1303">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="f1118-1304">比方說，安全性屬性這類<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作如果在建立動態組件之後，它們會加入。</span><span class="sxs-lookup"><span data-stu-id="f1118-1304">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="f1118-1305">針對指定的權限要求`requiredPermissions`， `optionalPermissions`，並`refusedPermissions`才會使用的參數`evidence`也提供參數，或如果儲存動態組件，而且重新載入到記憶體。</span><span class="sxs-lookup"><span data-stu-id="f1118-1305">The permission requests specified for the `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` parameters are used only if the `evidence` parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1306">當您開發可發出動態組件的程式碼時，我們建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>加上旗標在`refusedPermissions`參數。</span><span class="sxs-lookup"><span data-stu-id="f1118-1306">When you develop code that emits dynamic assemblies, we recommend that you include the <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag in the `refusedPermissions` parameter.</span></span> <span data-ttu-id="f1118-1307">此旗標包含確保的 Microsoft intermediate language (MSIL) 會進行驗證。</span><span class="sxs-lookup"><span data-stu-id="f1118-1307">The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</span></span> <span data-ttu-id="f1118-1308">這項技術會偵測到意外產生無法驗證的程式碼，否則這是非常難以偵測。</span><span class="sxs-lookup"><span data-stu-id="f1118-1308">This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</span></span> <span data-ttu-id="f1118-1309">這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1309">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when it is used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="f1118-1310">只有完全受信任的呼叫端可以提供辨識項，當定義動態<xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1310">Only fully trusted callers can supply evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="f1118-1311">執行階段對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與的權限。</span><span class="sxs-lookup"><span data-stu-id="f1118-1311">The runtime maps the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="f1118-1312">部分信任的呼叫端必須提供`null`針對`evidence`參數。</span><span class="sxs-lookup"><span data-stu-id="f1118-1312">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="f1118-1313">如果`evidence`是`null`，執行階段將 （也就是，目前的授與和拒絕集） 的權限集合從呼叫者的組件複製到的動態組件所定義，且標示為已解決的原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-1313">If `evidence` is `null`, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</span></span>  
  
 <span data-ttu-id="f1118-1314">如果動態組件會儲存至磁碟，則後續載入會根據儲存動態組件的位置與相關聯的原則授與。</span><span class="sxs-lookup"><span data-stu-id="f1118-1314">If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</span></span>  
  
 <span data-ttu-id="f1118-1315">如果`isSynchronized`是`true`，下列方法產生<xref:System.Reflection.Emit.AssemblyBuilder>將會同步處理： <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1315">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="f1118-1316">其中兩種方法會呼叫不同的執行緒上，如果其中一個會封鎖直到另完成為止。</span><span class="sxs-lookup"><span data-stu-id="f1118-1316">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 <span data-ttu-id="f1118-1317">中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="f1118-1317">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1318">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1318">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-1319">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1319">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1320">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1320">-or-</span>
          </span>
          <span data-ttu-id="f1118-1321">
            <paramref name="name" /> 的 <see langword="Name" /> 屬性以泛空白字元開頭，或者含有斜線或反斜線。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1321">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1322">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1322">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1323">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1323">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1324">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1324">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">
          <span data-ttu-id="f1118-1325">指定要呼叫之方法的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1325">A delegate that specifies a method to call.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1326">在指定的委派所識別的其他應用程式定義域中執行程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1326">Executes the code in another application domain that is identified by the specified delegate.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1327">`callBackDelegate` 可以封送處理為傳值方式指定， <xref:System.MarshalByRefObject>，或<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1327">`callBackDelegate` can specify a marshal-by-value, <xref:System.MarshalByRefObject>, or <xref:System.ContextBoundObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1328">下列範例示範如何使用靜態<xref:System.AppDomain.DoCallBack%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1328">The following sample demonstrates using a static <xref:System.AppDomain.DoCallBack%2A> method.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 <span data-ttu-id="f1118-1329">下列範例示範如何使用<xref:System.AppDomain.DoCallBack%2A>值的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1329">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by value.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 <span data-ttu-id="f1118-1330">下列範例示範如何使用<xref:System.AppDomain.DoCallBack%2A>所參考的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1330">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by reference.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1331">
            <paramref name="callBackDelegate" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1331">
              <paramref name="callBackDelegate" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1332">取得在已經初始化應用程式定義域時，由主應用程式提供的定義域管理員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1332">Gets the domain manager that was provided by the host when the application domain was initialized.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-1333">物件，表示在已經初始化應用程式定義域時，由主應用程式提供的定義域管理員；如果未提供任何定義域管理員，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1333">An object that represents the domain manager provided by the host when the application domain was initialized, or <see langword="null" /> if no domain manager was provided.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1334">受管理的主機，common language runtime (CLR) 可以提供網域管理員。</span><span class="sxs-lookup"><span data-stu-id="f1118-1334">An unmanaged host of the common language runtime (CLR) can provide a domain manager.</span></span> <span data-ttu-id="f1118-1335">可以初始化新的應用程式定義域中參與的定義域管理員，並將其提供其他管理員中，例如<xref:System.Security.HostSecurityManager>，參與的應用程式定義域的作業。</span><span class="sxs-lookup"><span data-stu-id="f1118-1335">The domain manager can participate in initializing the new application domain and supply other managers, such as a <xref:System.Security.HostSecurityManager>, that participate in the operations of the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-1336">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1336">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-1337">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1337">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1338">發生於將要卸載 <see cref="T:System.AppDomain" /> 時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1338">Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1339"><xref:System.EventHandler>委派為這個事件可以在應用程式網域卸載之前執行任何終止活動。</span><span class="sxs-lookup"><span data-stu-id="f1118-1339">The <xref:System.EventHandler> delegate for this event can perform any termination activities before the application domain is unloaded.</span></span>  
  
 <span data-ttu-id="f1118-1340">每個應用程式定義域必須執行處理卸載時應該註冊這個事件的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="f1118-1340">Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</span></span> <span data-ttu-id="f1118-1341">共用的事件處理常式應該不使用，因為<xref:System.EventHandler>委派不會識別正在卸載的網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1341">A shared event handler should not be used, because the <xref:System.EventHandler> delegate does not identify the domain that is being unloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1342">預設應用程式定義域中永遠不會引發這個事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1342">This event is never raised in the default application domain.</span></span>  
  
 <span data-ttu-id="f1118-1343">請勿在執行緒引發事件的相關假設。</span><span class="sxs-lookup"><span data-stu-id="f1118-1343">Do not make assumptions about the thread the event is raised on.</span></span> <span data-ttu-id="f1118-1344">可以在不同的執行緒以外的呼叫引發事件<xref:System.AppDomain.Unload%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1344">The event can be raised on a different thread than the one that called the <xref:System.AppDomain.Unload%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1345">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1345">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1346">取得組件解析程式用來探查動態建立之組件的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1346">Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-1347">組件解析程式用來探查以動態建立組件的目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1347">The directory that the assembly resolver uses to probe for dynamically created assemblies.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1348">若要設定的動態的目錄，將指定的基底目錄路徑<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性<xref:System.AppDomainSetup>會用以建立新的應用程式定義域的物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1348">To set the dynamic directory, assign a base directory path to the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property of the <xref:System.AppDomainSetup> object that will be used to create the new application domain.</span></span> <span data-ttu-id="f1118-1349">修改指派給屬性的基底目錄路徑的簡單名稱是指派給字串的雜湊程式碼子目錄<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>屬性，所以基底目錄格式*原始路徑* \\*雜湊碼*。</span><span class="sxs-lookup"><span data-stu-id="f1118-1349">The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so the format of the base directory is *original path*\\*hash code*.</span></span> <span data-ttu-id="f1118-1350">此基底目錄的子目錄動態的目錄。</span><span class="sxs-lookup"><span data-stu-id="f1118-1350">The dynamic directory is a subdirectory of this base directory.</span></span> <span data-ttu-id="f1118-1351">其簡單的名稱是值<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>屬性，因此它的格式*原始路徑*\\*雜湊碼*\\*應用程式名稱*。</span><span class="sxs-lookup"><span data-stu-id="f1118-1351">Its simple name is the value of the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so its format is *original path*\\*hash code*\\*application name*.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1352">下列範例與目錄的應用程式定義域建立動態組件的、 發出動態組件和將它儲存在動態的目錄中，將組件載入新的應用程式定義域然後使用它。</span><span class="sxs-lookup"><span data-stu-id="f1118-1352">The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</span></span>  
  
 <span data-ttu-id="f1118-1353">此範例會建立<xref:System.AppDomainSetup>物件以及設定其<xref:System.AppDomainSetup.ApplicationName%2A>"Example"的屬性並將其<xref:System.AppDomainSetup.DynamicBase%2A>"C:\DynamicAssemblyDir"的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1353">The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\DynamicAssemblyDir".</span></span> <span data-ttu-id="f1118-1354">此範例接著會顯示<xref:System.AppDomainSetup.DynamicBase%2A>屬性，以顯示應用程式名稱的雜湊碼，已附加為原本指派路徑的子目錄。</span><span class="sxs-lookup"><span data-stu-id="f1118-1354">The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1355">在此範例中的基底目錄就是要探查路徑外部的範例應用程式。</span><span class="sxs-lookup"><span data-stu-id="f1118-1355">The base directory in this example is intended to be outside the probing path for the example application.</span></span> <span data-ttu-id="f1118-1356">請務必在編譯中的不同位置的範例。</span><span class="sxs-lookup"><span data-stu-id="f1118-1356">Be sure to compile the example in a different location.</span></span> <span data-ttu-id="f1118-1357">刪除的基底目錄及其所有子目錄每次執行此範例的資訊。</span><span class="sxs-lookup"><span data-stu-id="f1118-1357">Delete the base directory and all its subdirectories each time you run the example.</span></span>  
  
 <span data-ttu-id="f1118-1358">此範例會建立新的應用程式定義域中，使用<xref:System.AppDomainSetup>物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1358">The example creates a new application domain, using the <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="f1118-1359">此範例會使用<xref:System.AppDomain.DynamicDirectory%2A>屬性，以擷取目錄的名稱，因此它可以建立該目錄。</span><span class="sxs-lookup"><span data-stu-id="f1118-1359">The example uses the <xref:System.AppDomain.DynamicDirectory%2A> property to retrieve the name of the directory, so it can create the directory.</span></span> <span data-ttu-id="f1118-1360">（此範例可以輕鬆地建立目錄事先藉由串連的原始路徑，應用程式名稱，而應用程式名稱的雜湊碼。）</span><span class="sxs-lookup"><span data-stu-id="f1118-1360">(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</span></span>  
  
 <span data-ttu-id="f1118-1361">此範例包含 `GenerateDynamicAssembly`方法，會發出名為組件`DynamicHelloWorld.dll`並將它儲存在新的應用程式定義域的動態目錄中。</span><span class="sxs-lookup"><span data-stu-id="f1118-1361">The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory.</span></span> <span data-ttu-id="f1118-1362">動態組件包含一種類型， `HelloWorld`，，有一個靜態方法 (`Shared`方法，在 Visual Basic 中的) 名為`HelloFromAD`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1362">The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`.</span></span> <span data-ttu-id="f1118-1363">呼叫這個方法會顯示應用程式定義域的名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1363">Calling this method displays the name of the application domain.</span></span>  
  
 <span data-ttu-id="f1118-1364">`Example`類別衍生自<xref:System.MarshalByRefObject>，因此範例可以建立類別的執行個體，在新的應用程式定義域，並呼叫其`Test`方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1364">The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method.</span></span> <span data-ttu-id="f1118-1365">`Test`方法會依其顯示名稱載入的動態組件，並呼叫靜態`HelloFromAD`方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1365">The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.</span></span>  
  
 <span data-ttu-id="f1118-1366">您可以顯示的動態目錄搜尋一般探查路徑之後，撰寫程式碼組件名為`DynamicHelloWorld.dll`和編譯此範例中的相同目錄中。</span><span class="sxs-lookup"><span data-stu-id="f1118-1366">You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example.</span></span> <span data-ttu-id="f1118-1367">組件必須具有一個名為類別`HelloWorld`靜態方法，名為`HelloFromAD`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1367">The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`.</span></span> <span data-ttu-id="f1118-1368">這個方法不需要有相同的功能與在範例中，它只可以在主控台中顯示的字串。</span><span class="sxs-lookup"><span data-stu-id="f1118-1368">This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</span></span> <span data-ttu-id="f1118-1369">組件也必須<xref:System.Reflection.AssemblyVersionAttribute>將它的版本設定為 1.0.0.0 的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1369">The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0.</span></span> <span data-ttu-id="f1118-1370">當您執行範例時，才能動態的目錄中搜尋找到您編譯目前目錄中的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1370">When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1371">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1371">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1372">用於存取的路徑資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1372">for access to the path information.</span>
          </span>
          <span data-ttu-id="f1118-1373">關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1373">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1374">取得與此應用程式定義域相關聯的 <see cref="T:System.Security.Policy.Evidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1374">Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-1375">與此應用程式定義域相關聯的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1375">The evidence associated with this application domain.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1376">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1376">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1377">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1377">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1378">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1378">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
          <span data-ttu-id="f1118-1379">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1379">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1380">執行包含在指定檔案中的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1380">Executes the assembly contained in the specified file.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-1381">包含要執行之組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1381">The name of the file that contains the assembly to execute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1382">執行包含在指定檔案中的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1382">Executes the assembly contained in the specified file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1383">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1383">The value returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1384">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1384">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1385">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1385">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="f1118-1386">這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1386">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="f1118-1387">您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1387">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1388">若要建立<xref:System.AppDomain>載入並執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1388">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1389">下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1389">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1390">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1390">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1391">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1391">
              <paramref name="assemblyFile" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1392">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1392">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1393">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1393">-or-</span>
          </span>
          <span data-ttu-id="f1118-1394">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1394">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1395">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1395">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1396">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1396">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1397">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1397">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1398">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1398">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1399">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1399">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1400">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1400">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1401">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1401">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1402">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1402">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-1403">包含要執行之組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1403">The name of the file that contains the assembly to execute.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="f1118-1404">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1404">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1405">使用指定的辨識項，執行包含在指定檔案中的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1405">Executes the assembly contained in the specified file, using the specified evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1406">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1406">The value returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1407">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1407">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1408"><xref:System.AppDomain.ExecuteAssembly%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1408">The <xref:System.AppDomain.ExecuteAssembly%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="f1118-1409">這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1409">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="f1118-1410">您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1410">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1411">下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1411">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1412">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1412">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1413">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1413">
              <paramref name="assemblyFile" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1414">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1414">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1415">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1415">-or-</span>
          </span>
          <span data-ttu-id="f1118-1416">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1416">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1417">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1417">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1418">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1418">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1419">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1419">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1420">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1420">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1421">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1421">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1422">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1422">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1423">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1423">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1424">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1424">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1425">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1425">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1426">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1426">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-1427">包含要執行之組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1427">The name of the file that contains the assembly to execute.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-1428">組件的進入點引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1428">The arguments to the entry point of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1429">使用指定的引數，執行包含在指定檔案中的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1429">Executes the assembly contained in the specified file, using the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1430">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1430">The value that is returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1431">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1431">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1432">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1432">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="f1118-1433">這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1433">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="f1118-1434">您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1434">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1435">下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1435">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1436">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1436">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1437">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1437">
              <paramref name="assemblyFile" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1438">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1438">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1439">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1439">-or-</span>
          </span>
          <span data-ttu-id="f1118-1440">用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1440">
              <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1441">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1441">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1442">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1442">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1443">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1443">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1444">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1444">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1445">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1445">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1446">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1446">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1447">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1447">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1448">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1448">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-1449">包含要執行之組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1449">The name of the file that contains the assembly to execute.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="f1118-1450">組件的提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1450">The supplied evidence for the assembly.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-1451">組件的進入點引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1451">The arguments to the entry point of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1452">使用指定的辨識項和引數，執行包含在指定檔案中的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1452">Executes the assembly contained in the specified file, using the specified evidence and arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1453">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1453">The value returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1454">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1454">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1455">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1455">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="f1118-1456">這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1456">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="f1118-1457">您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1457">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1458">下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1458">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1459">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1459">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1460">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1460">
              <paramref name="assemblyFile" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1461">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1461">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1462">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1462">-or-</span>
          </span>
          <span data-ttu-id="f1118-1463">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1463">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1464">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1464">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1465">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1465">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-1466">
            <paramref name="assemblySecurity" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1466">
              <paramref name="assemblySecurity" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1467">若未啟用舊版 CAS 原則，<paramref name="assemblySecurity" /> 應為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1467">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1468">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1468">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1469">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1469">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1470">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1470">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1471">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1471">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1472">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1472">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1473">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1473">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1474">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1474">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1475">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1475">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-1476">包含要執行之組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1476">The name of the file that contains the assembly to execute.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-1477">組件的進入點引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1477">The arguments to the entry point of the assembly.</span>
          </span>
        </param>
        <param name="hashValue">
          <span data-ttu-id="f1118-1478">表示計算出來的雜湊碼的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1478">Represents the value of the computed hash code.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="f1118-1479">表示組件資訊清單所使用的雜湊演算法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1479">Represents the hash algorithm used by the assembly manifest.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1480">使用指定的引數、雜湊值和雜湊演算法，執行包含在指定檔案中的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1480">Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1481">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1481">The value that is returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1482">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1482">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1483">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1483">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="f1118-1484">這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1484">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="f1118-1485">您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1485">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1486">下列範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1486">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1487">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1487">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1488">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1488">
              <paramref name="assemblyFile" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1489">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1489">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1490">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1490">-or-</span>
          </span>
          <span data-ttu-id="f1118-1491">用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1491">
              <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1492">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1492">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1493">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1493">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1494">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1494">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1495">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1495">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1496">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1496">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1497">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1497">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1498">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1498">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1499">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1499">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="f1118-1500">包含要執行之組件的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1500">The name of the file that contains the assembly to execute.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="f1118-1501">組件的提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1501">The supplied evidence for the assembly.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-1502">組件的進入點引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1502">The arguments to the entry point of the assembly.</span>
          </span>
        </param>
        <param name="hashValue">
          <span data-ttu-id="f1118-1503">表示計算出來的雜湊碼的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1503">Represents the value of the computed hash code.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="f1118-1504">表示組件資訊清單所使用的雜湊演算法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1504">Represents the hash algorithm used by the assembly manifest.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1505">使用指定的辨識項、引數、雜湊值和雜湊演算法，執行包含在指定檔案中的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1505">Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1506">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1506">The value returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1507">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1507">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1508">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1508">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="f1118-1509">這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1509">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="f1118-1510">您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1510">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1511">︰ 範例示範如何使用其中一個多載的<xref:System.AppDomain.ExecuteAssembly%2A>上兩個不同的網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1511">Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1512">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1512">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1513">找不到 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1513">
              <paramref name="assemblyFile" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1514">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1514">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1515">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1515">-or-</span>
          </span>
          <span data-ttu-id="f1118-1516">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyFile" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1516">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1517">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1517">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1518">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1518">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-1519">
            <paramref name="assemblySecurity" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1519">
              <paramref name="assemblySecurity" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1520">若未啟用舊版 CAS 原則，<paramref name="assemblySecurity" /> 應為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1520">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1521">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1521">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1522">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1522">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1523">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1523">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1524">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1524">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1525">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1525">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1526">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1526">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1527">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1527">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1528">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1528">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1529">執行組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1529">Executes an assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-1530">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1530">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-1531">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1531">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1532">執行需提供其顯示名稱的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1532">Executes an assembly given its display name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1533">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1533">The value returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1534"><xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="f1118-1534">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="f1118-1535">因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1535">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1536">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1536">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1537">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1537">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="f1118-1538">若要建立<xref:System.AppDomain>載入並執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1538">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1539">
            <paramref name="assemblyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1539">
              <paramref name="assemblyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1540">找不到 <paramref name="assemblyName" /> 所指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1540">The assembly specified by <paramref name="assemblyName" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1541">
            <paramref name="assemblyName" /> 所指定的組件不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1541">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1542">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1542">-or-</span>
          </span>
          <span data-ttu-id="f1118-1543">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1543">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1544">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1544">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1545">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1545">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1546">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1546">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1547">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1547">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span>
          </span>
          <span data-ttu-id="f1118-1548">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1548">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1549">用於存取網站時的顯示名稱會被重新導向至的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1549">for access to a Web site, when a display name is redirected to a URL.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1550">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1550">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1551">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1551">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-1552">
            <see cref="T:System.Reflection.AssemblyName" /> 物件，代表組件的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1552">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-1553">啟動處理程序時要傳遞的命令列引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1553">Command-line arguments to pass when starting the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1554">使用指定的引數，執行具有指定之 <see cref="T:System.Reflection.AssemblyName" /> 的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1554">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1555">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1555">The value that is returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1556"><xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="f1118-1556">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="f1118-1557">因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1557">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1558">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1558">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1559">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1559">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1560">找不到 <paramref name="assemblyName" /> 所指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1560">The assembly specified by <paramref name="assemblyName" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1561">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1561">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1562">
            <paramref name="assemblyName" /> 所指定的組件不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1562">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1563">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1563">-or-</span>
          </span>
          <span data-ttu-id="f1118-1564">用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1564">
              <paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1565">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1565">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1566">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1566">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1567">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1567">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span>
          </span>
          <span data-ttu-id="f1118-1568">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1568">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1569">用於存取網站時的顯示名稱會被重新導向至的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1569">for access to a Web site, when a display name is redirected to a URL.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1570">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1570">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1571">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1571">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-1572">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1572">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-1573">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1573">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="f1118-1574">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1574">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1575">使用指定之辨識項，執行需提供其顯示名稱的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1575">Executes an assembly given its display name, using the specified evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1576">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1576">The value returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1577"><xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="f1118-1577">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="f1118-1578">因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1578">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1579">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1579">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1580"><xref:System.AppDomain.ExecuteAssemblyByName%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1580">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1581">當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="f1118-1581">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f1118-1582">做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="f1118-1582">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1583">
            <paramref name="assemblyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1583">
              <paramref name="assemblyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1584">找不到 <paramref name="assemblyName" /> 所指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1584">The assembly specified by <paramref name="assemblyName" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1585">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1585">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1586">
            <paramref name="assemblyName" /> 所指定的組件不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1586">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1587">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1587">-or-</span>
          </span>
          <span data-ttu-id="f1118-1588">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1588">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1589">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1589">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1590">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1590">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1591">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1591">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span>
          </span>
          <span data-ttu-id="f1118-1592">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1592">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1593">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1593">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1594">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1594">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1595">用於存取網站時的顯示名稱會被重新導向至的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1595">for access to a Web site, when a display name is redirected to a URL.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1596">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1596">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1597">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1597">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-1598">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1598">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-1599">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1599">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-1600">啟動處理程序時要傳遞的命令列引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1600">Command-line arguments to pass when starting the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1601">使用指定的引數，執行具有指定之顯示名稱的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1601">Executes the assembly given its display name, using the specified arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1602">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1602">The value that is returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1603"><xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="f1118-1603">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="f1118-1604">因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1604">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1605">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1605">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1606">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1606">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1607">
            <paramref name="assemblyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1607">
              <paramref name="assemblyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1608">找不到 <paramref name="assemblyName" /> 所指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1608">The assembly specified by <paramref name="assemblyName" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1609">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1609">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1610">
            <paramref name="assemblyName" /> 所指定的組件不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1610">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1611">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1611">-or-</span>
          </span>
          <span data-ttu-id="f1118-1612">用以編譯 <paramref name="assemblyName" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1612">
              <paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1613">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1613">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1614">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1614">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1615">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1615">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span>
          </span>
          <span data-ttu-id="f1118-1616">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1616">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1617">用於存取網站時的顯示名稱會被重新導向至的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1617">for access to a Web site, when a display name is redirected to a URL.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1618">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1618">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1619">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1619">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-1620">
            <see cref="T:System.Reflection.AssemblyName" /> 物件，代表組件的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1620">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="f1118-1621">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1621">Evidence for loading the assembly.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-1622">啟動處理程序時要傳遞的命令列引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1622">Command-line arguments to pass when starting the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1623">使用指定之辨識項和引數，執行需提供 <see cref="T:System.Reflection.AssemblyName" /> 的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1623">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1624">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1624">The value returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1625"><xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="f1118-1625">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="f1118-1626">因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1626">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1627">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1627">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1628">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1628">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1629">當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="f1118-1629">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f1118-1630">做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="f1118-1630">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1631">找不到 <paramref name="assemblyName" /> 所指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1631">The assembly specified by <paramref name="assemblyName" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1632">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1632">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1633">
            <paramref name="assemblyName" /> 所指定的組件不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1633">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1634">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1634">-or-</span>
          </span>
          <span data-ttu-id="f1118-1635">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1635">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1636">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1636">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-1637">
            <paramref name="assemblySecurity" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1637">
              <paramref name="assemblySecurity" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1638">若未啟用舊版 CAS 原則，<paramref name="assemblySecurity" /> 應為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1638">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1639">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1639">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1640">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1640">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span>
          </span>
          <span data-ttu-id="f1118-1641">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1641">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1642">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1642">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1643">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1643">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1644">用於存取網站時的顯示名稱會被重新導向至的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1644">for access to a Web site, when a display name is redirected to a URL.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1645">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1645">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1646">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1646">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="f1118-1647">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1647">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-1648">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1648">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="f1118-1649">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1649">Evidence for loading the assembly.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="f1118-1650">啟動處理程序時要傳遞的命令列引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1650">Command-line arguments to pass when starting the process.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1651">使用指定之辨識項和引數，執行需提供其顯示名稱的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1651">Executes the assembly given its display name, using the specified evidence and arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1652">組件的進入點所傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1652">The value returned by the entry point of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1653"><xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="f1118-1653">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="f1118-1654">因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入的組件<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1654">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1655">組件會開始執行的.NET Framework 標頭中指定的進入點。</span><span class="sxs-lookup"><span data-stu-id="f1118-1655">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="f1118-1656">這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1656">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1657">當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="f1118-1657">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f1118-1658">做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="f1118-1658">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1659">
            <paramref name="assemblyName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1659">
              <paramref name="assemblyName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1660">找不到 <paramref name="assemblyName" /> 所指定的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1660">The assembly specified by <paramref name="assemblyName" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1661">已找到 <paramref name="assemblyName" /> 所指定的組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1661">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1662">
            <paramref name="assemblyName" /> 所指定的組件不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1662">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1663">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1663">-or-</span>
          </span>
          <span data-ttu-id="f1118-1664">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyName" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1664">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1665">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1665">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-1666">
            <paramref name="assemblySecurity" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1666">
              <paramref name="assemblySecurity" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1667">若未啟用舊版 CAS 原則，<paramref name="assemblySecurity" /> 應為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1667">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="f1118-1668">指定的組件不具任何進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1668">The specified assembly has no entry point.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1669">針對從檔案或目錄，權限本身，路徑中的資訊並將顯示名稱重新導向至路徑的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1669">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span>
          </span>
          <span data-ttu-id="f1118-1670">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1670">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1671">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1671">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1672">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1672">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1673">用於存取網站時的顯示名稱會被重新導向至的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1673">for access to a Web site, when a display name is redirected to a URL.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="f1118-1674">若要執行主控台應用程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1674">to execute a console application.</span>
          </span>
          <span data-ttu-id="f1118-1675">關聯的列舉型別：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1675">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1676">發生於執行階段在呼叫堆疊中搜尋應用程式定義域的例外狀況處理常式之前，在 Managed 程式碼中擲回例外狀況時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1676">Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1677">此事件是只有通知。</span><span class="sxs-lookup"><span data-stu-id="f1118-1677">This event is only a notification.</span></span> <span data-ttu-id="f1118-1678">處理這個事件不會處理例外狀況或會影響後續的例外狀況以任何方式處理。</span><span class="sxs-lookup"><span data-stu-id="f1118-1678">Handling this event does not handle the exception or affect subsequent exception handling in any way.</span></span> <span data-ttu-id="f1118-1679">在引發事件，並已叫用事件處理常式之後，common language runtime (CLR) 會開始搜尋例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="f1118-1679">After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</span></span> <span data-ttu-id="f1118-1680"><xref:System.AppDomain.FirstChanceException> 第一個有機會檢查任何 managed 例外狀況可讓應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1680"><xref:System.AppDomain.FirstChanceException> provides the application domain with a first chance to examine any managed exception.</span></span>  
  
 <span data-ttu-id="f1118-1681">每個應用程式網域，就可以處理事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1681">The event can be handled per application domain.</span></span> <span data-ttu-id="f1118-1682">如果執行緒會透過多個應用程式定義域傳遞執行呼叫時，CLR 可讓您開始搜尋應用程式定義域中相符的例外狀況處理常式之前，已註冊的事件處理常式中，每個應用程式定義域中引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1682">If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</span></span> <span data-ttu-id="f1118-1683">在處理事件之後，搜尋會將相符的例外狀況處理常式，該應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-1683">After the event has been handled, a search is made for a matching exception handler in that application domain.</span></span> <span data-ttu-id="f1118-1684">如果找不到，就會在下一步 的應用程式定義域引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1684">If none is found, the event is raised in the next application domain.</span></span>  
  
 <span data-ttu-id="f1118-1685">您必須處理所有例外狀況發生在事件處理常式<xref:System.AppDomain.FirstChanceException>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1685">You must handle all exceptions that occur in the event handler for the <xref:System.AppDomain.FirstChanceException> event.</span></span> <span data-ttu-id="f1118-1686">否則，<xref:System.AppDomain.FirstChanceException>是遞迴引發。</span><span class="sxs-lookup"><span data-stu-id="f1118-1686">Otherwise, <xref:System.AppDomain.FirstChanceException> is raised recursively.</span></span> <span data-ttu-id="f1118-1687">這可能會導致堆疊溢位和應用程式終止。</span><span class="sxs-lookup"><span data-stu-id="f1118-1687">This could result in a stack overflow and termination of the application.</span></span> <span data-ttu-id="f1118-1688">我們建議您為限制的執行區域 (Cer)，實作此事件的事件處理常式，以防止基礎結構相關例外狀況，例如記憶體不足或堆疊溢位例外狀況通知時，會影響虛擬機器正在處理中。</span><span class="sxs-lookup"><span data-stu-id="f1118-1688">We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</span></span>  
  
 <span data-ttu-id="f1118-1689">此事件不會引發例外狀況，表示損毀的程序的狀態，例如存取違規，除非事件處理常式上為安全性關鍵，而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1689">This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="f1118-1690">正在處理此通知事件時，common language runtime 會暫止執行緒中止。</span><span class="sxs-lookup"><span data-stu-id="f1118-1690">The common language runtime suspends thread aborts while this notification event is being handled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1691">下列範例會建立一系列具名的應用程式定義域`AD0`經由`AD3`，使用`Worker`每個應用程式定義域中的物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1691">The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain.</span></span> <span data-ttu-id="f1118-1692">每個`Worker`物件具有的參考`Worker`物件在下一步 的應用程式網域中，除了`Worker`最後一個應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-1692">Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain.</span></span> <span data-ttu-id="f1118-1693"><xref:System.AppDomain.FirstChanceException>以外的所有應用程式定義域中處理事件`AD1`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1693">The <xref:System.AppDomain.FirstChanceException> event is handled in all application domains except `AD1`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1694">除了此範例中，示範多個應用程式定義域中的第一個可能的例外狀況通知，您可以找到簡單使用案例[如何： 接收 First-chance 例外狀況通知](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1694">In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span></span>  
  
 <span data-ttu-id="f1118-1695">預設應用程式定義域時已建立的應用程式定義域，呼叫`TestException`第一個應用程式定義域的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1695">When the application domains have been created, the default application domain calls the `TestException` method for the first application domain.</span></span> <span data-ttu-id="f1118-1696">每個`Worker`物件會呼叫`TestException`方法下, 一步 的應用程式定義域，直到最後一個`Worker`會擲回例外狀況處理或未處理的。</span><span class="sxs-lookup"><span data-stu-id="f1118-1696">Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled.</span></span> <span data-ttu-id="f1118-1697">因此，目前的執行緒通過所有的應用程式定義域中，和`TestException`新增到每個應用程式定義域中的堆疊。</span><span class="sxs-lookup"><span data-stu-id="f1118-1697">Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.</span></span>  
  
 <span data-ttu-id="f1118-1698">當上次`Worker`物件會處理例外狀況，<xref:System.AppDomain.FirstChanceException>只有在最後一個應用程式定義域引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1698">When the last `Worker` object handles the exception, the <xref:System.AppDomain.FirstChanceException> event is raised only in the last application domain.</span></span> <span data-ttu-id="f1118-1699">其他的應用程式定義域永遠不會有機會處理例外狀況，因此不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1699">The other application domains never get a chance to handle the exception, so the event is not raised.</span></span>  
  
 <span data-ttu-id="f1118-1700">當上次`Worker`物件不會處理例外狀況，<xref:System.AppDomain.FirstChanceException>每個應用程式在網域中，事件處理常式就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1700">When the last `Worker` object does not handle the exception, the <xref:System.AppDomain.FirstChanceException> event is raised in each application domain that has an event handler.</span></span> <span data-ttu-id="f1118-1701">每個事件處理常式已完成之後，堆疊會繼續回溯直到預設應用程式定義域所捕捉的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-1701">After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1702">若要查看如何堆疊顯示隨著接近引發事件，並使其更接近預設應用程式定義域，變更`e.Exception.Message`要`e.Exception`在`FirstChanceHandler`事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="f1118-1702">To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers.</span></span> <span data-ttu-id="f1118-1703">請注意，當`TestException`稱為跨應用程式定義域界限，它會出現兩次： 一次的 proxy，一次虛設常式。</span><span class="sxs-lookup"><span data-stu-id="f1118-1703">Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</span></span>  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-1704">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1704">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-1705">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1705">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113">
          <span data-ttu-id="f1118-1706">如何：接收第一個可能發生的例外狀況通知</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1706">How to: Receive First-Chance Exception Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1707">取得應用程式定義域的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1707">Gets the friendly name of this application domain.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-1708">這個應用程式定義域的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1708">The friendly name of this application domain.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1709">預設應用程式定義域的易記名稱是可執行檔的程序的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1709">The friendly name of the default application domain is the file name of the process executable.</span></span> <span data-ttu-id="f1118-1710">例如，用來啟動處理程序的可執行檔是否`"c:\MyAppDirectory\MyAssembly.exe"`，預設應用程式定義域的易記名稱是`"MyAssembly.exe"`。</span><span class="sxs-lookup"><span data-stu-id="f1118-1710">For example, if the executable used to start the process is `"c:\MyAppDirectory\MyAssembly.exe"`, the friendly name of the default application domain is `"MyAssembly.exe"`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1711">下列程式碼範例使用<xref:System.AppDomain.FriendlyName%2A>屬性來取得目前的應用程式定義域的易記名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1711">The following code example uses the <xref:System.AppDomain.FriendlyName%2A> property to get the friendly name of the current application domain.</span></span> <span data-ttu-id="f1118-1712">預設應用程式定義域的易記名稱會是應用程式的可執行檔的名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1712">For the default application domain, the friendly name is the name of the application's executable file.</span></span> <span data-ttu-id="f1118-1713">在程式碼範例也會顯示應用程式定義域的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="f1118-1713">The code example also displays additional information about the application domain.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1714">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1714">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1715">取得已載入至這個應用程式定義域之執行內容的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1715">Gets the assemblies that have been loaded into the execution context of this application domain.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1716">這個應用程式定義域中的組件陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1716">An array of assemblies in this application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f1118-1717">下列程式碼範例使用<xref:System.AppDomain.GetAssemblies%2A>方法來取得已載入至應用程式定義域的所有組件清單。</span><span class="sxs-lookup"><span data-stu-id="f1118-1717">The following code example uses the <xref:System.AppDomain.GetAssemblies%2A> method to get a list of all assemblies that have been loaded into the application domain.</span></span> <span data-ttu-id="f1118-1718">組件隨即顯示到主控台。</span><span class="sxs-lookup"><span data-stu-id="f1118-1718">The assemblies are then displayed to the console.</span></span>  
  
 <span data-ttu-id="f1118-1719">若要執行此程式碼範例，您需要建立名為組件`CustomLibrary.dll`，或變更組件名稱傳遞給<xref:System.AppDomain.GetAssemblies%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1719">To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1720">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1720">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1721">取得目前的執行緒識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1721">Gets the current thread identifier.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1722">32 位元帶正負號的整數 (Signed Integer)，其為目前執行緒的識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1722">A 32-bit signed integer that is the identifier of the current thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1723">使用<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>屬性，這是穩定甚至當.NET Framework 由裝載環境能支援 fiber （也就是輕量型執行緒）。</span><span class="sxs-lookup"><span data-stu-id="f1118-1723">Use the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1724">呼叫這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1724">to call this method.</span>
          </span>
          <span data-ttu-id="f1118-1725">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1725">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="f1118-1726">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1726">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-1727">預先定義的應用程式定義域屬性的名稱，或是已經定義的應用程式定義域屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1727">The name of a predefined application domain property, or the name of an application domain property you have defined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1728">針對指定之名稱取得儲存在目前應用程式定義域中的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1728">Gets the value stored in the current application domain for the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1729">
            <paramref name="name" /> 屬性的值；如果這個屬性不存在，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1729">The value of the <paramref name="name" /> property, or <see langword="null" /> if the property does not exist.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1730">使用這個方法來擷取值的描述屬性的這個執行個體的名稱資料組的內部快取中的項目<xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1730">Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span> <span data-ttu-id="f1118-1731">請注意，比較`name`索引鍵 / 值組的名稱會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="f1118-1731">Note that the comparison of `name` with the name of key-value pairs is case-sensitive.</span></span>  
  
 <span data-ttu-id="f1118-1732">快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。</span><span class="sxs-lookup"><span data-stu-id="f1118-1732">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="f1118-1733">您可以查看其值與<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1733">You can inspect their values with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties.</span></span>  
  
 <span data-ttu-id="f1118-1734">您可以插入或修改您自己的使用者定義名稱資料組，而且<xref:System.AppDomain.SetData%2A>方法，並檢查其值與<xref:System.AppDomain.GetData%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1734">You can insert or modify your own user defined name-data pairs with the <xref:System.AppDomain.SetData%2A> method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 <span data-ttu-id="f1118-1735">下表描述`name`每個預先定義的系統項目和其對應<xref:System.AppDomainSetup>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1735">The following table describes the `name` of each predefined system entry and its corresponding <xref:System.AppDomainSetup> property.</span></span>  
  
|<span data-ttu-id="f1118-1736">'Name' 的值</span><span class="sxs-lookup"><span data-stu-id="f1118-1736">Value of 'name'</span></span>|<span data-ttu-id="f1118-1737">屬性</span><span class="sxs-lookup"><span data-stu-id="f1118-1737">Property</span></span>|  
|---------------------|--------------|  
|<span data-ttu-id="f1118-1738">「 APPBASE"</span><span class="sxs-lookup"><span data-stu-id="f1118-1738">"APPBASE"</span></span>|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1739">"APP_CONFIG_FILE"</span><span class="sxs-lookup"><span data-stu-id="f1118-1739">"APP_CONFIG_FILE"</span></span>|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1740">「 APP_LAUNCH_URL"</span><span class="sxs-lookup"><span data-stu-id="f1118-1740">"APP_LAUNCH_URL"</span></span>|<span data-ttu-id="f1118-1741">（沒有內容）</span><span class="sxs-lookup"><span data-stu-id="f1118-1741">(no property)</span></span><br /><br /> <span data-ttu-id="f1118-1742">「 APP_LAUNCH_URL"表示原先要求的使用者之前任何重新導向, 的 URL。</span><span class="sxs-lookup"><span data-stu-id="f1118-1742">"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</span></span> <span data-ttu-id="f1118-1743">它位於已啟動應用程式，例如 Internet Explorer 的瀏覽器時，才。</span><span class="sxs-lookup"><span data-stu-id="f1118-1743">It is available only when the application has been launched with a browser such as Internet Explorer.</span></span> <span data-ttu-id="f1118-1744">並非所有瀏覽器提供此值。</span><span class="sxs-lookup"><span data-stu-id="f1118-1744">Not all browsers provide this value.</span></span>|  
|<span data-ttu-id="f1118-1745">「 APP_NAME"</span><span class="sxs-lookup"><span data-stu-id="f1118-1745">"APP_NAME"</span></span>|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1746">「 BINPATH_PROBE_ONLY"</span><span class="sxs-lookup"><span data-stu-id="f1118-1746">"BINPATH_PROBE_ONLY"</span></span>|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1747">「 CACHE_BASE"</span><span class="sxs-lookup"><span data-stu-id="f1118-1747">"CACHE_BASE"</span></span>|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1748">「 CODE_DOWNLOAD_DISABLED"</span><span class="sxs-lookup"><span data-stu-id="f1118-1748">"CODE_DOWNLOAD_DISABLED"</span></span>|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1749">「 DEV_PATH"</span><span class="sxs-lookup"><span data-stu-id="f1118-1749">"DEV_PATH"</span></span>|<span data-ttu-id="f1118-1750">（沒有內容）</span><span class="sxs-lookup"><span data-stu-id="f1118-1750">(no property)</span></span>|  
|<span data-ttu-id="f1118-1751">「 DISALLOW_APP"</span><span class="sxs-lookup"><span data-stu-id="f1118-1751">"DISALLOW_APP"</span></span>|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1752">"DISALLOW_APP_BASE_PROBING"</span><span class="sxs-lookup"><span data-stu-id="f1118-1752">"DISALLOW_APP_BASE_PROBING"</span></span>|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1753">「 DISALLOW_APP_REDIRECTS"</span><span class="sxs-lookup"><span data-stu-id="f1118-1753">"DISALLOW_APP_REDIRECTS"</span></span>|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1754">"DYNAMIC_BASE"</span><span class="sxs-lookup"><span data-stu-id="f1118-1754">"DYNAMIC_BASE"</span></span>|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1755">「 FORCE_CACHE_INSTALL"</span><span class="sxs-lookup"><span data-stu-id="f1118-1755">"FORCE_CACHE_INSTALL"</span></span>|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1756">「 LICENSE_FILE"或特定應用程式的字串</span><span class="sxs-lookup"><span data-stu-id="f1118-1756">"LICENSE_FILE", or an application-specific string</span></span>|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1757">「 LOADER_OPTIMIZATION"</span><span class="sxs-lookup"><span data-stu-id="f1118-1757">"LOADER_OPTIMIZATION"</span></span>|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1758">「 LOCATION_URI"</span><span class="sxs-lookup"><span data-stu-id="f1118-1758">"LOCATION_URI"</span></span>|<span data-ttu-id="f1118-1759">（沒有內容）</span><span class="sxs-lookup"><span data-stu-id="f1118-1759">(no property)</span></span>|  
|<span data-ttu-id="f1118-1760">「 PRIVATE_BINPATH"</span><span class="sxs-lookup"><span data-stu-id="f1118-1760">"PRIVATE_BINPATH"</span></span>|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="f1118-1761">"REGEX_DEFAULT_MATCH_TIMEOUT"</span><span class="sxs-lookup"><span data-stu-id="f1118-1761">"REGEX_DEFAULT_MATCH_TIMEOUT"</span></span>|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> <span data-ttu-id="f1118-1762">「 REGEX_DEFAULT_MATCH_TIMEOUT"不是系統項目和它的值可以藉由呼叫設定<xref:System.AppDomain.SetData%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1762">"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <xref:System.AppDomain.SetData%2A> method.</span></span>|  
|<span data-ttu-id="f1118-1763">"SHADOW_COPY_DIRS"</span><span class="sxs-lookup"><span data-stu-id="f1118-1763">"SHADOW_COPY_DIRS"</span></span>|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1764">下列範例會建立新的應用程式定義域、 設定的網域中，系統提供值，並將新的值組的網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1764">The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</span></span> <span data-ttu-id="f1118-1765">下列範例示範如何使用<xref:System.AppDomain.GetData%2A>方法來擷取這些值組中的資料，並對主控台顯示它們。</span><span class="sxs-lookup"><span data-stu-id="f1118-1765">The example then demonstrates how to use the <xref:System.AppDomain.GetData%2A> method to retrieve the data from these value pairs and display them to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1766">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1766">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1767">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1767">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1768">存取路徑本身，如果此屬性會套用至路徑中的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1768">for access to the information in the path itself, if the property applies to a path.</span>
          </span>
          <span data-ttu-id="f1118-1769">關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1769">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1770">取得目前執行個體的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1770">Gets the type of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1771">目前執行個體的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1771">The type of the current instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1772">取得可唯一識別處理程序中之應用程式定義域的整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1772">Gets an integer that uniquely identifies the application domain within the process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-1773">可識別應用程式定義域的整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1773">An integer that identifies the application domain.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f1118-1774">下列程式碼範例會建立第二個應用程式定義域，並顯示相關的預設網域和新的網域資訊。</span><span class="sxs-lookup"><span data-stu-id="f1118-1774">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1775">藉由防止建立租用 (Lease)，為 <see cref="T:System.AppDomain" /> 提供無限的存留期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1775">Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1776">一定是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1776">Always <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1777">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1777">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-1778">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1778">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-1779">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1779">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="f1118-1780">要測試的相容性參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1780">The compatibility switch to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1781">取得可為 Null 的布林值，這個值表示是否已設定任何相容性參數，如果已設定，是否已設定指定的相容性參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1781">Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1782">如果未設定任何相容性參數則為 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)；否則為布林值，以表示是否已設定 <paramref name="value" /> 所指定之相容性參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1782">A null reference (<see langword="Nothing" /> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1783">這個方法會測試是否已指定相容性參數設定為目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1783">This method tests whether the specified compatibility switch has been set for the current application domain.</span></span> <span data-ttu-id="f1118-1784">相容性參數通常還原行為 （例如排序方式字串） 的.NET framework 版本之間已變更。</span><span class="sxs-lookup"><span data-stu-id="f1118-1784">Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</span></span>  <span data-ttu-id="f1118-1785">它們由呼叫設定<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType>方法，然後再建立應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1785">They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> method before creating an application domain.</span></span>  
  
 <span data-ttu-id="f1118-1786">下表提供可以設定以還原舊版的.NET framework 的行為的相容性參數的範例。</span><span class="sxs-lookup"><span data-stu-id="f1118-1786">The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</span></span>  
  
|<span data-ttu-id="f1118-1787">參數</span><span class="sxs-lookup"><span data-stu-id="f1118-1787">Switch</span></span>|<span data-ttu-id="f1118-1788">意義</span><span class="sxs-lookup"><span data-stu-id="f1118-1788">Meaning</span></span>|  
|------------|-------------|  
|<span data-ttu-id="f1118-1789">"NetFx40_LegacySecurityPolicy"</span><span class="sxs-lookup"><span data-stu-id="f1118-1789">"NetFx40_LegacySecurityPolicy"</span></span>|<span data-ttu-id="f1118-1790">程式碼存取安全性 (CAS)[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用此應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-1790">Code access security (CAS) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="f1118-1791">請參閱[ &lt;NetFx40_LegacySecurityPolicy&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1791">See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span></span>|  
|<span data-ttu-id="f1118-1792">"NetFx40_Legacy20SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="f1118-1792">"NetFx40_Legacy20SortingBehavior"</span></span>|<span data-ttu-id="f1118-1793">排序的預設值的字串[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]這個應用程式定義域中已啟用。</span><span class="sxs-lookup"><span data-stu-id="f1118-1793">String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain.</span></span> <span data-ttu-id="f1118-1794">它的成功需要 sort00001000.dll 安裝。</span><span class="sxs-lookup"><span data-stu-id="f1118-1794">Its success requires sort00001000.dll to be installed.</span></span> <span data-ttu-id="f1118-1795">請參閱[ &lt;CompatSortNLSVersion&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1795">See [&lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span></span>|  
|<span data-ttu-id="f1118-1796">"NetFx40_Legacy40SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="f1118-1796">"NetFx40_Legacy40SortingBehavior"</span></span>|<span data-ttu-id="f1118-1797">排序的預設值的字串[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和 Unicode 5.0 會啟用此應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-1797">String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain.</span></span> <span data-ttu-id="f1118-1798">它的成功需要 sort00060101.dll 安裝。</span><span class="sxs-lookup"><span data-stu-id="f1118-1798">Its success requires sort00060101.dll to be installed.</span></span>|  
|<span data-ttu-id="f1118-1799">"NetFx40_TimeSpanLegacyFormatMode"</span><span class="sxs-lookup"><span data-stu-id="f1118-1799">"NetFx40_TimeSpanLegacyFormatMode"</span></span>|<span data-ttu-id="f1118-1800"><xref:System.TimeSpan> 格式化行為的[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]啟用此應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-1800"><xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span>  <span data-ttu-id="f1118-1801">請參閱[ &lt;TimeSpan_LegacyFormatMode&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)和 「 還原舊版 TimeSpan 格式化 」 一節的<xref:System.TimeSpan>主題。</span><span class="sxs-lookup"><span data-stu-id="f1118-1801">See [&lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.</span></span>|  
|<span data-ttu-id="f1118-1802">"UseRandomizedStringHashAlgorithm"</span><span class="sxs-lookup"><span data-stu-id="f1118-1802">"UseRandomizedStringHashAlgorithm"</span></span>|<span data-ttu-id="f1118-1803">執行階段計算字串的雜湊碼在每個應用程式定義域為基準，而不是使用單一的雜湊演算法可跨應用程式定義域產生一致雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-1803">The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</span></span> <span data-ttu-id="f1118-1804">請參閱[ &lt;UseRandomizedStringHashAlgorithm&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1804">See [&lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1805">傳回值，指出應用程式定義域是否為該處理程序的預設應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1805">Returns a value that indicates whether the application domain is the default application domain for the process.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1806">如果目前的 <see cref="T:System.AppDomain" /> 物件代表處理程序的預設應用程式定義域，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1806">
              <see langword="true" /> if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1807">每個受管理的程序具有預設應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1807">Every managed process has a default application domain.</span></span> <span data-ttu-id="f1118-1808">在 預設網域，開始執行。</span><span class="sxs-lookup"><span data-stu-id="f1118-1808">Execution begins in the default domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1809">下列程式碼範例會建立第二個應用程式定義域，並顯示相關的預設網域和新的網域資訊。</span><span class="sxs-lookup"><span data-stu-id="f1118-1809">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1810">指示這個應用程式定義域是否正在卸載，以及其包含的物件是否正在由 Common Language Runtime 進行最終處理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1810">Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1811">如果這個應用程式定義域正在卸載且 Common Language Runtime 已開始叫用完成項，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1811">
              <see langword="true" /> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1812">物件的最終處理方法會提供物件的記憶體回收之前執行任何必要的清除作業的機會。</span><span class="sxs-lookup"><span data-stu-id="f1118-1812">The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</span></span> <span data-ttu-id="f1118-1813">在最終處理之後, 此物件會為可存取，但處於無效狀態，因此無法使用。</span><span class="sxs-lookup"><span data-stu-id="f1118-1813">After finalization, the object is accessible but in an invalid state and therefore unusable.</span></span> <span data-ttu-id="f1118-1814">最後，記憶體回收完成，並回收物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1814">Eventually, garbage collection completes and reclaims the object.</span></span>  
  
 <span data-ttu-id="f1118-1815">在下列情況的其中一個呼叫物件的完成項方法： 記憶體回收期間，當正在關閉通用語言執行平台，或包含物件的應用程式定義域卸載時。</span><span class="sxs-lookup"><span data-stu-id="f1118-1815">An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</span></span> <span data-ttu-id="f1118-1816"><xref:System.AppDomain.IsFinalizingForUnload%2A>方法會傳回`true`只有在最後一個案例中; 它不會傳回`true`當最終處理的結果從例行回收或 CLR 關閉。</span><span class="sxs-lookup"><span data-stu-id="f1118-1816">The <xref:System.AppDomain.IsFinalizingForUnload%2A> method returns `true` only in the last case; it does not return `true` if finalization results from routine garbage collection or from CLR shutdown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1817">若要判斷是否因為 CLR 關閉，所以最終處理，請使用<xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1817">To determine whether finalization is due to CLR shutdown, use the <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f1118-1818">它會傳回`true`最終處理是否因為應用程式定義域正在卸載或 clr 正在關閉。</span><span class="sxs-lookup"><span data-stu-id="f1118-1818">It returns `true` if finalization is due to an application domain being unloaded or to the CLR shutting down.</span></span>  
  
 <span data-ttu-id="f1118-1819">同時在您完成的方法執行期間定義域卸載，您可能想要存取靜態欄位所參考，且具有最終處理方法的另一個物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1819">While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</span></span> <span data-ttu-id="f1118-1820">不過，您無法可靠地執行，因為存取的物件可能會有已經結束。</span><span class="sxs-lookup"><span data-stu-id="f1118-1820">However, you cannot reliably do so because the accessed object might already have been finalized.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1821">此規則的例外是<xref:System.Console>類別，其中包含參考資料流物件的靜態欄位，但您可以一律，即使在網域卸載或系統關機期間寫入系統主控台中，因此，特別實作。</span><span class="sxs-lookup"><span data-stu-id="f1118-1821">An exception to this rule is the <xref:System.Console> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</span></span>  
  
 <span data-ttu-id="f1118-1822">物件的完成項方法中使用這個方法，以判斷是否包含物件的應用程式定義域正在卸載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1822">Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</span></span> <span data-ttu-id="f1118-1823">如果是這樣，您無法可靠地存取具有完成項方法，並且由靜態欄位參考的任何物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1823">If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1824">取得值，該值指出載入目前應用程式定義域中的組件是否在完全信任情況下執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1824">Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-1825">如果載入目前應用程式定義域中的組件在完全信任情況下執行，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1825">
              <see langword="true" /> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1826">這個方法永遠傳回`true`桌面上執行的應用程式的預設應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1826">This method always returns `true` for the default application domain of an application that runs on the desktop.</span></span> <span data-ttu-id="f1118-1827">它會傳回`false`，利用所建立的沙箱化應用程式網域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載，除非應用程式定義域授與的權限相當於完全信任。</span><span class="sxs-lookup"><span data-stu-id="f1118-1827">It returns `false` for a sandboxed application domain that was created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1828">下列範例示範<xref:System.AppDomain.IsFullyTrusted%2A>屬性和<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>與完全信任和部分信任的應用程式定義域的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-1828">The following example demonstrates the <xref:System.AppDomain.IsFullyTrusted%2A> property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> property with fully trusted and partially trusted application domains.</span></span> <span data-ttu-id="f1118-1829">應用程式的預設應用程式定義域為完全受信任的應用程式網域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1829">The fully trusted application domain is the default application domain for the application.</span></span> <span data-ttu-id="f1118-1830">部分信任的應用程式定義域由使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1830">The partially trusted application domain is created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span>  
  
 <span data-ttu-id="f1118-1831">此範例會使用`Worker`類別衍生自<xref:System.MarshalByRefObject>，因此它可以封送處理跨應用程式定義域界限。</span><span class="sxs-lookup"><span data-stu-id="f1118-1831">The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="f1118-1832">此範例會建立`Worker`預設應用程式定義域中的物件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1832">The example creates a `Worker` object in the default application domain.</span></span> <span data-ttu-id="f1118-1833">然後它會呼叫`TestIsFullyTrusted`方法，以顯示屬性值，應用程式定義域並載入至應用程式定義域的兩個組件： mscorlib，這是.NET Framework 和範例組件的一部分。</span><span class="sxs-lookup"><span data-stu-id="f1118-1833">It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</span></span> <span data-ttu-id="f1118-1834">這兩個組件是完全受信任，所以完全信任，應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1834">The application domain is fully trusted, so both assemblies are fully trusted.</span></span>  
  
 <span data-ttu-id="f1118-1835">此範例會建立另一個`Worker`物件在沙箱應用程式定義域，然後再次呼叫`TestIsFullyTrusted`方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1835">The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method.</span></span> <span data-ttu-id="f1118-1836">Mscorlib 永遠是受信任，甚至是在部分信任的應用程式網域中，但是範例組件是以部分信任。</span><span class="sxs-lookup"><span data-stu-id="f1118-1836">Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</span></span>  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1837">取得值，這個值表示目前應用程式定義域是否會授與一組權限給所有載入該應用程式定義域中的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1837">Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-1838">如果目前應用程式定義域具有一組同質性權限，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1838">
              <see langword="true" /> if the current application domain has a homogenous set of permissions; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1839">這個屬性會傳回`true`使用所建立的沙箱化應用程式定義域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1839">This property returns `true` for sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="f1118-1840">沙箱應用程式定義域具有一組同質性權限;也就是相同的權限集授與載入應用程式定義域的所有部分信任組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1840">Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="f1118-1841">（選擇性） 沙箱應用程式定義域會有免套用此權限集，並改為使用完全信任執行的強式名稱組件清單。</span><span class="sxs-lookup"><span data-stu-id="f1118-1841">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 <span data-ttu-id="f1118-1842">完全受信任的程式碼可以使用<xref:System.AppDomain.PermissionSet%2A>屬性來判斷沙箱應用程式定義域的同質性的授權集。</span><span class="sxs-lookup"><span data-stu-id="f1118-1842">Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.</span></span>  
  
 <span data-ttu-id="f1118-1843">這個屬性也會傳回`true`預設應用程式定義域的桌面應用程式，因為該應用程式定義域會完全信任授與所有組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1843">This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-1844">將 <see cref="T:System.Reflection.Assembly" /> 載入這個應用程式定義域中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1844">Loads an <see cref="T:System.Reflection.Assembly" /> into this application domain.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="f1118-1845">
            <see langword="byte" /> 類型的陣列，這是包含發出組件之以 COFF 為基礎的影像。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1845">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1846">載入具備通用物件檔案格式 (COFF) 影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1846">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1847">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1847">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1848">開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。</span><span class="sxs-lookup"><span data-stu-id="f1118-1848">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="f1118-1849">這個方法應只將組件載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1849">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="f1118-1850">為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1850">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f1118-1851">若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1851">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="f1118-1852">通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1852">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1853">下列範例示範如何載入原始的組件的使用。</span><span class="sxs-lookup"><span data-stu-id="f1118-1853">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="f1118-1854">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1854">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1855">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1855">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1856">
            <paramref name="rawAssembly" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1856">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1857">
            <paramref name="rawAssembly" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1857">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1858">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1858">-or-</span>
          </span>
          <span data-ttu-id="f1118-1859">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1859">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1860">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1860">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1861">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1861">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1862">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1862">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1863">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1863">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">
          <span data-ttu-id="f1118-1864">物件，描述要載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1864">An object that describes the assembly to load.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1865">載入提供了 <see cref="T:System.Reflection.AssemblyName" /> 的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1865">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1866">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1866">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1867">這個方法應只將組件載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1867">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="f1118-1868">為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1868">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f1118-1869">若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1869">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="f1118-1870">如果尚未載入要求的組件的版本，這個方法會傳回載入的組件，即使要求不同的版本。</span><span class="sxs-lookup"><span data-stu-id="f1118-1870">If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</span></span>  
  
 <span data-ttu-id="f1118-1871">提供的部分組件名稱`assemblyRef`不建議使用。</span><span class="sxs-lookup"><span data-stu-id="f1118-1871">Supplying a partial assembly name for `assemblyRef` is not recommended.</span></span> <span data-ttu-id="f1118-1872">（部分的名稱會省略一或多個文化特性、 版本或公開金鑰語彙基元。</span><span class="sxs-lookup"><span data-stu-id="f1118-1872">(A partial name omits one or more of culture, version, or public key token.</span></span> <span data-ttu-id="f1118-1873">採用而不是字串的多載<xref:System.Reflection.AssemblyName>物件，"MyAssembly，版本 = 1.0.0.0"舉例說明部分的名稱和"MyAssembly，version=1.0.0.0，Culture = neutral，PublicKeyToken = 18ab3442da84b47"是完整名稱的範例。)使用部分的名稱已對效能產生負面影響。</span><span class="sxs-lookup"><span data-stu-id="f1118-1873">For overloads that take a string instead of an <xref:System.Reflection.AssemblyName> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</span></span> <span data-ttu-id="f1118-1874">此外，部分組件名稱可以載入組件從全域組件快取才有的應用程式的基底目錄中的組件的完整複本 (<xref:System.AppDomain.BaseDirectory%2A>或<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1874">In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<xref:System.AppDomain.BaseDirectory%2A> or <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="f1118-1875">如果目前<xref:System.AppDomain>物件表示應用程式定義域`A`，而<xref:System.AppDomain.Load%2A>方法從應用程式定義域呼叫`B`，組件會載入兩個應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1875">If the current <xref:System.AppDomain> object represents application domain `A`, and the <xref:System.AppDomain.Load%2A> method is called from application domain `B`, the assembly is loaded into both application domains.</span></span> <span data-ttu-id="f1118-1876">例如，下列程式碼載入`MyAssembly`至新的應用程式定義域`ChildDomain`也到應用程式定義域執行的程式碼：</span><span class="sxs-lookup"><span data-stu-id="f1118-1876">For example, the following code loads `MyAssembly` into the new application domain `ChildDomain` and also into the application domain where the code executes:</span></span>  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 <span data-ttu-id="f1118-1877">組件載入這兩個網域，因為<xref:System.Reflection.Assembly>不是衍生自<xref:System.MarshalByRefObject>，並因此傳回值的<xref:System.AppDomain.Load%2A>方法無法封送處理。</span><span class="sxs-lookup"><span data-stu-id="f1118-1877">The assembly is loaded into both domains because <xref:System.Reflection.Assembly> does not derive from <xref:System.MarshalByRefObject>, and therefore the return value of the <xref:System.AppDomain.Load%2A> method cannot be marshaled.</span></span> <span data-ttu-id="f1118-1878">相反地，common language runtime 會嘗試載入至呼叫的應用程式定義域的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1878">Instead, the common language runtime tries to load the assembly into the calling application domain.</span></span> <span data-ttu-id="f1118-1879">載入至兩個應用程式定義域的組件可能是不同的兩個應用程式定義域的路徑設定是否不同。</span><span class="sxs-lookup"><span data-stu-id="f1118-1879">The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-1880">如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>屬性所設定，第一次嘗試載入組件會使用顯示名稱 (包括版本、 文化特性，並依此類推，所傳回<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1880">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="f1118-1881">如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性用來搜尋該組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1881">If the file is not found, the <xref:System.Reflection.AssemblyName.CodeBase%2A> property is used to search for the assembly.</span></span> <span data-ttu-id="f1118-1882">如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，顯示名稱比對組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-1882">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="f1118-1883">如果比對失敗，<xref:System.IO.FileLoadException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-1883">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1884">
            <paramref name="assemblyRef" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1884">
              <paramref name="assemblyRef" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1885">找不到 <paramref name="assemblyRef" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1885">
              <paramref name="assemblyRef" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1886">
            <paramref name="assemblyRef" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1886">
              <paramref name="assemblyRef" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1887">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1887">-or-</span>
          </span>
          <span data-ttu-id="f1118-1888">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyRef" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1888">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1889">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1889">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1890">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1890">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1891">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1891">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1892">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1892">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <span data-ttu-id="f1118-1893">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1893">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-1894">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1894">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1895">載入提供了顯示名稱的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1895">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1896">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1896">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1897">這個方法應只將組件載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1897">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="f1118-1898">為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1898">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f1118-1899">若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1899">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="f1118-1900">通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1900">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1901">
            <paramref name="assemblyString" /> 是 <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1901">
              <paramref name="assemblyString" /> is <see langword="null" /></span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1902">找不到 <paramref name="assemblyString" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1902">
              <paramref name="assemblyString" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1903">
            <paramref name="assemblyString" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1903">
              <paramref name="assemblyString" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1904">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1904">-or-</span>
          </span>
          <span data-ttu-id="f1118-1905">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyString" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1905">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1906">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1906">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1907">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1907">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1908">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1908">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1909">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1909">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1910">提供存取組件的位置，如果組件不是本機的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1910">for the ability to access the location of the assembly if the assembly is not local.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="f1118-1911">
            <see langword="byte" /> 類型的陣列，這是包含發出組件之以 COFF 為基礎的影像。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1911">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="f1118-1912">
            <see langword="byte" /> 類型的陣列，包含代表組件符號的未經處理位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1912">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1913">載入具備通用物件檔案格式 (COFF) 影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1913">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span>
          </span>
          <span data-ttu-id="f1118-1914">也會載入代表 <see cref="T:System.Reflection.Assembly" /> 符號且未經處理的位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1914">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1915">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1915">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1916">開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。</span><span class="sxs-lookup"><span data-stu-id="f1118-1916">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="f1118-1917">這個方法應只將組件載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1917">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="f1118-1918">為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1918">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f1118-1919">若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1919">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="f1118-1920">通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1920">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1921">下列範例示範如何載入原始的組件的使用。</span><span class="sxs-lookup"><span data-stu-id="f1118-1921">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="f1118-1922">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1922">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1923">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1923">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1924">
            <paramref name="rawAssembly" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1924">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1925">
            <paramref name="rawAssembly" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1925">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1926">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1926">-or-</span>
          </span>
          <span data-ttu-id="f1118-1927">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1927">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1928">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1928">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1929">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1929">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1930">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1930">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1931">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1931">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1932">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1932">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">
          <span data-ttu-id="f1118-1933">物件，描述要載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1933">An object that describes the assembly to load.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="f1118-1934">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1934">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1935">載入提供了 <see cref="T:System.Reflection.AssemblyName" /> 的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1935">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1936">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1936">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1937">這個方法應只將組件載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1937">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="f1118-1938">為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1938">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f1118-1939">若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1939">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="f1118-1940">通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1940">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1941">
            <paramref name="assemblyRef" /> 是 <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1941">
              <paramref name="assemblyRef" /> is <see langword="null" /></span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1942">找不到 <paramref name="assemblyRef" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1942">
              <paramref name="assemblyRef" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1943">
            <paramref name="assemblyRef" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1943">
              <paramref name="assemblyRef" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1944">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1944">-or-</span>
          </span>
          <span data-ttu-id="f1118-1945">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyRef" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1945">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1946">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1946">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1947">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1947">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1948">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1948">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1949">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1949">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1950">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1950">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1951">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1951">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1952">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1952">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <span data-ttu-id="f1118-1953">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1953">The display name of the assembly.</span>
          </span>
          <span data-ttu-id="f1118-1954">請參閱 <see cref="P:System.Reflection.Assembly.FullName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1954">See <see cref="P:System.Reflection.Assembly.FullName" />.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="f1118-1955">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1955">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1956">載入提供了顯示名稱的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1956">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1957">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1957">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1958">這個方法應只將組件載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1958">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="f1118-1959">為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1959">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f1118-1960">若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1960">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="f1118-1961">通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1961">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1962">
            <paramref name="assemblyString" /> 是 <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1962">
              <paramref name="assemblyString" /> is <see langword="null" /></span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="f1118-1963">找不到 <paramref name="assemblyString" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1963">
              <paramref name="assemblyString" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1964">
            <paramref name="assemblyString" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1964">
              <paramref name="assemblyString" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1965">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1965">-or-</span>
          </span>
          <span data-ttu-id="f1118-1966">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="assemblyString" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1966">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1967">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1967">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1968">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1968">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1969">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1969">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="f1118-1970">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1970">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1971">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1971">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-1972">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1972">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-1973">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1973">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="f1118-1974">
            <see langword="byte" /> 類型的陣列，這是包含發出組件之以 COFF 為基礎的影像。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1974">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="f1118-1975">
            <see langword="byte" /> 類型的陣列，包含代表組件符號的未經處理位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1975">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="f1118-1976">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1976">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-1977">載入具備通用物件檔案格式 (COFF) 影像 (包含發出的 <see cref="T:System.Reflection.Assembly" />) 的 <see cref="T:System.Reflection.Assembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1977">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span>
          </span>
          <span data-ttu-id="f1118-1978">也會載入代表 <see cref="T:System.Reflection.Assembly" /> 符號且未經處理的位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1978">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-1979">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1979">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-1980">開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是應用程式定義域的信任層級相同。</span><span class="sxs-lookup"><span data-stu-id="f1118-1980">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="f1118-1981">這個方法應只將組件載入目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-1981">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="f1118-1982">為了方便起見提供這個方法的互通性的呼叫端無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-1982">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f1118-1983">若要將其他應用程式定義域的組件載入，使用方法例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-1983">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="f1118-1984">通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="f1118-1984">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-1985">下列範例示範如何載入原始的組件的使用。</span><span class="sxs-lookup"><span data-stu-id="f1118-1985">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="f1118-1986">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-1986">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-1987">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-1987">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-1988">
            <paramref name="rawAssembly" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1988">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="f1118-1989">
            <paramref name="rawAssembly" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1989">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="f1118-1990">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1990">-or-</span>
          </span>
          <span data-ttu-id="f1118-1991">目前載入的是 Common Language Runtime 2.0 版或更新版本，而 <paramref name="rawAssembly" /> 是使用更新的版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1991">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-1992">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1992">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="f1118-1993">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1993">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f1118-1994">
            <paramref name="securityEvidence" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1994">
              <paramref name="securityEvidence" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f1118-1995">若未啟用舊版 CAS 原則，<paramref name="securityEvidence" /> 應為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1995">When legacy CAS policy is not enabled, <paramref name="securityEvidence" /> should be <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-1996">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1996">to provide evidence.</span>
          </span>
          <span data-ttu-id="f1118-1997">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1997">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
          <span data-ttu-id="f1118-1998">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1998">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-1999">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-1999">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="f1118-2000">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2000">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="f1118-2001">用於讀取的路徑，不是格式"file:// 或"\\\UNC\dir\\"或"c:\\"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2001">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2002">取得或設定值，這個值表示是否對目前處理程序啟用應用程式定義域的 CPU 和記憶體監視。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2002">Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</span>
          </span>
          <span data-ttu-id="f1118-2003">一旦對處理程序啟用監視，就不能停用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2003">Once monitoring is enabled for a process, it cannot be disabled.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2004">如果啟用監視，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2004">
              <see langword="true" /> if monitoring is enabled; otherwise <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2005">這`static`屬性 (`Shared`屬性在 Visual Basic) 控制 CPU 和記憶體監視的程序中的所有應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-2005">This `static` property (`Shared` property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</span></span>  
  
 <span data-ttu-id="f1118-2006">如果您嘗試將此屬性設定為`false`，則<xref:System.ArgumentException>會擲回例外狀況，即使目前屬性的值是`false`。</span><span class="sxs-lookup"><span data-stu-id="f1118-2006">If you attempt to set this property to `false`, a <xref:System.ArgumentException> exception is thrown, even if the current value of the property is `false`.</span></span>  
  
 <span data-ttu-id="f1118-2007">一旦啟用監視，您可以使用<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>， <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>， <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>，和<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>執行個體來監視個別的應用程式定義域的 CPU 和記憶體使用的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2007">Once monitoring is enabled, you can use the <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, and <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> instance properties to monitor CPU and memory use of individual application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f1118-2008">目前的處理程序嘗試將值 <see langword="false" /> 指派給這個屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2008">The current process attempted to assign the value <see langword="false" /> to this property.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2009">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2009">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2010">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2010">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">
          <span data-ttu-id="f1118-2011">應用程式定義域資源監視</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2011">Application Domain Resource Monitoring</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd">
          <span data-ttu-id="f1118-2012">&lt;appdomainResourceMonitoring&gt;項目</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2012">&lt;appdomainResourceMonitoring&gt; Element</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2013">取得自上次回收作業後存留下來，且已知正由目前應用程式定義域參考之位元組的數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2013">Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2014">存留的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2014">The number of surviving bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2015">每次記憶體回收會更新統計資料。</span><span class="sxs-lookup"><span data-stu-id="f1118-2015">The statistics are updated with each garbage collection.</span></span> <span data-ttu-id="f1118-2016">不過，它們會保證完整、 阻斷式收集; 之後，才是正確的也就是的集合，其中包含所有層代和，以停止應用程式，這時集合就會發生。</span><span class="sxs-lookup"><span data-stu-id="f1118-2016">However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</span></span> <span data-ttu-id="f1118-2017">比方說，<xref:System.GC.Collect?displayProperty=nameWithType>方法多載會執行完整、 阻斷式收集。</span><span class="sxs-lookup"><span data-stu-id="f1118-2017">For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload performs a full, blocking collection.</span></span> <span data-ttu-id="f1118-2018">（並行集合會在背景進行的而且不會封鎖應用程式）。</span><span class="sxs-lookup"><span data-stu-id="f1118-2018">(Concurrent collection occurs in the background and does not block the application.)</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f1118-2019">
            <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性已設為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2019">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2020">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2020">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2021">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2021">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">
          <span data-ttu-id="f1118-2022">應用程式定義域資源監視</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2022">Application Domain Resource Monitoring</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2023">針對處理程序中的所有應用程式定義域，取得自上次回收作業存留下來的位元組總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2023">Gets the total bytes that survived from the last collection for all application domains in the process.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2024">處理程序的存留位元組總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2024">The total number of surviving bytes for the process.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2025">完整、 阻斷式收集之後, 的位元組數目目前保留位於此數字代表 managed 堆積。</span><span class="sxs-lookup"><span data-stu-id="f1118-2025">After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</span></span> <span data-ttu-id="f1118-2026">它應該接近所報告的數字<xref:System.GC.GetTotalMemory%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2026">It should be close to the number reported by the <xref:System.GC.GetTotalMemory%2A> method.</span></span> <span data-ttu-id="f1118-2027">暫時的集合之後, 此數字代表位元組數目目前保留要即時暫時層代中。</span><span class="sxs-lookup"><span data-stu-id="f1118-2027">After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f1118-2028">
            <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性已設為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2028">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2029">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2029">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2030">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2030">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">
          <span data-ttu-id="f1118-2031">應用程式定義域資源監視</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2031">Application Domain Resource Monitoring</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2032">取得應用程式定義域自其建立後已配置之所有記憶體的總大小 (以位元組為單位)，但不減去已回收的記憶體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2032">Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2033">所有記憶體配置的總大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2033">The total size of all memory allocations.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f1118-2034">
            <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性已設為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2034">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2035">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2035">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2036">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2036">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">
          <span data-ttu-id="f1118-2037">應用程式定義域資源監視</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2037">Application Domain Resource Monitoring</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2038">取得自處理程序啟動後，所有執行緒在目前應用程式定義域中執行時用掉的處理器時間總計。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2038">Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2039">目前應用程式定義域的處理器時間總計。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2039">Total processor time for the current application domain.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2040">總時間所報告的應用程式定義域包含應用程式定義域中執行的處理序中的每個執行緒所花費的時間。</span><span class="sxs-lookup"><span data-stu-id="f1118-2040">The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</span></span>  
  
 <span data-ttu-id="f1118-2041">呼叫 unmanaged 程式碼的執行緒仍會關聯應用程式定義域，並執行 unmanaged 程式碼會報告應用程式定義域進行呼叫所花費的處理器時間。</span><span class="sxs-lookup"><span data-stu-id="f1118-2041">A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</span></span>  
  
 <span data-ttu-id="f1118-2042">當執行緒遭到封鎖或睡眠中，它不會佔用處理器時間。</span><span class="sxs-lookup"><span data-stu-id="f1118-2042">When a thread is blocked or sleeping, it does not consume processor time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f1118-2043">
            <see langword="static" /> (在 Visual Basic 中為 <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> 屬性已設為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2043">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2044">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2044">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2045">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2045">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">
          <span data-ttu-id="f1118-2046">應用程式定義域資源監視</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2046">Application Domain Resource Monitoring</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2047">取得沙箱應用程式定義域的權限集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2047">Gets the permission set of a sandboxed application domain.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2048">沙箱應用程式定義域的權限集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2048">The permission set of the sandboxed application domain.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2049">使用所建立的沙箱應用程式定義域<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法多載有一組同質性權限，也就是相同的權限集授與所有部分信任的組件載入應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-2049">Sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="f1118-2050">（選擇性） 沙箱應用程式定義域會有免套用此權限集，並改為使用完全信任執行的強式名稱組件清單。</span><span class="sxs-lookup"><span data-stu-id="f1118-2050">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2051">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2051">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2052">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2052">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2053">發生於預設應用程式定義域的父處理程序結束時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2053">Occurs when the default application domain's parent process exits.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2054"><xref:System.EventHandler>針對此事件可以執行終止活動，例如關閉檔案，釋出儲存體，在處理序結束之前。</span><span class="sxs-lookup"><span data-stu-id="f1118-2054">The <xref:System.EventHandler> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</span></span>  
  
 <span data-ttu-id="f1118-2055">從.NET Framework 2.0 版開始，每個註冊的事件處理常式的應用程式定義域會引發這個事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2055">Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-2056">總執行時間的所有<xref:System.AppDomain.ProcessExit>事件處理常式是受到限制，就如同所有的完成項執行時間總計會限制在關閉處理序。</span><span class="sxs-lookup"><span data-stu-id="f1118-2056">The total execution time of all <xref:System.AppDomain.ProcessExit> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</span></span> <span data-ttu-id="f1118-2057">預設值為兩秒。</span><span class="sxs-lookup"><span data-stu-id="f1118-2057">The default is two seconds.</span></span> <span data-ttu-id="f1118-2058">受管理的主機可以呼叫來變更此執行階段[iclrpolicymanager:: Settimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)方法[OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)列舉值。</span><span class="sxs-lookup"><span data-stu-id="f1118-2058">An unmanaged host can change this execution time by calling the [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) method with the [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) enumeration value.</span></span>  
  
 <span data-ttu-id="f1118-2059">在.NET framework 1.0 和 1.1 版中，此事件是引發只在預設應用程式網域中，並且只有在預設應用程式定義域中註冊事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="f1118-2059">In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</span></span>  
  
 <span data-ttu-id="f1118-2060">若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-2060">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="f1118-2061">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2061">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2062">發生於僅限反映之內容中的組件解析失敗時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2062">Occurs when the resolution of an assembly fails in the reflection-only context.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2063">在僅限反映的內容中，會不會自動解析相依性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2063">In the reflection-only context, dependencies are not resolved automatically.</span></span> <span data-ttu-id="f1118-2064">它們必須預先載入或傳回由這個事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="f1118-2064">They must be preloaded or returned by the handler for this event.</span></span> <span data-ttu-id="f1118-2065">當組件具有尚未載入至僅限反映內容的相依性時，會引發這個事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2065">This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</span></span> <span data-ttu-id="f1118-2066">遺失的相依性由<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2066">The missing dependency is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f1118-2067"><xref:System.ResolveEventHandler>本項目中必須傳回符合相依性的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2067">The <xref:System.ResolveEventHandler> for this event must return an assembly that satisfies the dependency.</span></span> <span data-ttu-id="f1118-2068">傳回組件必須載入僅限反映的內容。</span><span class="sxs-lookup"><span data-stu-id="f1118-2068">The assembly that is returned must be loaded into the reflection-only context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f1118-2069">僅針對遺失的相依性的組件載入僅限反映的內容會引發這個事件 (例如，藉由使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>方法)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2069">This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method).</span></span> <span data-ttu-id="f1118-2070">如果找不到要載入的組件時，它不會引發。</span><span class="sxs-lookup"><span data-stu-id="f1118-2070">It is not raised if the assembly that you are loading cannot be found.</span></span>  
  
 <span data-ttu-id="f1118-2071">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性會傳回要求無法解析組件載入的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2071">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="f1118-2072">了解要求的組件的識別可能會有助於識別正確版本的相依性，如果一個以上的版本。</span><span class="sxs-lookup"><span data-stu-id="f1118-2072">Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</span></span> <span data-ttu-id="f1118-2073">如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2073">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f1118-2074">對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>套用原則之前，屬性會傳回組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-2074">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
 <span data-ttu-id="f1118-2075">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2075">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2076">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2076">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2077">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2077">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2078">傳回已經載入到應用程式定義域之僅限反映的內容之組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2078">Returns the assemblies that have been loaded into the reflection-only context of the application domain.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-2079">
            <see cref="T:System.Reflection.Assembly" /> 物件的陣列，代表已經載入到應用程式定義域中僅限反映之內容的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2079">An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2080">這個方法會傳回已載入至僅限反映內容的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2080">This method returns the assemblies that have been loaded into the reflection-only context.</span></span> <span data-ttu-id="f1118-2081">若要取得已載入的組件的執行，請使用<xref:System.AppDomain.GetAssemblies%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2081">To get the assemblies that have been loaded for execution, use the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2082">下列程式碼範例會載入 System.dll 組件，到執行內容，然後放入僅限反映的內容。</span><span class="sxs-lookup"><span data-stu-id="f1118-2082">The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</span></span> <span data-ttu-id="f1118-2083"><xref:System.AppDomain.GetAssemblies%2A>和<xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A>方法用來顯示每個內容所載入的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2083">The <xref:System.AppDomain.GetAssemblies%2A> and <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> methods are used to display the assemblies loaded into each context.</span></span>  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2084">嘗試在卸載的應用程式定義域中執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2084">An operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2085">取得組件解析程式應該在其中探查私用組件的路徑，此路徑位於基底目錄下。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2085">Gets the path under the base directory where the assembly resolver should probe for private assemblies.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2086">組件解析程式應該在其中探查私用組件的路徑，此路徑位於基底目錄下。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2086">The path under the base directory where the assembly resolver should probe for private assemblies.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2087">私用組件會部署在相同的目錄結構與應用程式。</span><span class="sxs-lookup"><span data-stu-id="f1118-2087">Private assemblies are deployed in the same directory structure as the application.</span></span> <span data-ttu-id="f1118-2088">如果所指定的路徑<xref:System.AppDomain.RelativeSearchPath%2A>屬性不是下方<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>，則會忽略它。</span><span class="sxs-lookup"><span data-stu-id="f1118-2088">If the path specified by the <xref:System.AppDomain.RelativeSearchPath%2A> property is not under <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, it is ignored.</span></span>  
  
 <span data-ttu-id="f1118-2089">這個屬性會傳回設定使用的值<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2089">This property returns the value set using <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2090">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2090">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="f1118-2091">用於存取的路徑資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2091">for access to the path information.</span>
          </span>
          <span data-ttu-id="f1118-2092">關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2092">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2093">發生於資源的解析失敗時 (原因是因為該資源在組件中不是有效連結或內嵌的資源)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2093">Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2094"><xref:System.ResolveEventHandler>針對此事件可嘗試找出包含資源的組件，並將它傳回。</span><span class="sxs-lookup"><span data-stu-id="f1118-2094">The <xref:System.ResolveEventHandler> for this event can attempt to locate the assembly containing the resource and return it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f1118-2095">如果解析失敗，因為針對有效的連結資源找不到檔案，不會引發此事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2095">This event is not raised if resolution fails because no file can be found for a valid linked resource.</span></span> <span data-ttu-id="f1118-2096">如果找不到的資訊清單資源資料流，但如果找不到個別的資源索引鍵，則不會引發它，就會引發這個事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2096">It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</span></span>  
  
 <span data-ttu-id="f1118-2097">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性包含要求之資源的組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2097">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the resource.</span></span> <span data-ttu-id="f1118-2098">如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2098">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f1118-2099">若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-2099">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="f1118-2100">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2100">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2101">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2101">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2102">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2102">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">
          <span data-ttu-id="f1118-2103">安全性原則層級。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2103">The security policy level.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2104">為這個應用程式定義域建立安全性原則層級。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2104">Establishes the security policy level for this application domain.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2105">載入組件之前呼叫這個方法<xref:System.AppDomain>為了讓安全性原則，以產生的影響。</span><span class="sxs-lookup"><span data-stu-id="f1118-2105">Call this method before an assembly is loaded into the <xref:System.AppDomain> in order for the security policy to have effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2106">下列範例示範如何使用<xref:System.AppDomain.SetAppDomainPolicy%2A>方法來設定應用程式定義域的安全性原則層級。</span><span class="sxs-lookup"><span data-stu-id="f1118-2106">The following example demonstrates how to use the <xref:System.AppDomain.SetAppDomainPolicy%2A> method to set the security policy level of an application domain.</span></span>  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-2107">
            <paramref name="domainPolicy" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2107">
              <paramref name="domainPolicy" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.Policy.PolicyException">
          <span data-ttu-id="f1118-2108">安全性原則層級已經設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2108">The security policy level has already been set.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2109">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2109">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2110">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2110">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2111">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2111">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f1118-2112">陰影複本位置的完整路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2112">The fully qualified path to the shadow copy location.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2113">將指定的目錄路徑建立為陰影複製組件的所在位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2113">Establishes the specified directory path as the location where assemblies are shadow copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2114">如果，則會忽略快取路徑<xref:System.AppDomainSetup.ApplicationName%2A>屬性未設定。</span><span class="sxs-lookup"><span data-stu-id="f1118-2114">The cache path is ignored if the <xref:System.AppDomainSetup.ApplicationName%2A> property is not set.</span></span> <span data-ttu-id="f1118-2115">請參閱 <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2115">See the <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="f1118-2116">如需陰影複製的詳細資訊請參閱 <<c0> [ 陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2116">For more information on shadow copying see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2117">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2117">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2118">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2118">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2119">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2119">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">
          <span data-ttu-id="f1118-2120">陰影複製組件</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2120">Shadow Copying Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2121">將某個值指派給應用程式定義域屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2121">Assigns a value to an application domain property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-2122">要建立或變更的使用者定義之應用程式定義域屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2122">The name of a user-defined application domain property to create or change.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="f1118-2123">屬性的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2123">The value of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2124">將指定值指派至指定的應用程式定義域屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2124">Assigns the specified value to the specified application domain property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2125">使用此方法中插入項目，或修改的值描述屬性的這個執行個體的名稱資料組的內部快取中的項目<xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2125">Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="f1118-2126">快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。</span><span class="sxs-lookup"><span data-stu-id="f1118-2126">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="f1118-2127">您無法插入或修改系統項目使用此方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2127">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="f1118-2128">嘗試修改系統項目方法呼叫沒有任何作用中;此方法不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2128">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="f1118-2129">您可以查看使用的系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性中所述<xref:System.AppDomain.GetData%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2129">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties described in <xref:System.AppDomain.GetData%2A>.</span></span>  
  
 <span data-ttu-id="f1118-2130">您可以呼叫這個方法，以評估供應"REGEX_DEFAULT_MATCH_TIMEOUT 」 的規則運算式模式的預設逾時間隔的值設定的值`name`引數和<xref:System.TimeSpan>值，表示在逾時值與間隔`data`引數。</span><span class="sxs-lookup"><span data-stu-id="f1118-2130">You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span> <span data-ttu-id="f1118-2131">您可以也插入或修改您自己的使用者定義名稱資料組使用這個方法並檢查其值與<xref:System.AppDomain.GetData%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2131">You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2132">下列範例示範如何使用<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29>方法用來建立新的值組。</span><span class="sxs-lookup"><span data-stu-id="f1118-2132">The following example demonstrates how to use the <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> method to create a new value pair.</span></span> <span data-ttu-id="f1118-2133">然後此範例使用<xref:System.AppDomain.GetData%2A>方法來擷取值，並將它顯示到主控台。</span><span class="sxs-lookup"><span data-stu-id="f1118-2133">The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2134">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2134">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2135">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2135">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2136">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2136">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f1118-2137">要建立或變更的使用者定義之應用程式定義域屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2137">The name of a user-defined application domain property to create or change.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="f1118-2138">屬性的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2138">The value of the property.</span>
          </span>
        </param>
        <param name="permission">
          <span data-ttu-id="f1118-2139">當擷取屬性時，向呼叫端要求的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2139">The permission to demand of the caller when the property is retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2140">將指定之值指派給指定之應用程式定義域屬性，而當擷取這個屬性時，有指定向呼叫端要求的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2140">Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2141">使用此方法來插入或修改您的使用者定義的項目，在內部快取的名稱/資料組，可描述應用程式定義域的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2141">Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</span></span> <span data-ttu-id="f1118-2142">當您將項目時，您可以指定的權限要求，以強制在擷取的項目時。颾魤 ㄛ 您可以呼叫這個方法，以評估供應"REGEX_DEFAULT_MATCH_TIMEOUT 」 的規則運算式模式的預設逾時間隔的值設定的值`name`引數和<xref:System.TimeSpan>值，表示做為值的逾時間隔`data`引數。</span><span class="sxs-lookup"><span data-stu-id="f1118-2142">When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span>  
  
 <span data-ttu-id="f1118-2143">您無法使用這個方法，將安全性需求的系統定義的屬性字串。</span><span class="sxs-lookup"><span data-stu-id="f1118-2143">You cannot use this method to assign a security demand to a system-defined property string.</span></span>  
  
 <span data-ttu-id="f1118-2144">快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。</span><span class="sxs-lookup"><span data-stu-id="f1118-2144">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="f1118-2145">您無法插入或修改系統項目使用此方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2145">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="f1118-2146">嘗試修改系統項目方法呼叫沒有任何作用中;此方法不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2146">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="f1118-2147">您可以查看使用的系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等項目<xref:System.AppDomainSetup>屬性，如 < 備註 > 一節所述<xref:System.AppDomain.GetData%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2147">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method or the equivalent <xref:System.AppDomainSetup> properties described in the Remarks section for the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-2148">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2148">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f1118-2149">
            <paramref name="name" /> 可指定系統定義之屬性字串，且 <paramref name="permission" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2149">
              <paramref name="name" /> specifies a system-defined property string and <paramref name="permission" /> is not <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2150">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2150">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2151">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2151">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f1118-2152">完整的路徑，代表用來儲存動態組件之子目錄的基底目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2152">The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2153">建立指定的目錄路徑，做為存放及存取動態產生檔案之子目錄的基底目錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2153">Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2154">這個方法會設定<xref:System.AppDomainSetup.DynamicBase%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。</span><span class="sxs-lookup"><span data-stu-id="f1118-2154">This method sets the <xref:System.AppDomainSetup.DynamicBase%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2155">此方法現已淘汰，並不應該用於新的開發。</span><span class="sxs-lookup"><span data-stu-id="f1118-2155">This method is now obsolete, and should not be used for new development.</span></span> <span data-ttu-id="f1118-2156">下列範例示範如何使用非過時的替代方式，<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2156">The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f1118-2157">如需此範例的說明，請參閱 <<c0> <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> 屬性或<xref:System.AppDomain.DynamicDirectory%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2157">For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2158">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2158">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2159">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2159">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2160">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2160">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">
          <span data-ttu-id="f1118-2161">其中一個 <see cref="T:System.Security.Principal.PrincipalPolicy" /> 值，指定要附加至執行緒之主體物件的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2161">One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2162">如果執行緒在這個應用程式定義域執行時嘗試繫結至主體，則指定主體和識別 (Identity) 物件應該如何附加至執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2162">Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2163">設定此值才會生效，如果您將使用之前<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2163">Setting this value will only be effective if you set it before using the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f1118-2164">例如，如果您設定<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>到指定的主體 （例如，泛型主體），然後使用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法來設定<xref:System.Security.Principal.PrincipalPolicy>到<xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>，目前的主體會保留泛用的主體。</span><span class="sxs-lookup"><span data-stu-id="f1118-2164">For example, if you set <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> to a given principal (for example, a generic principal) and then use the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to set the <xref:System.Security.Principal.PrincipalPolicy> to <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, the current principal will remain the generic principal.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2165">下列範例示範使用的執行緒上作用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以變更應用程式定義域的主體的原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-2165">The following example shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span> <span data-ttu-id="f1118-2166">它也會示範使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>變更適用於附加至應用程式定義域中的執行緒之主體的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2166">It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2167">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2167">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-2168">操作主體物件的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2168">for ability to manipulate the principal object.</span>
          </span>
          <span data-ttu-id="f1118-2169">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2169">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span>
          </span>
          <span data-ttu-id="f1118-2170">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2170">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2171">開啟陰影複製。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2171">Turns on shadow copying.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2172">如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2172">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2173">此方法現已淘汰，並不應該用於新的開發。</span><span class="sxs-lookup"><span data-stu-id="f1118-2173">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2174">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2174">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2175">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2175">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2176">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2176">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">
          <span data-ttu-id="f1118-2177">陰影複製組件</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2177">Shadow Copying Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="f1118-2178">目錄名稱的清單，其中的每個名稱以分號隔開。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2178">A list of directory names, where each name is separated by a semicolon.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2179">建立指定的目錄路徑，做為要陰影複製的組件位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2179">Establishes the specified directory path as the location of assemblies to be shadow copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2180">根據預設，陰影複製會包含經由探查所找到的所有組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2180">By default, a shadow copy includes all assemblies found through probing.</span></span> <span data-ttu-id="f1118-2181"><xref:System.AppDomain.SetShadowCopyPath%2A>方法會將陰影複製限制為所指定的目錄中的組件`path`。</span><span class="sxs-lookup"><span data-stu-id="f1118-2181">The <xref:System.AppDomain.SetShadowCopyPath%2A> method restricts the shadow copy to the assemblies in the directories specified by `path`.</span></span>  
  
 <span data-ttu-id="f1118-2182"><xref:System.AppDomain.SetShadowCopyPath%2A>方法不會指定要搜尋的組件的其他目錄。</span><span class="sxs-lookup"><span data-stu-id="f1118-2182">The <xref:System.AppDomain.SetShadowCopyPath%2A> method does not specify additional directories to be searched for assemblies.</span></span> <span data-ttu-id="f1118-2183">要陰影複製組件必須已經位於搜尋路徑中，例如下<xref:System.AppDomain.BaseDirectory%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2183">Assemblies to be shadow-copied must already be located in the search path, for example under <xref:System.AppDomain.BaseDirectory%2A>.</span></span> <span data-ttu-id="f1118-2184"><xref:System.AppDomain.SetShadowCopyPath%2A>方法可讓您指定的搜尋路徑適合將陰影複製。</span><span class="sxs-lookup"><span data-stu-id="f1118-2184">The <xref:System.AppDomain.SetShadowCopyPath%2A> method specifies which search paths are eligible to be shadow-copied.</span></span>  
  
 <span data-ttu-id="f1118-2185">這個方法會設定<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。</span><span class="sxs-lookup"><span data-stu-id="f1118-2185">This method sets the <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
 <span data-ttu-id="f1118-2186">如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2186">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2187">此方法現已淘汰，並不應該用於新的開發。</span><span class="sxs-lookup"><span data-stu-id="f1118-2187">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2188">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2188">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2189">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2189">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2190">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2190">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">
          <span data-ttu-id="f1118-2191">陰影複製組件</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2191">Shadow Copying Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">
          <span data-ttu-id="f1118-2192">要附加至執行緒的主體物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2192">The principal object to attach to threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2193">如果執行緒在這個應用程式定義域中執行時嘗試繫結至預設的主體，則設定預設的主體物件附加至執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2193">Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f1118-2194">下列範例示範使用的效果<xref:System.AppDomain.SetThreadPrincipal%2A>變更適用於附加至應用程式定義域中執行的執行緒之主體的方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2194">The following example shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads that are executing in the application domain.</span></span> <span data-ttu-id="f1118-2195">它也會顯示在使用的執行緒上作用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法，以變更應用程式定義域的主體的原則。</span><span class="sxs-lookup"><span data-stu-id="f1118-2195">It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-2196">
            <paramref name="principal" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2196">
              <paramref name="principal" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.Policy.PolicyException">
          <span data-ttu-id="f1118-2197">主要執行緒已經設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2197">The thread principal has already been set.</span>
          </span>
        </exception>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2198">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2198">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-2199">操作主體物件的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2199">for ability to manipulate the principal object.</span>
          </span>
          <span data-ttu-id="f1118-2200">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2200">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span>
          </span>
          <span data-ttu-id="f1118-2201">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2201">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2202">取得這個執行個體的應用程式定義域組態資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2202">Gets the application domain configuration information for this instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2203">應用程式定義域初始化資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2203">The application domain initialization information.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2204">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2204">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2205">取得是否已設定應用程式定義域以進行檔案陰影複製的指示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2205">Gets an indication whether the application domain is configured to shadow copy files.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f1118-2206">如果已設定應用程式定義域以進行檔案陰影複製，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2206">
              <see langword="true" /> if the application domain is configured to shadow copy files; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2207">如需詳細資訊，請參閱 <<c0> <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> 並[陰影複製組件](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2207">For more information, see <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2208">嘗試對卸載的應用程式定義域執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2208">The operation is attempted on an unloaded application domain.</span>
          </span>
        </exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">
          <span data-ttu-id="f1118-2209">陰影複製組件</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2209">Shadow Copying Assemblies</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="f1118-2210">保留供未來使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2210">Reserved for future use.</span>
          </span>
          <span data-ttu-id="f1118-2211">必須是 IID_NULL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2211">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="f1118-2212">要對應之傳入的名稱陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2212">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="f1118-2213">要對應的名稱計數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2213">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="f1118-2214">用於解譯名稱的地區設定內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2214">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="f1118-2215">呼叫端配置的陣列，用於接收對應於名稱的 ID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2215">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2216">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2216">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2217">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-2217">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="f1118-2218">如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="f1118-2218">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="f1118-2219">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2219">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="f1118-2220">要傳回的類型資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2220">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="f1118-2221">類型資訊的地區設定識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2221">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="f1118-2222">接收要求的類型資訊物件的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2222">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2223">擷取物件的類型資訊，可以用來取得介面的類型資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2223">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2224">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-2224">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="f1118-2225">如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="f1118-2225">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="f1118-2226">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2226">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="f1118-2227">指向接收物件提供的類型資訊介面數目的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2227">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2228">擷取物件提供的類型資訊介面數目 (0 或 1)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2228">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2229">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-2229">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="f1118-2230">如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="f1118-2230">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="f1118-2231">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2231">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="f1118-2232">辨識成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2232">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="f1118-2233">保留供未來使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2233">Reserved for future use.</span>
          </span>
          <span data-ttu-id="f1118-2234">必須是 IID_NULL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2234">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="f1118-2235">地區設定內容，用於解譯引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2235">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="f1118-2236">描述呼叫之內容的旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2236">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="f1118-2237">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2237">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="f1118-2238">指向用於儲存結果之位置的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2238">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="f1118-2239">包含例外狀況資訊的結構指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2239">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="f1118-2240">第一個有錯誤的引數索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2240">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2241">提供物件所公開的屬性和方法的存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2241">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2242">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="f1118-2242">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="f1118-2243">如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="f1118-2243">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="f1118-2244">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2244">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2245">取得字串表示，其中包含應用程式定義域及任何內容原則的易記名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2245">Obtains a string representation that includes the friendly name of the application domain and any context policies.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f1118-2246">將常值字串 "Name:"、應用程式定義域的易記名稱、內容原則的字串表示或字串 "There are no context policies" 串連起來所構成的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2246">A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f1118-2247">下列程式碼範例顯示的傳回值<xref:System.AppDomain.ToString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f1118-2247">The following code example displays the return value of the <xref:System.AppDomain.ToString%2A> method.</span></span>  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">
          <span data-ttu-id="f1118-2248">已經卸載目前的 <see cref="T:System.AppDomain" /> 所表示的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2248">The application domain represented by the current <see cref="T:System.AppDomain" /> has been unloaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2249">發生於類型解析失敗時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2249">Occurs when the resolution of a type fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2250"><xref:System.AppDomain.TypeResolve> Common language runtime 無法判斷組件可以建立要求的型別時，就會發生事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2250">The <xref:System.AppDomain.TypeResolve> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</span></span> <span data-ttu-id="f1118-2251">如果類型定義中的動態組件，或動態組件中未定義類型，但執行階段不知道哪個組件中定義型別，也可能會發生。</span><span class="sxs-lookup"><span data-stu-id="f1118-2251">This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</span></span> <span data-ttu-id="f1118-2252">後者的情況可能會發生時<xref:System.Type.GetType%2A?displayProperty=nameWithType>呼叫組件名稱未限定的型別名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-2252">The latter situation can occur when <xref:System.Type.GetType%2A?displayProperty=nameWithType> is called with a type name that is not qualified with the assembly name.</span></span>  
  
 <span data-ttu-id="f1118-2253"><xref:System.ResolveEventHandler>針對此事件可以嘗試找出並建立類型。</span><span class="sxs-lookup"><span data-stu-id="f1118-2253">The <xref:System.ResolveEventHandler> for this event can attempt to locate and create the type.</span></span>  
  
 <span data-ttu-id="f1118-2254">不過，<xref:System.AppDomain.TypeResolve>事件不會發生執行階段可讓您知道不可能以尋找特定組件中的類型。</span><span class="sxs-lookup"><span data-stu-id="f1118-2254">However, the <xref:System.AppDomain.TypeResolve> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</span></span> <span data-ttu-id="f1118-2255">比方說，不會不會發生此事件的型別找不到靜態組件中因為執行階段知道類型無法以動態方式新增至靜態組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2255">For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</span></span>  
  
 <span data-ttu-id="f1118-2256">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>屬性包含要求的型別之組件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2256">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the type.</span></span> <span data-ttu-id="f1118-2257">如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2257">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f1118-2258">若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-2258">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="f1118-2259">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2259">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2260">下列範例會示範<xref:System.AppDomain.TypeResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2260">The following sample demonstrates the <xref:System.AppDomain.TypeResolve> event.</span></span>  
  
 <span data-ttu-id="f1118-2261">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="f1118-2261">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="f1118-2262">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2262">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2263">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2263">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2264">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2264">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f1118-2265">發生於未攔截到例外狀況時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2265">Occurs when an exception is not caught.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2266">此事件會通知無法攔截的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2266">This event provides notification of uncaught exceptions.</span></span> <span data-ttu-id="f1118-2267">它可讓應用程式之前的系統預設處理常式回報給使用者的例外狀況，並終止應用程式記錄例外狀況的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="f1118-2267">It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</span></span> <span data-ttu-id="f1118-2268">如果應用程式的狀態相關的足夠資訊可用，則可能會採取其他動作，例如儲存供稍後復原計畫資料。</span><span class="sxs-lookup"><span data-stu-id="f1118-2268">If sufficient information about the state of the application is available, other actions may be undertaken — such as saving program data for later recovery.</span></span> <span data-ttu-id="f1118-2269">請謹慎，因為未處理例外狀況時，會損毀程式資料。</span><span class="sxs-lookup"><span data-stu-id="f1118-2269">Caution is advised, because program data can become corrupted when exceptions are not handled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-2270">在.NET framework 1.0 和 1.1 版中，應用程式終止偵錯選項報告和使用者會引發這個事件之前，而不是在後。</span><span class="sxs-lookup"><span data-stu-id="f1118-2270">In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</span></span>  
  
 <span data-ttu-id="f1118-2271">可以在任何應用程式定義域中處理這個事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2271">This event can be handled in any application domain.</span></span> <span data-ttu-id="f1118-2272">不過，事件不一定會引發例外狀況的發生位置的應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-2272">However, the event is not necessarily raised in the application domain where the exception occurred.</span></span> <span data-ttu-id="f1118-2273">只有當執行緒在整個堆疊已回溯而未找到適用的例外狀況處理常式，因此可以引發事件的第一個位置是在執行緒的起源的應用程式定義域，是未處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2273">An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-2274">在.NET framework 1.0 和 1.1 版中，只會針對應用程式啟動時，會將由系統建立預設應用程式定義域發生此事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2274">In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</span></span> <span data-ttu-id="f1118-2275">如果應用程式建立其他應用程式定義域，指定此事件的委派，這些應用程式網域中沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="f1118-2275">If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</span></span>  
  
 <span data-ttu-id="f1118-2276">如果<xref:System.AppDomain.UnhandledException>預設應用程式定義域中處理事件，會引發這個事件發生的任何未處理例外狀況，在任何執行緒中，無論何種應用程式定義域中啟動的執行緒。</span><span class="sxs-lookup"><span data-stu-id="f1118-2276">If the <xref:System.AppDomain.UnhandledException> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</span></span> <span data-ttu-id="f1118-2277">如果有事件處理常式的應用程式定義域中啟動執行緒<xref:System.AppDomain.UnhandledException>，應用程式定義域中引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2277">If the thread started in an application domain that has an event handler for <xref:System.AppDomain.UnhandledException>, the event is raised in that application domain.</span></span> <span data-ttu-id="f1118-2278">如果該應用程式定義域不是預設的應用程式定義域，而且也沒有事件處理常式預設應用程式定義域中，會引發事件，這兩個應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f1118-2278">If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</span></span>  
  
 <span data-ttu-id="f1118-2279">比方說，假設啟動執行緒應用程式定義域 」 AD1"，"AD2，"的應用程式定義域中呼叫的方法，並從中呼叫應用程式定義域 」 AD3 」，方法會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2279">For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</span></span> <span data-ttu-id="f1118-2280">第一個應用程式定義域，<xref:System.AppDomain.UnhandledException>可以引發事件是 「 AD1"。</span><span class="sxs-lookup"><span data-stu-id="f1118-2280">The first application domain in which the <xref:System.AppDomain.UnhandledException> event can be raised is "AD1".</span></span> <span data-ttu-id="f1118-2281">如果該應用程式定義域不是預設應用程式定義域，也是預設應用程式定義域中引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2281">If that application domain is not the default application domain, the event can also be raised in the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-2282">Common language runtime 會暫止的執行緒中止時的事件處理常式<xref:System.AppDomain.UnhandledException>執行事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2282">The common language runtime suspends thread aborts while event handlers for the <xref:System.AppDomain.UnhandledException> event are executing.</span></span>  
  
 <span data-ttu-id="f1118-2283">如果事件處理常式<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>屬性與適當的旗標，事件處理常式會被視為限制的執行區域。</span><span class="sxs-lookup"><span data-stu-id="f1118-2283">If the event handler has a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</span></span>  
  
 <span data-ttu-id="f1118-2284">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，此事件不會引發例外狀況的損毀的程序的狀態，例如堆疊溢位，或存取違規，除非事件處理常式上為安全性關鍵，而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2284">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="f1118-2285">在.NET framework 1.0 和 1.1 版中，主應用程式執行緒以外的執行緒中發生未處理例外狀況會由執行階段會攔截，並因此不會造成應用程式終止。</span><span class="sxs-lookup"><span data-stu-id="f1118-2285">In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</span></span> <span data-ttu-id="f1118-2286">因此，就可能<xref:System.AppDomain.UnhandledException>而不終止應用程式會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2286">Thus, it is possible for the <xref:System.AppDomain.UnhandledException> event to be raised without the application terminating.</span></span> <span data-ttu-id="f1118-2287">從.NET Framework 2.0 版開始，這個子執行緒中的未處理例外狀況的支援已移除，因為這類的無訊息失敗的累積效果包含效能降低、 損毀的資料和鎖定，且很難偵錯。</span><span class="sxs-lookup"><span data-stu-id="f1118-2287">Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</span></span> <span data-ttu-id="f1118-2288">如需詳細資訊，包括一份案例中，執行階段不會終止，請參閱[受控執行緒中的例外狀況](~/docs/standard/threading/exceptions-in-managed-threads.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2288">For more information, including a list of cases in which the runtime does not terminate, see [Exceptions in Managed Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="f1118-2289">若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="f1118-2289">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="f1118-2290">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="f1118-2290">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
## <a name="other-events-for-unhandled-exceptions"></a><span data-ttu-id="f1118-2291">未處理例外狀況的其他事件</span><span class="sxs-lookup"><span data-stu-id="f1118-2291">Other Events for Unhandled Exceptions</span></span>  
 <span data-ttu-id="f1118-2292">針對特定應用程式模型，<xref:System.AppDomain.UnhandledException>事件可以清空的其他事件，如果主應用程式執行緒中發生未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2292">For certain application models, the <xref:System.AppDomain.UnhandledException> event can be preempted by other events if the unhandled exception occurs in the main application thread.</span></span>  
  
 <span data-ttu-id="f1118-2293">使用 Windows Forms 應用程式，在未處理的例外狀況中的主應用程式執行緒的原因<xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType>會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2293">In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> event to be raised.</span></span> <span data-ttu-id="f1118-2294">如果處理此事件，預設行為是未處理的例外狀況不會終止應用程式，雖然應用程式處於未知狀態。</span><span class="sxs-lookup"><span data-stu-id="f1118-2294">If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</span></span> <span data-ttu-id="f1118-2295">在此情況下，<xref:System.AppDomain.UnhandledException>不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2295">In that case, the <xref:System.AppDomain.UnhandledException> event is not raised.</span></span> <span data-ttu-id="f1118-2296">可以變更此行為，藉由使用應用程式組態檔，或是利用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType>方法，以將模式變更為<xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType>之前<xref:System.Windows.Forms.Application.ThreadException>連結事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="f1118-2296">This behavior can be changed by using the application configuration file, or by using the <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> method to change the mode to <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> before the <xref:System.Windows.Forms.Application.ThreadException> event handler is hooked up.</span></span> <span data-ttu-id="f1118-2297">只適用於主應用程式執行緒。</span><span class="sxs-lookup"><span data-stu-id="f1118-2297">This applies only to the main application thread.</span></span> <span data-ttu-id="f1118-2298"><xref:System.AppDomain.UnhandledException>其他執行緒中擲回未處理的例外狀況都會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2298">The <xref:System.AppDomain.UnhandledException> event is raised for unhandled exceptions thrown in other threads.</span></span>  
  
 <span data-ttu-id="f1118-2299">從 Microsoft Visual Studio 2005 開始，Visual Basic 應用程式架構可以提供另一個事件在主應用程式執行緒的未處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2299">Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</span></span> <span data-ttu-id="f1118-2300">請參閱<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2300">See the <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="f1118-2301">此事件具有與所使用的事件引數物件的名稱相同的事件引數物件<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>，但具有不同的屬性。</span><span class="sxs-lookup"><span data-stu-id="f1118-2301">This event has an event arguments object with the same name as the event arguments object used by <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, but with different properties.</span></span> <span data-ttu-id="f1118-2302">這個事件引數物件的有特別的是，<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>屬性，可讓應用程式繼續執行，而忽略未處理的例外狀況 （並讓應用程式處於未知狀態）。</span><span class="sxs-lookup"><span data-stu-id="f1118-2302">In particular, this event arguments object has an <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</span></span> <span data-ttu-id="f1118-2303">在此情況下，<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>不會引發事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2303">In that case, the <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> event is not raised.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2304">如以下範例將示範<xref:System.AppDomain.UnhandledException>事件。</span><span class="sxs-lookup"><span data-stu-id="f1118-2304">The followingexample demonstrates the <xref:System.AppDomain.UnhandledException> event.</span></span> <span data-ttu-id="f1118-2305">它會定義事件處理常式， `MyHandler`，叫用時的預設應用程式定義域中擲回未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2305">It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain.</span></span> <span data-ttu-id="f1118-2306">然後，會擲回兩個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2306">It then throws two exceptions.</span></span> <span data-ttu-id="f1118-2307">第一個由**try/catch**區塊。</span><span class="sxs-lookup"><span data-stu-id="f1118-2307">The first is handled by a **try/catch** block.</span></span> <span data-ttu-id="f1118-2308">第二個是未處理，並叫用`MyHandle`應用程式終止之前的常式。</span><span class="sxs-lookup"><span data-stu-id="f1118-2308">The second is unhandled and invokes the `MyHandle` routine before the application terminates.</span></span>  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f1118-2309">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2309">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f1118-2310">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2310">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">
          <span data-ttu-id="f1118-2311">要卸載的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2311">An application domain to unload.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f1118-2312">卸載指定的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2312">Unloads the specified application domain.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1118-2313">.NET Framework 2.0 版中已有執行緒專門用來卸載應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-2313">In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</span></span> <span data-ttu-id="f1118-2314">這可改善可靠性，尤其是當裝載.NET Framework。</span><span class="sxs-lookup"><span data-stu-id="f1118-2314">This improves reliability, especially when the .NET Framework is hosted.</span></span> <span data-ttu-id="f1118-2315">當執行緒呼叫<xref:System.AppDomain.Unload%2A>，目標網域已標示為卸載。</span><span class="sxs-lookup"><span data-stu-id="f1118-2315">When a thread calls <xref:System.AppDomain.Unload%2A>, the target domain is marked for unloading.</span></span> <span data-ttu-id="f1118-2316">專用的執行緒嘗試卸載定義域，並在網域中的所有執行緒都被都中止。</span><span class="sxs-lookup"><span data-stu-id="f1118-2316">The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</span></span> <span data-ttu-id="f1118-2317">如果執行緒不會中止，例如因為它正在執行 unmanaged 程式碼，或因為它執行`finally`區塊，然後在一段時間後的<xref:System.CannotUnloadAppDomainException>初次呼叫的執行緒中擲回<xref:System.AppDomain.Unload%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2317">If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a `finally` block, then after a period of time a <xref:System.CannotUnloadAppDomainException> is thrown in the thread that originally called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="f1118-2318">如果無法最終中止的執行緒結束時，目標網域不卸載。</span><span class="sxs-lookup"><span data-stu-id="f1118-2318">If the thread that could not be aborted eventually ends, the target domain is not unloaded.</span></span> <span data-ttu-id="f1118-2319">因此，在.NET Framework 2.0 版`domain`不保證會卸除，因為它可能無法終止正在執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="f1118-2319">Thus, in the .NET Framework version 2.0 `domain` is not guaranteed to unload, because it might not be possible to terminate executing threads.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1118-2320">在某些情況下，呼叫<xref:System.AppDomain.Unload%2A>會導致立即<xref:System.CannotUnloadAppDomainException>，例如在完成項呼叫。</span><span class="sxs-lookup"><span data-stu-id="f1118-2320">In some cases, calling <xref:System.AppDomain.Unload%2A> causes an immediate <xref:System.CannotUnloadAppDomainException>, for example if it is called in a finalizer.</span></span>  
  
 <span data-ttu-id="f1118-2321">中的執行緒`domain`使用終止<xref:System.Threading.Thread.Abort%2A>方法，就會擲回<xref:System.Threading.ThreadAbortException>執行緒中。</span><span class="sxs-lookup"><span data-stu-id="f1118-2321">The threads in `domain` are terminated using the <xref:System.Threading.Thread.Abort%2A> method, which throws a <xref:System.Threading.ThreadAbortException> in the thread.</span></span> <span data-ttu-id="f1118-2322">不過，應該立即終止執行緒，它會繼續執行無法預期的一段時間中`finally`子句。</span><span class="sxs-lookup"><span data-stu-id="f1118-2322">Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a `finally` clause.</span></span>  
  
## <a name="version-compatibility"></a><span data-ttu-id="f1118-2323">版本相容性</span><span class="sxs-lookup"><span data-stu-id="f1118-2323">Version Compatibility</span></span>  
 <span data-ttu-id="f1118-2324">在.NET Framework 1.0 和 1.1，如果呼叫執行緒<xref:System.AppDomain.Unload%2A>正在執行`domain`，另一個執行緒已啟動執行卸載作業。</span><span class="sxs-lookup"><span data-stu-id="f1118-2324">In the .NET Framework version 1.0 and 1.1 if the thread that calls <xref:System.AppDomain.Unload%2A> is running in `domain`, another thread is started to perform the unload operation.</span></span> <span data-ttu-id="f1118-2325">如果`domain`不能卸載<xref:System.CannotUnloadAppDomainException>該執行緒不在原始呼叫的執行緒中擲回<xref:System.AppDomain.Unload%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1118-2325">If `domain` cannot be unloaded, a <xref:System.CannotUnloadAppDomainException> is thrown in that thread, not in the original thread that called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="f1118-2326">不過，如果執行緒呼叫<xref:System.AppDomain.Unload%2A>外部執行`domain`，執行緒會收到例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f1118-2326">However, if the thread that calls <xref:System.AppDomain.Unload%2A> is running outside `domain`, that thread receives the exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1118-2327">下列程式碼範例示範如何卸載應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="f1118-2327">The following code example shows how to unload an application domain.</span></span>  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f1118-2328">
            <paramref name="domain" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2328">
              <paramref name="domain" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <span data-ttu-id="f1118-2329">無法卸載 <paramref name="domain" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2329">
              <paramref name="domain" /> could not be unloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Exception">
          <span data-ttu-id="f1118-2330">卸載程序期間發生錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2330">An error occurred during the unload process.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f1118-2331">若要加入此事件的事件處理常式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2331">to add an event handler for this event.</span>
          </span>
          <span data-ttu-id="f1118-2332">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2332">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span>
          </span>
          <span data-ttu-id="f1118-2333">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f1118-2333">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>