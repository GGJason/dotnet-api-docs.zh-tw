<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="795aa213f55320afb69e8ac92a851b4700704644" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52734497" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支援 .NET Framework 類別階層架構中的所有類別，提供衍生類別的低階服務。 這是 .NET Framework 中所有類別的超基底類別，是類別階層架構的根。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 語言通常不需要宣告繼承自類別<xref:System.Object>因為繼承是隱含的。  
  
 因為.NET Framework 中的所有類別都衍生自<xref:System.Object>，每個方法中定義<xref:System.Object>類別是所有的物件中的可用系統中。 衍生類別並覆寫其中一些方法，包括：  
  
-   <xref:System.Object.Equals%2A> -支援的物件之間的比較。  
  
-   <xref:System.Object.Finalize%2A> -自動收回物件前，請執行清除作業。  
  
-   <xref:System.Object.GetHashCode%2A> 產生對應至物件的值數目，以支援雜湊資料表的使用。  
  
-   <xref:System.Object.ToString%2A> -製造人類看得懂的文字字串描述類別的執行個體。  
  
## <a name="performance-considerations"></a>效能考量  
 如果您正在設計的類別，例如集合、 必須處理任何類型的物件，您可以建立接受的執行個體的類別成員<xref:System.Object>類別。 不過，boxing 和 unboxing 類型的程序會帶來效能成本。 如果您知道您的新類別會經常處理特定實值型別則您可以使用其中一個策略的 boxing 成本降到最低。  
  
-   建立一般的方法可接受<xref:System.Object>型別和一組特定類型的方法多載接受預期類別經常處理每一個實值型別。 如果特定類型的方法可接受呼叫的參數型別，就會發生任何 boxing，並叫用特定類型的方法。 如果沒有任何方法引數的比對呼叫的參數型別，參數會經過 boxing 處理，並叫用一般方法。  
  
-   設計您的類型和其成員使用泛型。 當您建立您的類別的執行個體，並指定泛型型別引數時，common language runtime 就會建立封閉式的泛型型別。 泛型方法型別特定，沒有 boxing 呼叫的參數就可以叫用。  
  
 雖然有時候是必要開發接受及傳回的一般用途類別<xref:System.Object>類型，可以改善效能，也提供特定類型的類別來處理常使用的型別。 比方說，提供特定設定和取得布林值的類別，可消除 boxing 和 unboxing 的布林值的成本。  
  
   
  
## Examples  
 下列範例會定義點型別衍生自<xref:System.Object>類別並覆寫的虛擬方法的許多<xref:System.Object>類別。 此外，此範例示範如何呼叫許多靜態和執行個體方法的<xref:System.Object>類別。  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公用靜態 (<see langword="Shared" /> Visual Basic 中) 的這種類型的成員都是安全執行緒。 不保證執行個體成員是安全執行緒。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Object" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會呼叫建構函式在衍生類別中，但它也可用來直接建立的執行個體<xref:System.Object>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷兩個物件執行個體是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要與目前物件比較的物件。</param>
        <summary>判斷指定的物件是否等於目前的物件。</summary>
        <returns>如果指定的物件等於目前的物件，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體之間的比較的類型和`obj`參數取決於目前的執行個體是否為參考型別或實值型別。  
  
-   如果目前的執行個體是參考型別<xref:System.Object.Equals%28System.Object%29>方法會測試參考是否相等，並呼叫<xref:System.Object.Equals%28System.Object%29>方法就相當於呼叫<xref:System.Object.ReferenceEquals%2A>方法。 參考相等表示所比較的物件變數參考相同的物件。 下列範例說明這類比較的結果。 它會定義`Person`類別，這是參考型別，並呼叫`Person`類別建構函式產生兩個新`Person`物件`person1a`和`person2`，具有相同的值。 它也會指派`person1a`到另一個物件變數， `person1b`。 做為範例所示，從輸出`person1a`和`person1b`相等，因為它們參考相同的物件。 不過，`person1a`和`person2`不相等，雖然它們有相同的值。  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   如果目前的執行個體是實值類型，<xref:System.Object.Equals%28System.Object%29>方法測試值是否相等。 實值相等表示下列各項：  
  
    -   兩個物件都屬於相同的類型。 如下列範例所示<xref:System.Byte>不等於物件，其值為 12<xref:System.Int32>有值為 12，，因為兩個物件具有不同的執行階段類型的物件。  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   兩個物件的公用和私用欄位的值相等。 下列範例會測試值相等。 它會定義`Person`結構，也就是實值型別，並呼叫`Person`類別建構函式產生兩個新`Person`物件`person1`和`person2`，具有相同的值。 範例輸出所示，兩個物件變數參考不同的物件，雖然`person1`並`person2`相等，因為它們具有相同的值為私用`personName`欄位。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 因為<xref:System.Object>類別是.NET Framework 中的所有類型的基底類別<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法提供所有其他類型的預設相等比較。 不過，類型通常會覆寫<xref:System.Object.Equals%2A>方法來實作實值相等。 如需詳細資訊，請參閱 < 附註的呼叫端和注意事項繼承者區段。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>資訊 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 當您呼叫<xref:System.Object.Equals%28System.Object%29>中之類別的方法多載[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不會覆寫的類別提供的預設行為<xref:System.Object.Equals%28System.Object%29>。 這是.NET Framework 提供的支援之一[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱 < [.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且不要只實作目前<xref:System.Object.Equals%28System.Object%29>方法。 不過，它們似乎具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法時您用於您的 C# 或 Visual Basic 程式碼，和.NET Framework 會提供這些方法中的預設行為。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.Equals%28System.Object%29>方法多載。  
  
## <a name="notes-for-callers"></a>呼叫端資訊  
 在衍生的類別經常覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法來實作實值相等。 此外，型別也經常會提供額外的強型別多載，來`Equals`方法，通常是藉由實作<xref:System.IEquatable%601>介面。 當您呼叫`Equals`方法來測試是否相等，您應該知道是否會覆寫目前的執行個體<xref:System.Object.Equals%2A?displayProperty=nameWithType>，並了解如何以特定的呼叫`Equals`方法已解決。 否則，您可能會執行測試不同的是您想要相等，而且方法可能會傳回未預期的值。  
  
 下列範例提供一個實例。 它會將三個執行個體化<xref:System.Text.StringBuilder>物件具有相同的字串，並接著四個呼叫`Equals`方法。 第一個方法呼叫傳回`true`，並將其餘的三個傳回`false`。  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 在第一個案例中，強型別<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>方法多載，測試值是否相等時，會呼叫。 因為字串指派給這兩個<xref:System.Text.StringBuilder>物件是否相等，則方法會傳回`true`。 不過，<xref:System.Text.StringBuilder>未覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。 因為這個緣故時,<xref:System.Text.StringBuilder>物件轉換成<xref:System.Object>，當<xref:System.Text.StringBuilder>執行個體指派給變數的型別<xref:System.Object>，和當<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>方法會傳遞兩個<xref:System.Text.StringBuilder>的物件，預設值<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>呼叫方法。 因為<xref:System.Text.StringBuilder>是參考型別，這相當於傳遞兩個<xref:System.Text.StringBuilder>物件到<xref:System.Object.ReferenceEquals%2A>方法。 雖然這三個<xref:System.Text.StringBuilder>物件包含相同的字串，它們參考三個不同的物件。 如此一來，這些三個方法會呼叫傳回`false`。  
  
 您可以比較目前物件與另一個物件參考是否相等，藉由呼叫<xref:System.Object.ReferenceEquals%2A>方法。 在 Visual Basic 中，您也可以使用`is`關鍵字 (例如`If Me Is otherObject Then ...`)。  
  
## <a name="notes-for-inheritors"></a>繼承者注意事項  
 當您定義自己的型別時，該類型會繼承所定義的功能`Equals`其基底類型的方法。 下表列出的預設實作`Equals`方法主要的一種.NET Framework 中的型別。  
  
|型別分類|所定義的相等|註解|  
|-------------------|-------------------------|--------------|  
|直接衍生自的類別 <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|參考相等;相當於呼叫<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>。|  
|結構|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|值相等;直接的逐位元組比較或使用反映的欄位欄位比較。|  
|列舉|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|值必須有相同的列舉型別與相同的基礎值。|  
|Delegate - 委派|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|委派必須具有相同的引動過程清單之相同類型。|  
|介面|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|參考相等。|  
  
 對於實值類型，您應該一律覆寫<xref:System.Object.Equals%2A>，因為依賴反映的等號比較測試會提供效能不佳。 您也可以覆寫的預設實作<xref:System.Object.Equals%2A>參考型別來測試值是否相等，而不是參考相等，並定義實值相等，就精確而言。 這類實作的<xref:System.Object.Equals%2A>傳回`true`如果兩個物件有相同的值，即使它們不是相同的執行個體。 類型的實作器會決定構成物件的值，但它通常是部分或所有儲存的資料物件的執行個體變數中。 例如，值<xref:System.String>物件為基礎的字元字串;<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>方法覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，以傳回`true`任何兩個字串包含相同字元的相同順序的執行個體。  
  
 下列範例示範如何覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法來測試值是否相等。 它會覆寫<xref:System.Object.Equals%2A>方法`Person`類別。 如果`Person`接受等號比較，其基底類別實作兩個`Person`物件會參考單一物件，請將它們時，才。 不過，在此情況下，兩個`Person`物件是否相等，如果它們有相同的值，如`Person.Id`屬性。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 除了覆寫<xref:System.Object.Equals%2A>，您可以實作<xref:System.IEquatable%601>介面，以提供強型別的測試是否相等。  
  
 下列陳述式必須為 true 的所有實作<xref:System.Object.Equals%28System.Object%29>方法。 在清單中， `x`， `y`，並`z`代表物件參考未**null**。  
  
-   `x.Equals(x)` 傳回`true`，牽涉到浮點數類型的情況除外。 請參閱 ISO/IEC/IEEE 60559:2011，資訊技術-微處理器系統-浮點算術。  
  
-   `x.Equals(y)` 會傳回與 `y.Equals(x)` 相同的值。  
  
-   `x.Equals(y)` 會傳回`true`如果兩個`x`並`y`是`NaN`。  
  
-   如果`(x.Equals(y) && y.Equals(z))`會傳回`true`，然後`x.Equals(z)`傳回`true`。  
  
-   後續呼叫`x.Equals(y)`傳回相同的值，只要所參考的物件`x`和`y`不會修改。  
  
-   `x.Equals(null)` 會傳回 `false`。  
  
 實作<xref:System.Object.Equals%2A>不得擲回例外狀況; 它們應該一律會傳回值。 例如，如果`obj`是`null`，則<xref:System.Object.Equals%2A>方法應傳回`false`而非擲回<xref:System.ArgumentNullException>。  
  
 覆寫時，請遵循下列指導方針<xref:System.Object.Equals%28System.Object%29>:  
  
-   型別都會實作<xref:System.IComparable>必須覆寫<xref:System.Object.Equals%28System.Object%29>。  
  
-   類型覆寫<xref:System.Object.Equals%28System.Object%29>也必須覆寫<xref:System.Object.GetHashCode%2A>，否則雜湊表可能無法正常運作。  
  
-   您應該考慮實作<xref:System.IEquatable%601>介面，以支援強型別測試是否相等。 您<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>實作應該會傳回與一致的結果<xref:System.Object.Equals%2A>。  
  
-   如果您的程式語言支援運算子多載，而且您多載等號比較運算子，針對指定的型別，您也必須覆寫<xref:System.Object.Equals%28System.Object%29>方法，以傳回與等號比較運算子相同的結果。 這有助於確保會使用該類別程式庫程式碼<xref:System.Object.Equals%2A>(例如<xref:System.Collections.ArrayList>和<xref:System.Collections.Hashtable>) 行為與等號比較運算子由應用程式程式碼的方式一致的方式。  
  
### <a name="guidelines-for-reference-types"></a>參考類型的指導方針  
 下列指導方針適用於覆寫<xref:System.Object.Equals%28System.Object%29>是參考型別：  
  
-   請考慮覆寫<xref:System.Object.Equals%2A>如果類型的語意是基礎類型所代表的某些值為基礎。  
  
-   大部分的參考型別必須多載等號比較運算子，即使它們會覆寫<xref:System.Object.Equals%2A>。 不過，如果您要實作參考型別，要有值的語意，例如複雜數字 類型中，您必須覆寫等號比較運算子。  
  
-   您不應該覆寫<xref:System.Object.Equals%2A>可變動參考類型。 這是因為覆寫<xref:System.Object.Equals%2A>需要，您也會覆寫<xref:System.Object.GetHashCode%2A>方法，如前一節所述。 這表示可變動參考類型的執行個體的雜湊碼，可以在其生命週期，這會導致遺失物件雜湊表中進行變更。  
  
### <a name="guidelines-for-value-types"></a>實值類型的指導方針  
 下列指導方針適用於覆寫<xref:System.Object.Equals%28System.Object%29>的實值型別：  
  
-   如果您要定義實值型別，其中包含一或多個欄位的值是參考型別，您應該覆寫<xref:System.Object.Equals%28System.Object%29>。 <xref:System.Object.Equals%28System.Object%29>所提供的實作<xref:System.ValueType>執行逐位元組比較的值類型的欄位是所有實值型別，但它會使用反映來執行其欄位包含參考類型的實值型別的欄位的比較。  
  
-   如果您覆寫<xref:System.Object.Equals%2A>和您的開發語言支援運算子多載，您必須多載等號比較運算子。  
  
-   您應該實作<xref:System.IEquatable%601>介面。 呼叫強型別<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法可以避免 boxing`obj`引數。  
  
   
  
## Examples  
 下列範例所示`Point`類別會覆寫<xref:System.Object.Equals%2A>方法，以提供實值相等，並`Point3D`類別衍生自`Point`。 因為`Point`會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>來測試值是否相等，<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>不會呼叫方法。 不過，`Point3D.Equals`呼叫`Point.Equals`因為`Point`實作<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供實值相等的方式。  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals`方法會檢查並確定`obj`引數不是**null**和它所參考的這個物件與相同類型的執行個體。 如果其中一個檢查失敗，則方法會傳回`false`。  
  
 `Point.Equals`方法呼叫<xref:System.Object.GetType%2A>方法，以判斷兩個物件的執行階段類型是否相同。 如果使用表單的核取的方法`obj is Point`C# 中或`TryCast(obj, Point)`在 Visual Basic 中，檢查會傳回`true`萬一其中`obj`的衍生類別的執行個體`Point`，即使`obj`和目前執行個體不是相同的執行階段型別。 完成驗證，這兩個物件都是相同類型，也就是方法轉型`obj`輸入`Point`，並傳回比較兩個物件的執行個體欄位的結果。  
  
 在  `Point3D.Equals`，繼承`Point.Equals`方法，它會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>，任何其他項目完成之前叫用。 因為`Point3D`是密封的類別 (`NotInheritable` Visual Basic 中)，在表單中的核取`obj is Point`在 C# 或`TryCast(obj, Point)`Visual Basic 中就已足夠，確保`obj`是`Point3D`物件。 如果它是`Point3D`物件，它會轉換為`Point`物件，並傳遞至基底類別實作<xref:System.Object.Equals%2A>。 只有當繼承`Point.Equals`方法會傳回`true`沒有方法比較`z`執行個體的衍生類別中引進的欄位。  
  
 下列範例會定義`Rectangle`類別在內部實作做為兩個矩形`Point`物件。 `Rectangle`類別也會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供的值是否相等。  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 某些語言，例如 C# 和 Visual Basic 支援運算子多載。 當類型多載等號比較運算子時，它也必須覆寫<xref:System.Object.Equals%28System.Object%29>方法，以提供相同的功能。 這通常透過撰寫<xref:System.Object.Equals%28System.Object%29>方面的多載等號比較運算子，如下列範例所示的方法。  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 因為`Complex`是實值類型，它不能衍生自。  因此，若要覆寫<xref:System.Object.Equals%28System.Object%29>方法實作不需要呼叫<xref:System.Object.GetType%2A>若要判斷精確的執行階段輸入的每個物件，但可以改為使用`is`C# 中的運算子或`TypeOf`檢查類型的VisualBasic中的運算子`obj`參數。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比較的第一個物件。</param>
        <param name="objB">要比較的第二個物件。</param>
        <summary>判斷指定的物件執行個體是否視為相等。</summary>
        <returns>如果物件可視為相等則為 <see langword="true" />，否則為 <see langword="false" />。 如果 <paramref name="objA" /> 和 <paramref name="objB" /> 都是 **null**，則這個方法會傳回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法會指示是否兩個物件，`objA`和`objB`，相等。 它也可讓您測試其值的物件**null**是否相等。 它會比較`objA`和`objB`是否相等，如下所示：  
  
-   它會判斷兩個物件是否代表相同的物件參考。 如果沒有的話，則方法會傳回`true`。 這項測試就相當於呼叫<xref:System.Object.ReferenceEquals%2A>方法。 此外，如果這兩個`objA`並`objB`會**null**，則方法會傳回`true`。  
  
-   它會判斷是否可能`objA`或是`objB`是**null**。 如果，則會傳回`false`。  
  
-   如果兩個物件不代表相同的物件參考，而且兩者都**null**，它會呼叫`objA`。`Equals`(`objB`)，並傳回結果。 這表示，如果`objA`會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，會呼叫此覆寫。  
  
   
  
## Examples  
 下列範例說明<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法，並比較它與<xref:System.Object.ReferenceEquals%2A>方法。  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>允許物件在記憶體回收進行回收之前，嘗試釋放資源並執行其他清除作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A>方法用來在終結物件之前，目前的物件所持有的 unmanaged 資源上執行清除作業。 此方法受到保護，因此只能透過此類別或衍生類別存取。  
  
 本節內容：  
  
-   [最終處理的運作方式](#How)  
  
-   [實作者的附註](#Notes)  
  
-   [SafeHandle 替代方法](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>最終處理的運作方式  
 <xref:System.Object>類別提供任何實作<xref:System.Object.Finalize%2A>方法，以及記憶體回收行程不會標記類型衍生自<xref:System.Object>進行最終處理它們會覆寫除非<xref:System.Object.Finalize%2A>方法。  
  
 如果型別會覆寫<xref:System.Object.Finalize%2A>方法，記憶體回收行程就會將每個執行個體類型的項目加入至稱為最終處理佇列的內部結構。 完成佇列包含 managed 堆積記憶體回收行程可以回收其記憶體之前，必須執行的最終處理程式碼中的所有物件的項目。 然後呼叫記憶體回收行程<xref:System.Object.Finalize%2A>方法會自動在下列情況下：  
  
-   記憶體回收行程已探索物件是無法存取，除非呼叫物件豁免的最終處理之後<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
-   **僅限.NET Framework 上**，在關閉應用程式定義域，除非物件已豁免最終處理。 在關機期間仍然可以存取的甚至是物件的完成的。  
  
 <xref:System.Object.Finalize%2A> 會自動呼叫一次在給定的執行個體，除非使用一種機制，例如重新註冊的物件<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>而<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法尚未後續呼叫。  
  
 <xref:System.Object.Finalize%2A> 作業會有下列限制：  
  
-   當完成項執行的確切時間是未定義。 若要確保您類別的執行個體都會實作決定性的資源釋放`Close`方法，或提供<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作。  
  
-   即使一個物件參考其他兩個物件的完成項不保證任何特定順序執行。 也就是說，如果物件 A 會有物件 B 的參考，而且兩者都有完成項，物件 B 可能已完成的物件的完成項開始時。  
  
-   未指定在其執行完成項執行緒。  
  
 <xref:System.Object.Finalize%2A>方法可能不會執行到完成為止，或可能完全無法執行下列的例外情況下：  
  
-   如果另一個完成項會無限期地封鎖 （進入無限迴圈，會嘗試取得鎖定，它可能永遠不會取得，等等）。 因為執行階段嘗試執行完成項完成時，其他完成項可能不會呼叫如果完成項區塊無限期。  
  
-   如果處理程序結束，而不讓執行階段清除。 在此情況下，執行階段的第一次通知程序終止的是 DLL_PROCESS_DETACH 通知。  
  
 執行階段會繼續在關機期間完成物件，只有當最終處理物件的數目會繼續減少時。  
  
 如果<xref:System.Object.Finalize%2A>或 覆寫<xref:System.Object.Finalize%2A>擲回例外狀況和執行階段不會覆寫預設原則的應用程式所裝載，因此執行階段終止程序並沒有作用`try` / `finally`區塊或執行完成項。 此行為可確保處理程序完整性，如果完成項無法釋放或終結資源。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>覆寫 Finalize 方法 
 您應該覆寫<xref:System.Object.Finalize%2A>類別使用 unmanaged 的資源，例如檔案控制代碼或必須發行時使用這些 managed 的物件會在記憶體回收期間捨棄的資料庫連接。 您不應該實作<xref:System.Object.Finalize%2A>方法受管理物件，因為記憶體回收行程自動釋放 managed 的資源。  
  
> [!IMPORTANT]
>  如果<xref:System.Runtime.InteropServices.SafeHandle>都有提供物件，包裝您的 unmanaged 的資源，建議的替代做法是實作使用安全控制代碼的處置模式，並不會覆寫<xref:System.Object.Finalize%2A>。 如需詳細資訊，請參閱 < [SafeHandle 替代方法](#SafeHandle)一節。  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法則會根據預設，不執行任何動作，但您應該覆寫<xref:System.Object.Finalize%2A>才有必要，而且只釋放 unmanaged 的資源。 回收記憶體，通常需要更長，如果在執行最終處理作業，因為它需要至少兩個記憶體回收。 此外，您應該覆寫<xref:System.Object.Finalize%2A>方法參考類型才。 Common language runtime 只完成參考型別。 它會忽略在實值型別上的完成項。  

範圍<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法是`protected`。 當您在類別中覆寫方法時，您應該維護這個限定的範圍。 藉由讓保持<xref:System.Object.Finalize%2A>受保護的方法，防止使用者從呼叫物件的應用程式的<xref:System.Object.Finalize%2A>直接方法。
  
 每個實作<xref:System.Object.Finalize%2A>衍生的型別必須呼叫其基底類型實作<xref:System.Object.Finalize%2A>。 這是這類應用程式碼允許呼叫的唯一情況<xref:System.Object.Finalize%2A>。 物件的<xref:System.Object.Finalize%2A>方法不應該在其基底類別以外的其他任何物件上呼叫方法。 這是因為被呼叫的其他物件收集同時作為呼叫物件時，例如在通用語言執行階段關機的情況下。 
  
> [!NOTE]
>  C# 編譯器不允許您覆寫<xref:System.Object.Finalize%2A>方法。 相反地，您提供完成項方法是實作[解構函式](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)為您的類別。 C# 解構函式會自動呼叫其基底類別解構函式。  
>   
>  Visual c + + 也提供自己的語法來實作<xref:System.Object.Finalize%2A>方法。 如需詳細資訊，請參閱 < 解構函式和完成項 > 一節[如何： 定義與使用類別和結構 (C + + /cli CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)。  
  
 因為記憶體回收是不具決定性，所以您不知道記憶體回收行程執行完成時。 若要釋出資源立即執行，您也可以選擇實作[處置模式](~/docs/standard/design-guidelines/dispose-pattern.md)而<xref:System.IDisposable>介面。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作可以呼叫您類別的取用者釋放 unmanaged 的資源，而且您可以使用<xref:System.Object.Finalize%2A>方法來釋放 unmanaged 的資源的情況<xref:System.IDisposable.Dispose%2A>不會呼叫方法。  
  
 <xref:System.Object.Finalize%2A> 之後它已清除記憶體回收期間，可能需要幾乎任何動作，包括 resurrecting 物件 （也就，讓物件可存取一次）。 不過，該物件可以只復活一次;<xref:System.Object.Finalize%2A>和物件上無法呼叫記憶體回收期間。 沒有一個動作，您的實作<xref:System.Object.Finalize%2A>絕對不應該接受： 應該永遠不會擲回例外狀況。 如果從呼叫的方法所擲回任何例外狀況<xref:System.Object.Finalize%2A>方法會處理<xref:System.Object.Finalize%2A>方法，執行階段會假設<xref:System.Object.Finalize%2A>方法傳回，並繼續呼叫<xref:System.Object.Finalize%2A>其他物件的方法。 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 替代方法  
 建立可靠的完成項通常很困難，因為您不能假設您的應用程式的狀態相關，而且這類未處理系統例外狀況<xref:System.OutOfMemoryException>和<xref:System.StackOverflowException>終止完成項。 而不是實作您類別的完成項，表示釋放 unmanaged 的資源，您可以使用衍生自物件<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>類別來包裝 unmanaged 的資源，，然後再實作處置模式，而不需要完成項。 .NET Framework 提供的下列類別<xref:Microsoft.Win32?displayProperty=nameWithType>命名空間衍生自<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 是檔案控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 為記憶體對應檔案控制代碼的包裝函數類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 是的 unmanaged 記憶體區塊指標的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle><xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>，和<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>是適用於密碼編譯控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 是管道控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 是登錄機碼的控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 是的等候控制代碼的包裝函式類別。  
  
 下列範例會使用[處置模式](~/docs/standard/design-guidelines/dispose-pattern.md)使用安全控制代碼，而不是覆寫<xref:System.Object.Finalize%2A>方法。 它會定義`FileAssociation`類別，包裝的應用程式會處理具有特定副檔名的檔案相關的登錄資訊。 傳回兩個登錄控制代碼`out`由 Windows 參數[RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)函式呼叫會傳遞至<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>建構函式。 受保護的型別`Dispose`然後方法會呼叫`SafeRegistryHandle.Dispose`方法來釋放這些兩個控制代碼。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 下列範例會確認<xref:System.Object.Finalize%2A>時，覆寫的物件呼叫方法<xref:System.Object.Finalize%2A>終結。 請注意，在生產環境應用程式中，<xref:System.Object.Finalize%2A>會覆寫方法，以釋放這個物件所持有的 unmanaged 的資源。 也請注意，C# 範例會提供解構函式，而不是覆寫<xref:System.Object.Finalize%2A>方法。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 如需其他範例，以覆寫<xref:System.Object.Finalize%2A>方法，請參閱<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>做為預設雜湊函式。</summary>
        <returns>目前物件的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雜湊程式碼是用來插入及識別雜湊為基礎的集合中的物件，例如數值<xref:System.Collections.Generic.Dictionary%602>類別，<xref:System.Collections.Hashtable>類別或衍生自類型<xref:System.Collections.DictionaryBase>類別。 <xref:System.Object.GetHashCode%2A>方法會提供此雜湊程式碼需要快速檢查物件是否相等的演算法。  
  
> [!NOTE]
>  如需有關雜湊碼的雜湊表中的使用方式資訊以及一些額外的雜湊程式碼演算法，請參閱[雜湊函式](https://en.wikipedia.org/wiki/Hash_function)維基百科中的項目。  
  
 兩個物件相等的等於傳回的雜湊碼。 不過，並非反之亦然： 相同的雜湊程式碼不會表示物件是否相等，因為不同 （相等） 的物件可以具有相同的雜湊碼。 此外，.NET Framework 並不保證的預設實作<xref:System.Object.GetHashCode%2A>方法和這個方法會傳回可能不同.NET Framework 版本與平台，例如 32 位元和 64 位元平台之間的值。 基於這些理由，請勿使用這個方法的預設實作做為唯一的物件識別碼的雜湊的用途。 從這個，請依照下列兩種結果：  
  
-   您不應該假設等於雜湊程式碼表示物件是否相等。  
  
-   您應該永遠不會保存，或在其中建立應用程式定義域之外使用的雜湊碼，因為相同的物件可跨應用程式定義域、 處理程序，與平台雜湊。  
  
> [!WARNING]
>  雜湊程式碼適用於有效率的插入和雜湊資料表為基礎的集合中的查閱。 雜湊程式碼不是永久的值。 基於此理由：  
>   
> -   不要序列化雜湊程式碼的值，或將它們儲存在資料庫中。  
> -   請勿為索引鍵使用雜湊程式碼，若要從索引集合中擷取物件。  
> -   不要跨應用程式定義域或處理程序傳送雜湊碼。 在某些情況下，雜湊程式碼可能會計算每個處理序或每個應用程式定義域為基礎。  
> -   請勿使用雜湊程式碼而不是在您需要強式密碼編譯雜湊時密碼編譯雜湊函式所傳回的值。 密碼編譯雜湊，使用一個衍生自類別<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>類別。  
> -   不會測試相等的雜湊程式碼，以判斷兩個物件是否相等。 （不相等的物件可以有相同的雜湊程式碼）。若要測試是否相等，呼叫<xref:System.Object.ReferenceEquals%2A>或<xref:System.Object.Equals%2A>方法。  
  
 <xref:System.Object.GetHashCode%2A>衍生型別可覆寫方法。 如果<xref:System.Object.GetHashCode%2A>是不覆寫時，雜湊碼的參考型別會藉由呼叫計算<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>基底類別方法，會計算出雜湊程式碼以基礎物件的參考; 如需詳細資訊，請參閱<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。 也就是說，兩個物件的<xref:System.Object.ReferenceEquals%2A>方法會傳回`true`有相同的雜湊碼。 如果實值型別不會覆寫<xref:System.Object.GetHashCode%2A>，則<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>基底類別方法會使用反映來計算的類型欄位的值為基礎的雜湊碼。 換句話說，其欄位具有相等值的實值型別具有相等的雜湊碼。 如需有關覆寫<xref:System.Object.GetHashCode%2A>，請參閱 「 備忘稿繼承者 」 一節。  
  
> [!WARNING]
>  如果您覆寫<xref:System.Object.GetHashCode%2A>方法中，您也會覆寫<xref:System.Object.Equals%2A>，反之亦然。 如果您覆寫<xref:System.Object.Equals%2A>方法會傳回`true`兩個物件是否相等，覆寫進行測試<xref:System.Object.GetHashCode%2A>方法必須傳回兩個物件相同的值。  
  
 如果當做索引鍵使用雜湊表中的物件不提供的有用實作<xref:System.Object.GetHashCode%2A>，您可以藉由提供指定的雜湊程式碼提供者<xref:System.Collections.IEqualityComparer>實作，以其中一個多載的<xref:System.Collections.Hashtable>類別建構函式。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>資訊 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 當您呼叫<xref:System.Object.GetHashCode%2A>中之類別的方法[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不會覆寫的類別提供的預設行為<xref:System.Object.GetHashCode%2A>。 這是.NET Framework 提供的支援之一[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱 < [.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且不要只實作目前<xref:System.Object.GetHashCode%2A>。 不過，它們似乎具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法時您用於您的 C# 或 Visual Basic 程式碼，和.NET Framework 會提供這些方法中的預設行為。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.GetHashCode%2A>方法。  
  
   
  
## Examples  
 其中一種最簡單的方式來計算相同或較小的範圍超過一個數字值的雜湊碼<xref:System.Int32>類型就是傳回該值。 下列範例示範這類實作的`Number`結構。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 通常，型別具有可以參與產生雜湊程式碼的多個資料欄位。 產生的雜湊碼的一個方式是結合使用這些欄位`XOR (eXclusive OR)`作業，如下列範例所示。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 先前的範例會傳回相同的雜湊程式碼 (n1，n2) 和 (n2 n1)，因此可能會產生比令人期待的多個衝突。 許多解決方案可用，以便在這些情況下的雜湊程式碼並不相同。 其中是要傳回的雜湊碼`Tuple`物件，以反映每個欄位的順序。 下列範例顯示可能的實作使用<xref:System.Tuple%602>類別。 不過請注意，具現化的效能負荷`Tuple`物件可能會大幅影響儲存大量的物件雜湊資料表中的應用程式的整體效能。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 第二個替代方案牽涉到藉由向左移位的後續欄位的雜湊碼由兩個或多個位元加權的個別的雜湊碼。 以最佳方式，而不是被捨棄，超過 31 的位元移位的位元環繞而不會被捨棄。 位元左移運算子，在 C# 和 Visual Basic 會捨棄，因為這需要建立左的 shift 包裝方法如下所示：  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 下列範例接著會使用這個 shift 包裝方法來計算的雜湊碼`Point`前一個範例中使用的結構。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>雜湊函式用來快速產生數字 （雜湊程式碼），其對應於物件的值。 雜湊函式通常專屬於每個類型，和唯一性，必須使用至少其中一個執行個體欄位做為輸入。 使用靜態欄位的值時，應該不計算雜湊碼。  
  
類別衍生自<see cref="T:System.Object" />，則<see langword="GetHashCode" />方法可以委派給基底類別<see cref="M:System.Object.GetHashCode" />衍生的類別會定義要參考相等的等號比較時，才實作。 預設實作<see cref="M:System.Object.GetHashCode" />參考類型會傳回相當於所傳回的雜湊碼<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />方法。 您可以覆寫<see cref="M:System.Object.GetHashCode" />不可變的參考型別。 一般情況下，針對可變動參考類型，您應該會覆寫<see cref="M:System.Object.GetHashCode" />只有當： 
-您可以計算出雜湊程式碼，從欄位不是可變動;或 
-您可以確保依賴其雜湊程式碼的集合中包含了該物件時，並不會變更可變動物件的雜湊碼。  
  
否則，您可能會認為可變動的物件會遺失的雜湊表。 如果您選擇要覆寫<see cref="M:System.Object.GetHashCode" />對於可變動參考類型，您的文件變得只有在您的型別的使用者不應該修改物件值，而此物件會儲存雜湊表中，清除。  
  
實值型別，<see cref="M:System.ValueType.GetHashCode" />提供使用反映的預設雜湊程式碼實作。 您應該考慮覆寫它，以提升效能。  
  
 <block subset="none" type="note"><para>  
 如需詳細資訊和範例，計算雜湊碼的各種不同的方式，請參閱 &lt; 範例 &gt; 一節。  
  
</para></block>  
  
 雜湊函式必須具有下列屬性： 
-如果兩個物件的比較結果為相等，<see cref="M:System.Object.GetHashCode" />每個物件的方法必須傳回相同的值。 不過，如果兩個物件不會比較為相等，<see cref="M:System.Object.GetHashCode" />兩個物件的方法沒有傳回不同的值。  
  
-<see cref="M:System.Object.GetHashCode" />物件的方法必須以一致的方式傳回相同雜湊程式碼，只要決定物件的傳回值的物件狀態進行任何修改[System.Object.Equals](xref:System.Object.Equals*)方法。 請注意，這是僅適用於目前執行的應用程式時，是否再次執行應用程式，可能會傳回不同的雜湊程式碼。  
  
-針對最佳效能，雜湊函式應該產生的平均分配所有輸入，包括大量已叢集化的輸入。 含意為，小幅修改以物件狀態應該會導致產生的雜湊程式碼中，為了達到最佳的雜湊資料表效能的大規模修改。  
  
雜湊函式應該便宜計算。  
  
-<see cref="M:System.Object.GetHashCode" />方法不應該擲回例外狀況。  
  
比方說，實作<see cref="M:System.String.GetHashCode" />所提供的方法<see cref="T:System.String" />類別會傳回相同的字串值的完全相同的雜湊碼。 因此，兩個<see cref="T:System.String" />物件傳回相同的雜湊程式碼，如果它們代表相同的字串值。 此外，方法會使用所有的字元字串中產生合理地隨機散發的輸出，即使輸入叢集在特定範圍 (例如，許多使用者可能只包含較低 128 ASCII 字元，即使的字串字串可以包含任何 65,535 的 Unicode 字元）。  
  
在類別上提供良好的雜湊函式會大幅影響將這些物件加入至雜湊表的效能。 中提供良好的雜湊函式實作的索引鍵的雜湊資料表，搜尋項目，將會採用常數時間 （例如，o （1） 作業）。 中的雜湊函式的實作不佳的雜湊資料表，搜尋的效能取決於雜湊表中的項目數 (比方說，是 O (`n`) 作業，其中`n`是雜湊表中的項目數)。 惡意使用者可以輸入，從而減少衝突發生，可能會大幅降低取決於雜湊表，在下列情況下的應用程式的效能資料： 
-當雜湊函式會產生頻繁的衝突。  
  
-當大部分的雜湊表中的物件會產生相等，或大約等於另一個雜湊碼。  
  
-當使用者輸入要從中計算雜湊程式碼的資料。  
  
衍生類別覆寫<see cref="M:System.Object.GetHashCode" />也必須覆寫<see cref="M:System.Object.Equals(System.Object)" />若要保證視為相等的兩個物件具有相同的雜湊程式碼; 否則<see cref="T:System.Collections.Hashtable" />類型可能無法正常運作。</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前執行個體的 <see cref="T:System.Type" />。</summary>
        <returns>目前執行個體的確切執行階段類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為<xref:System.Object?displayProperty=nameWithType>在.NET Framework 型別系統中，為所有類型的基底類別<xref:System.Object.GetType%2A>方法可以用來傳回<xref:System.Type>表示.NET Framework 的所有類型的物件。 .NET Framework 可辨識下列五種型別：  
  
-   類別，衍生自<xref:System.Object?displayProperty=nameWithType>，  
  
-   實值型別，衍生自<xref:System.ValueType?displayProperty=nameWithType>。  
  
-   介面衍生自<xref:System.Object?displayProperty=nameWithType>從.NET Framework 2.0 開始。  
  
-   列舉型別，衍生自<xref:System.Enum?displayProperty=nameWithType>。  
  
-   委派，衍生自<xref:System.MulticastDelegate?displayProperty=nameWithType>。  
  
 兩個物件`x`並`y`具有相同的執行階段類型`Object.ReferenceEquals(x.GetType(),y.GetType())`傳回`true`。 下列範例會使用<xref:System.Object.GetType%2A>方法使用<xref:System.Object.ReferenceEquals%2A>方法來判斷兩個數值是否為兩個數字的值相同的型別。  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  若要判斷物件是否為特定的型別，您可以使用您語言的型別比較關鍵字，或建構。 例如，您可以使用`TypeOf…Is`在 Visual Basic 中建構或`is`C# 中的關鍵字。  
  
 <xref:System.Object.GetType%2A>方法繼承自所有的型別衍生自<xref:System.Object>。 這表示，除了使用您自己的語言比較關鍵字，您可以使用<xref:System.Object.GetType%2A>方法，以判斷特定物件的型別，如下列範例所示。  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type>物件會公開目前的類別相關聯的中繼資料<xref:System.Object>。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Object.GetType%2A>傳回目前的執行個體的執行階段類型。  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立目前 <see cref="T:System.Object" /> 的淺層複製。</summary>
        <returns>目前 <see cref="T:System.Object" /> 的淺層複製。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A>方法藉由建立新的物件，並再將目前物件的非靜態欄位複製到新的物件建立淺層複本。 如果欄位是實值型別，則會執行位元欄位的複本。 如果欄位是參考型別，則會複製參考，但參考的物件不;因此，原始的物件和其複製品參考相同的物件。  
  
 例如，假設物件 x。 接著，參考物件 A 和 B 參考物件 c。X 的淺層複本建立新物件，X2，也會參考物件 A 和 b。相反地，X 的深層複本建立新物件 X2 A2 和 B2，也就是 A 的複本的新物件和 B.B2，則是參照新物件 C2，也就是一份 c。此範例說明 shallow 和深層複製作業之間的差異。  
  
 有多種方法來實作深層複製作業，如果藉由執行淺層複製作業<xref:System.Object.MemberwiseClone%2A>方法不符合您的需求。 這些需求包括下列各項：  
  
-   呼叫類別建構函式複製到使用取自第一個物件的屬性值中建立第二個物件的物件。 這是假設物件的值完全由其類別建構函式。  
  
-   呼叫<xref:System.Object.MemberwiseClone%2A>建立物件的淺層複本，然後將指派其值會與原始物件的任何屬性或欄位的值是參考型別相同的新物件的方法。 `DeepCopy`方法在此範例說明此方法。  
  
-   序列化物件是深層複製，然後還原序列化的資料給不同的物件變數。  
  
-   使用反映進行遞迴時，以執行深層複製作業。  
  
   
  
## Examples  
 下列範例說明<xref:System.Object.MemberwiseClone%2A>方法。 它會定義`ShallowCopy`方法，以呼叫<xref:System.Object.MemberwiseClone%2A>方法來執行淺層複製作業`Person`物件。 它也會定義`DeepCopy`執行深層複製作業的方法`Person`物件。  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 在此範例中，`Person.IdInfo`屬性會傳回`IdInfo`物件。 如輸出所範例所示，當`Person`物件會複製藉由呼叫<xref:System.Object.MemberwiseClone%2A>方法中，複製`Person`物件是原始物件，而的獨立複本，不同之處在於它們會共用相同`Person.IdInfo`物件參考。 如此一來，修改 clone`Person.IdInfo`屬性變更時，原始物件的`Person.IdInfo`屬性。 相反地，深層複製作業執行時，複製`Person`物件，包括其`Person.IdInfo`可以修改屬性，而不會影響原始物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比較的第一個物件。</param>
        <param name="objB">要比較的第二個物件。</param>
        <summary>判斷指定的 <see cref="T:System.Object" /> 執行個體是否為相同的執行個體。</summary>
        <returns>如果 <paramref name="objA" /> 與 <paramref name="objB" /> 為相同的執行個體或兩者皆為 **null**，則為 <see langword="true" />否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Object.Equals%2A>方法，並使用等號比較運算子，<xref:System.Object.ReferenceEquals%2A>無法覆寫方法。 因為這個緣故，如果您想要測試兩個物件是否相等的參考，但不確定的實作而分心`Equals`方法中，您可以呼叫<xref:System.Object.ReferenceEquals%2A>方法。  
  
 不過，傳回值<xref:System.Object.ReferenceEquals%2A>方法可能會出現在這兩種案例中的異常：  
  
-   當比較實值型別。 如果`objA`並`objB`是實值類型，它們會進行 boxed 處理之前傳遞至<xref:System.Object.ReferenceEquals%2A>方法。 這表示，如果這兩個`objA`並`objB`代表相同的執行個體的實值型別<xref:System.Object.ReferenceEquals%2A>方法卻傳回`false`，如下列範例所示。  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     如需 boxing 實值型別資訊，請參閱[Boxing 和 Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)。  
  
-   當比較字串。 如果`objA`並`objB`都是字串，<xref:System.Object.ReferenceEquals%2A>方法會傳回`true`如果字串暫留。 它不會執行測試的值相等。  在下列範例中，`s1`和`s2`相等，因為它們是兩個執行個體的單一保留的字串。 不過，`s3`和`s4`不相等，因為它們都有相同的字串值，雖然未保留該字串。  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     如需有關字串拘留的詳細資訊，請參閱<xref:System.String.IsInterned%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Object.ReferenceEquals%2A>，判斷兩個物件是否相同的執行個體。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回代表目前物件的字串。</summary>
        <returns>表示目前物件的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 主要格式設定.NET Framework 中的方法。 使其適合顯示，它可以轉換為其字串表示的物件。 (如需.NET Framework 中的支援的格式資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。)預設實作<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法傳回的物件型別的完整的名稱。  
  
> [!IMPORTANT]
>  您可以依照下列連結，從另一種類型的成員清單到達此頁面。 這是因為該類型不覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>。 相反地，它所繼承的功能<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
 經常覆寫類型<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以提供更適合的字串表示，特定的類型。 型別也經常多載<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以提供支援的格式字串，或區分文化特性格式。  
  
 本節內容：  
  
 [預設 object.tostring （） 方法](#Default)   
 [覆寫 object.tostring （） 方法](#Overriding)   
 [ToString 方法多載化](#Overloading)   
 [擴充 Object.ToString 方法](#Extending)   
 [Windows 執行階段的相關資訊](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>預設 object.tostring （） 方法  
 預設實作<xref:System.Object.ToString%2A>方法會傳回之型別的完整格式的名稱<xref:System.Object>，如下列範例所示。  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 因為<xref:System.Object>的基底類別的所有參考型別在.NET Framework 中，此行為由參考型別，不會覆寫繼承<xref:System.Object.ToString%2A>方法。 下列範例將說明這點。 它會定義名為類別`Object1`它會接受所有的預設實作<xref:System.Object>成員。 其<xref:System.Object.ToString%2A>方法會傳回物件的完整型別名稱。  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>覆寫 object.tostring （） 方法  
 型別通常覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法來傳回字串，表示物件執行個體。 例如，基底類型，例如<xref:System.Char>， <xref:System.Int32>，並<xref:System.String>提供<xref:System.Object.ToString%2A>傳回該物件所代表之值的字串形式的實作。 下列範例會定義類別`Object2`，會覆寫<xref:System.Object.ToString%2A>方法，以傳回型別名稱和其值。  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 下表列出.NET Framework 中的類型分類，並指出是否在覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
|型別分類|覆寫 object.tostring （)|行為|  
|-------------------|-----------------------------------|--------------|  
|類別|N/A|N/A|  
|結構|[是] (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|相同 object.tostring （）|  
|列舉|[是] (<xref:System.Enum.ToString?displayProperty=nameWithType>)|成員名稱|  
|介面|否|N/A|  
|Delegate - 委派|否|N/A|  
  
 請參閱注意事項繼承者注意事項 > 一節，如需詳細資訊，在覆寫<xref:System.Object.ToString%2A>。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>ToString 方法多載化  
 除了無參數的覆寫<xref:System.Object.ToString?displayProperty=nameWithType>方法中，許多型別多載`ToString`方法，以提供的方法接受參數的版本。 大多數情況下，這是為了提供變數的格式和區分文化特性的格式化支援。  
  
 下列範例會多載`ToString`方法，以傳回結果字串，其中包含的各種欄位的值`Automobile`類別。 它會定義四個格式字串： G，會傳回年份; 與模型名稱D，傳回模型名稱、 年和機門; 數目C，傳回模型名稱、 年的磁柱; 數目和 A，它會傳回所有的四個欄位值的字串。  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 下列範例會呼叫多載<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法來顯示文化特性的貨幣值的格式。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 如需有關格式字串和文化特性格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。 針對支援的數值格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 支援的日期和時間值的格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>擴充 Object.ToString 方法  
 因為型別會繼承預設<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法中，您可以找到它的行為不想要並想要加以變更。 這是特別的陣列和集合類別。 雖然您可能會預期`ToString`方法的陣列或集合類別，以顯示其成員的值，它改為顯示類型的完整型別名稱，如下列範例所示。  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 您有數個選項，以產生您想要的結果字串。  
  
-   如果類型是陣列、 集合物件或該物件會實作<xref:System.Collections.IEnumerable>或是<xref:System.Collections.Generic.IEnumerable%601>介面，您可以使用，以列舉其項目`foreach`C# 中的陳述式或`For Each...Next`建構在 Visual Basic 中。  
  
-   如果類別不是`sealed`（在 C# 中) 或`NotInheritable`（在 Visual Basic 中)，您可以開發其繼承自基底類別的包裝函數類別<xref:System.Object.ToString%2A?displayProperty=nameWithType>您想要自訂的方法。 至少，這需要您下列：  
  
    1.  實作任何所需的建構函式。 在衍生的類別不會繼承其基底類別建構函式。  
  
    2.  覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以傳回您想要的結果字串。  
  
     下列範例會定義包裝函式類別<xref:System.Collections.Generic.List%601>類別。 它會覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以顯示每個方法的集合，而不是完整的類型名稱的值。  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   開發[擴充方法](~/docs/standard/design-guidelines/extension-methods.md)傳回您想要的結果字串。 請注意，您無法覆寫預設值<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以這種方式 (也就是您的延伸模組類別 （在 C# 中) 或 （在 Visual Basic) 的模組不能有一個名為的無參數方法`ToString`呼叫取代原始的型別`ToString`方法. 您必須提供一些其他的程式無參數的名稱，`ToString`取代。  
  
     下列範例會定義兩個方法，擴充<xref:System.Collections.Generic.List%601>類別： 無參數`ToString2`方法，並`ToString`方法<xref:System.String>表示格式字串參數。  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>資訊 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 當您呼叫<xref:System.Object.ToString%2A>中之類別的方法[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不會覆寫的類別提供的預設行為<xref:System.Object.ToString%2A>。 這是.NET Framework 提供的支援之一[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱 < [.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且永遠不要只實作<xref:System.Object.ToString%2A>。 不過，它們一律出現有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法時您用於您的 C# 或 Visual Basic 程式碼，和.NET Framework 會提供這些方法中的預設行為。  
  
 開頭[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，將會使用 common language runtime [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)上[!INCLUDE[wrt](~/includes/wrt-md.md)]再切換回預設實作的物件<xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.ToString%2A>方法。  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)]和 IStringable 介面  
 開頭[!INCLUDE[win81](~/includes/win81-md.md)]，則[!INCLUDE[wrt](~/includes/wrt-md.md)]包含[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面方法[IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)，提供基本格式支援能夠與所提供<xref:System.Object.ToString%2A?displayProperty=nameWithType>。 若要避免模稜兩可，您不應該實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) managed 類型上。  
  
 受管理的物件由原生程式碼或以 JavaScript 或 C + 等語言撰寫的程式碼的呼叫時 + /CX 中，看起來就像實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。 Common language runtime 會自動將路由來電[IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)要<xref:System.Object.ToString%2A?displayProperty=nameWithType>在事件[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)上受管理的物件未實作。  
  
> [!WARNING]
>  因為 common language runtime 自動實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)所有受管理中的型別[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]應用程式，我們建議您不要不提供您自己[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)實作。 實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)呼叫時，可能會導致非預期的行為`ToString`從[!INCLUDE[wrt](~/includes/wrt-md.md)]、 C + + /CX 或 JavaScript。  
  
 如果您選擇實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)匯出在公用 managed 類型中[!INCLUDE[wrt](~/includes/wrt-md.md)]元件，適用下列限制：  
  
-   您可以定義[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面只能在 「 類別實作 」 關聯性，例如  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     在 C# 中，或  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     在 Visual Basic 中。  
  
-   您不能實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面上。  
  
-   您不能宣告為類型參數[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)不可為方法、 屬性或欄位的傳回型別。  
  
-   您無法隱藏您[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)實作基底類別使用的方法定義，如下所示：  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     相反地， [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)實作一律必須覆寫基底類別實作。 您只能藉由針對強型別類別執行個體叫用 `ToString` 實作來隱藏該實作。  
  
 請注意，在各種不同的條件，從原生程式碼於 managed 類型可實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)或隱藏其[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)實作可能會產生非預期的行為。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您實作您自己的類型時，您應該覆寫<see cref="M:System.Object.ToString" />方法傳回對於這些類型有意義的值。 衍生的類別需要更充分掌控格式比<see cref="M:System.Object.ToString" />提供可實作<see cref="T:System.IFormattable" />介面。 其<see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />方法可讓您定義控制格式的格式字串，並使用<see cref="T:System.IFormatProvider" />可以提供特定文化特性的格式化物件。  
  
覆寫<see cref="M:System.Object.ToString" />方法應遵循這些指導方針： 
-傳回的字串應該是易記而讓人判讀。  
  
-傳回的字串應專門用於識別物件的執行個體的值。  
  
-傳回的字串應該越短越好，使其適用於偵錯工具的顯示。  
  
-您<see cref="M:System.Object.ToString" />覆寫不應該傳回<see cref="F:System.String.Empty" />或 null 字串。  
  
-您<see cref="M:System.Object.ToString" />覆寫不應該擲回例外狀況。  
  
-如果執行個體的字串表示區分文化特性，或可以多種方式進行格式化，實作<see cref="T:System.IFormattable" />介面。  
  
-如果傳回的字串會包含機密資訊，您應該先要求適當的權限。 如果要求成功，您可以傳回機密的資訊;否則，您應該傳回排除機密資訊的字串。  
  
-您<see cref="M:System.Object.ToString" />覆寫應該沒有任何可預見的副作用以避免在偵錯的複雜性。 例如，若要呼叫<see cref="M:System.Object.ToString" />方法不應該變更執行個體欄位的值。  
  
-如果您的型別實作的剖析方法 (或<see langword="Parse" />或是<see langword="TryParse" />方法、 建構函式或其他靜態方法，從字串型別的執行個體具現化)，您應該確保所傳回的字串<see cref="M:System.Object.ToString" />方法可以是轉換成物件執行個體。</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
      </Docs>
    </Member>
  </Members>
</Type>