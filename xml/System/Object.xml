<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="15f433904f15b52fc408db54f7fd65e20a71b739" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174245" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支援 .NET Framework 類別階層架構中的所有類別，提供衍生類別的低階服務。 這是 .NET Framework 中所有類別的超基底類別，是類別階層架構的根。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 語言通常不需要宣告繼承自一個類別<xref:System.Object>因為繼承是隱含的。  
  
 因為.NET Framework 中的所有類別都衍生自<xref:System.Object>，每個方法中定義<xref:System.Object>類別系統中是可用於所有物件。 衍生類別可以和覆寫某些方法，包括：  
  
-   <xref:System.Object.Equals%2A> -支援物件之間的比較。  
  
-   <xref:System.Object.Finalize%2A> -自動收回物件前，請執行清除作業。  
  
-   <xref:System.Object.GetHashCode%2A> 產生的數字對應到物件的值以支援雜湊資料表的使用。  
  
-   <xref:System.Object.ToString%2A> -製造人類看得懂的文字字串描述類別的執行個體。  
  
## <a name="performance-considerations"></a>效能考量  
 如果您正在設計的類別，例如集合，必須處理任何類型的物件，您可以建立接受的執行個體的類別成員<xref:System.Object>類別。 不過，boxing 和 unboxing 類型的程序會帶來效能成本。 如果您知道您的新類別會經常處理某些值類型您可以使用其中一個策略 boxing 成本降到最低。  
  
-   建立一般的方法可接受<xref:System.Object>型別，以及一組特定類型的方法多載會接受每個您預期您經常處理的類別的實值型別。 如果特定類型的方法可接受呼叫的參數型別，就會發生任何 boxing，會叫用特定類型的方法。 如果沒有符合呼叫的參數型別沒有方法引數，參數會進行 boxed 處理，會叫用一般的方法。  
  
-   設計您的類型和其成員使用泛型。 當您建立類別的執行個體，並指定泛型型別引數時，common language runtime 建立封閉泛型類型。 泛型方法型別而異，而且會叫用沒有 boxing 呼叫的參數。  
  
 雖然有時候是為了開發一般用途的類別，可接受並傳回<xref:System.Object>型別，可以改善效能，也提供特定類型的類別來處理常用的型別。 例如，提供類別的特定設定和取得布林值會排除 boxing 和 unboxing 的布林值的成本。  
  
   
  
## Examples  
 下列範例會定義衍生自點類型<xref:System.Object>類別並覆寫虛擬方法的許多<xref:System.Object>類別。 此外，此範例示範如何呼叫許多靜態和執行個體的方法<xref:System.Object>類別。  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公用靜態 (<see langword="Shared" />在 Visual Basic 中) 這種類型的成員都具備執行緒安全。 不保證執行個體成員是安全執行緒。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Object" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會呼叫建構函式在衍生類別中，但它也可用來直接建立的執行個體<xref:System.Object>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷兩個物件執行個體是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要與目前物件比較的物件。</param>
        <summary>判斷指定的物件是否等於目前的物件。</summary>
        <returns>如果指定的物件等於目前的物件，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較目前的執行個體之間的類型和`obj`參數，取決於目前的執行個體是參考類型或實值類型。  
  
-   如果目前的執行個體是參考類型，<xref:System.Object.Equals%28System.Object%29>方法測試參考是否相等，而呼叫<xref:System.Object.Equals%28System.Object%29>方法相當於呼叫<xref:System.Object.ReferenceEquals%2A>方法。 參考相等，表示要比較的物件變數會參照相同的物件。 下列範例說明這類比較的結果。 它會定義`Person`類別，這是參考類型，並呼叫`Person`類別建構函式來產生兩個新`Person`物件`person1a`和`person2`，必須有相同的值。 它也會將指派`person1a`給另一個物件變數， `person1b`。 做為範例所示，從輸出`person1a`和`person1b`相等，因為其參考相同的物件。 不過，`person1a`和`person2`不相等，雖然它們有相同的值。  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   如果目前的執行個體是實值類型，<xref:System.Object.Equals%28System.Object%29>方法測試值是否相等。 值相等的意義如下：  
  
    -   兩個物件都屬於相同的型別。 如下列範例所示，<xref:System.Byte>有 12 個值的物件不等於<xref:System.Int32>有其值為 12，因為兩個物件具有不同的執行階段類型的物件。  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   兩個物件的公用和私用欄位的值相等。 下列範例會測試的值相等。 它會定義`Person`結構，也就是實值類型，並呼叫`Person`類別建構函式來產生兩個新`Person`物件`person1`和`person2`，必須有相同的值。 範例輸出所示，不過兩個物件變數參考不同的物件，`person1`和`person2`相等，因為它們具有相同的值與私人`personName`欄位。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 因為<xref:System.Object>類別是.NET Framework 中中的所有類型的基底類別<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法提供對於所有其他類型的預設相等比較。 不過，型別通常覆寫<xref:System.Object.Equals%2A>方法，以實作值是否相等。 如需詳細資訊，請參閱 < 附註的呼叫端和注意事項繼承者區段。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>附註 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 當您呼叫<xref:System.Object.Equals%28System.Object%29>中之類別的方法多載[!INCLUDE[wrt](~/includes/wrt-md.md)]，它提供的預設行為不覆寫的類別<xref:System.Object.Equals%28System.Object%29>。 這是.NET Framework 所提供的支援[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱[.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且不要只實作目前<xref:System.Object.Equals%28System.Object%29>方法。 不過，它們便會顯示有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>時您用於您的 C# 或 Visual Basic 程式碼，以及.NET Framework 提供的預設行為，這些方法的方法。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.Equals%28System.Object%29>方法多載。  
  
## <a name="notes-for-callers"></a>呼叫端資訊  
 經常衍生的類別覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，以實作值是否相等。 此外，型別也經常會提供額外的強型別多載來`Equals`方法，通常是藉由實作<xref:System.IEquatable%601>介面。 當您呼叫`Equals`方法來測試是否相等，您應該知道是否會覆寫目前的執行個體<xref:System.Object.Equals%2A?displayProperty=nameWithType>並了解如何在特定呼叫`Equals`方法已解決。 否則，您可能執行的測試相等，不同於您想要的結果，而且方法可能會傳回非預期的值。  
  
 下列範例提供一個實例。 它會具現化三個<xref:System.Text.StringBuilder>物件與相同的字串，並接著四個呼叫`Equals`方法。 第一個方法呼叫傳回`true`，和剩餘的三個傳回`false`。  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 在第一個案例中，強型別<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>方法多載，測試值是否相等，會呼叫。 因為字串指派給這兩個<xref:System.Text.StringBuilder>物件是否相等，則方法會傳回`true`。 不過，<xref:System.Text.StringBuilder>不會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。 因為這個緣故時,<xref:System.Text.StringBuilder>物件轉換成<xref:System.Object>，當<xref:System.Text.StringBuilder>執行個體指派給變數的型別<xref:System.Object>，和當<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>方法會傳遞兩個<xref:System.Text.StringBuilder>的物件，預設值<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法呼叫。 因為<xref:System.Text.StringBuilder>是參考類型，這相當於傳遞兩個<xref:System.Text.StringBuilder>物件加入至<xref:System.Object.ReferenceEquals%2A>方法。 雖然這三個<xref:System.Text.StringBuilder>物件包含完全相同的字串，它們會參考至三個相異的物件。 如此一來，這些三個方法呼叫傳回`false`。  
  
 您可以藉由呼叫比較目前物件與另一個物件的參考相等性<xref:System.Object.ReferenceEquals%2A>方法。 在 Visual Basic 中，您也可以使用`is`關鍵字 (例如， `If Me Is otherObject Then ...`)。  
  
## <a name="notes-for-inheritors"></a>繼承者注意事項  
 當您定義自己的型別時，該類型繼承所定義的功能`Equals`其基底型別的方法。 下表列出的預設實作`Equals`方法在.NET Framework 類型的主要類別。  
  
|型別分類|所定義的相等|註解|  
|-------------------|-------------------------|--------------|  
|直接衍生自類別 <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|參考相等。相當於呼叫<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>。|  
|結構|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|值相等。直接位元組的比較或欄位的欄位比較使用反映。|  
|列舉|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|值必須有相同的列舉類型與相同的基礎值。|  
|Delegate - 委派|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|委派必須具有相同的引動過程清單的相同類型。|  
|介面|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|參考相等。|  
  
 對於實值類型，您應該一律覆寫<xref:System.Object.Equals%2A>，因為依賴反映的等號比較測試會提供效能不佳。 您也可以覆寫的預設實作<xref:System.Object.Equals%2A>參考類型的值是否相等，而不是參考相等測試，以及定義精確意義的值是否相等。 這類實作<xref:System.Object.Equals%2A>傳回`true`如果兩個物件擁有相同的值，即使它們不是相同的執行個體。 型別實作器決定何者構成物件的值，但是它通常是部分或所有儲存的資料物件的執行個體變數中。 例如，值<xref:System.String>物件為基礎的字元字串;<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>方法覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法以傳回`true`任何兩個字串含有相同的順序中的相同字元的執行個體。  
  
 下列範例示範如何覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法來測試值是否相等。 它會覆寫<xref:System.Object.Equals%2A>方法`Person`類別。 如果`Person`接受等號比較、 其基底類別實作兩個`Person`會等於只有當參考單一物件，這些物件。 不過，在此情況下，兩個`Person`物件是否相等，如果它們有相同的值`Person.Id`屬性。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 除了覆寫<xref:System.Object.Equals%2A>，您可以實作<xref:System.IEquatable%601>介面，以提供強型別的測試是否相等。  
  
 下列陳述式必須為 true 的所有實作<xref:System.Object.Equals%28System.Object%29>方法。 在清單中， `x`， `y`，和`z`代表物件參考未**null**。  
  
-   `x.Equals(x)` 傳回`true`，除非在涉及浮點類型的情況下。 請參閱 ISO/IEC/IEEE 60559:2011，資訊技術-微處理器系統-浮點算術。  
  
-   `x.Equals(y)` 傳回相同的值做為`y.Equals(x)`。  
  
-   `x.Equals(y)` 傳回`true`如果兩個`x`和`y`是`NaN`。  
  
-   如果`(x.Equals(y) && y.Equals(z))`傳回`true`，然後`x.Equals(z)`傳回`true`。  
  
-   後續呼叫`x.Equals(y)`傳回相同的值，只要參考的物件`x`和`y`不會修改。  
  
-   `x.Equals(null)` 會傳回 `false`。  
  
 實作<xref:System.Object.Equals%2A>必須不會擲回例外狀況，他們應該一律會傳回的值。 例如，如果`obj`是`null`、<xref:System.Object.Equals%2A>方法應傳回`false`而不是擲回<xref:System.ArgumentNullException>。  
  
 覆寫時，請遵循下列方針<xref:System.Object.Equals%28System.Object%29>:  
  
-   型別都會實作<xref:System.IComparable>必須覆寫<xref:System.Object.Equals%28System.Object%29>。  
  
-   類型覆寫<xref:System.Object.Equals%28System.Object%29>也必須覆寫<xref:System.Object.GetHashCode%2A>，否則雜湊表可能無法正常運作。  
  
-   您應該考慮實作<xref:System.IEquatable%601>介面，以支援強型別測試是否相等。 您<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>實作應該傳回一致的結果<xref:System.Object.Equals%2A>。  
  
-   如果您的程式語言支援運算子多載，而且您多載等號比較運算子，針對指定的型別，您也必須覆寫<xref:System.Object.Equals%28System.Object%29>方法以傳回與等號比較運算子相同的結果。 這有助於確保會使用該類別程式庫程式碼<xref:System.Object.Equals%2A>(例如<xref:System.Collections.ArrayList>和<xref:System.Collections.Hashtable>) 行為與等號比較運算子由應用程式程式碼的方式一致的方式。  
  
### <a name="guidelines-for-reference-types"></a>參考類型的指導方針  
 下列指導方針適用於覆寫<xref:System.Object.Equals%28System.Object%29>是參考型別：  
  
-   請考慮覆寫<xref:System.Object.Equals%2A>如果類型的語意是基礎類型所代表的某些值為基礎。  
  
-   大部分的參考型別必須多載等號比較運算子，即使它們覆寫<xref:System.Object.Equals%2A>。 不過，如果您實作的參考類型，這是具有實值語意，例如複數類型，您必須覆寫等號比較運算子。  
  
-   您不應覆寫<xref:System.Object.Equals%2A>可變動參考類型上。 這是因為覆寫<xref:System.Object.Equals%2A>需要，您也會覆寫<xref:System.Object.GetHashCode%2A>方法，如前一節中討論。 這表示可變動參考類型的執行個體的雜湊程式碼可以在其生命週期，這可能導致遺失物件雜湊表中變更。  
  
### <a name="guidelines-for-value-types"></a>實值類型的指導方針  
 下列指導方針適用於覆寫<xref:System.Object.Equals%28System.Object%29>的實值類型：  
  
-   如果您要定義實值型別，其中包含一個或多個欄位的值是參考類型，您應該覆寫<xref:System.Object.Equals%28System.Object%29>。 <xref:System.Object.Equals%28System.Object%29>提供實作<xref:System.ValueType>執行位元組的比較的值類型欄位所有實值類型，但它會使用反映來執行其欄位包含參考類型的實值類型欄位的欄位比較。  
  
-   如果您覆寫<xref:System.Object.Equals%2A>和您的開發語言支援運算子多載，您必須多載等號比較運算子。  
  
-   您應該實作<xref:System.IEquatable%601>介面。 呼叫的強型別<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法可以避免 boxing`obj`引數。  
  
   
  
## Examples  
 下列範例所示`Point`類別會覆寫<xref:System.Object.Equals%2A>方法以提供實值相等和`Point3D`類別衍生自`Point`。 因為`Point`會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>來測試值是否相等，<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>不會呼叫方法。 不過，`Point3D.Equals`呼叫`Point.Equals`因為`Point`實作<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方式提供值是否相等。  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals`方法會檢查並確定`obj`引數不是**null**並且會參考與此物件相同類型的執行個體。 如果其中一個檢查失敗，則方法會傳回`false`。  
  
 `Point.Equals`方法呼叫<xref:System.Object.GetType%2A>方法，以判斷兩個物件的執行階段類型是否相同。 如果此方法使用表單的核取`obj is Point`在 C# 或`TryCast(obj, Point)`在 Visual Basic 中，會傳回核取`true`萬一其中`obj`的衍生類別的執行個體`Point`，即使`obj`和目前執行個體不是相同的執行階段類型。 確認兩個物件都屬於相同類型，方法轉換`obj`輸入`Point`並傳回比較兩個物件的執行個體欄位的結果。  
  
 在`Point3D.Equals`，繼承`Point.Equals`方法，它會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>，任何其他項目完成之前，會叫用。 因為`Point3D`是密封的類別 (`NotInheritable`在 Visual Basic 中)，在表單中的核取`obj is Point`在 C# 或`TryCast(obj, Point)`在 Visual Basic 中是以確保足夠`obj`是`Point3D`物件。 如果是`Point3D`物件，它會轉換為`Point`物件，並傳遞至基底類別實作<xref:System.Object.Equals%2A>。 只有當繼承`Point.Equals`方法會傳回`true`未方法比較`z`執行個體導入衍生類別中的欄位。  
  
 下列範例會定義`Rectangle`類別，以在內部實作做為兩個矩形`Point`物件。 `Rectangle`類別也會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供的值是否相等。  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 某些語言，例如 C# 和 Visual Basic 支援運算子多載。 當類型多載等號比較運算子時，它也必須覆寫<xref:System.Object.Equals%28System.Object%29>方法以提供相同的功能。 這通常會透過撰寫<xref:System.Object.Equals%28System.Object%29>方面的多載等號比較運算子，如下列範例所示的方法。  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 因為`Complex`是實值類型，不能衍生自。  因此，若要覆寫<xref:System.Object.Equals%28System.Object%29>方法實作不需要呼叫<xref:System.Object.GetType%2A>若要判斷精確的執行階段輸入的每個物件，但改為使用`is`C# 中的運算子或`TypeOf`檢查類型的VisualBasic中的運算子`obj`參數。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比較的第一個物件。</param>
        <param name="objB">要比較的第二個物件。</param>
        <summary>判斷指定的物件執行個體是否視為相等。</summary>
        <returns>如果物件可視為相等則為 <see langword="true" />，否則為 <see langword="false" />。 如果 <paramref name="objA" /> 和 <paramref name="objB" /> 皆為 **null**，則這個方法會傳回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 靜態<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法表示兩個物件是否，`objA`和`objB`，是否相等。 它也可讓您測試其值的物件**null**是否相等。 它會比較`objA`和`objB`是否相等，如下所示：  
  
-   它會判斷兩個物件是否表示相同的物件參考。 如果沒有的話，則方法會傳回`true`。 這個測試就相當於呼叫<xref:System.Object.ReferenceEquals%2A>方法。 此外，如果這兩個`objA`和`objB`是**null**，方法會傳回`true`。  
  
-   它會判斷是否可能是`objA`或`objB`是**null**。 因此，它會傳回如果`false`。  
  
-   如果兩個物件不代表相同的物件參考，而且兩者都**null**，它會呼叫`objA`。`Equals`(`objB`)，並傳回結果。 這表示如果`objA`會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>呼叫方法，此覆寫。  
  
   
  
## Examples  
 下列範例說明<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法，並比較它與<xref:System.Object.ReferenceEquals%2A>方法。  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在記憶體回收開始前，允許物件嘗試釋放資源，並執行其他清除作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A>方法用來在終結物件之前，目前的物件所持有的 unmanaged 資源上執行清除作業。 此方法受到保護，因此只能透過這個類別或衍生類別存取。  
  
 本節內容：  
  
-   [最終處理的運作方式](#How)  
  
-   [實作者注意事項](#Notes)  
  
-   [SafeHandle 替代方法](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>最終處理的運作方式  
 <xref:System.Object>類別提供的任何實作<xref:System.Object.Finalize%2A>方法，以及記憶體回收行程不會將標示類型衍生自<xref:System.Object>進行最終處理它們會覆寫除非<xref:System.Object.Finalize%2A>方法。  
  
 如果型別沒有覆寫<xref:System.Object.Finalize%2A>方法，記憶體回收行程會將每個執行個體類型的項目加入稱為最終處理佇列的內部結構。 最終處理佇列包含 managed 堆積記憶體回收行程回收其記憶體之前，必須執行其最終處理程式碼中的所有物件的項目。 記憶體回收行程再呼叫<xref:System.Object.Finalize%2A>在下列情況下自動的方法：  
  
-   記憶體回收行程已探索物件是無法存取，除非物件已從最終處理豁免呼叫之後<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
-   在關閉應用程式定義域，除非該物件是豁免最終處理。 在關機時完成甚至仍然可以存取的物件。  
  
 <xref:System.Object.Finalize%2A> 會自動呼叫一次在給定的執行個體，除非物件已重新登錄使用一種機制，例如<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>和<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法尚未後續呼叫。  
  
 <xref:System.Object.Finalize%2A> 作業會有下列限制：  
  
-   當執行完成項的確切時間未定義。 若要確保您類別的執行個體實作的決定性的資源釋放`Close`方法，或提供<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作。  
  
-   即使一個物件參考的其他兩個物件的完成項不保證任何特定的順序執行。 也就是說，如果物件 A 有參考到物件 B，且兩者都有完成項，物件 B 可能已完成的物件的完成項開始時。  
  
-   未指定執行完成項執行緒。  
  
 <xref:System.Object.Finalize%2A>方法可能不會執行到完成為止，或可能完全無法執行下列例外狀況的情況下：  
  
-   如果另一個完成項會無限期地封鎖 （進入無限迴圈，嘗試取得的鎖定，它可能永遠不會取得，等等）。 執行階段會嘗試執行到完成的完成項，因為其他完成項可能不能呼叫完成項區塊無限期。  
  
-   如果處理序結束，而不讓執行階段有機會以清除。 在此情況下，終止處理序的執行階段的第一個通知是 DLL_PROCESS_DETACH 通知。  
  
 執行階段會在關機期間完成物件，可進行最終處理物件的數目會繼續減少時，才繼續。  
  
 如果<xref:System.Object.Finalize%2A>的覆寫或<xref:System.Object.Finalize%2A>擲回例外狀況和執行階段不會覆寫預設原則的應用程式所裝載，執行階段終止處理程序並沒有作用中`try` / `finally`區塊或會執行完成項。 此行為可確保處理程序完整性，如果完成項無法釋放或終結的資源。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>覆寫 Finalize 方法 
 您應該覆寫<xref:System.Object.Finalize%2A>類別使用 unmanaged 的資源，例如檔案控制代碼或使用它們的 managed 的物件在記憶體回收期間捨棄時必須釋放的資料庫連接。 您不應該實作<xref:System.Object.Finalize%2A>方法的 managed 物件，因為記憶體回收行程自動釋放 managed 的資源。  
  
> [!IMPORTANT]
>  如果<xref:System.Runtime.InteropServices.SafeHandle>物件可供使用，包裝您的 unmanaged 的資源，建議的替代做法是實作使用安全控制代碼的處置模式，並不會覆寫<xref:System.Object.Finalize%2A>。 如需詳細資訊，請參閱[SafeHandle 替代方法](#SafeHandle)> 一節。  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法則會根據預設，不做任何動作，但是您應該覆寫<xref:System.Object.Finalize%2A>才有必要，而且只釋放 unmanaged 的資源。 回收記憶體，會花更長時間執行最終處理作業，如果，因為它需要至少兩個記憶體回收。 此外，您應該覆寫<xref:System.Object.Finalize%2A>只有類型參考的方法。 Common language runtime 只完成參考型別。 它會忽略實值類型上的完成項。  

範圍<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法`protected`。 當您在類別中覆寫方法時，您應該維護這個限定的範圍。 會保留<xref:System.Object.Finalize%2A>受保護的方法，避免從呼叫物件的應用程式的使用者<xref:System.Object.Finalize%2A>直接的方法。
  
 每個實作<xref:System.Object.Finalize%2A>衍生類型中必須呼叫其基底類型實作<xref:System.Object.Finalize%2A>。 這是應用程式的程式碼可以呼叫的唯一情況<xref:System.Object.Finalize%2A>。 物件的<xref:System.Object.Finalize%2A>方法不應該在其基底類別以外的其他任何物件上呼叫的方法。 這是因為其他物件呼叫收集在同一時間作為呼叫物件時，例如在通用語言執行階段關機的情況下。 
  
> [!NOTE]
>  C# 編譯器不允許您覆寫<xref:System.Object.Finalize%2A>方法。 相反地，您提供完成項藉由實作[解構函式](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)為您的類別。 C# 解構函式自動呼叫其基底類別的解構函式。  
>   
>  Visual c + + 也提供自己的語法實作<xref:System.Object.Finalize%2A>方法。 如需詳細資訊，請參閱 < 解構函式和完成項 > 一節[如何： 定義和使用類別和結構 (C + + /CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)。  
  
 因為記憶體回收是不具決定性的所以您不知道記憶體回收行程執行完成時。 若要釋放資源，您也可以選擇實作[處置模式](~/docs/standard/design-guidelines/dispose-pattern.md)和<xref:System.IDisposable>介面。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作可以呼叫您類別的取用者釋放 unmanaged 的資源，而且您可以使用<xref:System.Object.Finalize%2A>方法來釋放 unmanaged 的資源的<xref:System.IDisposable.Dispose%2A>不會呼叫方法。  
  
 <xref:System.Object.Finalize%2A> 它已被清除記憶體回收期間之後，可以採取幾乎任何的動作，包括 resurrecting 物件 （也就，讓物件能夠存取一次）。 不過，此物件可以只復活一次。<xref:System.Object.Finalize%2A>無法在記憶體回收期間重新啟動的物件上呼叫。 沒有一個動作，您的實作<xref:System.Object.Finalize%2A>絕對不應該接受： 它應該絕不會擲回例外狀況。 如果已從呼叫的方法所擲回任何例外狀況<xref:System.Object.Finalize%2A>方法會處理<xref:System.Object.Finalize%2A>方法，執行階段會假設<xref:System.Object.Finalize%2A>方法傳回，並繼續呼叫<xref:System.Object.Finalize%2A>其他物件的方法。 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 替代方法  
 建立可靠的完成項通常很困難，因為您不能假設應用程式的狀態相關，而且這類未處理系統例外狀況<xref:System.OutOfMemoryException>和<xref:System.StackOverflowException>終止完成項。 而不是實作類別的完成項來釋放 unmanaged 的資源，您可以使用衍生自物件<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>類別來包裝您的 unmanaged 的資源，並再實作沒有完成項的處置模式。 .NET Framework 提供的下列類別<xref:Microsoft.Win32?displayProperty=nameWithType>衍生自命名空間<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 是的檔案控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 為記憶體對應檔案控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 是包裝函式類別的 unmanaged 記憶體區塊的指標。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle><xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>，和<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>是密碼編譯控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 是管道控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 是登錄機碼的控制代碼的包裝函式類別。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 是等候控制代碼的包裝函式類別。  
  
 下列範例會使用[處置模式](~/docs/standard/design-guidelines/dispose-pattern.md)使用安全控制代碼，而不是覆寫<xref:System.Object.Finalize%2A>方法。 它會定義`FileAssociation`包裝應用程式會處理具有特定副檔名的檔案的登錄資訊的類別。 傳回做為兩個登錄控制代碼`out`windows 參數[RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)函式呼叫會傳遞至<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>建構函式。 類型的保護，`Dispose`方法接著呼叫`SafeRegistryHandle.Dispose`方法來釋放這些兩個控點。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 下列範例會確認<xref:System.Object.Finalize%2A>呼叫方法時，會覆寫物件<xref:System.Object.Finalize%2A>終結。 請注意，在實際執行應用程式中，<xref:System.Object.Finalize%2A>會覆寫方法，以釋放這個物件所持有的 unmanaged 的資源。 也請注意，C# 範例會提供解構函式，而不是覆寫<xref:System.Object.Finalize%2A>方法。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 如需其他範例會覆寫<xref:System.Object.Finalize%2A>方法，請參閱<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>做為預設雜湊函式。</summary>
        <returns>目前物件的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雜湊程式碼是用來插入及識別雜湊為基礎的集合中的物件，例如數值<xref:System.Collections.Generic.Dictionary%602>類別<xref:System.Collections.Hashtable>類別或衍生自<xref:System.Collections.DictionaryBase>類別。 <xref:System.Object.GetHashCode%2A>方法可為需要的物件是否相等的快速檢查的演算法來提供此雜湊程式碼。  
  
> [!NOTE]
>  如需有關雜湊程式碼的雜湊表中的使用方式資訊以及一些其他的雜湊程式碼演算法，請參閱[雜湊函式](https://en.wikipedia.org/wiki/Hash_function)維基百科中的項目。  
  
 兩個物件相等的等於傳回的雜湊碼。 不過，反向並不成立： 等於雜湊程式碼不會表示物件是否相等，因為不同 （相等） 的物件可以有相同的雜湊碼。 此外，.NET Framework 並不保證的預設實作<xref:System.Object.GetHashCode%2A>方法，以及這個方法會傳回可能不同.NET Framework 版本與平台，例如 32 位元和 64 位元平台之間的值。 基於這些理由，請勿使用這個方法的預設實作做為唯一物件識別項進行雜湊。 從這個，請依照下列兩種結果：  
  
-   您不應該假設等於雜湊程式碼表示物件是否相等。  
  
-   您應該永遠不會保存，或使用雜湊程式碼中建立的應用程式定義域之外，因為相同的物件可能會跨應用程式定義域、 處理程序和平台的雜湊。  
  
> [!WARNING]
>  雜湊程式碼僅供有效率的插入和雜湊資料表為基礎的集合中的查閱。 雜湊程式碼不是永久的值。 基於此理由：  
>   
>  -   請勿將序列化雜湊碼值或將它們儲存在資料庫中。  
> -   請勿從索引鍵的集合中擷取物件中使用索引鍵的雜湊碼。  
> -   不要跨應用程式定義域或處理程序傳送雜湊碼。 在某些情況下，雜湊程式碼可能會針對每個處理程序或每個應用程式網域的計算。  
> -   請勿使用雜湊程式碼而不是如果您需要的密碼編譯強式雜湊，密碼編譯雜湊函式所傳回的值。 密碼編譯雜湊，若為使用衍生自類別<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>類別。  
> -   不會測試相等的雜湊程式碼，以判斷兩個物件是否相等。 （不相等的物件可以有相同的雜湊程式碼）。若要測試是否相等，請呼叫<xref:System.Object.ReferenceEquals%2A>或<xref:System.Object.Equals%2A>方法。  
  
 <xref:System.Object.GetHashCode%2A>衍生型別可覆寫方法。 如果<xref:System.Object.GetHashCode%2A>是未覆寫，雜湊程式碼的參考型別會藉由呼叫計算<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>基底類別，用來計算雜湊程式碼的方法基礎上物件的參考; 如需詳細資訊，請參閱<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。 換句話說，兩個物件的<xref:System.Object.ReferenceEquals%2A>方法會傳回`true`有相同的雜湊程式碼。 如果實值類型不會覆寫<xref:System.Object.GetHashCode%2A>、<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>基底類別方法會使用反映來計算基礎類型的欄位值的雜湊碼。 換句話說，其欄位具有相等值的實值型別具有相等的雜湊碼。 如需有關覆寫<xref:System.Object.GetHashCode%2A>，請參閱 「 附註繼承者 」 一節。  
  
> [!WARNING]
>  如果您覆寫<xref:System.Object.GetHashCode%2A>方法，您也應該覆寫<xref:System.Object.Equals%2A>，反之亦然。 如果您覆寫<xref:System.Object.Equals%2A>方法會傳回`true`兩個物件是否相等，您覆寫進行測試<xref:System.Object.GetHashCode%2A>方法必須傳回相同值的兩個物件。  
  
 如果當做索引鍵使用雜湊表中的物件不提供的有用實作<xref:System.Object.GetHashCode%2A>，您可以指定雜湊碼提供者藉由提供<xref:System.Collections.IEqualityComparer>至其中的多載實作<xref:System.Collections.Hashtable>類別建構函式。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>附註 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 當您呼叫<xref:System.Object.GetHashCode%2A>中之類別的方法[!INCLUDE[wrt](~/includes/wrt-md.md)]，它提供的預設行為不覆寫的類別<xref:System.Object.GetHashCode%2A>。 這是.NET Framework 所提供的支援[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱[.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且不要只實作目前<xref:System.Object.GetHashCode%2A>。 不過，它們便會顯示有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>時您用於您的 C# 或 Visual Basic 程式碼，以及.NET Framework 提供的預設行為，這些方法的方法。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.GetHashCode%2A>方法。  
  
   
  
## Examples  
 其中一種簡單的方式來計算數值的值具有相同或較小的範圍比雜湊碼<xref:System.Int32>就只會傳回該值為型別。 下列範例示範這類實作`Number`結構。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 通常，型別具有可以參與產生雜湊程式碼的多個資料欄位。 若要產生的雜湊碼的一種方式為結合使用這些欄位`XOR (eXclusive OR)`作業，如下列範例所示。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前一個範例會傳回相同的雜湊程式碼 (n1，n2) 和 (n2 n1)，，因此可能會產生較多超過為想要的衝突。 幾個解決方案可用，以便在這些情況下的雜湊程式碼並不相同。 其中是要傳回的雜湊碼`Tuple`物件，以反映每個欄位的順序。 下列範例示範可能的實作使用<xref:System.Tuple%602>類別。 不過請注意，具現化的效能負荷`Tuple`物件可能會大幅影響將大量的物件儲存雜湊資料表中的應用程式的整體效能。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 第二個替代方案牽涉到由左移位連續欄位的雜湊碼由兩個或多個位元加權個別的雜湊碼。 以最佳方式，而不是被捨棄，超過 31 位元移位的位元應該圍繞而不會被捨棄。 位元左移位運算子在 C# 和 Visual Basic 中捨棄，因為您需要建立左的 shift 包裝方法如下所示：  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 下列範例接著會使用這個 shift 包裝方法來計算的雜湊碼`Point`前一個範例中使用的結構。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>雜湊函式用來快速產生數字 （雜湊程式碼），會對應至物件的值。雜湊函式通常是每個類型，和唯一性，必須使用至少其中一個執行個體欄位做為輸入。使用靜態欄位的值不應該計算雜湊碼。類別衍生自<see cref="T:System.Object" />、<see langword="GetHashCode" />方法可以委派給基底類別<see cref="M:System.Object.GetHashCode" />衍生的類別定義會參考相等的等號時，才實作。預設實作<see cref="M:System.Object.GetHashCode" />參考型別會傳回相當於所傳回的雜湊碼<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />方法。您可以覆寫<see cref="M:System.Object.GetHashCode" />不可變的參考類型。一般情況下，對於可變動參考類型，您應該覆寫<see cref="M:System.Object.GetHashCode" />才:-您可以計算出雜湊中的程式碼不是可變動; 的欄位或-您可以確保可變動物件的雜湊程式碼不會變更而物件會包含在 collecti上，依賴其雜湊碼。否則，您可能會認為可變動物件將會遺失雜湊表中。如果您選擇要覆寫<see cref="M:System.Object.GetHashCode" />對於可變動參考類型，您的文件應該解釋清楚的使用者，您的型別不應修改物件值，而此物件會儲存雜湊表中。對於實值類型<see cref="M:System.ValueType.GetHashCode" />提供使用反映的預設雜湊程式碼實作。您應該考慮加以覆寫以提升效能。<block subset="none" type="note"><para> 如需詳細資訊和範例，計算雜湊碼的各種不同的方式，請參閱 &lt; 範例 &gt; 一節。</para></block>  雜湊函式必須具有下列屬性:-如果兩個物件比較結果為相等，<see cref="M:System.Object.GetHashCode" />每個物件的方法必須傳回相同的值。不過，如果兩個物件不會比較為相等，<see cref="M:System.Object.GetHashCode" />兩個物件的方法沒有傳回不同的值。 -<see cref="M:System.Object.GetHashCode" />物件方法必須一致地傳回相同雜湊碼，只要未修改的物件狀態，決定傳回值物件之 [System.Object.Equals](xref:System.Object.Equals*) 方法。請注意這是僅針對目前執行的應用程式，則為 true，如果再次執行應用程式，可能會傳回不同的雜湊程式碼。 -針對最佳效能，雜湊函式應該產生所有輸入，包括大量已叢集化的輸入是平均的分配。含意為，小型修改物件的狀態應該會導致大型修改產生的雜湊程式碼中，為了達到最佳的雜湊表效能。 雜湊函式應該計算耗費大量資源。 -<see cref="M:System.Object.GetHashCode" />方法不可擲回例外狀況。例如，實作<see cref="M:System.String.GetHashCode" />所提供的方法<see cref="T:System.String" />類別會傳回相同的字串值相同的雜湊碼。因此，兩個<see cref="T:System.String" />物件傳回相同的雜湊程式碼，如果它們代表相同的字串值。此外，此方法會使用的所有字元在字串中產生合理隨機散發的輸出，即使輸入叢集在特定範圍 (例如，許多使用者可能只包含較低 128 ASCII 字元，即使的字串字串可以包含任何 65,535 的 Unicode 字元）。提供良好的雜湊函式的類別上會大幅影響將這些物件加入至雜湊表的效能。在提供良好的雜湊函式實作的索引鍵的雜湊資料表中，搜尋項目會常數 （例如，一種 o （1） 運算） 的時間。具有不佳函式實作的雜湊的雜湊資料表，搜尋的效能取決於雜湊表中的項目數目 (例如，若為 O('n') 作業，其中 'n' 雜湊表中的項目數目是)。惡意使用者可以輸入資料，從而發生衝突，可能會大幅降低雜湊表，在下列情況下所取決的應用程式的效能數:-當雜湊函式會產生頻繁的衝突。 -當大比例的雜湊表中的物件產生的相等或大約等於另一個雜湊碼。 -當使用者輸入的雜湊程式碼會計算的資料。在衍生類別覆寫<see cref="M:System.Object.GetHashCode" />也必須覆寫<see cref="M:System.Object.Equals(System.Object)" />保證會被視為相等的兩個物件具有相同的雜湊程式碼; 否則<see cref="T:System.Collections.Hashtable" />類型可能無法正常運作。</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前執行個體的 <see cref="T:System.Type" />。</summary>
        <returns>目前執行個體的確切執行階段類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為<xref:System.Object?displayProperty=nameWithType>在.NET Framework 類型系統中，為所有類型的基底類別<xref:System.Object.GetType%2A>方法可以用來傳回<xref:System.Type>代表所有.NET Framework 類型的物件。 .NET Framework 可辨識下列五種類型：  
  
-   類別，衍生自<xref:System.Object?displayProperty=nameWithType>，  
  
-   實值類型，衍生自<xref:System.ValueType?displayProperty=nameWithType>。  
  
-   介面，衍生自<xref:System.Object?displayProperty=nameWithType>從.NET Framework 2.0 開始。  
  
-   列舉型別，衍生自<xref:System.Enum?displayProperty=nameWithType>。  
  
-   委派，衍生自<xref:System.MulticastDelegate?displayProperty=nameWithType>。  
  
 兩個物件`x`和`y`具有相同的執行階段類型`Object.ReferenceEquals(x.GetType(),y.GetType())`傳回`true`。 下列範例會使用<xref:System.Object.GetType%2A>方法<xref:System.Object.ReferenceEquals%2A>方法，以判斷兩個數值是否為兩個其他數字的值相同的型別。  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  若要判斷物件是否為特定的型別，您可以使用您語言的型別比較關鍵字，或建構。 例如，您可以使用`TypeOf…Is`在 Visual Basic 中建構或`is`C# 中的關鍵字。  
  
 <xref:System.Object.GetType%2A>方法繼承自所有型別衍生自<xref:System.Object>。 這表示，除了使用您自己的語言比較關鍵字，您可以使用<xref:System.Object.GetType%2A>方法，以判斷特定物件的類型，如下列範例所示。  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type>物件會公開與目前的類別相關聯的中繼資料<xref:System.Object>。  
  
   
  
## Examples  
 下列程式碼範例會示範<xref:System.Object.GetType%2A>傳回目前執行個體的執行階段類型。  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立目前 <see cref="T:System.Object" /> 的淺層複製。</summary>
        <returns>目前 <see cref="T:System.Object" /> 的淺層複製。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A>方法建立新的物件，並再將目前物件的非靜態欄位複製到新的物件建立淺層複本。 如果欄位是實值類型，則會執行位元欄位的複本。 如果欄位是參考類型，則會複製參考，但參考的物件不;因此，原始的物件和其複製參考相同的物件。  
  
 例如，請考慮 x 依次參考物件 A 和 B 參考物件 c。X 的淺層複本建立新的物件 X2 參考物件 A 和 b。相反地，X 的深層複本建立新物件 X2 A2 與 B2 a 的新物件和 B.B2 參考新物件 C2，也就是一份 c。此範例說明 shallow 和深層複製作業之間的差異。  
  
 透過深層複製作業，實作時所執行的淺層複製作業的許多方式<xref:System.Object.MemberwiseClone%2A>方法不符合您的需求。 這些需求包括下列各項：  
  
-   呼叫類別建構函式要複製到取自第一個物件的屬性值建立第二個物件的物件。 這是假設物件的值會完全由其類別建構函式。  
  
-   呼叫<xref:System.Object.MemberwiseClone%2A>方法來建立物件的淺層複本，並將指派其值為與原始物件的任何屬性或欄位的值是參考型別相同的新物件。 `DeepCopy`方法在此範例將示範這個方法。  
  
-   序列化物件變成深層複製，，然後還原序列化的資料至不同的物件變數。  
  
-   使用反映遞迴時，以執行深層複製作業。  
  
   
  
## Examples  
 下列範例說明<xref:System.Object.MemberwiseClone%2A>方法。 它會定義`ShallowCopy`方法呼叫<xref:System.Object.MemberwiseClone%2A>方法上執行的淺層複製作業`Person`物件。 它也會定義`DeepCopy`執行深層複製作業的方法`Person`物件。  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 在此範例中，`Person.IdInfo`屬性會傳回`IdInfo`物件。 做為範例所示，從輸出時`Person`物件會藉由呼叫複製<xref:System.Object.MemberwiseClone%2A>方法中，複製`Person`物件是原始物件的獨立複本，不同之處在於它們共用相同`Person.IdInfo`物件參考。 如此一來，修改複製品的`Person.IdInfo`屬性變更的原始物件`Person.IdInfo`屬性。 相反地，深層複製作業執行時，複製`Person`物件，包括其`Person.IdInfo`屬性，可以修改而不會影響原始物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比較的第一個物件。</param>
        <param name="objB">要比較的第二個物件。</param>
        <summary>判斷指定的 <see cref="T:System.Object" /> 執行個體是否為相同的執行個體。</summary>
        <returns>如果 <paramref name="objA" /> 與 <paramref name="objB" /> 為相同的執行個體或兩者皆為 **null**，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Object.Equals%2A>方法和等號比較運算子，<xref:System.Object.ReferenceEquals%2A>無法覆寫方法。 因為這個緣故，如果您想要測試兩個物件是否相等的參考，您不確定的實作`Equals`方法，您可以呼叫<xref:System.Object.ReferenceEquals%2A>方法。  
  
 不過，傳回值<xref:System.Object.ReferenceEquals%2A>方法可能會出現在這兩個案例中的異常：  
  
-   比較值的類型。 如果`objA`和`objB`為實值類型傳遞至之前 boxing 處理<xref:System.Object.ReferenceEquals%2A>方法。 這表示，如果這兩個`objA`和`objB`代表相同的執行個體的實值類型，<xref:System.Object.ReferenceEquals%2A>方法卻傳回`false`，如下列範例所示。  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Boxing 實值型別資訊，請參閱[Boxing 和 Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)。  
  
-   當比較字串。 如果`objA`和`objB`是字串，<xref:System.Object.ReferenceEquals%2A>方法會傳回`true`如果實習的字串。 它不會執行測試的值相等。  在下列範例中，`s1`和`s2`相等，因為它們是兩個執行個體已經保留的單一字串。 不過，`s3`和`s4`不相等，因為雖然它們有相同的字串值時，該字串未被保留了。  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     如需有關字串拘留的詳細資訊，請參閱<xref:System.String.IsInterned%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Object.ReferenceEquals%2A>來判斷兩個物件是否相同的執行個體。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回代表目前物件的字串。</summary>
        <returns>表示目前物件的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 主要格式在.NET Framework 中的方法。 它將物件轉換為其字串表示，因此適合顯示。 (如需格式在.NET Framework 的支援資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。)預設實作<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法傳回的物件類型的完整的名稱。  
  
> [!IMPORTANT]
>  您可能會到達此頁面由另一種類型的成員清單中的下列連結。 這是因為該類型不會覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>。 相反地，它所繼承的功能<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
 型別經常覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以提供更適合的字串表示，特定的型別。 型別也經常多載<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以支援的格式字串，或區分文化特性的格式。  
  
 本節內容：  
  
 [預設 object.tostring （） 方法](#Default)   
 [覆寫 object.tostring （） 方法](#Overriding)   
 [ToString 方法多載化](#Overloading)   
 [擴充 Object.ToString 方法](#Extending)   
 [Windows 執行階段資訊](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>預設 object.tostring （） 方法  
 預設實作<xref:System.Object.ToString%2A>方法會傳回型別的完整格式的名稱<xref:System.Object>，如下列範例所示。  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 因為<xref:System.Object>的基底類別的所有參考型別在.NET Framework 中，此行為由參考型別，不會覆寫繼承<xref:System.Object.ToString%2A>方法。 下列範例將說明這點。 它會定義名為類別`Object1`接受所有的預設實作<xref:System.Object>成員。 其<xref:System.Object.ToString%2A>方法會傳回物件的完整限定的類型名稱。  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>覆寫 object.tostring （） 方法  
 型別通常覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以傳回字串，表示物件執行個體。 例如，基底類型例如<xref:System.Char>， <xref:System.Int32>，和<xref:System.String>提供<xref:System.Object.ToString%2A>傳回物件所代表之值的字串形式的實作。 下列範例會定義一個類別， `Object2`，會覆寫<xref:System.Object.ToString%2A>方法以傳回型別名稱與其值。  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 下表列出.NET Framework 中的類型分類，並指出是否它們會覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
|型別分類|覆寫 object.tostring （)|行為|  
|-------------------|-----------------------------------|--------------|  
|類別|N/A|N/A|  
|結構|是 (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|相同 object.tostring （）|  
|列舉|是 (<xref:System.Enum.ToString?displayProperty=nameWithType>)|成員名稱|  
|介面|否|N/A|  
|Delegate - 委派|否|N/A|  
  
 請參閱注意事項繼承者注意事項 > 一節，如需詳細資訊，覆寫<xref:System.Object.ToString%2A>。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>ToString 方法多載化  
 除了覆寫的無參數<xref:System.Object.ToString?displayProperty=nameWithType>方法中，許多型別多載`ToString`方法以提供方法的接受參數的版本。 大多數情況下，這是為了提供變數的格式和文化特性格式的支援。  
  
 下列範例會多載`ToString`方法以傳回結果字串，其中包含的各種欄位的值`Automobile`類別。 它會定義四個格式字串： G，會傳回年度，則與模型名稱D，傳回模型名稱、 年和的門。C，傳回模型名稱、 年份和數目的磁柱;和 A，它會傳回所有的四個欄位值的字串。  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 下列範例會呼叫多載<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法來顯示文化特性的貨幣值的格式。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 如需有關格式字串和文化特性格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。 支援的數值格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 支援的日期和時間值的格式字串，請參閱[標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>擴充 Object.ToString 方法  
 因為類型會繼承預設<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，您可能會尋找其行為不想要並想要進行變更。 特別是陣列和集合類別。 雖然您可能預期`ToString`方法来顯示其成員的值陣列或集合類別，它改為顯示類型的完整限定的類型名稱，如下列範例所示。  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 您有數個選項，以產生您想要的結果字串。  
  
-   如果類型是陣列、 集合物件或該物件會實作<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>介面，您可以使用列舉其項目`foreach`C# 中的陳述式或`For Each...Next`在 Visual Basic 中建構。  
  
-   如果類別不是`sealed`（C# 中） 或`NotInheritable`（在 Visual Basic 中)，您可以開發其繼承自基底類別的包裝函數類別<xref:System.Object.ToString%2A?displayProperty=nameWithType>您想要自訂的方法。 最小，這需要您下列：  
  
    1.  實作任何必要的建構函式。 在衍生的類別不會繼承其基底類別建構函式。  
  
    2.  覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以傳回您想要的結果字串。  
  
     下列範例定義的包裝函式類別<xref:System.Collections.Generic.List%601>類別。 它會覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以顯示每個方法的集合，而不是完整限定的類型名稱的值。  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   開發[擴充方法](~/docs/standard/design-guidelines/extension-methods.md)傳回您想要的結果字串。 請注意，您無法覆寫預設<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以這種方式 (也就是您的延伸模組類別 （C# 中） 或 （在 Visual Basic) 的模組不能有無參數方法，名為`ToString`，而呼叫取代原始型別`ToString`方法. 您必須提供其他的名稱為您的無參數`ToString`取代。  
  
     下列範例會定義兩個方法來擴充<xref:System.Collections.Generic.List%601>類別： 無參數`ToString2`方法，和`ToString`方法<xref:System.String>表示的格式字串參數。  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>附註 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 當您呼叫<xref:System.Object.ToString%2A>中之類別的方法[!INCLUDE[wrt](~/includes/wrt-md.md)]，它提供的預設行為不覆寫的類別<xref:System.Object.ToString%2A>。 這是.NET Framework 所提供的支援[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱[.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且永遠不要只實作<xref:System.Object.ToString%2A>。 不過，它們一定會顯示有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法，當您在您的 C# 或 Visual Basic 程式碼，使用與.NET Framework 會提供這些方法中的預設行為。  
  
 從開始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，common language runtime 會使用[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)上[!INCLUDE[wrt](~/includes/wrt-md.md)]物件的預設實作回到之前<xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.ToString%2A>方法。  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)]和 IStringable 介面  
 從開始[!INCLUDE[win81](~/includes/win81-md.md)]、[!INCLUDE[wrt](~/includes/wrt-md.md)]包含[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面方法[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)，提供基本格式支援的比較所提供<xref:System.Object.ToString%2A?displayProperty=nameWithType>。 若要避免模稜兩可，您不應該實作[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) managed 類型上。  
  
 當受管理的物件稱為原生程式碼或程式碼撰寫語言，例如 JavaScript 或 C + + /CX 中，它們會顯示實作[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。 Common language runtime 會自動路由傳送來自呼叫[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)至<xref:System.Object.ToString%2A?displayProperty=nameWithType>在事件[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)未實作在 managed 物件上。  
  
> [!WARNING]
>  因為 common language runtime 自動實作[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)所有管理中的型別[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]應用程式中，我們建議您，您不會提供您自己[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)實作。 實作[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)呼叫時，可能會導致非預期的行為`ToString`從[!INCLUDE[wrt](~/includes/wrt-md.md)]、 C + + /CX 中或 JavaScript。  
  
 如果您選擇實作[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)中匯出的公用 managed 類型中[!INCLUDE[wrt](~/includes/wrt-md.md)]元件，請套用下列限制：  
  
-   您可以定義[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面只能在 「 類別實作 」 關聯性，例如  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     在 C# 中，或  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     在 Visual Basic 中。  
  
-   您不能實作[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面上。  
  
-   您無法為型別參數宣告[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)不能是方法、 屬性或欄位的傳回型別。  
  
-   您無法隱藏您[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)從使用如下所示的方法定義的基底類別的實作：  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     相反地， [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)實作一律必須覆寫基底類別實作。 您只能藉由針對強型別類別執行個體叫用 `ToString` 實作來隱藏該實作。  
  
 請注意，在各種不同的條件，從原生程式碼來實作的 managed 類型[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)或隱藏其[ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)實作可能會產生非預期的行為。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當您實作您自己的類型時，您應該覆寫<see cref="M:System.Object.ToString" />方法傳回對這些類型有意義的值。在衍生類別需要更多控制的格式比<see cref="M:System.Object.ToString" />提供可實作<see cref="T:System.IFormattable" />介面。其<see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />方法可讓您定義控制格式的格式字串，並使用<see cref="T:System.IFormatProvider" />可以提供特定文化特性格式化的物件。覆寫的<see cref="M:System.Object.ToString" />方法應該遵循這些指導方針:-友善且由人類可讀取，應傳回的字串。 -傳回的字串應專門用於識別物件的執行個體的值。 -傳回的字串應該越短越好，使其適用於偵錯工具顯示。 -您<see cref="M:System.Object.ToString" />覆寫不應該傳回<see cref="F:System.String.Empty" />或 null 字串。 -您<see cref="M:System.Object.ToString" />覆寫應該不會擲回例外狀況。 -如果執行個體的字串表示區分文化特性，或可以多種方式進行格式化，實作<see cref="T:System.IFormattable" />介面。 -如果傳回的字串包含機密資訊，您應該先要求適當的權限。如果要求成功，您可以傳回的敏感資訊。否則，您應該會傳回不包含機密資訊的字串。 -您<see cref="M:System.Object.ToString" />覆寫應具有任何副作用若要避免在偵錯的複雜性。例如，若要呼叫<see cref="M:System.Object.ToString" />方法不應該變更的執行個體欄位的值。 -如果您的型別所實作之剖析方法 (或<see langword="Parse" />或<see langword="TryParse" />方法、 建構函式或某些其他靜態方法，會具現化的類型從字串的執行個體)，您應該確保所傳回的字串<see cref="M:System.Object.ToString" />方法可以是轉換成物件執行個體。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>