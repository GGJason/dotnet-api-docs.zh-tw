<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Object.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07da621eb36bda643f3e0a1e5b1a3ef53120877ab9.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da621eb36bda643f3e0a1e5b1a3ef53120877ab9</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</source>
          <target state="translated">支援 .NET Framework 類別階層架構中的所有類別，提供衍生類別的低階服務。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</source>
          <target state="translated">這是 .NET Framework 中所有類別的超基底類別，是類別階層架構的根。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Languages typically do not require a class to declare inheritance from <ph id="ph1">&lt;xref:System.Object&gt;</ph> because the inheritance is implicit.</source>
          <target state="translated">語言通常不需要宣告繼承自一個類別<ph id="ph1">&lt;xref:System.Object&gt;</ph>因為繼承是隱含的。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Because all classes in the .NET Framework are derived from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, every method defined in the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class is available in all objects in the system.</source>
          <target state="translated">因為.NET Framework 中的所有類別都衍生自<ph id="ph1">&lt;xref:System.Object&gt;</ph>，每個方法中定義<ph id="ph2">&lt;xref:System.Object&gt;</ph>類別系統中是可用於所有物件。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Derived classes can and do override some of these methods, including:</source>
          <target state="translated">衍生類別可以和覆寫某些方法，包括：</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> - Supports comparisons between objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> -支援物件之間的比較。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> - Performs cleanup operations before an object is automatically reclaimed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> -自動收回物件前，請執行清除作業。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> - Generates a number corresponding to the value of the object to support the use of a hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> 產生的數字對應到物件的值以支援雜湊資料表的使用。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> - Manufactures a human-readable text string that describes an instance of the class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> -製造人類看得懂的文字字串描述類別的執行個體。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Performance Considerations</source>
          <target state="translated">效能考量</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">如果您正在設計的類別，例如集合，必須處理任何類型的物件，您可以建立接受的執行個體的類別成員<ph id="ph1">&lt;xref:System.Object&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>However, the process of boxing and unboxing a type carries a performance cost.</source>
          <target state="translated">不過，boxing 和 unboxing 類型的程序會帶來效能成本。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</source>
          <target state="translated">如果您知道您的新類別會經常處理某些值類型您可以使用其中一個策略 boxing 成本降到最低。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Create a general method that accepts an <ph id="ph1">&lt;xref:System.Object&gt;</ph> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</source>
          <target state="translated">建立一般的方法可接受<ph id="ph1">&lt;xref:System.Object&gt;</ph>型別，以及一組特定類型的方法多載會接受每個您預期您經常處理的類別的實值型別。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</source>
          <target state="translated">如果特定類型的方法可接受呼叫的參數型別，就會發生任何 boxing，會叫用特定類型的方法。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</source>
          <target state="translated">如果沒有符合呼叫的參數型別沒有方法引數，參數會進行 boxed 處理，會叫用一般的方法。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Design your type and its members to use generics.</source>
          <target state="translated">設計您的類型和其成員使用泛型。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</source>
          <target state="translated">當您建立類別的執行個體，並指定泛型型別引數時，common language runtime 建立封閉泛型類型。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The generic method is type-specific and can be invoked without boxing the calling parameter.</source>
          <target state="translated">泛型方法型別而異，而且會叫用沒有 boxing 呼叫的參數。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Although it is sometimes necessary to develop general purpose classes that accept and return <ph id="ph1">&lt;xref:System.Object&gt;</ph> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</source>
          <target state="translated">雖然有時候是為了開發一般用途的類別，可接受並傳回<ph id="ph1">&lt;xref:System.Object&gt;</ph>型別，可以改善效能，也提供特定類型的類別來處理常用的型別。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</source>
          <target state="translated">例如，提供類別的特定設定和取得布林值會排除 boxing 和 unboxing 的布林值的成本。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The following example defines a Point type derived from the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class and overrides many of the virtual methods of the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">下列範例會定義衍生自點類型<ph id="ph1">&lt;xref:System.Object&gt;</ph>類別並覆寫虛擬方法的許多<ph id="ph2">&lt;xref:System.Object&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>In addition, the example shows how to call many of the static and instance methods of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">此外，此範例示範如何呼叫許多靜態和執行個體的方法<ph id="ph1">&lt;xref:System.Object&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">公用靜態 (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph>在 Visual Basic 中) 這種類型的成員都具備執行緒安全。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Instance members are not guaranteed to be thread-safe.</source>
          <target state="translated">不保證執行個體成員是安全執行緒。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Object.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.#ctor">
          <source>This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">這個建構函式會呼叫建構函式在衍生類別中，但它也可用來直接建立的執行個體<ph id="ph1">&lt;xref:System.Object&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Determines whether two object instances are equal.</source>
          <target state="translated">判斷兩個物件執行個體是否相等。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>The object to compare with the current object.</source>
          <target state="translated">要與目前物件比較的物件。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>Determines whether the specified object is equal to the current object.</source>
          <target state="translated">判斷指定的物件是否等於目前的物件。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified object  is equal to the current object; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果指定的物件等於目前的物件，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type of comparison between the current instance and the <ph id="ph1">`obj`</ph> parameter depends on whether the current instance is a reference type or a value type.</source>
          <target state="translated">比較目前的執行個體之間的類型和<ph id="ph1">`obj`</ph>參數，取決於目前的執行個體是參考類型或實值類型。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a reference type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for reference equality, and a call to the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method is equivalent to a call to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">如果目前的執行個體是參考類型，<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法測試參考是否相等，而呼叫<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法相當於呼叫<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality means that the object variables that are compared refer to the same object.</source>
          <target state="translated">參考相等，表示要比較的物件變數會參照相同的物件。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example illustrates the result of such a comparison.</source>
          <target state="translated">下列範例說明這類比較的結果。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> class, which is a reference type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1a`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">它會定義<ph id="ph1">`Person`</ph>類別，這是參考類型，並呼叫<ph id="ph2">`Person`</ph>類別建構函式來產生兩個新<ph id="ph3">`Person`</ph>物件<ph id="ph4">`person1a`</ph>和<ph id="ph5">`person2`</ph>，必須有相同的值。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It also assigns <ph id="ph1">`person1a`</ph> to another object variable, <ph id="ph2">`person1b`</ph>.</source>
          <target state="translated">它也會將指派<ph id="ph1">`person1a`</ph>給另一個物件變數， <ph id="ph2">`person1b`</ph>。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person1b`</ph> are equal because they reference the same object.</source>
          <target state="translated">做為範例所示，從輸出<ph id="ph1">`person1a`</ph>和<ph id="ph2">`person1b`</ph>相等，因為其參考相同的物件。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person2`</ph> are not equal, although they have the same value.</source>
          <target state="translated">不過，<ph id="ph1">`person1a`</ph>和<ph id="ph2">`person2`</ph>不相等，雖然它們有相同的值。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a value type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for value equality.</source>
          <target state="translated">如果目前的執行個體是實值類型，<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法測試值是否相等。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality means the following:</source>
          <target state="translated">值相等的意義如下：</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The two objects are of the same type.</source>
          <target state="translated">兩個物件都屬於相同的型別。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the following example shows, a <ph id="ph1">&lt;xref:System.Byte&gt;</ph> object that has a value of 12 does not equal an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> object that has a value of 12, because the two objects have different run-time types.</source>
          <target state="translated">如下列範例所示，<ph id="ph1">&lt;xref:System.Byte&gt;</ph>有 12 個值的物件不等於<ph id="ph2">&lt;xref:System.Int32&gt;</ph>有其值為 12，因為兩個物件具有不同的執行階段類型的物件。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The values of the public and private fields of the two objects are equal.</source>
          <target state="translated">兩個物件的公用和私用欄位的值相等。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example tests for value equality.</source>
          <target state="translated">下列範例會測試的值相等。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> structure, which is a value type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">它會定義<ph id="ph1">`Person`</ph>結構，也就是實值類型，並呼叫<ph id="ph2">`Person`</ph>類別建構函式來產生兩個新<ph id="ph3">`Person`</ph>物件<ph id="ph4">`person1`</ph>和<ph id="ph5">`person2`</ph>，必須有相同的值。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, although the two object variables refer to different objects, <ph id="ph1">`person1`</ph> and <ph id="ph2">`person2`</ph> are equal because they have the same value for the private <ph id="ph3">`personName`</ph> field.</source>
          <target state="translated">範例輸出所示，不過兩個物件變數參考不同的物件，<ph id="ph1">`person1`</ph>和<ph id="ph2">`person2`</ph>相等，因為它們具有相同的值與私人<ph id="ph3">`personName`</ph>欄位。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class is the base class for all types in the .NET Framework, the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method provides the default equality comparison for all other types.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Object&gt;</ph>類別是.NET Framework 中中的所有類型的基底類別<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法提供對於所有其他類型的預設相等比較。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, types often override the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method to implement value equality.</source>
          <target state="translated">不過，型別通常覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>方法，以實作值是否相等。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For more information, see the Notes for Callers and Notes for Inheritors sections.</source>
          <target state="translated">如需詳細資訊，請參閱 &lt; 附註的呼叫端和注意事項繼承者區段。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">附註 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">當您呼叫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>中之類別的方法多載<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>，它提供的預設行為不覆寫的類別<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">這是.NET Framework 所提供的支援<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>(請參閱<bpt id="p1">[</bpt>.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement an <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">中的類別<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>不繼承<ph id="ph2">&lt;xref:System.Object&gt;</ph>，且不要只實作目前<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">不過，它們便會顯示有<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>，和<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>時您用於您的 C# 或 Visual Basic 程式碼，以及.NET Framework 提供的預設行為，這些方法的方法。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 以 C# 或 Visual Basic 撰寫的類別可以覆寫<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法多載。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Callers</source>
          <target state="translated">呼叫端資訊</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Derived classes frequently override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to implement value equality.</source>
          <target state="translated">經常衍生的類別覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法，以實作值是否相等。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition, types also frequently provide an additional strongly typed overload to the <ph id="ph1">`Equals`</ph> method, typically by implementing the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">此外，型別也經常會提供額外的強型別多載來<ph id="ph1">`Equals`</ph>方法，通常是藉由實作<ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph>介面。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">`Equals`</ph> method to test for equality, you should know whether the current instance overrides <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> and understand how a particular call to an <ph id="ph3">`Equals`</ph> method is resolved.</source>
          <target state="translated">當您呼叫<ph id="ph1">`Equals`</ph>方法來測試是否相等，您應該知道是否會覆寫目前的執行個體<ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>並了解如何在特定呼叫<ph id="ph3">`Equals`</ph>方法已解決。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</source>
          <target state="translated">否則，您可能執行的測試相等，不同於您想要的結果，而且方法可能會傳回非預期的值。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example provides an illustration.</source>
          <target state="translated">下列範例提供一個實例。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It instantiates three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects with identical strings, and then makes four calls to <ph id="ph2">`Equals`</ph> methods.</source>
          <target state="translated">它會具現化三個<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>物件與相同的字串，並接著四個呼叫<ph id="ph2">`Equals`</ph>方法。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The first method call returns <ph id="ph1">`true`</ph>, and the remaining three return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">第一個方法呼叫傳回<ph id="ph1">`true`</ph>，和剩餘的三個傳回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the first case, the strongly typed <ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph> method overload, which tests for value equality, is called.</source>
          <target state="translated">在第一個案例中，強型別<ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph>方法多載，測試值是否相等，會呼叫。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the strings assigned to the two <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are equal, the method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">因為字串指派給這兩個<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>物件是否相等，則方法會傳回<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> does not override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">不過，<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>不會覆寫<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because of this, when the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object is cast to an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, when a <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> instance is assigned to a variable of type <ph id="ph4">&lt;xref:System.Object&gt;</ph>, and when the <ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method is passed two <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> objects, the default <ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is called.</source>
          <target state="translated">因為這個緣故時,<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>物件轉換成<ph id="ph2">&lt;xref:System.Object&gt;</ph>，當<ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph>執行個體指派給變數的型別<ph id="ph4">&lt;xref:System.Object&gt;</ph>，和當<ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph>方法會傳遞兩個<ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph>的物件，預設值<ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法呼叫。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> is a reference type, this is equivalent to passing the two <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>是參考類型，這相當於傳遞兩個<ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>物件加入至<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Although all three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects contain identical strings, they refer to three distinct objects.</source>
          <target state="translated">雖然這三個<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>物件包含完全相同的字串，它們會參考至三個相異的物件。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As a result, these three method calls return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如此一來，這些三個方法呼叫傳回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can compare the current object to another object for reference equality by calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">您可以藉由呼叫比較目前物件與另一個物件的參考相等性<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In Visual Basic, you can also use the <ph id="ph1">`is`</ph> keyword (for example, <ph id="ph2">`If Me Is otherObject Then ...`</ph>).</source>
          <target state="translated">在 Visual Basic 中，您也可以使用<ph id="ph1">`is`</ph>關鍵字 (例如， <ph id="ph2">`If Me Is otherObject Then ...`</ph>)。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Inheritors</source>
          <target state="translated">繼承者注意事項</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you define your own type, that type inherits the functionality defined by the <ph id="ph1">`Equals`</ph> method of its base type.</source>
          <target state="translated">當您定義自己的型別時，該類型繼承所定義的功能<ph id="ph1">`Equals`</ph>其基底型別的方法。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following table lists the default implementation of the <ph id="ph1">`Equals`</ph> method for the major categories of types in the .NET Framework.</source>
          <target state="translated">下表列出的預設實作<ph id="ph1">`Equals`</ph>方法在.NET Framework 類型的主要類別。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Type category</source>
          <target state="translated">型別分類</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Equality defined by</source>
          <target state="translated">所定義的相等</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Comments</source>
          <target state="translated">註解</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Class derived directly from <ph id="ph1">&lt;xref:System.Object&gt;</ph></source>
          <target state="translated">直接衍生自類別 <ph id="ph1">&lt;xref:System.Object&gt;</ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality; equivalent to calling <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">參考相等。相當於呼叫<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Structure</source>
          <target state="translated">結構</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</source>
          <target state="translated">值相等。直接位元組的比較或欄位的欄位比較使用反映。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Enumeration</source>
          <target state="translated">列舉</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Values must have the same enumeration type and the same underlying value.</source>
          <target state="translated">值必須有相同的列舉類型與相同的基礎值。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegate</source>
          <target state="translated">Delegate - 委派</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegates must have the same type with identical invocation lists.</source>
          <target state="translated">委派必須具有相同的引動過程清單的相同類型。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Interface</source>
          <target state="translated">介面</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality.</source>
          <target state="translated">參考相等。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For a value type, you should always override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, because tests for equality that rely on reflection offer poor performance.</source>
          <target state="translated">對於實值類型，您應該一律覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>，因為依賴反映的等號比較測試會提供效能不佳。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can also override the default implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</source>
          <target state="translated">您也可以覆寫的預設實作<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>參考類型的值是否相等，而不是參考相等測試，以及定義精確意義的值是否相等。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Such implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> return <ph id="ph2">`true`</ph> if the two objects have the same value, even if they are not the same instance.</source>
          <target state="translated">這類實作<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>傳回<ph id="ph2">`true`</ph>如果兩個物件擁有相同的值，即使它們不是相同的執行個體。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</source>
          <target state="translated">型別實作器決定何者構成物件的值，但是它通常是部分或所有儲存的資料物件的執行個體變數中。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, the value of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object is based on the characters of the string; the <ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method overrides the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to return <ph id="ph4">`true`</ph> for any two string instances that contain the same characters in the same order.</source>
          <target state="translated">例如，值<ph id="ph1">&lt;xref:System.String&gt;</ph>物件為基礎的字元字串;<ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法覆寫<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法以傳回<ph id="ph4">`true`</ph>任何兩個字串含有相同的順序中的相同字元的執行個體。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows how to override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to test for value equality.</source>
          <target state="translated">下列範例示範如何覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法來測試值是否相等。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method for the <ph id="ph2">`Person`</ph> class.</source>
          <target state="translated">它會覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>方法<ph id="ph2">`Person`</ph>類別。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`Person`</ph> accepted its base class implementation of equality, two <ph id="ph2">`Person`</ph> objects would be equal only if they referenced a single object.</source>
          <target state="translated">如果<ph id="ph1">`Person`</ph>接受等號比較、 其基底類別實作兩個<ph id="ph2">`Person`</ph>會等於只有當參考單一物件，這些物件。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, in this case, two <ph id="ph1">`Person`</ph> objects are equal if they have the same value for the <ph id="ph2">`Person.Id`</ph> property.</source>
          <target state="translated">不過，在此情況下，兩個<ph id="ph1">`Person`</ph>物件是否相等，如果它們有相同的值<ph id="ph2">`Person.Id`</ph>屬性。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition to overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, you can implement the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface to provide a strongly typed test for equality.</source>
          <target state="translated">除了覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>，您可以實作<ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph>介面，以提供強型別的測試是否相等。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following statements must be true for all implementations of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">下列陳述式必須為 true 的所有實作<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the list, <ph id="ph1">`x`</ph>, <ph id="ph2">`y`</ph>, and <ph id="ph3">`z`</ph> represent object references that are not <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">在清單中， <ph id="ph1">`x`</ph>， <ph id="ph2">`y`</ph>，和<ph id="ph3">`z`</ph>代表物件參考未<bpt id="p1">**</bpt>null<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(x)`</ph> returns <ph id="ph2">`true`</ph>, except in cases that involve floating-point types.</source>
          <target state="translated"><ph id="ph1">`x.Equals(x)`</ph> 傳回<ph id="ph2">`true`</ph>，除非在涉及浮點類型的情況下。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</source>
          <target state="translated">請參閱 ISO/IEC/IEEE 60559:2011，資訊技術-微處理器系統-浮點算術。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns the same value as <ph id="ph2">`y.Equals(x)`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> 傳回相同的值做為<ph id="ph2">`y.Equals(x)`</ph>。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns <ph id="ph2">`true`</ph> if both <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph> are <ph id="ph5">`NaN`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> 傳回<ph id="ph2">`true`</ph>如果兩個<ph id="ph3">`x`</ph>和<ph id="ph4">`y`</ph>是<ph id="ph5">`NaN`</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> returns <ph id="ph2">`true`</ph>, then <ph id="ph3">`x.Equals(z)`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph>傳回<ph id="ph2">`true`</ph>，然後<ph id="ph3">`x.Equals(z)`</ph>傳回<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Successive calls to <ph id="ph1">`x.Equals(y)`</ph> return the same value as long as the objects referenced by <ph id="ph2">`x`</ph> and <ph id="ph3">`y`</ph> are not modified.</source>
          <target state="translated">後續呼叫<ph id="ph1">`x.Equals(y)`</ph>傳回相同的值，只要參考的物件<ph id="ph2">`x`</ph>和<ph id="ph3">`y`</ph>不會修改。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(null)`</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(null)`</ph> 會傳回 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> must not throw exceptions; they should always return a value.</source>
          <target state="translated">實作<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>必須不會擲回例外狀況，他們應該一律會傳回的值。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, if <ph id="ph1">`obj`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph> method should return <ph id="ph4">`false`</ph> instead of throwing an <ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
          <target state="translated">例如，如果<ph id="ph1">`obj`</ph>是<ph id="ph2">`null`</ph>、<ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>方法應傳回<ph id="ph4">`false`</ph>而不是擲回<ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Follow these guidelines when overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</source>
          <target state="translated">覆寫時，請遵循下列方針<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> must override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">型別都會實作<ph id="ph1">&lt;xref:System.IComparable&gt;</ph>必須覆寫<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> must also override <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; otherwise, hash tables  might not work correctly.</source>
          <target state="translated">類型覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>也必須覆寫<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>，否則雜湊表可能無法正常運作。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should consider implementing the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface to support strongly typed tests for equality.</source>
          <target state="translated">您應該考慮實作<ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph>介面，以支援強型別測試是否相等。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Your <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> implementation should return results that are consistent with <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">您<ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph>實作應該傳回一致的結果<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to return the same result as the equality operator.</source>
          <target state="translated">如果您的程式語言支援運算子多載，而且您多載等號比較運算子，針對指定的型別，您也必須覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法以傳回與等號比較運算子相同的結果。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This  helps ensure that class library code that uses <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> (such as <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) behaves in a manner that is consistent with the way the equality operator is used by application code.</source>
          <target state="translated">這有助於確保會使用該類別程式庫程式碼<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>(例如<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>和<ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) 行為與等號比較運算子由應用程式程式碼的方式一致的方式。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Reference Types</source>
          <target state="translated">參考類型的指導方針</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a reference type:</source>
          <target state="translated">下列指導方針適用於覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>是參考型別：</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Consider overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> if the semantics of the type are based on the fact that the type represents some value(s).</source>
          <target state="translated">請考慮覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>如果類型的語意是基礎類型所代表的某些值為基礎。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Most reference types must not overload the equality operator, even if they override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">大部分的參考型別必須多載等號比較運算子，即使它們覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</source>
          <target state="translated">不過，如果您實作的參考類型，這是具有實值語意，例如複數類型，您必須覆寫等號比較運算子。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should not override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> on a mutable reference type.</source>
          <target state="translated">您不應覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>可變動參考類型上。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is because overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> requires that you also override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, as discussed in the previous section.</source>
          <target state="translated">這是因為覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>需要，您也會覆寫<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法，如前一節中討論。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</source>
          <target state="translated">這表示可變動參考類型的執行個體的雜湊程式碼可以在其生命週期，這可能導致遺失物件雜湊表中變更。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Value Types</source>
          <target state="translated">實值類型的指導方針</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a value type:</source>
          <target state="translated">下列指導方針適用於覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>的實值類型：</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you are defining a value type that includes one or more fields whose values are reference types, you should override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">如果您要定義實值型別，其中包含一個或多個欄位的值是參考類型，您應該覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> implementation provided by <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>提供實作<ph id="ph2">&lt;xref:System.ValueType&gt;</ph>執行位元組的比較的值類型欄位所有實值類型，但它會使用反映來執行其欄位包含參考類型的實值類型欄位的欄位比較。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and your development language supports operator overloading, you must overload the equality operator.</source>
          <target state="translated">如果您覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>和您的開發語言支援運算子多載，您必須多載等號比較運算子。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should implement the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">您應該實作<ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph>介面。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Calling the strongly typed <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> method avoids boxing the <ph id="ph2">`obj`</ph> argument.</source>
          <target state="translated">呼叫的強型別<ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph>方法可以避免 boxing<ph id="ph2">`obj`</ph>引數。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows a <ph id="ph1">`Point`</ph> class that overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method to provide value equality, and a <ph id="ph3">`Point3D`</ph> class that is derived from <ph id="ph4">`Point`</ph>.</source>
          <target state="translated">下列範例所示<ph id="ph1">`Point`</ph>類別會覆寫<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>方法以提供實值相等和<ph id="ph3">`Point3D`</ph>類別衍生自<ph id="ph4">`Point`</ph>。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point`</ph> overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to test for value equality, the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is not called.</source>
          <target state="translated">因為<ph id="ph1">`Point`</ph>會覆寫<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>來測試值是否相等，<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>不會呼叫方法。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`Point3D.Equals`</ph> calls <ph id="ph2">`Point.Equals`</ph> because <ph id="ph3">`Point`</ph> implements <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> in a manner that provides value equality.</source>
          <target state="translated">不過，<ph id="ph1">`Point3D.Equals`</ph>呼叫<ph id="ph2">`Point.Equals`</ph>因為<ph id="ph3">`Point`</ph>實作<ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方式提供值是否相等。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method checks to make sure that the <ph id="ph2">`obj`</ph> argument is not <bpt id="p1">**</bpt>null<ept id="p1">**</ept> and that it references an instance of the same type as this object.</source>
          <target state="translated"><ph id="ph1">`Point.Equals`</ph>方法會檢查並確定<ph id="ph2">`obj`</ph>引數不是<bpt id="p1">**</bpt>null<ept id="p1">**</ept>並且會參考與此物件相同類型的執行個體。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If either check fails, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果其中一個檢查失敗，則方法會傳回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method calls the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine whether the run-time types of the two objects are identical.</source>
          <target state="translated"><ph id="ph1">`Point.Equals`</ph>方法呼叫<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>方法，以判斷兩個物件的執行階段類型是否相同。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the method used a check of the form <ph id="ph1">`obj is Point`</ph> in C# or <ph id="ph2">`TryCast(obj, Point)`</ph> in Visual Basic, the check would return <ph id="ph3">`true`</ph> in cases where <ph id="ph4">`obj`</ph> is an instance of a derived class of <ph id="ph5">`Point`</ph>, even though <ph id="ph6">`obj`</ph> and the current instance are not of the same run-time type.</source>
          <target state="translated">如果此方法使用表單的核取<ph id="ph1">`obj is Point`</ph>在 C# 或<ph id="ph2">`TryCast(obj, Point)`</ph>在 Visual Basic 中，會傳回核取<ph id="ph3">`true`</ph>萬一其中<ph id="ph4">`obj`</ph>的衍生類別的執行個體<ph id="ph5">`Point`</ph>，即使<ph id="ph6">`obj`</ph>和目前執行個體不是相同的執行階段類型。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Having verified that both objects are of the same type, the method casts <ph id="ph1">`obj`</ph> to type <ph id="ph2">`Point`</ph> and returns the result of comparing the instance fields of the two objects.</source>
          <target state="translated">確認兩個物件都屬於相同類型，方法轉換<ph id="ph1">`obj`</ph>輸入<ph id="ph2">`Point`</ph>並傳回比較兩個物件的執行個體欄位的結果。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In <ph id="ph1">`Point3D.Equals`</ph>, the inherited <ph id="ph2">`Point.Equals`</ph> method, which overrides <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>, is invoked before anything else is done.</source>
          <target state="translated">在<ph id="ph1">`Point3D.Equals`</ph>，繼承<ph id="ph2">`Point.Equals`</ph>方法，它會覆寫<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>，任何其他項目完成之前，會叫用。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point3D`</ph> is a sealed class (<ph id="ph2">`NotInheritable`</ph> in Visual Basic), a check in the form <ph id="ph3">`obj is Point`</ph> in C# or <ph id="ph4">`TryCast(obj, Point)`</ph> in Visual Basic is adequate to ensure that <ph id="ph5">`obj`</ph> is a <ph id="ph6">`Point3D`</ph> object.</source>
          <target state="translated">因為<ph id="ph1">`Point3D`</ph>是密封的類別 (<ph id="ph2">`NotInheritable`</ph>在 Visual Basic 中)，在表單中的核取<ph id="ph3">`obj is Point`</ph>在 C# 或<ph id="ph4">`TryCast(obj, Point)`</ph>在 Visual Basic 中是以確保足夠<ph id="ph5">`obj`</ph>是<ph id="ph6">`Point3D`</ph>物件。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If it is a <ph id="ph1">`Point3D`</ph> object, it is cast to a <ph id="ph2">`Point`</ph> object and passed to the base class implementation of <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">如果是<ph id="ph1">`Point3D`</ph>物件，它會轉換為<ph id="ph2">`Point`</ph>物件，並傳遞至基底類別實作<ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Only when the inherited <ph id="ph1">`Point.Equals`</ph> method returns <ph id="ph2">`true`</ph> does the method compare the <ph id="ph3">`z`</ph> instance fields introduced in the derived class.</source>
          <target state="translated">只有當繼承<ph id="ph1">`Point.Equals`</ph>方法會傳回<ph id="ph2">`true`</ph>未方法比較<ph id="ph3">`z`</ph>執行個體導入衍生類別中的欄位。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example defines a <ph id="ph1">`Rectangle`</ph> class that internally implements a rectangle as two <ph id="ph2">`Point`</ph> objects.</source>
          <target state="translated">下列範例會定義<ph id="ph1">`Rectangle`</ph>類別，以在內部實作做為兩個矩形<ph id="ph2">`Point`</ph>物件。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Rectangle`</ph> class also overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to provide for value equality.</source>
          <target state="translated"><ph id="ph1">`Rectangle`</ph>類別也會覆寫<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>提供的值是否相等。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Some languages such as C# and Visual Basic support operator overloading.</source>
          <target state="translated">某些語言，例如 C# 和 Visual Basic 支援運算子多載。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When a type overloads the equality operator, it must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to provide the same functionality.</source>
          <target state="translated">當類型多載等號比較運算子時，它也必須覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法以提供相同的功能。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is typically accomplished by writing the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method in terms of the overloaded equality operator, as in the following example.</source>
          <target state="translated">這通常會透過撰寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方面的多載等號比較運算子，如下列範例所示的方法。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Complex`</ph> is a value type, it cannot be derived from.</source>
          <target state="translated">因為<ph id="ph1">`Complex`</ph>是實值類型，不能衍生自。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Therefore, the override to <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method need not call <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> to determine the precise run-time type of each object, but can instead use the <ph id="ph3">`is`</ph> operator in C# or the <ph id="ph4">`TypeOf`</ph> operator in Visual Basic to check the type of the <ph id="ph5">`obj`</ph> parameter.</source>
          <target state="translated">因此，若要覆寫<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法實作不需要呼叫<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>若要判斷精確的執行階段輸入的每個物件，但改為使用<ph id="ph3">`is`</ph>C# 中的運算子或<ph id="ph4">`TypeOf`</ph>檢查類型的VisualBasic中的運算子<ph id="ph5">`obj`</ph>參數。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">要比較的第一個物件。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">要比較的第二個物件。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>Determines whether the specified object instances are considered equal.</source>
          <target state="translated">判斷指定的物件執行個體是否視為相等。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the objects are considered equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果物件可視為相等則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If both <ph id="ph1">&lt;paramref name="objA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="objA" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> 都是 <bpt id="p1">**</bpt>null<ept id="p1">**</ept>，則這個方法會傳回 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The static <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method indicates whether two objects, <ph id="ph2">`objA`</ph> and  <ph id="ph3">`objB`</ph>, are equal.</source>
          <target state="translated">靜態<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph>方法表示兩個物件是否，<ph id="ph2">`objA`</ph>和<ph id="ph3">`objB`</ph>，是否相等。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It also enables you to test objects whose value is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> for equality.</source>
          <target state="translated">它也可讓您測試其值的物件<bpt id="p1">**</bpt>null<ept id="p1">**</ept>是否相等。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It compares <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> for equality as follows:</source>
          <target state="translated">它會比較<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>是否相等，如下所示：</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether the two objects represent the same object reference.</source>
          <target state="translated">它會判斷兩個物件是否表示相同的物件參考。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If they do, the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">如果沒有的話，則方法會傳回<ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This test is equivalent to calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">這個測試就相當於呼叫<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>In addition, if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">此外，如果這兩個<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>是<bpt id="p1">**</bpt>null<ept id="p1">**</ept>，方法會傳回<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether either <ph id="ph1">`objA`</ph> or <ph id="ph2">`objB`</ph> is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">它會判斷是否可能是<ph id="ph1">`objA`</ph>或<ph id="ph2">`objB`</ph>是<bpt id="p1">**</bpt>null<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If so, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">因此，它會傳回如果<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If the two objects do not represent the same object reference and neither is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, it calls <ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>) and returns the result.</source>
          <target state="translated">如果兩個物件不代表相同的物件參考，而且兩者都<bpt id="p1">**</bpt>null<ept id="p1">**</ept>，它會呼叫<ph id="ph1">`objA`</ph>。<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>)，並傳回結果。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This means that if <ph id="ph1">`objA`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, this override is called.</source>
          <target state="translated">這表示如果<ph id="ph1">`objA`</ph>會覆寫<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>呼叫方法，此覆寫。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method and compares it with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">下列範例說明<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph>方法，並比較它與<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Object.Finalize">
          <source>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</source>
          <target state="translated">在記憶體回收開始前，允許物件嘗試釋放資源，並執行其他清除作業。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法用來在終結物件之前，目前的物件所持有的 unmanaged 資源上執行清除作業。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The method is protected and therefore is accessible only through this class or through a derived class.</source>
          <target state="translated">此方法受到保護，因此只能透過這個類別或衍生類別存取。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this section:</source>
          <target state="translated">本節內容：</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>How finalization works<ept id="p1">](#How)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>最終處理的運作方式<ept id="p1">](#How)</ept></target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>Notes for implementers<ept id="p1">](#Notes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>實作者注意事項<ept id="p1">](#Notes)</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>SafeHandle 替代方法<ept id="p1">](#SafeHandle)</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>How finalization works</source>
          <target state="translated">最終處理的運作方式</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object&gt;</ph> class provides no implementation for the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, and the garbage collector does not mark types derived from <ph id="ph3">&lt;xref:System.Object&gt;</ph> for finalization unless they override the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph>類別提供的任何實作<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法，以及記憶體回收行程不會將標示類型衍生自<ph id="ph3">&lt;xref:System.Object&gt;</ph>進行最終處理它們會覆寫除非<ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a type does override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</source>
          <target state="translated">如果型別沒有覆寫<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法，記憶體回收行程會將每個執行個體類型的項目加入稱為最終處理佇列的內部結構。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</source>
          <target state="translated">最終處理佇列包含 managed 堆積記憶體回收行程回收其記憶體之前，必須執行其最終處理程式碼中的所有物件的項目。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The garbage collector then calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method automatically under the following conditions:</source>
          <target state="translated">記憶體回收行程再呼叫<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>在下列情況下自動的方法：</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">記憶體回收行程已探索物件是無法存取，除非物件已從最終處理豁免呼叫之後<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown of an application domain, unless the object is exempt from finalization.</source>
          <target state="translated">在關閉應用程式定義域，除非該物件是豁免最終處理。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown, even objects that are still accessible are finalized.</source>
          <target state="translated">在關機時完成甚至仍然可以存取的物件。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph> and the <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method has not been subsequently called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 會自動呼叫一次在給定的執行個體，除非物件已重新登錄使用一種機制，例如<ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>方法尚未後續呼叫。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> operations have the following limitations:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 作業會有下列限制：</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The exact time when the finalizer executes is undefined.</source>
          <target state="translated">當執行完成項的確切時間未定義。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To ensure deterministic release of resources for instances of your class, implement a <ph id="ph1">`Close`</ph> method or provide a <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">若要確保您類別的執行個體實作的決定性的資源釋放<ph id="ph1">`Close`</ph>方法，或提供<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>實作。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</source>
          <target state="translated">即使一個物件參考的其他兩個物件的完成項不保證任何特定的順序執行。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</source>
          <target state="translated">也就是說，如果物件 A 有參考到物件 B，且兩者都有完成項，物件 B 可能已完成的物件的完成項開始時。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The thread on which the finalizer runs is unspecified.</source>
          <target state="translated">未指定執行完成項執行緒。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method might not run to completion or might not run at all under the following exceptional circumstances:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法可能不會執行到完成為止，或可能完全無法執行下列例外狀況的情況下：</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</source>
          <target state="translated">如果另一個完成項會無限期地封鎖 （進入無限迴圈，嘗試取得的鎖定，它可能永遠不會取得，等等）。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</source>
          <target state="translated">執行階段會嘗試執行到完成的完成項，因為其他完成項可能不能呼叫完成項區塊無限期。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If the process terminates without giving the runtime a chance to clean up.</source>
          <target state="translated">如果處理序結束，而不讓執行階段有機會以清除。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</source>
          <target state="translated">在此情況下，終止處理序的執行階段的第一個通知是 DLL_PROCESS_DETACH 通知。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</source>
          <target state="translated">執行階段會在關機期間完成物件，可進行最終處理物件的數目會繼續減少時，才繼續。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> or an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active <ph id="ph3">`try`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks or finalizers are executed.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>的覆寫或<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>擲回例外狀況和執行階段不會覆寫預設原則的應用程式所裝載，執行階段終止處理程序並沒有作用中<ph id="ph3">`try`</ph> <ph id="ph4">/</ph> <ph id="ph5">`finally`</ph>區塊或會執行完成項。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This behavior ensures process integrity if the finalizer cannot free or destroy resources.</source>
          <target state="translated">此行為可確保處理程序完整性，如果完成項無法釋放或終結的資源。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Overriding the Finalize method</source>
          <target state="translated">覆寫 Finalize 方法</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should override <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</source>
          <target state="translated">您應該覆寫<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>類別使用 unmanaged 的資源，例如檔案控制代碼或使用它們的 managed 的物件在記憶體回收期間捨棄時必須釋放的資料庫連接。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You shouldn't implement a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for managed objects because the garbage collector releases managed resources automatically.</source>
          <target state="translated">您不應該實作<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法的 managed 物件，因為記憶體回收行程自動釋放 managed 的資源。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>物件可供使用，包裝您的 unmanaged 的資源，建議的替代做法是實作使用安全控制代碼的處置模式，並不會覆寫<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see <bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept> section.</source>
          <target state="translated">如需詳細資訊，請參閱<bpt id="p1">[</bpt>SafeHandle 替代方法<ept id="p1">](#SafeHandle)</ept>&gt; 一節。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method does nothing by default, but you should override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> only if necessary, and only to release unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>方法則會根據預設，不做任何動作，但是您應該覆寫<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>才有必要，而且只釋放 unmanaged 的資源。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</source>
          <target state="translated">回收記憶體，會花更長時間執行最終處理作業，如果，因為它需要至少兩個記憶體回收。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In addition, you should override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for reference types only.</source>
          <target state="translated">此外，您應該覆寫<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>只有類型參考的方法。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The common language runtime only finalizes reference types.</source>
          <target state="translated">Common language runtime 只完成參考型別。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It ignores finalizers on value types.</source>
          <target state="translated">它會忽略實值類型上的完成項。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The scope of the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">範圍<ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>方法<ph id="ph2">`protected`</ph>。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should maintain this limited scope when you override the method in your class.</source>
          <target state="translated">當您在類別中覆寫方法時，您應該維護這個限定的範圍。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>By keeping a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method protected, you prevent users of your application from calling an object's <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method directly.</source>
          <target state="translated">會保留<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>受保護的方法，避免從呼叫物件的應用程式的使用者<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>直接的方法。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Every implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> in a derived type must call its base type's implementation of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">每個實作<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>衍生類型中必須呼叫其基底類型實作<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is the only case in which application code is allowed to call <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">這是應用程式的程式碼可以呼叫的唯一情況<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>An object's <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method shouldn't call a method on any objects other than that of its base class.</source>
          <target state="translated">物件的<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法不應該在其基底類別以外的其他任何物件上呼叫的方法。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</source>
          <target state="translated">這是因為其他物件呼叫收集在同一時間作為呼叫物件時，例如在通用語言執行階段關機的情況下。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The C# compiler does not allow you to override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">C# 編譯器不允許您覆寫<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead, you provide a finalizer by implementing a <bpt id="p1">[</bpt>destructor<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> for your class.</source>
          <target state="translated">相反地，您提供完成項藉由實作<bpt id="p1">[</bpt>解構函式<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept>為您的類別。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>A C# destructor automatically calls the destructor of its base class.</source>
          <target state="translated">C# 解構函式自動呼叫其基底類別的解構函式。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Visual C++ also provides its own syntax for implementing the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Visual c + + 也提供自己的語法實作<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see the "Destructors and finalizers" section of <bpt id="p1">[</bpt>How to: Define and Consume Classes and Structs (C++/CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.</source>
          <target state="translated">如需詳細資訊，請參閱 &lt; 解構函式和完成項 &gt; 一節<bpt id="p1">[</bpt>如何： 定義和使用類別和結構 (C + + /CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</source>
          <target state="translated">因為記憶體回收是不具決定性的所以您不知道記憶體回收行程執行完成時。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To release resources immediately, you can also choose to implement the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> and the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">若要釋放資源，您也可以選擇實作<bpt id="p1">[</bpt>處置模式<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>和<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>介面。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method to free unmanaged resources in the event that the <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>實作可以呼叫您類別的取用者釋放 unmanaged 的資源，而且您可以使用<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法來釋放 unmanaged 的資源的<ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>不會呼叫方法。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 它已被清除記憶體回收期間之後，可以採取幾乎任何的動作，包括 resurrecting 物件 （也就，讓物件能夠存取一次）。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>However, the object can only be resurrected once; <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> cannot be called on resurrected objects during garbage collection.</source>
          <target state="translated">不過，此物件可以只復活一次。<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>無法在記憶體回收期間重新啟動的物件上呼叫。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>There is one action that your implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> should never take: it should never throw an exception.</source>
          <target state="translated">沒有一個動作，您的實作<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>絕對不應該接受： 它應該絕不會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If any exceptions thrown by methods called from the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method are unhandled by the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the runtime assumes that the <ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph> method returned and continues to call the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods of other objects.</source>
          <target state="translated">如果已從呼叫的方法所擲回任何例外狀況<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法會處理<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法，執行階段會假設<ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法傳回，並繼續呼叫<ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph>其他物件的方法。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The SafeHandle alternative</source>
          <target state="translated">SafeHandle 替代方法</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> and <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> terminate the finalizer.</source>
          <target state="translated">建立可靠的完成項通常很困難，因為您不能假設應用程式的狀態相關，而且這類未處理系統例外狀況<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>和<ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph>終止完成項。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</source>
          <target state="translated">而不是實作類別的完成項來釋放 unmanaged 的資源，您可以使用衍生自物件<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>類別來包裝您的 unmanaged 的資源，並再實作沒有完成項的處置模式。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The .NET Framework provides the following classes in the <ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph> namespace that are derived from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</source>
          <target state="translated">.NET Framework 提供的下列類別<ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph>衍生自命名空間<ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> is a wrapper class for a file handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> 是的檔案控制代碼的包裝函式類別。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> is a wrapper class for memory-mapped file handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> 為記憶體對應檔案控制代碼的包裝函式類別。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> is a wrapper class for a pointer to a block of unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> 是包裝函式類別的 unmanaged 記憶體區塊的指標。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> are wrapper classes for cryptographic handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph><ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>，和<ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph>是密碼編譯控制代碼的包裝函式類別。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> is a wrapper class for pipe handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> 是管道控制代碼的包裝函式類別。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> is a wrapper class for a handle to a registry key.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> 是登錄機碼的控制代碼的包裝函式類別。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> is a wrapper class for a wait handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> 是等候控制代碼的包裝函式類別。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> with safe handles instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">下列範例會使用<bpt id="p1">[</bpt>處置模式<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>使用安全控制代碼，而不是覆寫<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It defines a <ph id="ph1">`FileAssociation`</ph> class that wraps registry information about the application that handles files with a particular file extension.</source>
          <target state="translated">它會定義<ph id="ph1">`FileAssociation`</ph>包裝應用程式會處理具有特定副檔名的檔案的登錄資訊的類別。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The two registry handles returned as <ph id="ph1">`out`</ph> parameters by Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> function calls are passed to the <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> constructor.</source>
          <target state="translated">傳回做為兩個登錄控制代碼<ph id="ph1">`out`</ph>windows 參數<bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept>函式呼叫會傳遞至<ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph>建構函式。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The type's protected <ph id="ph1">`Dispose`</ph> method then calls the <ph id="ph2">`SafeRegistryHandle.Dispose`</ph> method  to free these two handles.</source>
          <target state="translated">類型的保護，<ph id="ph1">`Dispose`</ph>方法接著呼叫<ph id="ph2">`SafeRegistryHandle.Dispose`</ph>方法來釋放這些兩個控點。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example verifies that the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is called when an object that overrides <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> is destroyed.</source>
          <target state="translated">下列範例會確認<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>呼叫方法時，會覆寫物件<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>終結。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Note that, in a production application, the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method would be overridden to release unmanaged resources held by the object.</source>
          <target state="translated">請注意，在實際執行應用程式中，<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>會覆寫方法，以釋放這個物件所持有的 unmanaged 的資源。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Also note that the C# example provides a destructor instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">也請注意，C# 範例會提供解構函式，而不是覆寫<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For an additional example that overrides the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如需其他範例會覆寫<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法，請參閱<ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>Serves as the default hash function.</source>
          <target state="translated">做為預設雜湊函式。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>A hash code for the current object.</source>
          <target state="translated">目前物件的雜湊碼。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class, or a type derived from the <ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph> class.</source>
          <target state="translated">雜湊程式碼是用來插入及識別雜湊為基礎的集合中的物件，例如數值<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>類別<ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>類別或衍生自<ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method provides this hash code for algorithms that need quick checks of object equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法可為需要的物件是否相等的快速檢查的演算法來提供此雜湊程式碼。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the <bpt id="p1">[</bpt>Hash Function<ept id="p1">](https://en.wikipedia.org/wiki/Hash_function)</ept> entry in Wikipedia.</source>
          <target state="translated">如需有關雜湊程式碼的雜湊表中的使用方式資訊以及一些其他的雜湊程式碼演算法，請參閱<bpt id="p1">[</bpt>雜湊函式<ept id="p1">](https://en.wikipedia.org/wiki/Hash_function)</ept>維基百科中的項目。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two objects that are equal return hash codes that are equal.</source>
          <target state="translated">兩個物件相等的等於傳回的雜湊碼。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</source>
          <target state="translated">不過，反向並不成立： 等於雜湊程式碼不會表示物件是否相等，因為不同 （相等） 的物件可以有相同的雜湊碼。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Furthermore, the .NET Framework does not guarantee the default implementation of the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</source>
          <target state="translated">此外，.NET Framework 並不保證的預設實作<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法，以及這個方法會傳回可能不同.NET Framework 版本與平台，例如 32 位元和 64 位元平台之間的值。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</source>
          <target state="translated">基於這些理由，請勿使用這個方法的預設實作做為唯一物件識別項進行雜湊。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two consequences follow from this:</source>
          <target state="translated">從這個，請依照下列兩種結果：</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should not assume that equal hash codes imply object equality.</source>
          <target state="translated">您不應該假設等於雜湊程式碼表示物件是否相等。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</source>
          <target state="translated">您應該永遠不會保存，或使用雜湊程式碼中建立的應用程式定義域之外，因為相同的物件可能會跨應用程式定義域、 處理程序和平台的雜湊。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</source>
          <target state="translated">雜湊程式碼僅供有效率的插入和雜湊資料表為基礎的集合中的查閱。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is not a permanent value.</source>
          <target state="translated">雜湊程式碼不是永久的值。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For this reason:</source>
          <target state="translated">基於此理由：</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not serialize hash code values or store them in databases.</source>
          <target state="translated">請勿將序列化雜湊碼值或將它們儲存在資料庫中。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code as the key to retrieve an object from a keyed collection.</source>
          <target state="translated">請勿從索引鍵的集合中擷取物件中使用索引鍵的雜湊碼。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not send hash codes across application domains or processes.</source>
          <target state="translated">不要跨應用程式定義域或處理程序傳送雜湊碼。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In some cases, hash codes may be computed on a per-process or per-application domain basis.</source>
          <target state="translated">在某些情況下，雜湊程式碼可能會針對每個處理程序或每個應用程式網域的計算。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">請勿使用雜湊程式碼而不是如果您需要的密碼編譯強式雜湊，密碼編譯雜湊函式所傳回的值。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">密碼編譯雜湊，若為使用衍生自類別<ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph>或<ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not test for equality of hash codes to determine whether two objects are equal.</source>
          <target state="translated">不會測試相等的雜湊程式碼，以判斷兩個物件是否相等。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>(Unequal objects can have identical hash codes.) To test for equality, call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
          <target state="translated">（不相等的物件可以有相同的雜湊程式碼）。若要測試是否相等，請呼叫<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method can be overridden by a derived type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>衍生型別可覆寫方法。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> is not overridden, hash codes for reference types are computed by calling the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class, which computes a hash code based on an object's reference; for more information, see <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>是未覆寫，雜湊程式碼的參考型別會藉由呼叫計算<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>基底類別，用來計算雜湊程式碼的方法基礎上物件的參考; 如需詳細資訊，請參閱<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, two objects for which the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> have identical hash codes.</source>
          <target state="translated">換句話說，兩個物件的<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法會傳回<ph id="ph2">`true`</ph>有相同的雜湊程式碼。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If value types do not override <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</source>
          <target state="translated">如果實值類型不會覆寫<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>基底類別方法會使用反映來計算基礎類型的欄位值的雜湊碼。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, value types whose fields have equal values have equal hash codes.</source>
          <target state="translated">換句話說，其欄位具有相等值的實值型別具有相等的雜湊碼。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information about overriding <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, see the "Notes to Inheritors" section.</source>
          <target state="translated">如需有關覆寫<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>，請參閱 「 附註繼承者 」 一節。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you override the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, you should also override <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>, and vice versa.</source>
          <target state="translated">如果您覆寫<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法，您也應該覆寫<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>，反之亦然。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If your overridden <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when two objects are tested for equality, your overridden <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method must return the same value for the two objects.</source>
          <target state="translated">如果您覆寫<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>方法會傳回<ph id="ph2">`true`</ph>兩個物件是否相等，您覆寫進行測試<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法必須傳回相同值的兩個物件。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If an object that is used as a key in a hash table does not provide a useful implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, you can specify a hash code provider by supplying an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> implementation to one of the overloads of the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> class constructor.</source>
          <target state="translated">如果當做索引鍵使用雜湊表中的物件不提供的有用實作<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>，您可以指定雜湊碼提供者藉由提供<ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph>至其中的多載實作<ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>類別建構函式。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">附註 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">當您呼叫<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>中之類別的方法<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>，它提供的預設行為不覆寫的類別<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">這是.NET Framework 所提供的支援<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>(請參閱<bpt id="p1">[</bpt>.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement a <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">中的類別<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>不繼承<ph id="ph2">&lt;xref:System.Object&gt;</ph>，且不要只實作目前<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">不過，它們便會顯示有<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>，和<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>時您用於您的 C# 或 Visual Basic 程式碼，以及.NET Framework 提供的預設行為，這些方法的方法。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 以 C# 或 Visual Basic 撰寫的類別可以覆寫<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type is to simply return that value.</source>
          <target state="translated">其中一種簡單的方式來計算數值的值具有相同或較小的範圍比雜湊碼<ph id="ph1">&lt;xref:System.Int32&gt;</ph>就只會傳回該值為型別。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows such an implementation for a <ph id="ph1">`Number`</ph> structure.</source>
          <target state="translated">下列範例示範這類實作<ph id="ph1">`Number`</ph>結構。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Frequently, a type has multiple data fields that can participate in generating the hash code.</source>
          <target state="translated">通常，型別具有可以參與產生雜湊程式碼的多個資料欄位。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One way to generate a hash code is to combine these fields using an <ph id="ph1">`XOR (eXclusive OR)`</ph> operation, as shown in the following example.</source>
          <target state="translated">若要產生的雜湊碼的一種方式為結合使用這些欄位<ph id="ph1">`XOR (eXclusive OR)`</ph>作業，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</source>
          <target state="translated">前一個範例會傳回相同的雜湊程式碼 (n1，n2) 和 (n2 n1)，，因此可能會產生較多超過為想要的衝突。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A number of solutions are available so that hash codes in these cases are not identical.</source>
          <target state="translated">幾個解決方案可用，以便在這些情況下的雜湊程式碼並不相同。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One is to return the hash code of a <ph id="ph1">`Tuple`</ph> object that reflects the order of each field.</source>
          <target state="translated">其中是要傳回的雜湊碼<ph id="ph1">`Tuple`</ph>物件，以反映每個欄位的順序。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows a possible implementation that uses the <ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph> class.</source>
          <target state="translated">下列範例示範可能的實作使用<ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note, though, that the performance overhead of instantiating a <ph id="ph1">`Tuple`</ph> object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</source>
          <target state="translated">不過請注意，具現化的效能負荷<ph id="ph1">`Tuple`</ph>物件可能會大幅影響將大量的物件儲存雜湊資料表中的應用程式的整體效能。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</source>
          <target state="translated">第二個替代方案牽涉到由左移位連續欄位的雜湊碼由兩個或多個位元加權個別的雜湊碼。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</source>
          <target state="translated">以最佳方式，而不是被捨棄，超過 31 位元移位的位元應該圍繞而不會被捨棄。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</source>
          <target state="translated">位元左移位運算子在 C# 和 Visual Basic 中捨棄，因為您需要建立左的 shift 包裝方法如下所示：</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example then uses this shift-and-wrap method to compute the hash code of the <ph id="ph1">`Point`</ph> structure used in the previous examples.</source>
          <target state="translated">下列範例接著會使用這個 shift 包裝方法來計算的雜湊碼<ph id="ph1">`Point`</ph>前一個範例中使用的結構。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</source>
          <target state="translated">雜湊函式用來快速產生數字 （雜湊程式碼），會對應至物件的值。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</source>
          <target state="translated">雜湊函式通常是每個類型，和唯一性，必須使用至少其中一個執行個體欄位做為輸入。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash codes should not be computed by using the values of static fields.</source>
          <target state="translated">使用靜態欄位的值不應該計算雜湊碼。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For classes derived from <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, the <ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph> method can delegate to the base class <ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> implementation only if the derived class defines equality to be reference equality.</source>
          <target state="translated">類別衍生自<ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>、<ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph>方法可以委派給基底類別<ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>衍生的類別定義會參考相等的等號時，才實作。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The default implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for reference types returns a hash code that is equivalent to the one returned by the <ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph> method.</source>
          <target state="translated">預設實作<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>參考型別會傳回相當於所傳回的雜湊碼<ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for immutable reference types.</source>
          <target state="translated">您可以覆寫<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>不可變的參考類型。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In general, for mutable reference types, you should override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> only if:</source>
          <target state="translated">一般情況下，對於可變動參考類型，您應該覆寫<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>只有當：</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">您可以計算的雜湊碼，從欄位不是可變動;或</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">您可以確保可變動物件的雜湊程式碼不會變更其雜湊程式碼所依賴之集合中包含了該物件時。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Otherwise, you might think that the mutable object is lost in the hash table.</source>
          <target state="translated">否則，您可能會認為可變動物件將會遺失雜湊表中。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you do choose to override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</source>
          <target state="translated">如果您選擇要覆寫<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>對於可變動參考類型，您的文件應該解釋清楚的使用者，您的型別不應修改物件值，而此物件會儲存雜湊表中。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For value types, <ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph> provides a default hash code implementation that uses reflection.</source>
          <target state="translated">對於實值類型<ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph>提供使用反映的預設雜湊程式碼實作。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should consider overriding it for better performance.</source>
          <target state="translated">您應該考慮加以覆寫以提升效能。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information and examples that compute hash codes in a variety of ways, see the Examples section.</source>
          <target state="translated">如需詳細資訊和範例，計算雜湊碼的各種不同的方式，請參閱 &lt; 範例 &gt; 一節。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function must have the following properties:</source>
          <target state="translated">雜湊函式必須具有下列屬性：</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If two objects compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for each object must return the same value.</source>
          <target state="translated">如果兩個物件比較結果為相等，<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>每個物件的方法必須傳回相同的值。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, if two objects do not compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> methods for the two objects do not have to return different values.</source>
          <target state="translated">不過，如果兩個物件不會比較為相等，<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>兩個物件的方法沒有傳回不同的值。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's <bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>物件方法必須一致地傳回相同雜湊碼，只要有任何修改決定傳回值的物件，物件狀態<bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept>方法。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</source>
          <target state="translated">請注意這是僅針對目前執行的應用程式，則為 true，如果再次執行應用程式，可能會傳回不同的雜湊程式碼。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</source>
          <target state="translated">為了達到最佳效能，雜湊函式應該產生所有輸入，包括大量已叢集化的輸入是平均的分配。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</source>
          <target state="translated">含意為，小型修改物件的狀態應該會導致大型修改產生的雜湊程式碼中，為了達到最佳的雜湊表效能。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions should be inexpensive to compute.</source>
          <target state="translated">雜湊函式應該計算耗費大量資源。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method should not throw exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>方法不可擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For example, the implementation of the <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> method provided by the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> class returns identical hash codes for identical string values.</source>
          <target state="translated">例如，實作<ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph>所提供的方法<ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>類別會傳回相同的字串值相同的雜湊碼。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Therefore, two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects return the same hash code if they represent the same string value.</source>
          <target state="translated">因此，兩個<ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>物件傳回相同的雜湊程式碼，如果它們代表相同的字串值。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</source>
          <target state="translated">此外，此方法會使用的所有字元在字串中產生合理隨機散發的輸出，即使輸入叢集在特定範圍 (例如，許多使用者可能只包含較低 128 ASCII 字元，即使的字串字串可以包含任何 65,535 的 Unicode 字元）。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</source>
          <target state="translated">提供良好的雜湊函式的類別上會大幅影響將這些物件加入至雜湊表的效能。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</source>
          <target state="translated">在提供良好的雜湊函式實作的索引鍵的雜湊資料表中，搜尋項目會常數 （例如，一種 o （1） 運算） 的時間。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of items in the hash table).</source>
          <target state="translated">在具有不良函式實作的雜湊的雜湊資料表，搜尋的效能取決於雜湊表中的項目數 (比方說，O (<ph id="ph1">`n`</ph>) 作業，其中<ph id="ph2">`n`</ph>雜湊表中的項目數目是)。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</source>
          <target state="translated">惡意使用者可以輸入發生衝突，可能會大幅降低效能取決於雜湊表，在下列情況下的應用程式的數目增加的資料：</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When hash functions produce frequent collisions.</source>
          <target state="translated">當雜湊函式會產生頻繁的衝突。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</source>
          <target state="translated">當大比例的雜湊表中的物件產生的相等或大約等於另一個雜湊碼。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When users input the data from which the hash code is computed.</source>
          <target state="translated">當使用者輸入的雜湊程式碼會計算的資料。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Derived classes that override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> must also override <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> to guarantee that two objects considered equal have the same hash code; otherwise, the <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> type might not work correctly.</source>
          <target state="translated">在衍生類別覆寫<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>也必須覆寫<ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>保證會被視為相等的兩個物件具有相同的雜湊程式碼; 否則<ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>類型可能無法正常運作。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the current instance.</source>
          <target state="translated">取得目前執行個體的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>The exact runtime type of the current instance.</source>
          <target state="translated">目前執行個體的確切執行階段類型。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Because <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> is the base class for all types in the .NET Framework type system, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be used to return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects that represent all .NET Framework types.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>在.NET Framework 類型系統中，為所有類型的基底類別<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>方法可以用來傳回<ph id="ph3">&lt;xref:System.Type&gt;</ph>代表所有.NET Framework 類型的物件。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The .NET Framework recognizes the following five categories of types:</source>
          <target state="translated">.NET Framework 可辨識下列五種類型：</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Classes, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>,</source>
          <target state="translated">類別，衍生自<ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>，</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Value types, which are derived from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">實值類型，衍生自<ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Interfaces, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> starting with the .NET Framework 2.0.</source>
          <target state="translated">介面，衍生自<ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>從.NET Framework 2.0 開始。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Enumerations, which are derived from <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">列舉型別，衍生自<ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Delegates, which are derived from <ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">委派，衍生自<ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For two objects <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph> that have identical runtime types, <ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">兩個物件<ph id="ph1">`x`</ph>和<ph id="ph2">`y`</ph>具有相同的執行階段類型<ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph>傳回<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method to determine whether one numeric value is the same type as two other numeric values.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法，以判斷兩個數值是否為兩個其他數字的值相同的型別。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</source>
          <target state="translated">若要判斷物件是否為特定的型別，您可以使用您語言的型別比較關鍵字，或建構。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For example, you can use the <ph id="ph1">`TypeOf…Is`</ph> construct in Visual Basic or the <ph id="ph2">`is`</ph> keyword in C#.</source>
          <target state="translated">例如，您可以使用<ph id="ph1">`TypeOf…Is`</ph>在 Visual Basic 中建構或<ph id="ph2">`is`</ph>C# 中的關鍵字。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method is inherited by all types that derive from <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>方法繼承自所有型別衍生自<ph id="ph2">&lt;xref:System.Object&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>This means that, in addition to using your own language's comparison keyword, you can use the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine the type of a particular object, as the following example shows.</source>
          <target state="translated">這表示，除了使用您自己的語言比較關鍵字，您可以使用<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>方法，以判斷特定物件的類型，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposes the metadata associated with the class of the current <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph>物件會公開與目前的類別相關聯的中繼資料<ph id="ph2">&lt;xref:System.Object&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following code example demonstrates that <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> returns the runtime type of the current instance.</source>
          <target state="translated">下列程式碼範例會示範<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>傳回目前執行個體的執行階段類型。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>Creates a shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">建立目前 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 的淺層複製。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>A shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">目前 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 的淺層複製。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法建立新的物件，並再將目前物件的非靜態欄位複製到新的物件建立淺層複本。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">如果欄位是實值類型，則會執行位元欄位的複本。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</source>
          <target state="translated">如果欄位是參考類型，則會複製參考，但參考的物件不;因此，原始的物件和其複製參考相同的物件。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</source>
          <target state="translated">例如，請考慮 x 依次參考物件 A 和 B 參考物件 c。X 的淺層複本建立新的物件 X2 參考物件 A 和 b。相反地，X 的深層複本建立新物件 X2 A2 與 B2 a 的新物件和 B.B2 參考新物件 C2，也就是一份 c。此範例說明 shallow 和深層複製作業之間的差異。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method does not meet your needs.</source>
          <target state="translated">透過深層複製作業，實作時所執行的淺層複製作業的許多方式<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法不符合您的需求。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>These include the following:</source>
          <target state="translated">這些需求包括下列各項：</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</source>
          <target state="translated">呼叫類別建構函式要複製到取自第一個物件的屬性值建立第二個物件的物件。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>This assumes that the values of an object are entirely defined by its class constructor.</source>
          <target state="translated">這是假設物件的值會完全由其類別建構函式。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</source>
          <target state="translated">呼叫<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法來建立物件的淺層複本，並將指派其值為與原始物件的任何屬性或欄位的值是參考型別相同的新物件。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">`DeepCopy`</ph> method in the example illustrates this approach.</source>
          <target state="translated"><ph id="ph1">`DeepCopy`</ph>方法在此範例將示範這個方法。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</source>
          <target state="translated">序列化物件變成深層複製，，然後還原序列化的資料至不同的物件變數。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Use reflection with recursion to perform the deep copy operation.</source>
          <target state="translated">使用反映遞迴時，以執行深層複製作業。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method.</source>
          <target state="translated">下列範例說明<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It defines a <ph id="ph1">`ShallowCopy`</ph> method that calls the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to perform a shallow copy operation on a <ph id="ph3">`Person`</ph> object.</source>
          <target state="translated">它會定義<ph id="ph1">`ShallowCopy`</ph>方法呼叫<ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法上執行的淺層複製作業<ph id="ph3">`Person`</ph>物件。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It also defines a <ph id="ph1">`DeepCopy`</ph> method that performs a deep copy operation on a <ph id="ph2">`Person`</ph> object.</source>
          <target state="translated">它也會定義<ph id="ph1">`DeepCopy`</ph>執行深層複製作業的方法<ph id="ph2">`Person`</ph>物件。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>In this example, the <ph id="ph1">`Person.IdInfo`</ph> property returns an <ph id="ph2">`IdInfo`</ph> object.</source>
          <target state="translated">在此範例中，<ph id="ph1">`Person.IdInfo`</ph>屬性會傳回<ph id="ph2">`IdInfo`</ph>物件。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As the output from the example shows, when a <ph id="ph1">`Person`</ph> object is cloned by calling the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method, the cloned <ph id="ph3">`Person`</ph> object is an independent copy of the original object, except that they share the same <ph id="ph4">`Person.IdInfo`</ph> object reference.</source>
          <target state="translated">做為範例所示，從輸出時<ph id="ph1">`Person`</ph>物件會藉由呼叫複製<ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法中，複製<ph id="ph3">`Person`</ph>物件是原始物件的獨立複本，不同之處在於它們共用相同<ph id="ph4">`Person.IdInfo`</ph>物件參考。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As a result, modifying the clone's <ph id="ph1">`Person.IdInfo`</ph> property changes the original object's <ph id="ph2">`Person.IdInfo`</ph> property.</source>
          <target state="translated">如此一來，修改複製品的<ph id="ph1">`Person.IdInfo`</ph>屬性變更的原始物件<ph id="ph2">`Person.IdInfo`</ph>屬性。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>On the other hand, when a deep copy operation is performed, the cloned <ph id="ph1">`Person`</ph> object, including its <ph id="ph2">`Person.IdInfo`</ph> property, can be modified without affecting the original object.</source>
          <target state="translated">相反地，深層複製作業執行時，複製<ph id="ph1">`Person`</ph>物件，包括其<ph id="ph2">`Person.IdInfo`</ph>屬性，可以修改而不會影響原始物件。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">要比較的第一個物件。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The second object  to compare.</source>
          <target state="translated">要比較的第二個物件。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are the same instance.</source>
          <target state="translated">判斷指定的 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 執行個體是否為相同的執行個體。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> is the same instance as <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> or if both are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> 與 <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> 為相同的執行個體或兩者皆為 <bpt id="p1">**</bpt>null<ept id="p1">**</ept>，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>否則為 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method and the equality operator, the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method cannot be overridden.</source>
          <target state="translated">不同於<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>方法和等號比較運算子，<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>無法覆寫方法。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Because of this, if you want to test two object references for equality and you are unsure about the implementation of the <ph id="ph1">`Equals`</ph> method, you can call the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">因為這個緣故，如果您想要測試兩個物件是否相等的參考，您不確定的實作<ph id="ph1">`Equals`</ph>方法，您可以呼叫<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, the return value of the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method may appear to be anomalous in these two scenarios:</source>
          <target state="translated">不過，傳回值<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法可能會出現在這兩個案例中的異常：</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing value types.</source>
          <target state="translated">比較值的類型。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are value types, they are boxed before they are passed to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">如果<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>為實值類型傳遞至之前 boxing 處理<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>This means that if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> represent the same instance of a value type, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method nevertheless returns <ph id="ph4">`false`</ph>, as the following example shows.</source>
          <target state="translated">這表示，如果這兩個<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>代表相同的執行個體的實值類型，<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法卻傳回<ph id="ph4">`false`</ph>，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For information on boxing value types, see <bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</source>
          <target state="translated">Boxing 實值型別資訊，請參閱<bpt id="p1">[</bpt>Boxing 和 Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing strings.</source>
          <target state="translated">當比較字串。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are strings, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph4">`true`</ph> if the string is interned.</source>
          <target state="translated">如果<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>是字串，<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法會傳回<ph id="ph4">`true`</ph>如果實習的字串。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>It does not perform a test for value equality.</source>
          <target state="translated">它不會執行測試的值相等。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>In the following example, <ph id="ph1">`s1`</ph> and <ph id="ph2">`s2`</ph> are equal because they are two instances of a single interned string.</source>
          <target state="translated">在下列範例中，<ph id="ph1">`s1`</ph>和<ph id="ph2">`s2`</ph>相等，因為它們是兩個執行個體已經保留的單一字串。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, <ph id="ph1">`s3`</ph> and <ph id="ph2">`s4`</ph> are not equal, because although they are have identical string values, that string is not interned.</source>
          <target state="translated">不過，<ph id="ph1">`s3`</ph>和<ph id="ph2">`s4`</ph>不相等，因為雖然它們有相同的字串值時，該字串未被保留了。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For more information about string interning, see <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如需有關字串拘留的詳細資訊，請參閱<ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> to determine if two objects are the same instance.</source>
          <target state="translated">下列範例會使用<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>來判斷兩個物件是否相同的執行個體。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>Returns a string that represents the current object.</source>
          <target state="translated">傳回代表目前物件的字串。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>A string that represents the current object.</source>
          <target state="translated">表示目前物件的字串。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> is the major formatting method in the .NET Framework.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> 主要格式在.NET Framework 中的方法。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It converts an object to its string representation so that it is suitable for display.</source>
          <target state="translated">它將物件轉換為其字串表示，因此適合顯示。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>(For information about formatting support in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.) Default implementations of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method return the fully qualified name of the object's type.</source>
          <target state="translated">(如需格式在.NET Framework 的支援資訊，請參閱<bpt id="p1">[</bpt>格式化型別<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>。)預設實作<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法傳回的物件類型的完整的名稱。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You may have reached this page by following the link from the member list of another type.</source>
          <target state="translated">您可能會到達此頁面由另一種類型的成員清單中的下列連結。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>That is because that type does not override <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">這是因為該類型不會覆寫<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, it inherits the functionality of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">相反地，它所繼承的功能<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types frequently override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide a more suitable string representation of a particular type.</source>
          <target state="translated">型別經常覆寫<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以提供更適合的字串表示，特定的型別。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types also frequently overload the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide support for format strings or culture-sensitive formatting.</source>
          <target state="translated">型別也經常多載<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法，以支援的格式字串，或區分文化特性的格式。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In this section:</source>
          <target state="translated">本節內容：</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>The default Object.ToString() method<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>預設 object.tostring （） 方法<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overriding the Object.ToString() method<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>覆寫 object.tostring （） 方法<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overloading the ToString method<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>ToString 方法多載化<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Extending the Object.ToString method<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>擴充 Object.ToString 方法<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Notes for the Windows Runtime<ept id="p1">](#WinRT)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Windows 執行階段資訊<ept id="p1">](#WinRT)</ept></target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default Object.ToString() method</source>
          <target state="translated">預設 object.tostring （） 方法</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default implementation of the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the fully qualified name of the type of the <ph id="ph2">&lt;xref:System.Object&gt;</ph>, as the following example shows.</source>
          <target state="translated">預設實作<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>方法會傳回型別的完整格式的名稱<ph id="ph2">&lt;xref:System.Object&gt;</ph>，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because <ph id="ph1">&lt;xref:System.Object&gt;</ph> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated">因為<ph id="ph1">&lt;xref:System.Object&gt;</ph>的基底類別的所有參考型別在.NET Framework 中，此行為由參考型別，不會覆寫繼承<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example illustrates this.</source>
          <target state="translated">下列範例將說明這點。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines a class named <ph id="ph1">`Object1`</ph> that accepts the default implementation of all <ph id="ph2">&lt;xref:System.Object&gt;</ph> members.</source>
          <target state="translated">它會定義名為類別<ph id="ph1">`Object1`</ph>接受所有的預設實作<ph id="ph2">&lt;xref:System.Object&gt;</ph>成員。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the object's fully qualified type name.</source>
          <target state="translated">其<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>方法會傳回物件的完整限定的類型名稱。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overriding the Object.ToString() method</source>
          <target state="translated">覆寫 object.tostring （） 方法</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types commonly override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return a string that represents the object instance.</source>
          <target state="translated">型別通常覆寫<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以傳回字串，表示物件執行個體。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, the base types such as <ph id="ph1">&lt;xref:System.Char&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.String&gt;</ph> provide <ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph> implementations that return the string form of the value that the object represents.</source>
          <target state="translated">例如，基底類型例如<ph id="ph1">&lt;xref:System.Char&gt;</ph>， <ph id="ph2">&lt;xref:System.Int32&gt;</ph>，和<ph id="ph3">&lt;xref:System.String&gt;</ph>提供<ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph>傳回物件所代表之值的字串形式的實作。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a class, <ph id="ph1">`Object2`</ph>, that overrides the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method to return the type name along with its value.</source>
          <target state="translated">下列範例會定義一個類別， <ph id="ph1">`Object2`</ph>，會覆寫<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>方法以傳回型別名稱與其值。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following table lists the type categories in the .NET Framework and indicates whether or not they override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">下表列出.NET Framework 中的類型分類，並指出是否它們會覆寫<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Type category</source>
          <target state="translated">型別分類</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides Object.ToString()</source>
          <target state="translated">覆寫 object.tostring （)</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Behavior</source>
          <target state="translated">行為</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Class</source>
          <target state="translated">類別</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/A</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/A</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Structure</source>
          <target state="translated">結構</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">是 (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Same as Object.ToString()</source>
          <target state="translated">相同 object.tostring （）</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Enumeration</source>
          <target state="translated">列舉</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">是 (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The member name</source>
          <target state="translated">成員名稱</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Interface</source>
          <target state="translated">介面</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/A</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Delegate</source>
          <target state="translated">Delegate - 委派</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/A</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>See the Notes to Inheritors section for additional information on overriding <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">請參閱注意事項繼承者注意事項 &gt; 一節，如需詳細資訊，覆寫<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overloading the ToString method</source>
          <target state="translated">ToString 方法多載化</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In addition to overriding the parameterless <ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph> method, many types overload the <ph id="ph2">`ToString`</ph> method to provide versions of the method that accept parameters.</source>
          <target state="translated">除了覆寫的無參數<ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph>方法中，許多型別多載<ph id="ph2">`ToString`</ph>方法以提供方法的接受參數的版本。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</source>
          <target state="translated">大多數情況下，這是為了提供變數的格式和文化特性格式的支援。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example overloads the <ph id="ph1">`ToString`</ph> method to return a result string that includes the value of various fields of an <ph id="ph2">`Automobile`</ph> class.</source>
          <target state="translated">下列範例會多載<ph id="ph1">`ToString`</ph>方法以傳回結果字串，其中包含的各種欄位的值<ph id="ph2">`Automobile`</ph>類別。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</source>
          <target state="translated">它會定義四個格式字串： G，會傳回年度，則與模型名稱D，傳回模型名稱、 年和的門。C，傳回模型名稱、 年份和數目的磁柱;和 A，它會傳回所有的四個欄位值的字串。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example calls the overloaded <ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method to display culture-sensitive formatting of a currency value.</source>
          <target state="translated">下列範例會呼叫多載<ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法來顯示文化特性的貨幣值的格式。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For more information on format strings and culture-sensitive formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">如需有關格式字串和文化特性格式的詳細資訊，請參閱<bpt id="p1">[</bpt>格式化型別<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by numeric values, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">支援的數值格式字串，請參閱<bpt id="p1">[</bpt>標準數值格式字串<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂數值格式字串<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">支援的日期和時間值的格式字串，請參閱<bpt id="p1">[</bpt>標準日期和時間格式字串<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept>和<bpt id="p2">[</bpt>自訂日期和時間格式字串<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Extending the Object.ToString method</source>
          <target state="translated">擴充 Object.ToString 方法</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because a type inherits the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method, you may find its behavior undesirable and want to change it.</source>
          <target state="translated">因為類型會繼承預設<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法，您可能會尋找其行為不想要並想要進行變更。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is particularly true of arrays and collection classes.</source>
          <target state="translated">特別是陣列和集合類別。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>While you may expect the <ph id="ph1">`ToString`</ph> method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</source>
          <target state="translated">雖然您可能預期<ph id="ph1">`ToString`</ph>方法来顯示其成員的值陣列或集合類別，它改為顯示類型的完整限定的類型名稱，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You have several options to produce the result string that you'd like.</source>
          <target state="translated">您有數個選項，以產生您想要的結果字串。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the type is an array, a collection object, or an object that implements the <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interfaces, you can enumerate its elements by using the <ph id="ph3">`foreach`</ph> statement in C# or the <ph id="ph4">`For Each...Next`</ph> construct in Visual Basic.</source>
          <target state="translated">如果類型是陣列、 集合物件或該物件會實作<ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph>或<ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>介面，您可以使用列舉其項目<ph id="ph3">`foreach`</ph>C# 中的陳述式或<ph id="ph4">`For Each...Next`</ph>在 Visual Basic 中建構。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the class is not <ph id="ph1">`sealed`</ph> (in C#) or <ph id="ph2">`NotInheritable`</ph> (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method you want to customize.</source>
          <target state="translated">如果類別不是<ph id="ph1">`sealed`</ph>（C# 中） 或<ph id="ph2">`NotInheritable`</ph>（在 Visual Basic 中)，您可以開發其繼承自基底類別的包裝函數類別<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>您想要自訂的方法。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>At a minimum, this requires that you do the following:</source>
          <target state="translated">最小，這需要您下列：</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implement any necessary constructors.</source>
          <target state="translated">實作任何必要的建構函式。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes do not inherit their base class constructors.</source>
          <target state="translated">在衍生的類別不會繼承其基底類別建構函式。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return the result string that you'd like.</source>
          <target state="translated">覆寫<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以傳回您想要的結果字串。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a wrapper class for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">下列範例定義的包裝函式類別<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>類別。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to display the value of each method of the collection rather than the fully qualified type name.</source>
          <target state="translated">它會覆寫<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法，以顯示每個方法的集合，而不是完整限定的類型名稱的值。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Develop an <bpt id="p1">[</bpt>extension method<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept> that returns the result string that you want.</source>
          <target state="translated">開發<bpt id="p1">[</bpt>擴充方法<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept>傳回您想要的結果字串。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that you can't override the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named <ph id="ph2">`ToString`</ph> that is called in place of the original type's <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">請注意，您無法覆寫預設<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以這種方式 (也就是您的延伸模組類別 （C# 中） 或 （在 Visual Basic) 的模組不能有無參數方法，名為<ph id="ph2">`ToString`</ph>，而呼叫取代原始型別<ph id="ph3">`ToString`</ph>方法.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You'll have to provide some other name for your parameterless <ph id="ph1">`ToString`</ph> replacement.</source>
          <target state="translated">您必須提供其他的名稱為您的無參數<ph id="ph1">`ToString`</ph>取代。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines two methods that extend the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class: a parameterless <ph id="ph2">`ToString2`</ph> method, and a <ph id="ph3">`ToString`</ph> method with a <ph id="ph4">&lt;xref:System.String&gt;</ph> parameter that represents a format string.</source>
          <target state="translated">下列範例會定義兩個方法來擴充<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>類別： 無參數<ph id="ph2">`ToString2`</ph>方法，和<ph id="ph3">`ToString`</ph>方法<ph id="ph4">&lt;xref:System.String&gt;</ph>表示的格式字串參數。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">附註 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">當您呼叫<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>中之類別的方法<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>，它提供的預設行為不覆寫的類別<ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">這是.NET Framework 所提供的支援<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>(請參閱<bpt id="p1">[</bpt>.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and don’t always implement a <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">中的類別<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>不繼承<ph id="ph2">&lt;xref:System.Object&gt;</ph>，且永遠不要只實作<ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>However, they always appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</source>
          <target state="translated">不過，它們一定會顯示有<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>，和<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法，當您在您的 C# 或 Visual Basic 程式碼，使用與.NET Framework 會提供這些方法中的預設行為。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, the common language runtime will use <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object before falling back to the default implementation of <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>，common language runtime 會使用<bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>上<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>物件的預設實作回到之前<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 以 C# 或 Visual Basic 撰寫的類別可以覆寫<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> and the IStringable Interface</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>和 IStringable 介面</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with <ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> includes an <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface whose single method, <bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, provides basic formatting support comparable to that provided by <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">從開始<ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>、<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>包含<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>介面方法<bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>，提供基本格式支援的比較所提供<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>To prevent ambiguity, you should not implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on managed types.</source>
          <target state="translated">若要避免模稜兩可，您不應該實作<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> managed 類型上。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">當受管理的物件稱為原生程式碼或程式碼撰寫語言，例如 JavaScript 或 C + + /CX 中，它們會顯示實作<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The common language runtime will automatically route calls from <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> to <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> in the event <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> is not implemented on the managed object.</source>
          <target state="translated">Common language runtime 會自動路由傳送來自呼叫<bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>至<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>在事件<bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>未實作在 managed 物件上。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because the common language runtime auto-implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> for all managed types in <ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> apps, we recommend that you do not provide your own <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation.</source>
          <target state="translated">因為 common language runtime 自動實作<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>所有管理中的型別<ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph>應用程式中，我們建議您，您不會提供您自己<bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>實作。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implementing <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> may result in unintended behavior when calling <ph id="ph1">`ToString`</ph> from the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C++/CX, or JavaScript.</source>
          <target state="translated">實作<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>呼叫時，可能會導致非預期的行為<ph id="ph1">`ToString`</ph>從<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>、 C + + /CX 中或 JavaScript。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If you do choose to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in a public managed type that is exported in a <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> component, the following restrictions apply:</source>
          <target state="translated">如果您選擇實作<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>中匯出的公用 managed 類型中<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>元件，請套用下列限制：</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can define the <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface only in a "class implements" relationship, such as</source>
          <target state="translated">您可以定義<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>介面只能在 「 類別實作 」 關聯性，例如</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in C#, or</source>
          <target state="translated">在 C# 中，或</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in Visual Basic.</source>
          <target state="translated">在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on an interface.</source>
          <target state="translated">您不能實作<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>介面上。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot declare a parameter to be of type <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">您無法為型別參數宣告<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> cannot be the return type of a method, property, or field.</source>
          <target state="translated"><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>不能是方法、 屬性或欄位的傳回型別。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot hide your <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation from base classes by using a method definition such as the following:</source>
          <target state="translated">您無法隱藏您<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>從使用如下所示的方法定義的基底類別的實作：</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, the <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation must always override the base class implementation.</source>
          <target state="translated">相反地， <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>實作一律必須覆寫基底類別實作。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can hide a <ph id="ph1">`ToString`</ph> implementation only by invoking it on a strongly typed class instance.</source>
          <target state="translated">您只能藉由針對強型別類別執行個體叫用 <ph id="ph1">`ToString`</ph> 實作來隱藏該實作。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that under a variety of conditions, calls from native code to a managed type that implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> or hides its <bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation can produce unexpected behavior.</source>
          <target state="translated">請注意，在各種不同的條件，從原生程式碼來實作的 managed 類型<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>或隱藏其<bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>實作可能會產生非預期的行為。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you implement your own types, you should override the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method to return values that are meaningful for those types.</source>
          <target state="translated">當您實作您自己的類型時，您應該覆寫<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>方法傳回對這些類型有意義的值。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes that require more control over formatting than <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> provides can implement the <ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">在衍生類別需要更多控制的格式比<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>提供可實作<ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph>介面。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph> method enables you to define format strings that control formatting and to use an <ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph> object that can provide for culture-specific formatting.</source>
          <target state="translated">其<ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph>方法可讓您定義控制格式的格式字串，並使用<ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph>可以提供特定文化特性格式化的物件。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides of the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should follow these guidelines:</source>
          <target state="translated">覆寫的<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>方法應該遵循這些指導方針：</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be friendly and readable by humans.</source>
          <target state="translated">傳回的字串應該是易記、 可讀性更高讓人了。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should uniquely identify the value of the object instance.</source>
          <target state="translated">傳回的字串應專門用於識別物件的執行個體的值。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be as short as possible so that it is suitable for display by a debugger.</source>
          <target state="translated">傳回的字串應越短越好，使其適用於偵錯工具顯示。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not return <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> or a null string.</source>
          <target state="translated">您<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>覆寫不應該傳回<ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>或 null 字串。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not throw an exception.</source>
          <target state="translated">您<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>覆寫應該不會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">如果執行個體的字串表示區分文化特性，或可以多種方式進行格式化，實作<ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph>介面。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the returned string includes sensitive information, you should first demand an appropriate permission.</source>
          <target state="translated">如果傳回的字串包含機密資訊，您應該先要求適當的權限。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</source>
          <target state="translated">如果要求成功，您可以傳回的敏感資訊。否則，您應該會傳回不包含機密資訊的字串。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should have no observable side effects to avoid complications in debugging.</source>
          <target state="translated">您<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>覆寫應具有任何副作用若要避免在偵錯的複雜性。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, a call to the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should not change the value of instance fields.</source>
          <target state="translated">例如，若要呼叫<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>方法不應該變更的執行個體欄位的值。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If your type implements a parsing method (or <ph id="ph1">&lt;see langword="Parse" /&gt;</ph> or <ph id="ph2">&lt;see langword="TryParse" /&gt;</ph> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method can be converted to an object instance.</source>
          <target state="translated">如果您的型別實作的剖析方法 (或<ph id="ph1">&lt;see langword="Parse" /&gt;</ph>或<ph id="ph2">&lt;see langword="TryParse" /&gt;</ph>方法、 建構函式或某些其他靜態方法，會具現化的類型從字串的執行個體)，您應該確保所傳回的字串<ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph>方法可以是轉換成物件執行個體。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>