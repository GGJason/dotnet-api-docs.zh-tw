<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="308002d9ae24d643fad3d891656bd69b93f39794" /><Meta Name="ms.sourcegitcommit" Value="3575d47a0ba065e8986f03d99279f478811907b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/20/2019" /><Meta Name="ms.locfileid" Value="65922731" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="57479-101">支援.NET 類別階層架構中的所有類別，並為衍生類別提供低階服務。</span><span class="sxs-lookup"><span data-stu-id="57479-101">Supports all classes in the .NET class hierarchy and provides low-level services to derived classes.</span></span> <span data-ttu-id="57479-102">這是所有的.NET 類別; 的 ultimate 基底類別它是類型階層的根。</span><span class="sxs-lookup"><span data-stu-id="57479-102">This is the ultimate base class of all .NET classes; it is the root of the type hierarchy.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-103">語言通常不需要宣告繼承自類別<xref:System.Object>因為繼承是隱含的。</span><span class="sxs-lookup"><span data-stu-id="57479-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="57479-104">因為在.NET 中的所有類別都衍生自<xref:System.Object>，每個方法中定義<xref:System.Object>類別是所有的物件中的可用系統中。</span><span class="sxs-lookup"><span data-stu-id="57479-104">Because all classes in .NET are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="57479-105">衍生類別並覆寫其中一些方法，包括：</span><span class="sxs-lookup"><span data-stu-id="57479-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="57479-106"><xref:System.Object.Equals%2A> -支援的物件之間的比較。</span><span class="sxs-lookup"><span data-stu-id="57479-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="57479-107"><xref:System.Object.Finalize%2A> -自動收回物件前，請執行清除作業。</span><span class="sxs-lookup"><span data-stu-id="57479-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="57479-108"><xref:System.Object.GetHashCode%2A> 產生對應至物件的值數目，以支援雜湊資料表的使用。</span><span class="sxs-lookup"><span data-stu-id="57479-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="57479-109"><xref:System.Object.ToString%2A> -製造人類看得懂的文字字串描述類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="57479-110">效能考量</span><span class="sxs-lookup"><span data-stu-id="57479-110">Performance Considerations</span></span>  
 <span data-ttu-id="57479-111">如果您正在設計的類別，例如集合、 必須處理任何類型的物件，您可以建立接受的執行個體的類別成員<xref:System.Object>類別。</span><span class="sxs-lookup"><span data-stu-id="57479-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="57479-112">不過，boxing 和 unboxing 類型的程序會帶來效能成本。</span><span class="sxs-lookup"><span data-stu-id="57479-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="57479-113">如果您知道您的新類別會經常處理特定實值型別則您可以使用其中一個策略的 boxing 成本降到最低。</span><span class="sxs-lookup"><span data-stu-id="57479-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="57479-114">建立一般的方法可接受<xref:System.Object>型別和一組特定類型的方法多載接受預期類別經常處理每一個實值型別。</span><span class="sxs-lookup"><span data-stu-id="57479-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="57479-115">如果特定類型的方法可接受呼叫的參數型別，就會發生任何 boxing，並叫用特定類型的方法。</span><span class="sxs-lookup"><span data-stu-id="57479-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="57479-116">如果沒有任何方法引數的比對呼叫的參數型別，參數會經過 boxing 處理，並叫用一般方法。</span><span class="sxs-lookup"><span data-stu-id="57479-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="57479-117">設計您的類型和其成員使用泛型。</span><span class="sxs-lookup"><span data-stu-id="57479-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="57479-118">當您建立您的類別的執行個體，並指定泛型型別引數時，common language runtime 就會建立封閉式的泛型型別。</span><span class="sxs-lookup"><span data-stu-id="57479-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="57479-119">泛型方法型別特定，沒有 boxing 呼叫的參數就可以叫用。</span><span class="sxs-lookup"><span data-stu-id="57479-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="57479-120">雖然有時候是必要開發接受及傳回的一般用途類別<xref:System.Object>類型，可以改善效能，也提供特定類型的類別來處理常使用的型別。</span><span class="sxs-lookup"><span data-stu-id="57479-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="57479-121">比方說，提供特定設定和取得布林值的類別，可消除 boxing 和 unboxing 的布林值的成本。</span><span class="sxs-lookup"><span data-stu-id="57479-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57479-122">下列範例會定義點型別衍生自<xref:System.Object>類別並覆寫的虛擬方法的許多<xref:System.Object>類別。</span><span class="sxs-lookup"><span data-stu-id="57479-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="57479-123">此外，此範例示範如何呼叫許多靜態和執行個體方法的<xref:System.Object>類別。</span><span class="sxs-lookup"><span data-stu-id="57479-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="57479-124">公用靜態 (<see langword="Shared" /> Visual Basic 中) 的這種類型的成員都是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="57479-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="57479-125">不保證執行個體成員是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="57479-125">Instance members are not guaranteed to be thread-safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57479-126">初始化 <see cref="T:System.Object" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-127">這個建構函式會呼叫建構函式在衍生類別中，但它也可用來直接建立的執行個體<xref:System.Object>類別。</span><span class="sxs-lookup"><span data-stu-id="57479-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57479-128">判斷兩個物件執行個體是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-128">Determines whether two object instances are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="57479-129">要與目前物件比較的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-129">The object to compare with the current object.</span></span></param>
        <summary><span data-ttu-id="57479-130">判斷指定的物件是否等於目前的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-130">Determines whether the specified object is equal to the current object.</span></span></summary>
        <returns><span data-ttu-id="57479-131">若指定的物件等於目前的物件，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="57479-131"><see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-132">目前的執行個體之間的比較的類型和`obj`參數取決於目前的執行個體是否為參考型別或實值型別。</span><span class="sxs-lookup"><span data-stu-id="57479-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="57479-133">如果目前的執行個體是參考型別<xref:System.Object.Equals%28System.Object%29>方法會測試參考是否相等，並呼叫<xref:System.Object.Equals%28System.Object%29>方法就相當於呼叫<xref:System.Object.ReferenceEquals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="57479-134">參考相等表示所比較的物件變數參考相同的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="57479-135">下列範例說明這類比較的結果。</span><span class="sxs-lookup"><span data-stu-id="57479-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="57479-136">它會定義`Person`類別，這是參考型別，並呼叫`Person`類別建構函式產生兩個新`Person`物件`person1a`和`person2`，具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="57479-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="57479-137">它也會指派`person1a`到另一個物件變數， `person1b`。</span><span class="sxs-lookup"><span data-stu-id="57479-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="57479-138">做為範例所示，從輸出`person1a`和`person1b`相等，因為它們參考相同的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="57479-139">不過，`person1a`和`person2`不相等，雖然它們有相同的值。</span><span class="sxs-lookup"><span data-stu-id="57479-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="57479-140">如果目前的執行個體是實值類型，<xref:System.Object.Equals%28System.Object%29>方法測試值是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="57479-141">實值相等表示下列各項：</span><span class="sxs-lookup"><span data-stu-id="57479-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="57479-142">兩個物件都屬於相同的類型。</span><span class="sxs-lookup"><span data-stu-id="57479-142">The two objects are of the same type.</span></span> <span data-ttu-id="57479-143">如下列範例所示<xref:System.Byte>不等於物件，其值為 12<xref:System.Int32>有值為 12，，因為兩個物件具有不同的執行階段類型的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="57479-144">兩個物件的公用和私用欄位的值相等。</span><span class="sxs-lookup"><span data-stu-id="57479-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="57479-145">下列範例會測試值相等。</span><span class="sxs-lookup"><span data-stu-id="57479-145">The following example tests for value equality.</span></span> <span data-ttu-id="57479-146">它會定義`Person`結構，也就是實值型別，並呼叫`Person`類別建構函式產生兩個新`Person`物件`person1`和`person2`，具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="57479-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="57479-147">範例輸出所示，兩個物件變數參考不同的物件，雖然`person1`並`person2`相等，因為它們具有相同的值為私用`personName`欄位。</span><span class="sxs-lookup"><span data-stu-id="57479-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="57479-148">因為<xref:System.Object>類別是.NET Framework 中的所有類型的基底類別<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法提供所有其他類型的預設相等比較。</span><span class="sxs-lookup"><span data-stu-id="57479-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="57479-149">不過，類型通常會覆寫<xref:System.Object.Equals%2A>方法來實作實值相等。</span><span class="sxs-lookup"><span data-stu-id="57479-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="57479-150">如需詳細資訊，請參閱 < 附註的呼叫端和注意事項繼承者區段。</span><span class="sxs-lookup"><span data-stu-id="57479-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="57479-151">資訊 [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="57479-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="57479-152">當您呼叫<xref:System.Object.Equals%28System.Object%29>中之類別的方法多載[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不會覆寫的類別提供的預設行為<xref:System.Object.Equals%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="57479-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="57479-153">這是.NET Framework 提供的支援之一[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱 < [.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。</span><span class="sxs-lookup"><span data-stu-id="57479-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="57479-154">中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且不要只實作目前<xref:System.Object.Equals%28System.Object%29>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="57479-155">不過，它們似乎具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法時您用於您的 C# 或 Visual Basic 程式碼，和.NET Framework 會提供這些方法中的預設行為。</span><span class="sxs-lookup"><span data-stu-id="57479-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="57479-156">以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.Equals%28System.Object%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="57479-156">classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="57479-157">呼叫端資訊</span><span class="sxs-lookup"><span data-stu-id="57479-157">Notes for Callers</span></span>  
 <span data-ttu-id="57479-158">在衍生的類別經常覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法來實作實值相等。</span><span class="sxs-lookup"><span data-stu-id="57479-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="57479-159">此外，型別也經常會提供額外的強型別多載，來`Equals`方法，通常是藉由實作<xref:System.IEquatable%601>介面。</span><span class="sxs-lookup"><span data-stu-id="57479-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="57479-160">當您呼叫`Equals`方法來測試是否相等，您應該知道是否會覆寫目前的執行個體<xref:System.Object.Equals%2A?displayProperty=nameWithType>，並了解如何以特定的呼叫`Equals`方法已解決。</span><span class="sxs-lookup"><span data-stu-id="57479-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="57479-161">否則，您可能會執行測試不同的是您想要相等，而且方法可能會傳回未預期的值。</span><span class="sxs-lookup"><span data-stu-id="57479-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="57479-162">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="57479-162">The following example provides an illustration.</span></span> <span data-ttu-id="57479-163">它會將三個執行個體化<xref:System.Text.StringBuilder>物件具有相同的字串，並接著四個呼叫`Equals`方法。</span><span class="sxs-lookup"><span data-stu-id="57479-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="57479-164">第一個方法呼叫傳回`true`，並將其餘的三個傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="57479-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="57479-165">在第一個案例中，強型別<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>方法多載，測試值是否相等時，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="57479-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="57479-166">因為字串指派給這兩個<xref:System.Text.StringBuilder>物件是否相等，則方法會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="57479-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="57479-167">不過，<xref:System.Text.StringBuilder>未覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="57479-168">因為這個緣故時,<xref:System.Text.StringBuilder>物件轉換成<xref:System.Object>，當<xref:System.Text.StringBuilder>執行個體指派給變數的型別<xref:System.Object>，和當<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>方法會傳遞兩個<xref:System.Text.StringBuilder>的物件，預設值<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="57479-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="57479-169">因為<xref:System.Text.StringBuilder>是參考型別，這相當於傳遞兩個<xref:System.Text.StringBuilder>物件到<xref:System.Object.ReferenceEquals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="57479-170">雖然這三個<xref:System.Text.StringBuilder>物件包含相同的字串，它們參考三個不同的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="57479-171">如此一來，這些三個方法會呼叫傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="57479-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="57479-172">您可以比較目前物件與另一個物件參考是否相等，藉由呼叫<xref:System.Object.ReferenceEquals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="57479-173">在 Visual Basic 中，您也可以使用`is`關鍵字 (例如`If Me Is otherObject Then ...`)。</span><span class="sxs-lookup"><span data-stu-id="57479-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="57479-174">繼承者注意事項</span><span class="sxs-lookup"><span data-stu-id="57479-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="57479-175">當您定義自己的型別時，該類型會繼承所定義的功能`Equals`其基底類型的方法。</span><span class="sxs-lookup"><span data-stu-id="57479-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="57479-176">下表列出的預設實作`Equals`方法主要的一種.NET Framework 中的型別。</span><span class="sxs-lookup"><span data-stu-id="57479-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="57479-177">型別分類</span><span class="sxs-lookup"><span data-stu-id="57479-177">Type category</span></span>|<span data-ttu-id="57479-178">所定義的相等</span><span class="sxs-lookup"><span data-stu-id="57479-178">Equality defined by</span></span>|<span data-ttu-id="57479-179">註解</span><span class="sxs-lookup"><span data-stu-id="57479-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="57479-180">直接衍生自的類別 <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="57479-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="57479-181">參考相等;相當於呼叫<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="57479-182">結構</span><span class="sxs-lookup"><span data-stu-id="57479-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="57479-183">值相等;直接的逐位元組比較或使用反映的欄位欄位比較。</span><span class="sxs-lookup"><span data-stu-id="57479-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="57479-184">列舉</span><span class="sxs-lookup"><span data-stu-id="57479-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="57479-185">值必須有相同的列舉型別與相同的基礎值。</span><span class="sxs-lookup"><span data-stu-id="57479-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="57479-186">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="57479-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="57479-187">委派必須具有相同的引動過程清單之相同類型。</span><span class="sxs-lookup"><span data-stu-id="57479-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="57479-188">介面</span><span class="sxs-lookup"><span data-stu-id="57479-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="57479-189">參考相等。</span><span class="sxs-lookup"><span data-stu-id="57479-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="57479-190">對於實值類型，您應該一律覆寫<xref:System.Object.Equals%2A>，因為依賴反映的等號比較測試會提供效能不佳。</span><span class="sxs-lookup"><span data-stu-id="57479-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="57479-191">您也可以覆寫的預設實作<xref:System.Object.Equals%2A>參考型別來測試值是否相等，而不是參考相等，並定義實值相等，就精確而言。</span><span class="sxs-lookup"><span data-stu-id="57479-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="57479-192">這類實作的<xref:System.Object.Equals%2A>傳回`true`如果兩個物件有相同的值，即使它們不是相同的執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="57479-193">類型的實作器會決定構成物件的值，但它通常是部分或所有儲存的資料物件的執行個體變數中。</span><span class="sxs-lookup"><span data-stu-id="57479-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="57479-194">例如，值<xref:System.String>物件為基礎的字元字串;<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>方法覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，以傳回`true`任何兩個字串包含相同字元的相同順序的執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="57479-195">下列範例示範如何覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法來測試值是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="57479-196">它會覆寫<xref:System.Object.Equals%2A>方法`Person`類別。</span><span class="sxs-lookup"><span data-stu-id="57479-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="57479-197">如果`Person`接受等號比較，其基底類別實作兩個`Person`物件會參考單一物件，請將它們時，才。</span><span class="sxs-lookup"><span data-stu-id="57479-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="57479-198">不過，在此情況下，兩個`Person`物件是否相等，如果它們有相同的值，如`Person.Id`屬性。</span><span class="sxs-lookup"><span data-stu-id="57479-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="57479-199">除了覆寫<xref:System.Object.Equals%2A>，您可以實作<xref:System.IEquatable%601>介面，以提供強型別的測試是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="57479-200">下列陳述式必須為 true 的所有實作<xref:System.Object.Equals%28System.Object%29>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="57479-201">在清單中， `x`， `y`，並`z`代表物件參考未**null**。</span><span class="sxs-lookup"><span data-stu-id="57479-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="57479-202">`x.Equals(x)` 傳回`true`，牽涉到浮點數類型的情況除外。</span><span class="sxs-lookup"><span data-stu-id="57479-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="57479-203">請參閱[ISO/IEC/IEEE 60559:2011、 資訊技術-微處理器系統浮點算術](https://www.iso.org/standard/57469.html)。</span><span class="sxs-lookup"><span data-stu-id="57479-203">See [ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic](https://www.iso.org/standard/57469.html).</span></span>  
  
-   <span data-ttu-id="57479-204">`x.Equals(y)` 會傳回與 `y.Equals(x)` 相同的值。</span><span class="sxs-lookup"><span data-stu-id="57479-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="57479-205">`x.Equals(y)` 會傳回`true`如果兩個`x`並`y`是`NaN`。</span><span class="sxs-lookup"><span data-stu-id="57479-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="57479-206">如果`(x.Equals(y) && y.Equals(z))`會傳回`true`，然後`x.Equals(z)`傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="57479-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="57479-207">後續呼叫`x.Equals(y)`傳回相同的值，只要所參考的物件`x`和`y`不會修改。</span><span class="sxs-lookup"><span data-stu-id="57479-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="57479-208">`x.Equals(null)` 會傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="57479-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="57479-209">實作<xref:System.Object.Equals%2A>不得擲回例外狀況; 它們應該一律會傳回值。</span><span class="sxs-lookup"><span data-stu-id="57479-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="57479-210">例如，如果`obj`是`null`，則<xref:System.Object.Equals%2A>方法應傳回`false`而非擲回<xref:System.ArgumentNullException>。</span><span class="sxs-lookup"><span data-stu-id="57479-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="57479-211">覆寫時，請遵循下列指導方針<xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="57479-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="57479-212">型別都會實作<xref:System.IComparable>必須覆寫<xref:System.Object.Equals%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="57479-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="57479-213">類型覆寫<xref:System.Object.Equals%28System.Object%29>也必須覆寫<xref:System.Object.GetHashCode%2A>，否則雜湊表可能無法正常運作。</span><span class="sxs-lookup"><span data-stu-id="57479-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="57479-214">您應該考慮實作<xref:System.IEquatable%601>介面，以支援強型別測試是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="57479-215">您<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>實作應該會傳回與一致的結果<xref:System.Object.Equals%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="57479-216">如果您的程式語言支援運算子多載，而且您多載等號比較運算子，針對指定的型別，您也必須覆寫<xref:System.Object.Equals%28System.Object%29>方法，以傳回與等號比較運算子相同的結果。</span><span class="sxs-lookup"><span data-stu-id="57479-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="57479-217">這有助於確保會使用該類別程式庫程式碼<xref:System.Object.Equals%2A>(例如<xref:System.Collections.ArrayList>和<xref:System.Collections.Hashtable>) 行為與等號比較運算子由應用程式程式碼的方式一致的方式。</span><span class="sxs-lookup"><span data-stu-id="57479-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="57479-218">參考類型的指導方針</span><span class="sxs-lookup"><span data-stu-id="57479-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="57479-219">下列指導方針適用於覆寫<xref:System.Object.Equals%28System.Object%29>是參考型別：</span><span class="sxs-lookup"><span data-stu-id="57479-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="57479-220">請考慮覆寫<xref:System.Object.Equals%2A>如果類型的語意是基礎類型所代表的某些值為基礎。</span><span class="sxs-lookup"><span data-stu-id="57479-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="57479-221">大部分的參考型別必須多載等號比較運算子，即使它們會覆寫<xref:System.Object.Equals%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="57479-222">不過，如果您要實作參考型別，要有值的語意，例如複雜數字 類型中，您必須覆寫等號比較運算子。</span><span class="sxs-lookup"><span data-stu-id="57479-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="57479-223">您不應該覆寫<xref:System.Object.Equals%2A>可變動參考類型。</span><span class="sxs-lookup"><span data-stu-id="57479-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="57479-224">這是因為覆寫<xref:System.Object.Equals%2A>需要，您也會覆寫<xref:System.Object.GetHashCode%2A>方法，如前一節所述。</span><span class="sxs-lookup"><span data-stu-id="57479-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="57479-225">這表示可變動參考類型的執行個體的雜湊碼，可以在其生命週期，這會導致遺失物件雜湊表中進行變更。</span><span class="sxs-lookup"><span data-stu-id="57479-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="57479-226">實值類型的指導方針</span><span class="sxs-lookup"><span data-stu-id="57479-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="57479-227">下列指導方針適用於覆寫<xref:System.Object.Equals%28System.Object%29>的實值型別：</span><span class="sxs-lookup"><span data-stu-id="57479-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="57479-228">如果您要定義實值型別，其中包含一或多個欄位的值是參考型別，您應該覆寫<xref:System.Object.Equals%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="57479-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="57479-229"><xref:System.Object.Equals%28System.Object%29>所提供的實作<xref:System.ValueType>執行逐位元組比較的值類型的欄位是所有實值型別，但它會使用反映來執行其欄位包含參考類型的實值型別的欄位的比較。</span><span class="sxs-lookup"><span data-stu-id="57479-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="57479-230">如果您覆寫<xref:System.Object.Equals%2A>和您的開發語言支援運算子多載，您必須多載等號比較運算子。</span><span class="sxs-lookup"><span data-stu-id="57479-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="57479-231">您應該實作<xref:System.IEquatable%601>介面。</span><span class="sxs-lookup"><span data-stu-id="57479-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="57479-232">呼叫強型別<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法可以避免 boxing`obj`引數。</span><span class="sxs-lookup"><span data-stu-id="57479-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57479-233">下列範例所示`Point`類別會覆寫<xref:System.Object.Equals%2A>方法，以提供實值相等，並`Point3D`類別衍生自`Point`。</span><span class="sxs-lookup"><span data-stu-id="57479-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="57479-234">因為`Point`會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>來測試值是否相等，<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>不會呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="57479-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="57479-235">不過，`Point3D.Equals`呼叫`Point.Equals`因為`Point`實作<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供實值相等的方式。</span><span class="sxs-lookup"><span data-stu-id="57479-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="57479-236">`Point.Equals`方法會檢查並確定`obj`引數不是**null**和它所參考的這個物件與相同類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="57479-237">如果其中一個檢查失敗，則方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="57479-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="57479-238">`Point.Equals`方法呼叫<xref:System.Object.GetType%2A>方法，以判斷兩個物件的執行階段類型是否相同。</span><span class="sxs-lookup"><span data-stu-id="57479-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="57479-239">如果使用表單的核取的方法`obj is Point`C# 中或`TryCast(obj, Point)`在 Visual Basic 中，檢查會傳回`true`萬一其中`obj`的衍生類別的執行個體`Point`，即使`obj`和目前執行個體不是相同的執行階段型別。</span><span class="sxs-lookup"><span data-stu-id="57479-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="57479-240">完成驗證，這兩個物件都是相同類型，也就是方法轉型`obj`輸入`Point`，並傳回比較兩個物件的執行個體欄位的結果。</span><span class="sxs-lookup"><span data-stu-id="57479-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="57479-241">在  `Point3D.Equals`，繼承`Point.Equals`方法，它會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>，任何其他項目完成之前叫用。</span><span class="sxs-lookup"><span data-stu-id="57479-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="57479-242">因為`Point3D`是密封的類別 (`NotInheritable` Visual Basic 中)，在表單中的核取`obj is Point`在 C# 或`TryCast(obj, Point)`Visual Basic 中就已足夠，確保`obj`是`Point3D`物件。</span><span class="sxs-lookup"><span data-stu-id="57479-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="57479-243">如果它是`Point3D`物件，它會轉換為`Point`物件，並傳遞至基底類別實作<xref:System.Object.Equals%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="57479-244">只有當繼承`Point.Equals`方法會傳回`true`沒有方法比較`z`執行個體的衍生類別中引進的欄位。</span><span class="sxs-lookup"><span data-stu-id="57479-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="57479-245">下列範例會定義`Rectangle`類別在內部實作做為兩個矩形`Point`物件。</span><span class="sxs-lookup"><span data-stu-id="57479-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="57479-246">`Rectangle`類別也會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供的值是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="57479-247">某些語言，例如 C# 和 Visual Basic 支援運算子多載。</span><span class="sxs-lookup"><span data-stu-id="57479-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="57479-248">當類型多載等號比較運算子時，它也必須覆寫<xref:System.Object.Equals%28System.Object%29>方法，以提供相同的功能。</span><span class="sxs-lookup"><span data-stu-id="57479-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="57479-249">這通常透過撰寫<xref:System.Object.Equals%28System.Object%29>方面的多載等號比較運算子，如下列範例所示的方法。</span><span class="sxs-lookup"><span data-stu-id="57479-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="57479-250">因為`Complex`是實值類型，它不能衍生自。</span><span class="sxs-lookup"><span data-stu-id="57479-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="57479-251">因此，若要覆寫<xref:System.Object.Equals%28System.Object%29>方法實作不需要呼叫<xref:System.Object.GetType%2A>若要判斷精確的執行階段輸入的每個物件，但可以改為使用`is`C# 中的運算子或`TypeOf`檢查類型的VisualBasic中的運算子`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="57479-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="57479-252">要比較的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="57479-252">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="57479-253">要比較的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="57479-253">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="57479-254">判斷指定的物件執行個體是否視為相等。</span><span class="sxs-lookup"><span data-stu-id="57479-254">Determines whether the specified object instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="57479-255">如果物件可視為相等則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="57479-255"><see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="57479-256">如果 <paramref name="objA" /> 和 <paramref name="objB" /> 都是 **null**，則這個方法會傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="57479-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-257">靜態<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法會指示是否兩個物件，`objA`和`objB`，相等。</span><span class="sxs-lookup"><span data-stu-id="57479-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="57479-258">它也可讓您測試其值的物件**null**是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="57479-259">它會比較`objA`和`objB`是否相等，如下所示：</span><span class="sxs-lookup"><span data-stu-id="57479-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="57479-260">它會判斷兩個物件是否代表相同的物件參考。</span><span class="sxs-lookup"><span data-stu-id="57479-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="57479-261">如果沒有的話，則方法會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="57479-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="57479-262">這項測試就相當於呼叫<xref:System.Object.ReferenceEquals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="57479-263">此外，如果這兩個`objA`並`objB`會**null**，則方法會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="57479-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="57479-264">它會判斷是否可能`objA`或是`objB`是**null**。</span><span class="sxs-lookup"><span data-stu-id="57479-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="57479-265">如果，則會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="57479-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="57479-266">如果兩個物件不代表相同的物件參考，而且兩者都**null**，它會呼叫`objA`。`Equals`(`objB`)，並傳回結果。</span><span class="sxs-lookup"><span data-stu-id="57479-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="57479-267">這表示，如果`objA`會覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，會呼叫此覆寫。</span><span class="sxs-lookup"><span data-stu-id="57479-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57479-268">下列範例說明<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法，並比較它與<xref:System.Object.ReferenceEquals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57479-269">在記憶體回收開始前，允許物件嘗試釋放資源，並執行其他清除作業。</span><span class="sxs-lookup"><span data-stu-id="57479-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-270"><xref:System.Object.Finalize%2A>方法用來在終結物件之前，目前的物件所持有的 unmanaged 資源上執行清除作業。</span><span class="sxs-lookup"><span data-stu-id="57479-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="57479-271">此方法受到保護，因此只能透過此類別或衍生類別存取。</span><span class="sxs-lookup"><span data-stu-id="57479-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="57479-272">本節內容：</span><span class="sxs-lookup"><span data-stu-id="57479-272">In this section:</span></span>  
  
-   [<span data-ttu-id="57479-273">最終處理的運作方式</span><span class="sxs-lookup"><span data-stu-id="57479-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="57479-274">實作者的附註</span><span class="sxs-lookup"><span data-stu-id="57479-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="57479-275">SafeHandle 替代方法</span><span class="sxs-lookup"><span data-stu-id="57479-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="57479-276">最終處理的運作方式</span><span class="sxs-lookup"><span data-stu-id="57479-276">How finalization works</span></span>  
 <span data-ttu-id="57479-277"><xref:System.Object>類別提供任何實作<xref:System.Object.Finalize%2A>方法，以及記憶體回收行程不會標記類型衍生自<xref:System.Object>進行最終處理它們會覆寫除非<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="57479-278">如果型別會覆寫<xref:System.Object.Finalize%2A>方法，記憶體回收行程就會將每個執行個體類型的項目加入至稱為最終處理佇列的內部結構。</span><span class="sxs-lookup"><span data-stu-id="57479-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="57479-279">完成佇列包含 managed 堆積記憶體回收行程可以回收其記憶體之前，必須執行的最終處理程式碼中的所有物件的項目。</span><span class="sxs-lookup"><span data-stu-id="57479-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="57479-280">然後呼叫記憶體回收行程<xref:System.Object.Finalize%2A>方法會自動在下列情況下：</span><span class="sxs-lookup"><span data-stu-id="57479-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="57479-281">記憶體回收行程已探索物件是無法存取，除非呼叫物件豁免的最終處理之後<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="57479-282">**僅限.NET Framework 上**，在關閉應用程式定義域，除非物件已豁免最終處理。</span><span class="sxs-lookup"><span data-stu-id="57479-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="57479-283">在關機期間仍然可以存取的甚至是物件的完成的。</span><span class="sxs-lookup"><span data-stu-id="57479-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="57479-284"><xref:System.Object.Finalize%2A> 會自動呼叫一次在給定的執行個體，除非使用一種機制，例如重新註冊的物件<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>而<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法尚未後續呼叫。</span><span class="sxs-lookup"><span data-stu-id="57479-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="57479-285"><xref:System.Object.Finalize%2A> 作業會有下列限制：</span><span class="sxs-lookup"><span data-stu-id="57479-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="57479-286">當完成項執行的確切時間是未定義。</span><span class="sxs-lookup"><span data-stu-id="57479-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="57479-287">若要確保您類別的執行個體都會實作決定性的資源釋放`Close`方法，或提供<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作。</span><span class="sxs-lookup"><span data-stu-id="57479-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="57479-288">即使一個物件參考其他兩個物件的完成項不保證任何特定順序執行。</span><span class="sxs-lookup"><span data-stu-id="57479-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="57479-289">也就是說，如果物件 A 會有物件 B 的參考，而且兩者都有完成項，物件 B 可能已完成的物件的完成項開始時。</span><span class="sxs-lookup"><span data-stu-id="57479-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="57479-290">未指定在其執行完成項執行緒。</span><span class="sxs-lookup"><span data-stu-id="57479-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="57479-291"><xref:System.Object.Finalize%2A>方法可能不會執行到完成為止，或可能完全無法執行下列的例外情況下：</span><span class="sxs-lookup"><span data-stu-id="57479-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="57479-292">如果另一個完成項會無限期地封鎖 （進入無限迴圈，會嘗試取得鎖定，它可能永遠不會取得，等等）。</span><span class="sxs-lookup"><span data-stu-id="57479-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="57479-293">因為執行階段嘗試執行完成項完成時，其他完成項可能不會呼叫如果完成項區塊無限期。</span><span class="sxs-lookup"><span data-stu-id="57479-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="57479-294">如果處理程序結束，而不讓執行階段清除。</span><span class="sxs-lookup"><span data-stu-id="57479-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="57479-295">在此情況下，執行階段的第一次通知程序終止的是 DLL_PROCESS_DETACH 通知。</span><span class="sxs-lookup"><span data-stu-id="57479-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="57479-296">執行階段會繼續在關機期間完成物件，只有當最終處理物件的數目會繼續減少時。</span><span class="sxs-lookup"><span data-stu-id="57479-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="57479-297">如果<xref:System.Object.Finalize%2A>或 覆寫<xref:System.Object.Finalize%2A>擲回例外狀況和執行階段不會覆寫預設原則的應用程式所裝載，因此執行階段終止程序並沒有作用`try` / `finally`區塊或執行完成項。</span><span class="sxs-lookup"><span data-stu-id="57479-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="57479-298">此行為可確保處理程序完整性，如果完成項無法釋放或終結資源。</span><span class="sxs-lookup"><span data-stu-id="57479-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="57479-299">覆寫 Finalize 方法</span><span class="sxs-lookup"><span data-stu-id="57479-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="57479-300">您應該覆寫<xref:System.Object.Finalize%2A>類別使用 unmanaged 的資源，例如檔案控制代碼或必須發行時使用這些 managed 的物件會在記憶體回收期間捨棄的資料庫連接。</span><span class="sxs-lookup"><span data-stu-id="57479-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="57479-301">您不應該實作<xref:System.Object.Finalize%2A>方法受管理物件，因為記憶體回收行程自動釋放 managed 的資源。</span><span class="sxs-lookup"><span data-stu-id="57479-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="57479-302">如果<xref:System.Runtime.InteropServices.SafeHandle>都有提供物件，包裝您的 unmanaged 的資源，建議的替代做法是實作使用安全控制代碼的處置模式，並不會覆寫<xref:System.Object.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="57479-303">如需詳細資訊，請參閱 < [SafeHandle 替代方法](#SafeHandle)一節。</span><span class="sxs-lookup"><span data-stu-id="57479-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="57479-304"><xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法則會根據預設，不執行任何動作，但您應該覆寫<xref:System.Object.Finalize%2A>才有必要，而且只釋放 unmanaged 的資源。</span><span class="sxs-lookup"><span data-stu-id="57479-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="57479-305">回收記憶體，通常需要更長，如果在執行最終處理作業，因為它需要至少兩個記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="57479-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="57479-306">此外，您應該覆寫<xref:System.Object.Finalize%2A>方法參考類型才。</span><span class="sxs-lookup"><span data-stu-id="57479-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="57479-307">Common language runtime 只完成參考型別。</span><span class="sxs-lookup"><span data-stu-id="57479-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="57479-308">它會忽略在實值型別上的完成項。</span><span class="sxs-lookup"><span data-stu-id="57479-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="57479-309">範圍<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法是`protected`。</span><span class="sxs-lookup"><span data-stu-id="57479-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="57479-310">當您在類別中覆寫方法時，您應該維護這個限定的範圍。</span><span class="sxs-lookup"><span data-stu-id="57479-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="57479-311">藉由讓保持<xref:System.Object.Finalize%2A>受保護的方法，防止使用者從呼叫物件的應用程式的<xref:System.Object.Finalize%2A>直接方法。</span><span class="sxs-lookup"><span data-stu-id="57479-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="57479-312">每個實作<xref:System.Object.Finalize%2A>衍生的型別必須呼叫其基底類型實作<xref:System.Object.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="57479-313">這是這類應用程式碼允許呼叫的唯一情況<xref:System.Object.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="57479-314">物件的<xref:System.Object.Finalize%2A>方法不應該在其基底類別以外的其他任何物件上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="57479-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="57479-315">這是因為被呼叫的其他物件收集同時作為呼叫物件時，例如在通用語言執行階段關機的情況下。</span><span class="sxs-lookup"><span data-stu-id="57479-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="57479-316">C# 編譯器不允許您覆寫<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="57479-317">相反地，您提供完成項方法是實作[解構函式](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)為您的類別。</span><span class="sxs-lookup"><span data-stu-id="57479-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="57479-318">C# 解構函式會自動呼叫其基底類別解構函式。</span><span class="sxs-lookup"><span data-stu-id="57479-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="57479-319">視覺化C++也提供自己的語法，來實作<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="57479-320">如需詳細資訊，請參閱 < 解構函式和完成項 > 一節[How to:定義和使用類別和結構 (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)。</span><span class="sxs-lookup"><span data-stu-id="57479-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="57479-321">因為記憶體回收是不具決定性，所以您不知道記憶體回收行程執行完成時。</span><span class="sxs-lookup"><span data-stu-id="57479-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="57479-322">若要釋出資源立即執行，您也可以選擇實作[處置模式](~/docs/standard/garbage-collection/implementing-dispose.md)而<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="57479-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="57479-323"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>實作可以呼叫您類別的取用者釋放 unmanaged 的資源，而且您可以使用<xref:System.Object.Finalize%2A>方法來釋放 unmanaged 的資源的情況<xref:System.IDisposable.Dispose%2A>不會呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="57479-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="57479-324"><xref:System.Object.Finalize%2A> 之後它已清除記憶體回收期間，可能需要幾乎任何動作，包括 resurrecting 物件 （也就，讓物件可存取一次）。</span><span class="sxs-lookup"><span data-stu-id="57479-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="57479-325">不過，該物件可以只復活一次;<xref:System.Object.Finalize%2A>和物件上無法呼叫記憶體回收期間。</span><span class="sxs-lookup"><span data-stu-id="57479-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span>
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="57479-326">SafeHandle 替代方法</span><span class="sxs-lookup"><span data-stu-id="57479-326">The SafeHandle alternative</span></span>  
 <span data-ttu-id="57479-327">建立可靠的完成項通常很困難，因為您不能假設您的應用程式的狀態相關，而且這類未處理系統例外狀況<xref:System.OutOfMemoryException>和<xref:System.StackOverflowException>終止完成項。</span><span class="sxs-lookup"><span data-stu-id="57479-327">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="57479-328">而不是實作您類別的完成項，表示釋放 unmanaged 的資源，您可以使用衍生自物件<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>類別來包裝 unmanaged 的資源，，然後再實作處置模式，而不需要完成項。</span><span class="sxs-lookup"><span data-stu-id="57479-328">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="57479-329">.NET Framework 提供的下列類別<xref:Microsoft.Win32?displayProperty=nameWithType>命名空間衍生自<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="57479-329">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="57479-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 是檔案控制代碼的包裝函式類別。</span><span class="sxs-lookup"><span data-stu-id="57479-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="57479-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 為記憶體對應檔案控制代碼的包裝函數類別。</span><span class="sxs-lookup"><span data-stu-id="57479-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="57479-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 是的 unmanaged 記憶體區塊指標的包裝函式類別。</span><span class="sxs-lookup"><span data-stu-id="57479-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="57479-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle><xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>，和<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>是適用於密碼編譯控制代碼的包裝函式類別。</span><span class="sxs-lookup"><span data-stu-id="57479-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="57479-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 是管道控制代碼的包裝函式類別。</span><span class="sxs-lookup"><span data-stu-id="57479-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="57479-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 是登錄機碼的控制代碼的包裝函式類別。</span><span class="sxs-lookup"><span data-stu-id="57479-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="57479-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 是的等候控制代碼的包裝函式類別。</span><span class="sxs-lookup"><span data-stu-id="57479-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="57479-337">下列範例會使用[處置模式](~/docs/standard/garbage-collection/implementing-dispose.md)使用安全控制代碼，而不是覆寫<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-337">The following example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="57479-338">它會定義`FileAssociation`類別，包裝的應用程式會處理具有特定副檔名的檔案相關的登錄資訊。</span><span class="sxs-lookup"><span data-stu-id="57479-338">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="57479-339">傳回兩個登錄控制代碼`out`由 Windows 參數[RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)函式呼叫會傳遞至<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>建構函式。</span><span class="sxs-lookup"><span data-stu-id="57479-339">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="57479-340">受保護的型別`Dispose`然後方法會呼叫`SafeRegistryHandle.Dispose`方法來釋放這些兩個控制代碼。</span><span class="sxs-lookup"><span data-stu-id="57479-340">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="57479-341">下列範例會確認<xref:System.Object.Finalize%2A>時，覆寫的物件呼叫方法<xref:System.Object.Finalize%2A>終結。</span><span class="sxs-lookup"><span data-stu-id="57479-341">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="57479-342">請注意，在生產環境應用程式中，<xref:System.Object.Finalize%2A>會覆寫方法，以釋放這個物件所持有的 unmanaged 的資源。</span><span class="sxs-lookup"><span data-stu-id="57479-342">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="57479-343">也請注意，C# 範例會提供解構函式，而不是覆寫<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-343">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="57479-344">如需其他範例，以覆寫<xref:System.Object.Finalize%2A>方法，請參閱<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-344">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57479-345">做為預設雜湊函式。</span><span class="sxs-lookup"><span data-stu-id="57479-345">Serves as the default hash function.</span></span></summary>
        <returns><span data-ttu-id="57479-346">目前物件的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-346">A hash code for the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-347">雜湊程式碼是用來插入及識別雜湊為基礎的集合中的物件，例如數值<xref:System.Collections.Generic.Dictionary%602>類別，<xref:System.Collections.Hashtable>類別或衍生自類型<xref:System.Collections.DictionaryBase>類別。</span><span class="sxs-lookup"><span data-stu-id="57479-347">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="57479-348"><xref:System.Object.GetHashCode%2A>方法會提供此雜湊程式碼需要快速檢查物件是否相等的演算法。</span><span class="sxs-lookup"><span data-stu-id="57479-348">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="57479-349">如需有關雜湊碼的雜湊表中的使用方式資訊以及一些額外的雜湊程式碼演算法，請參閱[雜湊函式](https://en.wikipedia.org/wiki/Hash_function)維基百科中的項目。</span><span class="sxs-lookup"><span data-stu-id="57479-349">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="57479-350">兩個物件相等的等於傳回的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-350">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="57479-351">不過，並非反之亦然： 相同的雜湊程式碼不會表示物件是否相等，因為不同 （相等） 的物件可以具有相同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-351">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="57479-352">此外，.NET 並不保證的預設實作<xref:System.Object.GetHashCode%2A>方法和這個方法所傳回的值可能不同.NET 實作，例如不同版本的.NET Framework 和.NET Core 和平台之間，例如 32 位元和64 位元平台。</span><span class="sxs-lookup"><span data-stu-id="57479-352">Furthermore, .NET does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET implementations, such as different versions of .NET Framework and .NET Core, and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="57479-353">基於這些理由，請勿使用這個方法的預設實作做為唯一的物件識別碼的雜湊的用途。</span><span class="sxs-lookup"><span data-stu-id="57479-353">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="57479-354">從這個，請依照下列兩種結果：</span><span class="sxs-lookup"><span data-stu-id="57479-354">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="57479-355">您不應該假設等於雜湊程式碼表示物件是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-355">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="57479-356">您應該永遠不會保存，或在其中建立應用程式定義域之外使用的雜湊碼，因為相同的物件可跨應用程式定義域、 處理程序，與平台雜湊。</span><span class="sxs-lookup"><span data-stu-id="57479-356">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="57479-357">雜湊程式碼適用於有效率的插入和雜湊資料表為基礎的集合中的查閱。</span><span class="sxs-lookup"><span data-stu-id="57479-357">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="57479-358">雜湊程式碼不是永久的值。</span><span class="sxs-lookup"><span data-stu-id="57479-358">A hash code is not a permanent value.</span></span> <span data-ttu-id="57479-359">基於此理由：</span><span class="sxs-lookup"><span data-stu-id="57479-359">For this reason:</span></span>  
>   
> -   <span data-ttu-id="57479-360">不要序列化雜湊程式碼的值，或將它們儲存在資料庫中。</span><span class="sxs-lookup"><span data-stu-id="57479-360">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="57479-361">請勿為索引鍵使用雜湊程式碼，若要從索引集合中擷取物件。</span><span class="sxs-lookup"><span data-stu-id="57479-361">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="57479-362">不要跨應用程式定義域或處理程序傳送雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-362">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="57479-363">在某些情況下，雜湊程式碼可能會計算每個處理序或每個應用程式定義域為基礎。</span><span class="sxs-lookup"><span data-stu-id="57479-363">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="57479-364">請勿使用雜湊程式碼而不是在您需要強式密碼編譯雜湊時密碼編譯雜湊函式所傳回的值。</span><span class="sxs-lookup"><span data-stu-id="57479-364">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="57479-365">密碼編譯雜湊，使用一個衍生自類別<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>類別。</span><span class="sxs-lookup"><span data-stu-id="57479-365">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="57479-366">不會測試相等的雜湊程式碼，以判斷兩個物件是否相等。</span><span class="sxs-lookup"><span data-stu-id="57479-366">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="57479-367">（不相等的物件可以有相同的雜湊程式碼）。若要測試是否相等，呼叫<xref:System.Object.ReferenceEquals%2A>或<xref:System.Object.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-367">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="57479-368"><xref:System.Object.GetHashCode%2A>衍生型別可覆寫方法。</span><span class="sxs-lookup"><span data-stu-id="57479-368">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="57479-369">如果<xref:System.Object.GetHashCode%2A>是不覆寫時，雜湊碼的參考型別會藉由呼叫計算<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>基底類別方法，會計算出雜湊程式碼以基礎物件的參考; 如需詳細資訊，請參閱<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-369">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="57479-370">也就是說，兩個物件的<xref:System.Object.ReferenceEquals%2A>方法會傳回`true`有相同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-370">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="57479-371">如果實值型別不會覆寫<xref:System.Object.GetHashCode%2A>，則<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>基底類別方法會使用反映來計算的類型欄位的值為基礎的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-371">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="57479-372">換句話說，其欄位具有相等值的實值型別具有相等的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-372">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="57479-373">如需有關覆寫<xref:System.Object.GetHashCode%2A>，請參閱 「 備忘稿繼承者 」 一節。</span><span class="sxs-lookup"><span data-stu-id="57479-373">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="57479-374">如果您覆寫<xref:System.Object.GetHashCode%2A>方法中，您也會覆寫<xref:System.Object.Equals%2A>，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="57479-374">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="57479-375">如果您覆寫<xref:System.Object.Equals%2A>方法會傳回`true`兩個物件是否相等，覆寫進行測試<xref:System.Object.GetHashCode%2A>方法必須傳回兩個物件相同的值。</span><span class="sxs-lookup"><span data-stu-id="57479-375">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="57479-376">如果當做索引鍵使用雜湊表中的物件不提供的有用實作<xref:System.Object.GetHashCode%2A>，您可以藉由提供指定的雜湊程式碼提供者<xref:System.Collections.IEqualityComparer>實作，以其中一個多載的<xref:System.Collections.Hashtable>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="57479-376">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="57479-377">資訊 [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="57479-377">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="57479-378">當您呼叫<xref:System.Object.GetHashCode%2A>中之類別的方法[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不會覆寫的類別提供的預設行為<xref:System.Object.GetHashCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-378">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="57479-379">這是.NET Framework 提供的支援之一[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱 < [.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。</span><span class="sxs-lookup"><span data-stu-id="57479-379">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="57479-380">中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且不要只實作目前<xref:System.Object.GetHashCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-380">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="57479-381">不過，它們似乎具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法時您用於您的 C# 或 Visual Basic 程式碼，和.NET Framework 會提供這些方法中的預設行為。</span><span class="sxs-lookup"><span data-stu-id="57479-381">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="57479-382">以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.GetHashCode%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-382">classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57479-383">其中一種最簡單的方式來計算相同或較小的範圍超過一個數字值的雜湊碼<xref:System.Int32>類型就是傳回該值。</span><span class="sxs-lookup"><span data-stu-id="57479-383">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="57479-384">下列範例示範這類實作的`Number`結構。</span><span class="sxs-lookup"><span data-stu-id="57479-384">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="57479-385">通常，型別具有可以參與產生雜湊程式碼的多個資料欄位。</span><span class="sxs-lookup"><span data-stu-id="57479-385">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="57479-386">產生的雜湊碼的一個方式是結合使用這些欄位`XOR (eXclusive OR)`作業，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="57479-386">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="57479-387">先前的範例會傳回相同的雜湊程式碼 (n1，n2) 和 (n2 n1)，因此可能會產生比令人期待的多個衝突。</span><span class="sxs-lookup"><span data-stu-id="57479-387">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="57479-388">許多解決方案可用，以便在這些情況下的雜湊程式碼並不相同。</span><span class="sxs-lookup"><span data-stu-id="57479-388">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="57479-389">其中是要傳回的雜湊碼`Tuple`物件，以反映每個欄位的順序。</span><span class="sxs-lookup"><span data-stu-id="57479-389">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="57479-390">下列範例顯示可能的實作使用<xref:System.Tuple%602>類別。</span><span class="sxs-lookup"><span data-stu-id="57479-390">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="57479-391">不過請注意，具現化的效能負荷`Tuple`物件可能會大幅影響儲存大量的物件雜湊資料表中的應用程式的整體效能。</span><span class="sxs-lookup"><span data-stu-id="57479-391">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="57479-392">第二個替代方案牽涉到藉由向左移位的後續欄位的雜湊碼由兩個或多個位元加權的個別的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-392">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="57479-393">以最佳方式，而不是被捨棄，超過 31 的位元移位的位元環繞而不會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="57479-393">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="57479-394">位元左移運算子，在 C# 和 Visual Basic 會捨棄，因為這需要建立左的 shift 包裝方法如下所示：</span><span class="sxs-lookup"><span data-stu-id="57479-394">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="57479-395">下列範例接著會使用這個 shift 包裝方法來計算的雜湊碼`Point`前一個範例中使用的結構。</span><span class="sxs-lookup"><span data-stu-id="57479-395">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="57479-396">雜湊函式用來快速產生數字 （雜湊程式碼），其對應於物件的值。</span><span class="sxs-lookup"><span data-stu-id="57479-396">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span></span> <span data-ttu-id="57479-397">雜湊函式通常專屬於每個類型，和唯一性，必須使用至少其中一個執行個體欄位做為輸入。</span><span class="sxs-lookup"><span data-stu-id="57479-397">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span></span> <span data-ttu-id="57479-398">使用靜態欄位的值時，應該不計算雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-398">Hash codes should not be computed by using the values of static fields.</span></span>  
  
<span data-ttu-id="57479-399">類別衍生自<see cref="T:System.Object" />，則<see langword="GetHashCode" />方法可以委派給基底類別<see cref="M:System.Object.GetHashCode" />衍生的類別會定義要參考相等的等號比較時，才實作。</span><span class="sxs-lookup"><span data-stu-id="57479-399">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span></span> <span data-ttu-id="57479-400">預設實作<see cref="M:System.Object.GetHashCode" />參考類型會傳回相當於所傳回的雜湊碼<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />方法。</span><span class="sxs-lookup"><span data-stu-id="57479-400">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span></span> <span data-ttu-id="57479-401">您可以覆寫<see cref="M:System.Object.GetHashCode" />不可變的參考型別。</span><span class="sxs-lookup"><span data-stu-id="57479-401">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span></span> <span data-ttu-id="57479-402">一般情況下，針對可變動參考類型，您應該會覆寫<see cref="M:System.Object.GetHashCode" />只有當：</span><span class="sxs-lookup"><span data-stu-id="57479-402">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span></span> 
<span data-ttu-id="57479-403">-您可以計算出雜湊程式碼，從欄位不是可變動;或</span><span class="sxs-lookup"><span data-stu-id="57479-403">-   You can compute the hash code from fields that are not mutable; or</span></span> 
<span data-ttu-id="57479-404">-您可以確保依賴其雜湊程式碼的集合中包含了該物件時，並不會變更可變動物件的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-404">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span></span>  
  
<span data-ttu-id="57479-405">否則，您可能會認為可變動的物件會遺失的雜湊表。</span><span class="sxs-lookup"><span data-stu-id="57479-405">Otherwise, you might think that the mutable object is lost in the hash table.</span></span> <span data-ttu-id="57479-406">如果您選擇要覆寫<see cref="M:System.Object.GetHashCode" />對於可變動參考類型，您的文件變得只有在您的型別的使用者不應該修改物件值，而此物件會儲存雜湊表中，清除。</span><span class="sxs-lookup"><span data-stu-id="57479-406">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span></span>  
  
<span data-ttu-id="57479-407">實值型別，<see cref="M:System.ValueType.GetHashCode" />提供使用反映的預設雜湊程式碼實作。</span><span class="sxs-lookup"><span data-stu-id="57479-407">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span></span> <span data-ttu-id="57479-408">您應該考慮覆寫它，以提升效能。</span><span class="sxs-lookup"><span data-stu-id="57479-408">You should consider overriding it for better performance.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="57479-409">如需詳細資訊和範例，計算雜湊碼的各種不同的方式，請參閱 &lt; 範例 &gt; 一節。</span><span class="sxs-lookup"><span data-stu-id="57479-409">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="57479-410">雜湊函式必須具有下列屬性：</span><span class="sxs-lookup"><span data-stu-id="57479-410">A hash function must have the following properties:</span></span> 
<span data-ttu-id="57479-411">-如果兩個物件的比較結果為相等，<see cref="M:System.Object.GetHashCode" />每個物件的方法必須傳回相同的值。</span><span class="sxs-lookup"><span data-stu-id="57479-411">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span></span> <span data-ttu-id="57479-412">不過，如果兩個物件不會比較為相等，<see cref="M:System.Object.GetHashCode" />兩個物件的方法沒有傳回不同的值。</span><span class="sxs-lookup"><span data-stu-id="57479-412">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span></span>  
  
<span data-ttu-id="57479-413">-<see cref="M:System.Object.GetHashCode" />物件的方法必須以一致的方式傳回相同雜湊程式碼，只要決定物件的傳回值的物件狀態進行任何修改[System.Object.Equals](xref:System.Object.Equals*)方法。</span><span class="sxs-lookup"><span data-stu-id="57479-413">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span></span> <span data-ttu-id="57479-414">請注意，這是僅適用於目前執行的應用程式時，是否再次執行應用程式，可能會傳回不同的雜湊程式碼。</span><span class="sxs-lookup"><span data-stu-id="57479-414">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span></span>  
  
<span data-ttu-id="57479-415">-針對最佳效能，雜湊函式應該產生的平均分配所有輸入，包括大量已叢集化的輸入。</span><span class="sxs-lookup"><span data-stu-id="57479-415">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span></span> <span data-ttu-id="57479-416">含意為，小幅修改以物件狀態應該會導致產生的雜湊程式碼中，為了達到最佳的雜湊資料表效能的大規模修改。</span><span class="sxs-lookup"><span data-stu-id="57479-416">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span></span>  
  
<span data-ttu-id="57479-417">雜湊函式應該便宜計算。</span><span class="sxs-lookup"><span data-stu-id="57479-417">-   Hash functions should be inexpensive to compute.</span></span>  
  
<span data-ttu-id="57479-418">-<see cref="M:System.Object.GetHashCode" />方法不應該擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="57479-418">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span></span>  
  
<span data-ttu-id="57479-419">比方說，實作<see cref="M:System.String.GetHashCode" />所提供的方法<see cref="T:System.String" />類別會傳回相同的字串值的完全相同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-419">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span></span> <span data-ttu-id="57479-420">因此，兩個<see cref="T:System.String" />物件傳回相同的雜湊程式碼，如果它們代表相同的字串值。</span><span class="sxs-lookup"><span data-stu-id="57479-420">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span></span> <span data-ttu-id="57479-421">此外，方法會使用所有的字元字串中產生合理地隨機散發的輸出，即使輸入叢集在特定範圍 (例如，許多使用者可能只包含較低 128 ASCII 字元，即使的字串字串可以包含任何 65,535 的 Unicode 字元）。</span><span class="sxs-lookup"><span data-stu-id="57479-421">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span></span>  
  
<span data-ttu-id="57479-422">在類別上提供良好的雜湊函式會大幅影響將這些物件加入至雜湊表的效能。</span><span class="sxs-lookup"><span data-stu-id="57479-422">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span></span> <span data-ttu-id="57479-423">中提供良好的雜湊函式實作的索引鍵的雜湊資料表，搜尋項目，將會採用常數時間 （例如，o （1） 作業）。</span><span class="sxs-lookup"><span data-stu-id="57479-423">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span></span> <span data-ttu-id="57479-424">中的雜湊函式的實作不佳的雜湊資料表，搜尋的效能取決於雜湊表中的項目數 (比方說，是 O (`n`) 作業，其中`n`是雜湊表中的項目數)。</span><span class="sxs-lookup"><span data-stu-id="57479-424">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span></span> <span data-ttu-id="57479-425">惡意使用者可以輸入，從而減少衝突發生，可能會大幅降低取決於雜湊表，在下列情況下的應用程式的效能資料：</span><span class="sxs-lookup"><span data-stu-id="57479-425">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span></span> 
<span data-ttu-id="57479-426">-當雜湊函式會產生頻繁的衝突。</span><span class="sxs-lookup"><span data-stu-id="57479-426">-   When hash functions produce frequent collisions.</span></span>  
  
<span data-ttu-id="57479-427">-當大部分的雜湊表中的物件會產生相等，或大約等於另一個雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="57479-427">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span></span>  
  
<span data-ttu-id="57479-428">-當使用者輸入要從中計算雜湊程式碼的資料。</span><span class="sxs-lookup"><span data-stu-id="57479-428">-   When users input the data from which the hash code is computed.</span></span>  
  
<span data-ttu-id="57479-429">衍生類別覆寫<see cref="M:System.Object.GetHashCode" />也必須覆寫<see cref="M:System.Object.Equals(System.Object)" />若要保證視為相等的兩個物件具有相同的雜湊程式碼; 否則<see cref="T:System.Collections.Hashtable" />類型可能無法正常運作。</span><span class="sxs-lookup"><span data-stu-id="57479-429">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span></span></para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57479-430">取得目前執行個體的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="57479-430">Gets the <see cref="T:System.Type" /> of the current instance.</span></span></summary>
        <returns><span data-ttu-id="57479-431">目前執行個體的確切執行階段類型。</span><span class="sxs-lookup"><span data-stu-id="57479-431">The exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-432">因為<xref:System.Object?displayProperty=nameWithType>是基底類別，在.NET 中的所有類型中，輸入系統<xref:System.Object.GetType%2A>方法可以用來傳回<xref:System.Type>代表所有的.NET 類型的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-432">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET types.</span></span> <span data-ttu-id="57479-433">.NET 可辨識下列五種型別：</span><span class="sxs-lookup"><span data-stu-id="57479-433">.NET recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="57479-434">類別，衍生自<xref:System.Object?displayProperty=nameWithType>，</span><span class="sxs-lookup"><span data-stu-id="57479-434">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="57479-435">實值型別，衍生自<xref:System.ValueType?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-435">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="57479-436">介面衍生自<xref:System.Object?displayProperty=nameWithType>從.NET Framework 2.0 開始。</span><span class="sxs-lookup"><span data-stu-id="57479-436">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="57479-437">列舉型別，衍生自<xref:System.Enum?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-437">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="57479-438">委派，衍生自<xref:System.MulticastDelegate?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-438">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="57479-439">兩個物件`x`並`y`具有相同的執行階段類型`Object.ReferenceEquals(x.GetType(),y.GetType())`傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="57479-439">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="57479-440">下列範例會使用<xref:System.Object.GetType%2A>方法使用<xref:System.Object.ReferenceEquals%2A>方法來判斷兩個數值是否為兩個數字的值相同的型別。</span><span class="sxs-lookup"><span data-stu-id="57479-440">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="57479-441">若要判斷物件是否為特定的型別，您可以使用您語言的型別比較關鍵字，或建構。</span><span class="sxs-lookup"><span data-stu-id="57479-441">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="57479-442">例如，您可以使用`TypeOf…Is`在 Visual Basic 中建構或`is`C# 中的關鍵字。</span><span class="sxs-lookup"><span data-stu-id="57479-442">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="57479-443"><xref:System.Object.GetType%2A>方法繼承自所有的型別衍生自<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="57479-443">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="57479-444">這表示，除了使用您自己的語言比較關鍵字，您可以使用<xref:System.Object.GetType%2A>方法，以判斷特定物件的型別，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="57479-444">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="57479-445"><xref:System.Type>物件會公開目前的類別相關聯的中繼資料<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="57479-445">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57479-446">下列程式碼範例示範<xref:System.Object.GetType%2A>傳回目前的執行個體的執行階段類型。</span><span class="sxs-lookup"><span data-stu-id="57479-446">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57479-447">建立目前 <see cref="T:System.Object" /> 的淺層複製。</span><span class="sxs-lookup"><span data-stu-id="57479-447">Creates a shallow copy of the current <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="57479-448">目前 <see cref="T:System.Object" /> 的淺層複製。</span><span class="sxs-lookup"><span data-stu-id="57479-448">A shallow copy of the current <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-449"><xref:System.Object.MemberwiseClone%2A>方法藉由建立新的物件，並再將目前物件的非靜態欄位複製到新的物件建立淺層複本。</span><span class="sxs-lookup"><span data-stu-id="57479-449">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="57479-450">如果欄位是實值型別，則會執行位元欄位的複本。</span><span class="sxs-lookup"><span data-stu-id="57479-450">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="57479-451">如果欄位是參考型別，則會複製參考，但參考的物件不;因此，原始的物件和其複製品參考相同的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-451">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="57479-452">例如，假設物件 x。 接著，參考物件 A 和 B 參考物件 c。X 的淺層複本建立新物件，X2，也會參考物件 A 和 b。相反地，X 的深層複本建立新物件 X2 A2 和 B2，也就是 A 的複本的新物件和 B.B2，則是參照新物件 C2，也就是一份 c。此範例說明 shallow 和深層複製作業之間的差異。</span><span class="sxs-lookup"><span data-stu-id="57479-452">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="57479-453">有多種方法來實作深層複製作業，如果藉由執行淺層複製作業<xref:System.Object.MemberwiseClone%2A>方法不符合您的需求。</span><span class="sxs-lookup"><span data-stu-id="57479-453">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="57479-454">這些需求包括下列各項：</span><span class="sxs-lookup"><span data-stu-id="57479-454">These include the following:</span></span>  
  
-   <span data-ttu-id="57479-455">呼叫類別建構函式複製到使用取自第一個物件的屬性值中建立第二個物件的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-455">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="57479-456">這是假設物件的值完全由其類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="57479-456">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="57479-457">呼叫<xref:System.Object.MemberwiseClone%2A>建立物件的淺層複本，然後將指派其值會與原始物件的任何屬性或欄位的值是參考型別相同的新物件的方法。</span><span class="sxs-lookup"><span data-stu-id="57479-457">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="57479-458">`DeepCopy`方法在此範例說明此方法。</span><span class="sxs-lookup"><span data-stu-id="57479-458">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="57479-459">序列化物件是深層複製，然後還原序列化的資料給不同的物件變數。</span><span class="sxs-lookup"><span data-stu-id="57479-459">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="57479-460">使用反映進行遞迴時，以執行深層複製作業。</span><span class="sxs-lookup"><span data-stu-id="57479-460">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57479-461">下列範例說明<xref:System.Object.MemberwiseClone%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-461">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="57479-462">它會定義`ShallowCopy`方法，以呼叫<xref:System.Object.MemberwiseClone%2A>方法來執行淺層複製作業`Person`物件。</span><span class="sxs-lookup"><span data-stu-id="57479-462">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="57479-463">它也會定義`DeepCopy`執行深層複製作業的方法`Person`物件。</span><span class="sxs-lookup"><span data-stu-id="57479-463">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="57479-464">在此範例中，`Person.IdInfo`屬性會傳回`IdInfo`物件。</span><span class="sxs-lookup"><span data-stu-id="57479-464">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="57479-465">如輸出所範例所示，當`Person`物件會複製藉由呼叫<xref:System.Object.MemberwiseClone%2A>方法中，複製`Person`物件是原始物件，而的獨立複本，不同之處在於它們會共用相同`Person.IdInfo`物件參考。</span><span class="sxs-lookup"><span data-stu-id="57479-465">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="57479-466">如此一來，修改 clone`Person.IdInfo`屬性變更時，原始物件的`Person.IdInfo`屬性。</span><span class="sxs-lookup"><span data-stu-id="57479-466">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="57479-467">相反地，深層複製作業執行時，複製`Person`物件，包括其`Person.IdInfo`可以修改屬性，而不會影響原始物件。</span><span class="sxs-lookup"><span data-stu-id="57479-467">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="57479-468">要比較的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="57479-468">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="57479-469">要比較的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="57479-469">The second object  to compare.</span></span></param>
        <summary><span data-ttu-id="57479-470">判斷指定的 <see cref="T:System.Object" /> 執行個體是否為相同的執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-470">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span></span></summary>
        <returns><span data-ttu-id="57479-471">如果 <paramref name="objA" /> 與 <paramref name="objB" /> 為相同的執行個體或兩者皆為 **null**，則為 <see langword="true" />否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="57479-471"><see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-472">不同於<xref:System.Object.Equals%2A>方法，並使用等號比較運算子，<xref:System.Object.ReferenceEquals%2A>無法覆寫方法。</span><span class="sxs-lookup"><span data-stu-id="57479-472">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="57479-473">因為這個緣故，如果您想要測試兩個物件是否相等的參考，但不確定的實作而分心`Equals`方法中，您可以呼叫<xref:System.Object.ReferenceEquals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-473">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="57479-474">不過，傳回值<xref:System.Object.ReferenceEquals%2A>方法可能會出現在這兩種案例中的異常：</span><span class="sxs-lookup"><span data-stu-id="57479-474">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="57479-475">當比較實值型別。</span><span class="sxs-lookup"><span data-stu-id="57479-475">When comparing value types.</span></span> <span data-ttu-id="57479-476">如果`objA`並`objB`是實值類型，它們會進行 boxed 處理之前傳遞至<xref:System.Object.ReferenceEquals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-476">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="57479-477">這表示，如果這兩個`objA`並`objB`代表相同的執行個體的實值型別<xref:System.Object.ReferenceEquals%2A>方法卻傳回`false`，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="57479-477">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="57479-478">如需 boxing 實值型別資訊，請參閱[Boxing 和 Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)。</span><span class="sxs-lookup"><span data-stu-id="57479-478">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="57479-479">當比較字串。</span><span class="sxs-lookup"><span data-stu-id="57479-479">When comparing strings.</span></span> <span data-ttu-id="57479-480">如果`objA`並`objB`都是字串，<xref:System.Object.ReferenceEquals%2A>方法會傳回`true`如果字串暫留。</span><span class="sxs-lookup"><span data-stu-id="57479-480">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="57479-481">它不會執行測試的值相等。</span><span class="sxs-lookup"><span data-stu-id="57479-481">It does not perform a test for value equality.</span></span>  <span data-ttu-id="57479-482">在下列範例中，`s1`和`s2`相等，因為它們是兩個執行個體的單一保留的字串。</span><span class="sxs-lookup"><span data-stu-id="57479-482">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="57479-483">不過，`s3`和`s4`不相等，因為它們都有相同的字串值，雖然未保留該字串。</span><span class="sxs-lookup"><span data-stu-id="57479-483">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="57479-484">如需有關字串拘留的詳細資訊，請參閱<xref:System.String.IsInterned%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-484">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57479-485">下列範例會使用<xref:System.Object.ReferenceEquals%2A>，判斷兩個物件是否相同的執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-485">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57479-486">傳回代表目前物件的字串。</span><span class="sxs-lookup"><span data-stu-id="57479-486">Returns a string that represents the current object.</span></span></summary>
        <returns><span data-ttu-id="57479-487">表示目前物件的字串。</span><span class="sxs-lookup"><span data-stu-id="57479-487">A string that represents the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57479-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> 主要格式設定.NET Framework 中的方法。</span><span class="sxs-lookup"><span data-stu-id="57479-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="57479-489">使其適合顯示，它可以轉換為其字串表示的物件。</span><span class="sxs-lookup"><span data-stu-id="57479-489">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="57479-490">(如需.NET Framework 中的支援的格式資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。)預設實作<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法傳回的物件型別的完整的名稱。</span><span class="sxs-lookup"><span data-stu-id="57479-490">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="57479-491">您可以依照下列連結，從另一種類型的成員清單到達此頁面。</span><span class="sxs-lookup"><span data-stu-id="57479-491">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="57479-492">這是因為該類型不覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-492">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="57479-493">相反地，它所繼承的功能<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-493">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="57479-494">經常覆寫類型<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以提供更適合的字串表示，特定的類型。</span><span class="sxs-lookup"><span data-stu-id="57479-494">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="57479-495">型別也經常多載<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以提供支援的格式字串，或區分文化特性格式。</span><span class="sxs-lookup"><span data-stu-id="57479-495">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="57479-496">本節內容：</span><span class="sxs-lookup"><span data-stu-id="57479-496">In this section:</span></span>  
  
 <span data-ttu-id="57479-497">[預設 object.tostring （） 方法](#Default) </span><span class="sxs-lookup"><span data-stu-id="57479-497">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="57479-498">[覆寫 object.tostring （） 方法](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="57479-498">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="57479-499">[ToString 方法多載化](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="57479-499">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="57479-500">[擴充 Object.ToString 方法](#Extending) </span><span class="sxs-lookup"><span data-stu-id="57479-500">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="57479-501">Windows 執行階段的相關資訊</span><span class="sxs-lookup"><span data-stu-id="57479-501">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="57479-502">預設 object.tostring （） 方法</span><span class="sxs-lookup"><span data-stu-id="57479-502">The default Object.ToString() method</span></span>  
 <span data-ttu-id="57479-503">預設實作<xref:System.Object.ToString%2A>方法會傳回之型別的完整格式的名稱<xref:System.Object>，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="57479-503">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="57479-504">因為<xref:System.Object>的基底類別的所有參考型別在.NET Framework 中，此行為由參考型別，不會覆寫繼承<xref:System.Object.ToString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-504">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="57479-505">下列範例將說明這點。</span><span class="sxs-lookup"><span data-stu-id="57479-505">The following example illustrates this.</span></span> <span data-ttu-id="57479-506">它會定義名為類別`Object1`它會接受所有的預設實作<xref:System.Object>成員。</span><span class="sxs-lookup"><span data-stu-id="57479-506">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="57479-507">其<xref:System.Object.ToString%2A>方法會傳回物件的完整型別名稱。</span><span class="sxs-lookup"><span data-stu-id="57479-507">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="57479-508">覆寫 object.tostring （） 方法</span><span class="sxs-lookup"><span data-stu-id="57479-508">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="57479-509">型別通常覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法來傳回字串，表示物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-509">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="57479-510">例如，基底類型，例如<xref:System.Char>， <xref:System.Int32>，並<xref:System.String>提供<xref:System.Object.ToString%2A>傳回該物件所代表之值的字串形式的實作。</span><span class="sxs-lookup"><span data-stu-id="57479-510">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="57479-511">下列範例會定義類別`Object2`，會覆寫<xref:System.Object.ToString%2A>方法，以傳回型別名稱和其值。</span><span class="sxs-lookup"><span data-stu-id="57479-511">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="57479-512">下表列出.NET 中的類型分類，並指出是否在覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-512">The following table lists the type categories in .NET and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="57479-513">型別分類</span><span class="sxs-lookup"><span data-stu-id="57479-513">Type category</span></span>|<span data-ttu-id="57479-514">Overrides Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="57479-514">Overrides Object.ToString()</span></span>|<span data-ttu-id="57479-515">行為</span><span class="sxs-lookup"><span data-stu-id="57479-515">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="57479-516">類別</span><span class="sxs-lookup"><span data-stu-id="57479-516">Class</span></span>|<span data-ttu-id="57479-517">N/A</span><span class="sxs-lookup"><span data-stu-id="57479-517">n/a</span></span>|<span data-ttu-id="57479-518">N/A</span><span class="sxs-lookup"><span data-stu-id="57479-518">n/a</span></span>|  
|<span data-ttu-id="57479-519">結構</span><span class="sxs-lookup"><span data-stu-id="57479-519">Structure</span></span>|<span data-ttu-id="57479-520">[是] (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="57479-520">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="57479-521">與 `Object.ToString()` 相同</span><span class="sxs-lookup"><span data-stu-id="57479-521">Same as `Object.ToString()`</span></span>|  
|<span data-ttu-id="57479-522">列舉</span><span class="sxs-lookup"><span data-stu-id="57479-522">Enumeration</span></span>|<span data-ttu-id="57479-523">[是] (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="57479-523">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="57479-524">成員名稱</span><span class="sxs-lookup"><span data-stu-id="57479-524">The member name</span></span>|  
|<span data-ttu-id="57479-525">介面</span><span class="sxs-lookup"><span data-stu-id="57479-525">Interface</span></span>|<span data-ttu-id="57479-526">否</span><span class="sxs-lookup"><span data-stu-id="57479-526">No</span></span>|<span data-ttu-id="57479-527">N/A</span><span class="sxs-lookup"><span data-stu-id="57479-527">n/a</span></span>|  
|<span data-ttu-id="57479-528">Delegate - 委派</span><span class="sxs-lookup"><span data-stu-id="57479-528">Delegate</span></span>|<span data-ttu-id="57479-529">否</span><span class="sxs-lookup"><span data-stu-id="57479-529">No</span></span>|<span data-ttu-id="57479-530">N/A</span><span class="sxs-lookup"><span data-stu-id="57479-530">n/a</span></span>|  
  
 <span data-ttu-id="57479-531">請參閱注意事項繼承者注意事項 > 一節，如需詳細資訊，在覆寫<xref:System.Object.ToString%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-531">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="57479-532">ToString 方法多載化</span><span class="sxs-lookup"><span data-stu-id="57479-532">Overloading the ToString method</span></span>  
 <span data-ttu-id="57479-533">除了無參數的覆寫<xref:System.Object.ToString?displayProperty=nameWithType>方法中，許多型別多載`ToString`方法，以提供的方法接受參數的版本。</span><span class="sxs-lookup"><span data-stu-id="57479-533">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="57479-534">大多數情況下，這是為了提供變數的格式和區分文化特性的格式化支援。</span><span class="sxs-lookup"><span data-stu-id="57479-534">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="57479-535">下列範例會多載`ToString`方法，以傳回結果字串，其中包含的各種欄位的值`Automobile`類別。</span><span class="sxs-lookup"><span data-stu-id="57479-535">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="57479-536">它會定義四個格式字串：G，會傳回年份; 與模型名稱D，傳回模型名稱、 年和機門; 數目C，傳回模型名稱、 年的磁柱; 數目和 A，它會傳回所有的四個欄位值的字串。</span><span class="sxs-lookup"><span data-stu-id="57479-536">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="57479-537">下列範例會呼叫多載<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法來顯示文化特性的貨幣值的格式。</span><span class="sxs-lookup"><span data-stu-id="57479-537">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="57479-538">如需有關格式字串和文化特性格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。</span><span class="sxs-lookup"><span data-stu-id="57479-538">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="57479-539">針對支援的數值格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="57479-539">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="57479-540">支援的日期和時間值的格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="57479-540">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="57479-541">擴充 Object.ToString 方法</span><span class="sxs-lookup"><span data-stu-id="57479-541">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="57479-542">因為型別會繼承預設<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法中，您可以找到它的行為不想要並想要加以變更。</span><span class="sxs-lookup"><span data-stu-id="57479-542">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="57479-543">這是特別的陣列和集合類別。</span><span class="sxs-lookup"><span data-stu-id="57479-543">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="57479-544">雖然您可能會預期`ToString`方法的陣列或集合類別，以顯示其成員的值，它改為顯示類型的完整型別名稱，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="57479-544">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="57479-545">您有數個選項，以產生您想要的結果字串。</span><span class="sxs-lookup"><span data-stu-id="57479-545">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="57479-546">如果類型是陣列、 集合物件或該物件會實作<xref:System.Collections.IEnumerable>或是<xref:System.Collections.Generic.IEnumerable%601>介面，您可以使用，以列舉其項目`foreach`C# 中的陳述式或`For Each...Next`建構在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="57479-546">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="57479-547">如果類別不是`sealed`（在 C# 中) 或`NotInheritable`（在 Visual Basic 中)，您可以開發其繼承自基底類別的包裝函數類別<xref:System.Object.ToString%2A?displayProperty=nameWithType>您想要自訂的方法。</span><span class="sxs-lookup"><span data-stu-id="57479-547">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="57479-548">至少，這需要您下列：</span><span class="sxs-lookup"><span data-stu-id="57479-548">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="57479-549">實作任何所需的建構函式。</span><span class="sxs-lookup"><span data-stu-id="57479-549">Implement any necessary constructors.</span></span> <span data-ttu-id="57479-550">在衍生的類別不會繼承其基底類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="57479-550">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="57479-551">覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以傳回您想要的結果字串。</span><span class="sxs-lookup"><span data-stu-id="57479-551">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="57479-552">下列範例會定義包裝函式類別<xref:System.Collections.Generic.List%601>類別。</span><span class="sxs-lookup"><span data-stu-id="57479-552">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="57479-553">它會覆寫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以顯示每個方法的集合，而不是完整的類型名稱的值。</span><span class="sxs-lookup"><span data-stu-id="57479-553">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="57479-554">開發[擴充方法](~/docs/standard/design-guidelines/extension-methods.md)傳回您想要的結果字串。</span><span class="sxs-lookup"><span data-stu-id="57479-554">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="57479-555">請注意，您無法覆寫預設值<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，以這種方式 (也就是您的延伸模組類別 （在 C# 中) 或 （在 Visual Basic) 的模組不能有一個名為的無參數方法`ToString`呼叫取代原始的型別`ToString`方法.</span><span class="sxs-lookup"><span data-stu-id="57479-555">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="57479-556">您必須提供一些其他的程式無參數的名稱，`ToString`取代。</span><span class="sxs-lookup"><span data-stu-id="57479-556">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="57479-557">下列範例會定義兩個方法，擴充<xref:System.Collections.Generic.List%601>類別： 無參數`ToString2`方法，並`ToString`方法<xref:System.String>表示格式字串參數。</span><span class="sxs-lookup"><span data-stu-id="57479-557">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="57479-558">資訊 [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="57479-558">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="57479-559">當您呼叫<xref:System.Object.ToString%2A>中之類別的方法[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不會覆寫的類別提供的預設行為<xref:System.Object.ToString%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-559">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="57479-560">這是.NET Framework 提供的支援之一[!INCLUDE[wrt](~/includes/wrt-md.md)](請參閱 < [.NET Framework 支援的 Windows 市集應用程式和 Windows 執行階段](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。</span><span class="sxs-lookup"><span data-stu-id="57479-560">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="57479-561">中的類別[!INCLUDE[wrt](~/includes/wrt-md.md)]不繼承<xref:System.Object>，且永遠不要只實作<xref:System.Object.ToString%2A>。</span><span class="sxs-lookup"><span data-stu-id="57479-561">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="57479-562">不過，它們一律出現有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法時您用於您的 C# 或 Visual Basic 程式碼，和.NET Framework 會提供這些方法中的預設行為。</span><span class="sxs-lookup"><span data-stu-id="57479-562">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="57479-563">開頭[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，將會使用 common language runtime [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)上[!INCLUDE[wrt](~/includes/wrt-md.md)]再切換回預設實作的物件<xref:System.Object.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-563">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="57479-564">以 C# 或 Visual Basic 撰寫的類別可以覆寫<xref:System.Object.ToString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="57479-564">classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="57479-565">[!INCLUDE[wrt](~/includes/wrt-md.md)]和 IStringable 介面</span><span class="sxs-lookup"><span data-stu-id="57479-565">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="57479-566">開頭[!INCLUDE[win81](~/includes/win81-md.md)]，則[!INCLUDE[wrt](~/includes/wrt-md.md)]包含[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面方法[IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)，提供基本格式支援能夠與所提供<xref:System.Object.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="57479-566">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="57479-567">若要避免模稜兩可，您不應該實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) managed 類型上。</span><span class="sxs-lookup"><span data-stu-id="57479-567">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="57479-568">受管理的物件由原生程式碼或以 JavaScript 或 C + 等語言撰寫的程式碼的呼叫時 + /CX 中，看起來就像實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。</span><span class="sxs-lookup"><span data-stu-id="57479-568">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="57479-569">Common language runtime 會自動將路由來電[IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)要<xref:System.Object.ToString%2A?displayProperty=nameWithType>在事件[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)上受管理的物件未實作。</span><span class="sxs-lookup"><span data-stu-id="57479-569">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="57479-570">因為 common language runtime 自動實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)所有受管理中的型別[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]應用程式，我們建議您不要不提供您自己[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)實作。</span><span class="sxs-lookup"><span data-stu-id="57479-570">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="57479-571">實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)呼叫時，可能會導致非預期的行為`ToString`從[!INCLUDE[wrt](~/includes/wrt-md.md)]， C++/CX 或 JavaScript。</span><span class="sxs-lookup"><span data-stu-id="57479-571">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="57479-572">如果您選擇實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)匯出在公用 managed 類型中[!INCLUDE[wrt](~/includes/wrt-md.md)]元件，適用下列限制：</span><span class="sxs-lookup"><span data-stu-id="57479-572">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="57479-573">您可以定義[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面只能在 「 類別實作 」 關聯性，例如</span><span class="sxs-lookup"><span data-stu-id="57479-573">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="57479-574">在 C# 中，或</span><span class="sxs-lookup"><span data-stu-id="57479-574">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="57479-575">在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="57479-575">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="57479-576">您不能實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)介面上。</span><span class="sxs-lookup"><span data-stu-id="57479-576">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="57479-577">您不能宣告為類型參數[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。</span><span class="sxs-lookup"><span data-stu-id="57479-577">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="57479-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)不可為方法、 屬性或欄位的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="57479-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="57479-579">您無法隱藏您[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)實作基底類別使用的方法定義，如下所示：</span><span class="sxs-lookup"><span data-stu-id="57479-579">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="57479-580">相反地， [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)實作一律必須覆寫基底類別實作。</span><span class="sxs-lookup"><span data-stu-id="57479-580">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="57479-581">您只能藉由針對強型別類別執行個體叫用 `ToString` 實作來隱藏該實作。</span><span class="sxs-lookup"><span data-stu-id="57479-581">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="57479-582">請注意，在各種不同的條件，從原生程式碼於 managed 類型可實作[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)或隱藏其[ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)實作可能會產生非預期的行為。</span><span class="sxs-lookup"><span data-stu-id="57479-582">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="57479-583">當您實作您自己的類型時，您應該覆寫<see cref="M:System.Object.ToString" />方法傳回對於這些類型有意義的值。</span><span class="sxs-lookup"><span data-stu-id="57479-583">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span></span> <span data-ttu-id="57479-584">衍生的類別需要更充分掌控格式比<see cref="M:System.Object.ToString" />提供可實作<see cref="T:System.IFormattable" />介面。</span><span class="sxs-lookup"><span data-stu-id="57479-584">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span></span> <span data-ttu-id="57479-585">其<see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />方法可讓您定義控制格式的格式字串，並使用<see cref="T:System.IFormatProvider" />可以提供特定文化特性的格式化物件。</span><span class="sxs-lookup"><span data-stu-id="57479-585">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span></span>  
  
<span data-ttu-id="57479-586">覆寫<see cref="M:System.Object.ToString" />方法應遵循這些指導方針：</span><span class="sxs-lookup"><span data-stu-id="57479-586">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span></span> 
<span data-ttu-id="57479-587">-傳回的字串應該是易記而讓人判讀。</span><span class="sxs-lookup"><span data-stu-id="57479-587">-   The returned string should be friendly and readable by humans.</span></span>  
  
<span data-ttu-id="57479-588">-傳回的字串應專門用於識別物件的執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="57479-588">-   The returned string should uniquely identify the value of the object instance.</span></span>  
  
<span data-ttu-id="57479-589">-傳回的字串應該越短越好，使其適用於偵錯工具的顯示。</span><span class="sxs-lookup"><span data-stu-id="57479-589">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span></span>  
  
<span data-ttu-id="57479-590">-您<see cref="M:System.Object.ToString" />覆寫不應該傳回<see cref="F:System.String.Empty" />或 null 字串。</span><span class="sxs-lookup"><span data-stu-id="57479-590">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span></span>  
  
<span data-ttu-id="57479-591">-您<see cref="M:System.Object.ToString" />覆寫不應該擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="57479-591">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span></span>  
  
<span data-ttu-id="57479-592">-如果執行個體的字串表示區分文化特性，或可以多種方式進行格式化，實作<see cref="T:System.IFormattable" />介面。</span><span class="sxs-lookup"><span data-stu-id="57479-592">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span></span>  
  
<span data-ttu-id="57479-593">-如果傳回的字串會包含機密資訊，您應該先要求適當的權限。</span><span class="sxs-lookup"><span data-stu-id="57479-593">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span></span> <span data-ttu-id="57479-594">如果要求成功，您可以傳回機密的資訊;否則，您應該傳回排除機密資訊的字串。</span><span class="sxs-lookup"><span data-stu-id="57479-594">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span></span>  
  
<span data-ttu-id="57479-595">-您<see cref="M:System.Object.ToString" />覆寫應該沒有任何可預見的副作用以避免在偵錯的複雜性。</span><span class="sxs-lookup"><span data-stu-id="57479-595">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span></span> <span data-ttu-id="57479-596">例如，若要呼叫<see cref="M:System.Object.ToString" />方法不應該變更執行個體欄位的值。</span><span class="sxs-lookup"><span data-stu-id="57479-596">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span></span>  
  
<span data-ttu-id="57479-597">-如果您的型別實作的剖析方法 (或<see langword="Parse" />或是<see langword="TryParse" />方法、 建構函式或其他靜態方法，從字串型別的執行個體具現化)，您應該確保所傳回的字串<see cref="M:System.Object.ToString" />方法可以是轉換成物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="57479-597">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span></span></para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="57479-598">在 .NET 中將類型格式化</span><span class="sxs-lookup"><span data-stu-id="57479-598">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
