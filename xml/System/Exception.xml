<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3cd7feda3f45d855645a0e6ecb699bd9f871df9" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34254657" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表應用程式執行期間所發生的錯誤。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別是所有例外狀況的基底類別。 發生錯誤時，系統或目前正在執行的應用程式報告它藉由擲回例外狀況，其中包含錯誤的相關資訊。 擲回例外狀況之後，就會處理應用程式或預設的例外狀況處理常式。  
  
 本節內容：  
  
 [錯誤和例外狀況](#Errors)   
 [Try/catch 區塊](#TryCatch)   
 [例外狀況類型的功能](#Features)   
 [例外狀況類別屬性](#Properties)   
 [效能考量](#Performance)   
 [重新擲回例外狀況](#Rethrow)   
 [選擇標準例外狀況](#Standard)   
 [實作自訂例外狀況](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>錯誤和例外狀況  
 有許多原因可能會發生執行階段錯誤。 不過，並非所有的錯誤應該處理為您的程式碼中的例外狀況。 以下是可以在執行的階段和適當的方式來回應這些發生之錯誤的某些類別目錄。  
  
-   **使用方式錯誤。** 使用方式錯誤表示可能會導致例外狀況的程式邏輯中的錯誤。 不過，不能透過例外狀況處理，但藉由修改程式碼，應該解決錯誤。 例如的覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，在下列範例會假設`obj`引數必須永遠為非 null。  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException>所產生例外狀況時`obj`是`null`可以藉由修改原始程式碼，以明確地測試是否為 null，然後再呼叫排除<xref:System.Object.Equals%2A?displayProperty=nameWithType>覆寫和重新編譯。 下列範例包含已更正的原始程式碼處理`null`引數。  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     而不是使用使用方式錯誤的例外狀況處理，您可以使用<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType>方法，以找出在偵錯組建的使用方式錯誤和<xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType>方法，以識別使用方式錯誤偵錯和發行組建。 如需詳細資訊，請參閱[Managed 程式碼中的判斷提示](/visualstudio/debugger/assertions-in-managed-code)。  
  
-   **程式錯誤。** 程式錯誤是一定無法避免撰寫無錯誤的程式碼的執行階段錯誤。  
  
     在某些情況下，程式錯誤一定能反映預期或常式錯誤狀況。 在此情況下，您可能想要避免使用例外狀況處理來處理程式錯誤並改用重試操作。 例如，如果使用者只需要輸入特定格式的日期，您可以剖析日期字串藉由呼叫<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法，這個方法會傳回<xref:System.Boolean>值，指出是否剖析作業成功，而不是使用<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法，就會擲回<xref:System.FormatException>例外狀況，如果日期字串無法轉換成<xref:System.DateTime>值。 同樣地，如果使用者嘗試開啟不存在的檔案，您可以先呼叫<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>方法來檢查檔案是否存在，然後，如果沒有出現，請提示使用者是否想要建立它。  
  
     在其他情況下，程式錯誤會反映您的程式碼中可處理預期的錯誤狀況。 比方說，即使在您檢查檔案存在，它可能會遭到刪除之前，您可以開啟它，或它可能已損毀。 在此情況下，嘗試開啟檔案，藉由執行個體化<xref:System.IO.StreamReader>物件或呼叫<xref:System.IO.File.Open%2A>方法可能會擲回<xref:System.IO.FileNotFoundException>例外狀況。 在這些情況下，您應該使用例外狀況處理來從錯誤中復原。  
  
-   **系統失敗。** 在系統失敗是無法以程式設計的方式有意義的方式處理執行階段錯誤。 例如，任何方法可以擲回<xref:System.OutOfMemoryException>例外狀況，如果 common language runtime 無法配置額外的記憶體。 一般情況下，使用例外狀況處理不處理系統失敗。 相反地，您可以使用事件，例如<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>呼叫<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>記錄例外狀況資訊，並通知使用者失敗的應用程式終止前的方法。  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try/catch 區塊  
 Common language runtime 提供的例外狀況處理模型為基礎的例外狀況為物件，表示法和的程式碼和例外狀況處理程式碼到分隔`try`區塊和`catch`區塊。 可以有一或多個`catch`封鎖，每個設計用來處理特定類型的例外狀況或一個設計用來攔截更特定的例外狀況，比另一個區塊的區塊。  
  
 如果應用程式處理的應用程式程式碼執行期間所發生的例外狀況，程式碼必須放置內`try`陳述式，稱為`try`區塊。 應用程式程式碼會處理所擲回的例外狀況`try`區塊放在`catch`陳述式，稱為`catch`區塊。 零或多個`catch`區塊相關聯`try`區塊，以及每個`catch`區塊包含一個會決定它所處理的例外狀況類型的型別篩選。  
  
 中的例外狀況發生時就`try`區塊中，系統會搜尋相關聯`catch`區塊，直到找出應用程式程式碼中出現的順序以`catch`區塊處理例外狀況。 A`catch`區塊處理的例外狀況型別的`T`如果指定的 catch 區塊型別篩選`T`或任何類型的`T`衍生自。 系統會停止搜尋找到第一個`catch`區塊處理例外狀況。 基於這個理由，應用程式程式碼中`catch`之前，必須指定處理類型的區塊`catch`區塊處理其基底類型，如遵循本節的範例所示。 處理的 catch 區塊`System.Exception`最後指定。  
  
 如果沒有任何`catch`目前相關聯的區塊`try`區塊處理例外狀況，以及目前`try`區塊巢狀在其他`try`區塊，以在目前呼叫`catch`區塊相關聯的下一步封入`try`區塊會搜尋。 如果沒有`catch`找不到區塊代表例外狀況，系統會搜尋目前的呼叫中先前的巢狀層級。 如果沒有`catch`封鎖目前的呼叫中找到的例外狀況，呼叫堆疊向上傳遞的例外狀況，且一個堆疊框架會搜尋`catch`區塊處理例外狀況。 呼叫堆疊的搜尋會繼續直到例外狀況處理或呼叫堆疊上不存在任何框架。 如果呼叫堆疊的頂端為止沒有尋找`catch`處理例外狀況，而預設例外狀況處理常式區塊處理它，且應用程式終止。  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>例外狀況類型的功能  
 例外狀況型別支援下列功能：  
  
-   人類看得懂的文字描述錯誤。 當發生例外狀況時，執行階段會讓的文字訊息通知使用者錯誤的本質，以及建議的動作來解決問題。 此文字訊息保留在<xref:System.Exception.Message%2A>例外狀況物件的屬性。 建立期間的例外狀況物件，您可以傳遞給建構函式，以描述該特定例外狀況的詳細資料的文字字串。 如果沒有錯誤訊息的引數提供給建構函式，會使用預設的錯誤訊息。 如需詳細資訊，請參閱 <xref:System.Exception.Message%2A> 屬性 (Property)。  
  
-   呼叫堆疊時擲回例外狀況的狀態。 <xref:System.Exception.StackTrace%2A>屬性會有可用來判斷程式碼中發生錯誤的堆疊追蹤。 堆疊追蹤會列出所有被呼叫的方法和原始程式檔都會呼叫中的行號。  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>例外狀況類別屬性  
 <xref:System.Exception>類別包含數個屬性，可協助識別的程式碼位置、 類型、 說明檔，以及例外狀況的原因： <xref:System.Exception.StackTrace%2A>， <xref:System.Exception.InnerException%2A>， <xref:System.Exception.Message%2A>， <xref:System.Exception.HelpLink%2A>， <xref:System.Exception.HResult%2A>， <xref:System.Exception.Source%2A>，<xref:System.Exception.TargetSite%2A>，和<xref:System.Exception.Data%2A>。  
  
 當之間兩個或多個例外狀況有因果關係<xref:System.Exception.InnerException%2A>屬性維護這個資訊。 擲回外部例外狀況以回應內部例外狀況。 處理外部例外狀況的程式碼可以使用從先前的內部例外的資訊以更適當地處理錯誤。 例外狀況的補充資訊可以儲存為索引鍵/值組的集合<xref:System.Exception.Data%2A>屬性。  
  
 傳遞至建構函式的例外狀況物件的建立期間的錯誤訊息字串應該當地語系化，而且可以藉由提供從資源檔<xref:System.Resources.ResourceManager>類別。 如需當地語系化資源的詳細資訊，請參閱[建立附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)和[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主題。  
  
 為使用者提供更詳盡資訊例外狀況發生的原因，<xref:System.Exception.HelpLink%2A>屬性可以保留 URL （或 URN） 說明檔。  
  
 <xref:System.Exception>類別會使用 HRESULT COR_E_EXCEPTION，其具有值 0x80131500。  
  
 如需執行個體的初始屬性值的清單<xref:System.Exception>類別，請參閱<xref:System.Exception.%23ctor%2A>建構函式。  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>效能考量  
 擲回或處理例外狀況會耗用大量系統資源和執行時間。 擲回的例外處理真正的異常狀況，不能處理可預測的事件或流量控制。 例如，在某些情況下，例如當您正在開發的類別庫，它是合理地擲回例外狀況，如果方法引數無效，因為您預期您用有效的參數來呼叫的方法。 無效的方法引數，如果它不是使用錯誤的結果表示必定已發生。 相反地，不要擲回例外狀況如果使用者輸入無效，因為您可以預期使用者偶爾輸入無效的資料。 相反地，提供重試機制，讓使用者可以輸入有效的輸入。 也不應該使用例外狀況處理使用方式錯誤。 請改用[判斷提示](/visualstudio/debugger/assertions-in-managed-code)找出並修正使用方式錯誤。  
  
 此外，不擲回例外狀況時，傳回碼已經足夠;不會傳回程式碼轉換成例外狀況。和不定期進行 catch 例外狀況、 略過，並繼續處理。  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>重新擲回例外狀況  
 在許多情況下，例外狀況處理常式只是想要傳遞至呼叫端的例外狀況。 這大多發生在：  
  
-   類別庫，接著會包裝在.NET Framework 類別庫或其他類別庫中的方法的呼叫。  
  
-   應用程式或遇到嚴重的例外狀況的程式庫。 例外狀況處理常式可以記錄的例外狀況，並再重新擲回例外狀況。  
  
 重新擲回例外狀況的建議的方式是只使用[擲回](~/docs/csharp/language-reference/keywords/throw.md)C# 中的陳述式和[擲回](~/docs/visual-basic/language-reference/statements/throw-statement.md)在 Visual Basic 中的陳述式，但不包含運算式。 這可確保例外狀況傳播到呼叫端時，會保留所有的呼叫堆疊資訊。 下列範例將說明這點。 字串的擴充方法， `FindOccurrences`，包裝一個或多個呼叫<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>而不事先驗證它的引數。  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 呼叫者接著會呼叫`FindOccurrences`兩次。 在第二個呼叫`FindOccurrences`，呼叫端傳遞`null`作為搜尋字串，哪些案例<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentNullException>例外狀況。 這個例外狀況由`FindOccurrences`方法並傳遞的回呼叫端。 因為 throw 陳述式會使用沒有運算式，範例的輸出會顯示呼叫堆疊會保留。  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 相反地，如果使用重新擲回例外狀況  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 陳述式中，完整的呼叫堆疊不保留，而且此範例會產生下列輸出：  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 稍微較繁瑣的替代方式是擲回新的例外狀況，並保留內部例外狀況的原始例外狀況呼叫堆疊資訊。 呼叫端可以再使用新的例外狀況<xref:System.Exception.InnerException%2A>屬性，以擷取堆疊框架，原始的例外狀況的其他資訊。 在此情況下，是 throw 陳述式：  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 處理例外狀況的使用者程式碼必須知道<xref:System.Exception.InnerException%2A>屬性包含原始的例外狀況的相關資訊，如下列的例外狀況處理常式所示。  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>選擇標準例外狀況  
 當您有會擲回例外狀況時，您可以在.NET Framework，而不是實作自訂的例外狀況，通常使用現有的例外狀況類型。 您應該使用這兩項條件底下的標準例外狀況類型：  
  
-   您會擲回例外狀況的使用方式錯誤所造成 (也就是您的方法呼叫者的開發人員所做的程式邏輯中的錯誤)。 一般而言，您會擲回例外狀況例如<xref:System.ArgumentException>， <xref:System.ArgumentNullException>， <xref:System.InvalidOperationException>，或<xref:System.NotSupportedException>。 具現化的例外狀況物件應該會描述錯誤，讓開發人員可以修正此問題時，所提供的例外狀況物件的建構函式的字串。 如需詳細資訊，請參閱 <xref:System.Exception.Message%2A> 屬性 (Property)。  
  
-   您要處理的錯誤，可以傳達給呼叫者，現有的.NET Framework 例外狀況。 您應該將最常衍生的例外狀況可能擲回。 例如，如果方法需要的是有效的列舉類型成員的引數，則應該擲出<xref:System.ComponentModel.InvalidEnumArgumentException>（最多衍生類別），而非<xref:System.ArgumentException>。  
  
 下表列出常見的例外狀況類型以及在其下會擲回它們的條件。  
  
|例外|條件|  
|---------------|---------------|  
|<xref:System.ArgumentException>|傳遞至方法的非 null 引數無效。|  
|<xref:System.ArgumentNullException>|傳遞至方法的引數是`null`。|  
|<xref:System.ArgumentOutOfRangeException>|引數超出有效值的範圍。|  
|<xref:System.IO.DirectoryNotFoundException>|部分目錄路徑不是有效的。|  
|<xref:System.DivideByZeroException>|以整數分母或<xref:System.Decimal>除法運算為零。|  
|<xref:System.IO.DriveNotFoundException>|磁碟機無法使用或不存在。|  
|<xref:System.IO.FileNotFoundException>|檔案不存在。|  
|<xref:System.FormatException>|值不是適當的格式，以從字串轉換方法例如`Parse`。|  
|<xref:System.IndexOutOfRangeException>|索引是陣列或集合的範圍外。|  
|<xref:System.InvalidOperationException>|方法呼叫無效物件的目前狀態。|  
|<xref:System.Collections.Generic.KeyNotFoundException>|找不到指定之索引鍵來存取集合中的成員。|  
|<xref:System.NotImplementedException>|未實作方法或作業。|  
|<xref:System.NotSupportedException>|不支援方法或作業。|  
|<xref:System.ObjectDisposedException>|已處置的物件上執行作業。|  
|<xref:System.OverflowException>|算術、 轉型或轉換作業造成溢位。|  
|<xref:System.IO.PathTooLongException>|路徑或檔案名稱超過系統定義的最大長度。|  
|<xref:System.PlatformNotSupportedException>|目前的平台不支援此作業。|  
|<xref:System.RankException>|具有錯誤維度數目的陣列傳遞至方法時。|  
|<xref:System.TimeoutException>|分配給作業的時間間隔已過期。|  
|<xref:System.UriFormatException>|是無效的統一資源識別元 (URI)。|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>實作自訂例外狀況  
 在下列情況中，使用現有的.NET Framework 例外狀況處理錯誤狀況不足：  
  
-   當例外狀況會反映無法對應至現有的.NET Framework 例外狀況的唯一程式錯誤。  
  
-   需要處理的是不同於適用於現有的.NET Framework 例外狀況或例外狀況處理的例外狀況必須明確地區分類似的例外狀況。 例如，如果您擲回<xref:System.ArgumentOutOfRangeException>例外狀況時剖析字串，超出目標整數類資料類型範圍的數字表示，您不想要用於錯誤所產生的呼叫端不提供相同的例外狀況呼叫方法時適當限制的值。  
  
 <xref:System.Exception>類別是.NET Framework 中的所有例外狀況的基底類別。 許多衍生的類別需要之成員的繼承行為<xref:System.Exception>類別; 它們不覆寫的成員<xref:System.Exception>，也不要定義任何唯一的成員。  
  
 若要定義您自己的例外狀況類別：  
  
1.  定義類別繼承自<xref:System.Exception>。 如有必要，定義您的類別提供有關例外狀況的其他資訊所需的任何唯一成員。 例如，<xref:System.ArgumentException>類別包含<xref:System.ArgumentException.ParamName%2A>屬性，指定其引數造成的例外狀況，參數的名稱和<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>屬性包含<xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A>屬性，指出逾時間隔。  
  
2.  如果有必要，請覆寫任何繼承的成員您想要變更或修改其功能。 請注意，大部分現有衍生的類別<xref:System.Exception>不會覆寫繼承的成員的行為。  
  
3.  判斷是否可序列化的自訂例外狀況物件。 序列化可讓您儲存例外狀況的相關資訊，並允許例外狀況資訊傳回由一部伺服器和用戶端 proxy 的遠端執行功能的內容中的共用。 若要進行序列化的例外狀況物件，將它與標示<xref:System.SerializableAttribute>屬性。  
  
4.  定義例外狀況類別的建構函式。 通常，例外狀況類別具有一或多個下列建構函式：  
  
    -   <xref:System.Exception.%23ctor>其中會使用預設值來初始化新的例外狀況物件的屬性。  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>其中，初始化新的例外狀況物件，使用指定的錯誤訊息。  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>其中，初始化新的例外狀況物件，使用指定的錯誤訊息和內部例外狀況。  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>這是`protected`建構函式，以初始化新的例外狀況物件，從序列化資料。 如果您選擇讓例外狀況物件能夠進行序列化，則應該實作這個建構函式。  
  
 下列範例說明如何使用自訂例外狀況類別。 它會定義`NotPrimeException`用戶端嘗試擷取一連串的質數藉由指定不是主要的起始數字時，會擲回的例外狀況。 例外狀況定義新的屬性， `NonPrime`，傳回非-質數造成例外狀況。 除了實作函式和受保護的無參數建構函式的建構函式<xref:System.Runtime.Serialization.SerializationInfo>和<xref:System.Runtime.Serialization.StreamingContext>參數進行序列化，`NotPrimeException`類別會定義其他三個建構函式支援`NonPrime`屬性。  每個建構函式呼叫的基底類別建構函式，除了保留值的非質數數字。 `NotPrimeException`類別也會標示為<xref:System.SerializableAttribute>屬性。  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator`下列範例所示的類別使用 Sieve Eratosthenes 計算質數 2 限制，用戶端在其類別建構函式呼叫中指定的順序。 `GetPrimesFrom`方法會傳回所有大於或等於指定的較低限制的質數，但會擲回`NotPrimeException`如果該下限不是質數。  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 下列範例使兩個呼叫`GetPrimesFrom`方法與非質數，其中跨越應用程式定義域界限。 在這兩種情況下，會擲回例外狀況，並將其用戶端程式碼中成功處理中。  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 執行階段和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 在[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]如[!INCLUDE[win8](~/includes/win8-md.md)]，例外狀況傳播透過非.NET Framework 的堆疊框架時，未通常遺失某些例外狀況資訊。 從開始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]和[!INCLUDE[win81](~/includes/win81-md.md)]，通用語言執行平台會繼續使用原始<xref:System.Exception>除非非.NET Framework 的堆疊框架中修改該例外狀況擲回的物件。  
  
   
  
## Examples  
 下列範例會示範`catch`區塊定義為處理<xref:System.ArithmeticException>錯誤。 這`catch`也區塊攔截<xref:System.DivideByZeroException>錯誤，因為<xref:System.DivideByZeroException>衍生自<xref:System.ArithmeticException>，而且沒有任何`catch`明確定義的區塊<xref:System.DivideByZeroException>錯誤。  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會將新執行個體的 <xref:System.Exception.Message%2A> 屬性初始化為系統提供的訊息，該訊息會描述錯誤並考量目前系統的文化特性。  
  
 所有衍生的類別必須提供這個預設建構函式。 下表顯示 <xref:System.Exception> 執行個體的初始屬性值。  
  
|屬性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 參考 (在 Visual Basic 中為 `Nothing`)。|  
|<xref:System.Exception.Message%2A>|系統提供的當地語系化描述。|  
  
   
  
## Examples  
 下列程式碼範例衍生`Exception`使用預先定義的訊息。 這個程式碼示範使用無參數建構函式在衍生的類別和基底`Exception`類別。  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">描述錯誤的訊息。</param>
        <summary>使用指定的錯誤訊息，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式初始化<xref:System.Exception.Message%2A>屬性使用的新執行個體`message`參數。 如果`message`參數是`null`，這等同於呼叫<xref:System.Exception.%23ctor%2A>建構函式。  
  
 下表顯示 <xref:System.Exception> 執行個體的初始屬性值。  
  
|屬性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 參考 (在 Visual Basic 中為 `Nothing`)。|  
|<xref:System.Exception.Message%2A>|錯誤訊息字串。|  
  
   
  
## Examples  
 下列程式碼範例衍生`Exception`是否符合特定條件。 程式碼會示範如何使用建構函式之呼叫者指定的訊息做為參數，衍生的類別和基底`Exception`類別。  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" />，包含所擲回之例外狀況的相關序列化物件資料。</param>
        <param name="context">包含有關來源或目的端內容資訊的 <see cref="T:System.Runtime.Serialization.StreamingContext" />。</param>
        <summary>使用序列化資料，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 進行還原序列化 (Deserialization) 期間會呼叫這個建構函式，以便重新構成經由資料流傳送的例外狀況物件。 如需詳細資訊，請參閱[XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。  
  
   
  
## Examples  
 下列程式碼範例會定義衍生可序列化`Exception`類別。 此程式碼會強制除以-0 錯誤，並接著會建立衍生的例外狀況使用的執行個體 (<xref:System.Runtime.Serialization.SerializationInfo>， <xref:System.Runtime.Serialization.StreamingContext>) 建構函式。 程式碼會序列化至檔案的執行個體，將檔案還原序列化為新的例外狀況，就會擲回，然後會攔截並顯示例外狀況的資料。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">類別名稱為 <see langword="null" /> 或 <see cref="P:System.Exception.HResult" /> 為零 (0)。</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">解釋例外狀況原因的錯誤訊息。</param>
        <param name="innerException">造成目前例外狀況的例外狀況，若未指定內部例外狀況，則為 null 參考 (Visual Basic 中為 <see langword="Nothing" />)。</param>
        <summary>使用指定的錯誤訊息以及造成此例外狀況的內部例外狀況的參考，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 被擲回以做為前一個例外狀況直接結果的例外狀況，應該在 <xref:System.Exception.InnerException%2A> 屬性中包含對前一個例外狀況的參考。 <xref:System.Exception.InnerException%2A> 屬性會傳回與傳入建構函式中相同的值；如果 `Nothing` 屬性不提供內部例外值給建構函式，則傳回 null 參考 (在 Visual Basic 中為 <xref:System.Exception.InnerException%2A>)。  
  
 下表顯示 <xref:System.Exception> 執行個體的初始屬性值。  
  
|屬性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|內部例外狀況參考。|  
|<xref:System.Exception.Message%2A>|錯誤訊息字串。|  
  
   
  
## Examples  
 下列程式碼範例衍生`Exception`是否符合特定條件。 程式碼會示範如何使用建構函式之訊息和內部例外狀況做為參數，衍生的類別和基底`Exception`類別。  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得提供例外狀況之其他使用者定義相關資訊的索引鍵/值組集合。</summary>
        <value>實作 <see cref="T:System.Collections.IDictionary" /> 介面的物件，含有由使用者定義之索引鍵/值組所組成的集合。 預設為空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Collections.IDictionary?displayProperty=nameWithType>所傳回物件<xref:System.Exception.Data%2A>來儲存和擷取相關的例外狀況的補充資訊的屬性。 資訊是任意數目的使用者定義的索引鍵/值組的形式。 每個索引鍵/值組的索引鍵元件通常是物件的識別的字串，而組的值元件可以是物件的任何類型。  
  
## <a name="keyvalue-pair-security"></a>索引鍵/值組的安全性  
 儲存在所傳回的集合中的索引鍵/值組<xref:System.Exception.Data%2A>屬性並未受到保護。 如果您的應用程式呼叫一連串巢狀的常式，而且每個常式包含例外狀況處理常式，則產生的呼叫堆疊會包含這些例外狀況處理常式的階層。 如果較低層級常式擲回例外狀況，呼叫堆疊階層中的任何上層例外狀況處理常式可以讀取及/或修改其他任何例外狀況處理常式儲存在集合中的索引鍵/值組。 這表示您必須保證索引鍵/值組中的資訊不是機密，如果索引鍵/值組中的資訊已損毀您的應用程式將會正確運作。  
  
## <a name="key-conflicts"></a>索引鍵衝突  
 索引鍵衝突發生於不同的例外狀況處理常式指定相同的金鑰存取的索引鍵/值組。 開發應用程式，因為索引鍵衝突的結果較低層級例外狀況處理常式可以與較高層級的例外狀況處理常式不小心進行通訊，且此通訊可能會導致難以察覺的程式錯誤時，請務必小心。 不過，如果您注意您可以使用索引鍵衝突可增強應用程式。  
  
## <a name="avoiding-key-conflicts"></a>避免索引鍵衝突  
 採用產生索引鍵/值組的唯一索引鍵的命名慣例，以避免索引鍵衝突。 例如，命名慣例可能會產生句號分隔應用程式的名稱所組成的索引鍵，則此方法可提供補充有關的配對和唯一識別碼。  
  
 假設兩個應用程式，名為產品與供應商，每個有名稱為 Sales 的方法。 產品應用程式中的 Sales 方法提供產品識別碼 （存貨保持單元或 SKU）。 供應商應用程式中的 Sales 方法提供的識別碼或 SID，供應商。 因此，此範例中的命名慣例，會產生 「 Products.Sales.SKU"和"Suppliers.Sales.SID"索引鍵。  
  
## <a name="exploiting-key-conflicts"></a>利用金鑰衝突  
 若要控制處理使用的一或多個特殊，按照預先安排的索引鍵存在利用索引鍵衝突。 假設在一個案例中，呼叫堆疊階層中最高的層級的例外狀況處理常式會攔截所有較低層級例外狀況處理常式擲回的例外狀況。 高階的例外狀況處理常式的索引鍵/值組與特殊索引鍵存在，如果格式中剩餘的索引鍵/值組<xref:System.Collections.IDictionary>物件使用非標準的方式; 否則一般的方式格式化其餘的索引鍵/值組。  
  
 現在，假設，在另一個案例中，每個階層的層級呼叫堆疊的例外狀況處理常式攔截例外狀況擲回的下一個較低層級例外狀況處理常式。 此外，每個例外狀況處理常式會知道所傳回的集合<xref:System.Exception.Data%2A>屬性包含一組可存取的索引鍵/值組的按照預先安排的索引鍵集。  
  
 每個例外狀況處理常式會按照預先安排索引鍵集中，使用該例外狀況處理常式特有的資訊更新對應的索引鍵/值組的值元件。 完成更新程序之後，例外狀況處理常式會擲回的例外狀況下, 一個較高層級的例外狀況處理常式。 最後，最高的層級的例外狀況處理常式存取的索引鍵/值組，並會顯示合併的更新資訊的較低層級例外狀況處理常式。  
  
   
  
## Examples  
 下列範例示範如何加入和擷取資訊使用<xref:System.Exception.Data%2A>屬性。  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，傳回一或多個後續的例外狀況的根本原因 <see cref="T:System.Exception" />。</summary>
        <returns>例外狀況鏈中擲回的第一個例外狀況。 如果目前的例外狀況的 <see cref="P:System.Exception.InnerException" /> 屬性為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，則這個屬性會傳回目前的例外狀況。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外狀況鏈結組所組成的例外狀況鏈結中的每個例外狀況擲回做為參考中的例外狀況直接結果，其`InnerException`屬性。 指定的鏈結，可以有一個例外狀況鏈結中的所有例外狀況的根本原因。 這個例外狀況會呼叫基底例外狀況及其`InnerException`屬性永遠會包含 null 參考。  
  
 所有例外狀況鏈結中的例外狀況，`GetBaseException`方法必須傳回相同的物件 （基底例外狀況）。  
  
 使用`GetBaseException`方法，當您想要尋找例外狀況的根本原因，但不是需要目前的例外狀況與第一個例外狀況之間所發生的例外狀況的相關資訊。  
  
   
  
## Examples  
 下列程式碼範例會定義兩個衍生`Exception`類別。 它會強制例外狀況，然後擲回它再次與每個衍生的類別。 程式碼將示範如何使用`GetBaseException`方法來擷取原始的例外狀況。  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="GetBaseException" />需要控制的例外狀況內容或格式的類別中覆寫方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" />，包含所擲回之例外狀況的相關序列化物件資料。</param>
        <param name="context">包含有關來源或目的端內容資訊的 <see cref="T:System.Runtime.Serialization.StreamingContext" />。</param>
        <summary>在衍生類別中覆寫時，使用例外狀況的資訊設定 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` 會使用所有指定要序列化的例外狀況物件資料來設定 <xref:System.Runtime.Serialization.SerializationInfo>。 在還原序列化期間，從在資料流上傳輸的 `SerializationInfo` 重新組成例外狀況。  
  
   
  
## Examples  
 下列程式碼範例會定義衍生可序列化`Exception`類別可實作`GetObjectData`這樣會微幅變更兩個屬性，然後呼叫的基底類別進行序列化。 此範例會強制除以-0 錯誤，然後建立衍生的例外狀況的執行個體。 程式碼會序列化至檔案的執行個體，將檔案還原序列化為新的例外狀況，就會擲回，然後會攔截並顯示例外狀況的資料。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 參數是 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前執行個體的執行階段類型。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，代表目前執行個體的確實執行階段類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A>方法支援.NET Framework 基礎結構存在，且在內部叫用基本的方法， <xref:System.Object.GetType%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個例外狀況相關聯的說明檔連結。</summary>
        <value>統一資源名稱 (URN) 或統一資源定位器 (URL)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用來表示說明檔的傳回值為 URN 或 URL。 例如，`HelpLink`值可以是：  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 下列程式碼範例會擲回`Exception`設定`HelpLink`屬性，其建構函式，然後攔截例外狀況，並顯示`HelpLink`。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 HRESULT，它是指派給特定例外狀況的編碼數值。</summary>
        <value>HRESULT 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT 是 32 位元值，分成三個不同的欄位： 嚴重性代碼、 設備碼和錯誤碼。 嚴重性代碼指出傳回的值是否代表資訊、 警告或錯誤。 設備碼指出系統錯誤負責的區域。 錯誤碼是指派給代表例外狀況的唯一數字。 每個例外狀況會對應至不同的 HRESULT。 當 managed 程式碼擲回例外狀況時，執行階段會傳遞 HRESULT 給 COM 用戶端。 Unmanaged 程式碼會傳回錯誤 HRESULT 會轉換成則由執行階段擲回的例外狀況。 HRESULT 值和其對應的.NET Framework 例外狀況的相關資訊，請參閱[如何： 對應 Hresult 和例外狀況](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。 請參閱[常見的 HRESULT 值](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)中 Windows 文件的清單，您最有可能會遇到的值。  
  
 從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、<xref:System.Exception.HResult%2A>屬性的 setter 受到保護，而其 getter 是公用。  在舊版的.NET Framework 中，會受到保護 getter 和 setter。  
  
   
  
## Examples  
 下列程式碼範例會定義衍生`Exception`設定的類別`HResult`其建構函式中的自訂值的屬性。  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得造成目前例外狀況的 <see cref="T:System.Exception" /> 執行個體。</summary>
        <value>物件，描述造成目前例外狀況的錯誤。 <see cref="P:System.Exception.InnerException" /> 屬性會傳回與傳遞到 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> 建構函式中相同的值；如果沒有提供內部例外狀況值給建構函式，則傳回 <see langword="null" />。 這個屬性是唯讀的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外狀況時`X`做為前一個例外狀況直接結果擲回`Y`、<xref:System.Exception.InnerException%2A>屬性`X`應該包含參考`Y`。  
  
 您可以使用 <xref:System.Exception.InnerException%2A> 屬性來取得造成目前例外狀況的例外狀況集合。  
  
 您可以建立新的例外狀況，以攔截先前的例外狀況。 處理第二個例外狀況可以使用從先前的例外狀況的其他資訊以更適當地處理錯誤程式碼。  
  
 假設有讀取檔案，並將該檔案中的資料格式的函式。 在此範例中，為程式碼嘗試讀取檔案，<xref:System.IO.IOException>就會擲回。 此函式攔截<xref:System.IO.IOException>並擲回<xref:System.IO.FileNotFoundException>。 <xref:System.IO.IOException>無法儲存在<xref:System.Exception.InnerException%2A>屬性<xref:System.IO.FileNotFoundException>，啟用程式碼攔截<xref:System.IO.FileNotFoundException>檢查初始錯誤的原因。  
  
 <xref:System.Exception.InnerException%2A>屬性，其中包含內部例外狀況的參考，例外狀況物件的初始設定。  
  
   
  
## Examples  
 下列範例示範擲回和攔截例外狀況參考內部的例外狀況。  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得描述目前例外狀況的訊息。</summary>
        <value>解釋例外狀況原因的錯誤訊息，或空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 錯誤訊息為目標的開發人員正在處理例外狀況。 文字<xref:System.Exception.Message%2A>屬性應該完整描述錯誤，可能的話，也會說明如何修正錯誤。 最上層例外狀況處理常式可能會顯示訊息給使用者，因此您應確保文法正確且以句號結尾訊息的每個句子。 請勿使用問號或驚嘆號。 如果您的應用程式中使用當地語系化的例外狀況訊息，您應該確保它們會正確轉譯。  
  
> [!IMPORTANT]
>  不會揭露例外狀況訊息中的機密資訊而不會檢查適當的權限。  
  
 值<xref:System.Exception.Message%2A>屬性包含在所傳回的資訊<xref:System.Exception.ToString%2A>。<xref:System.Exception.Message%2A>屬性只有在建立時設定<xref:System.Exception>。 如果目前的執行個體的建構函式提供的任何訊息，則系統會不提供預設的訊息使用目前的系統文化特性進行格式化。  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 執行階段和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 從開始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]和[!INCLUDE[win81](~/includes/win81-md.md)]，從 Windows 執行階段型別和成員不是.NET Framework 的一部分，從傳播例外狀況的錯誤訊息精確度已獲得改善。 特別是，例外狀況訊息從 Visual c + + 元件擴充功能 (C + + /CX) 現在會傳播回.NET Framework<xref:System.Exception>物件。  
  
   
  
## Examples  
 下列程式碼範例會擲回，並接著攔截<xref:System.Exception>例外狀況，並顯示例外狀況的文字訊息使用<xref:System.Exception.Message%2A>屬性。
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果您擲回例外狀況，從屬性，而且您需要在文字中參考<see cref="P:System.Exception.Message" />您設定或取得的屬性引數，如果要使用 「 值 」 屬性引數的名稱。</para>
        </block>
        <block subset="none" type="overrides">
          <para>
            <see cref="P:System.Exception.Message" />需要控制訊息內容或格式的類別中覆寫屬性。需要顯示已攔截到例外狀況的相關資訊時，應用程式程式碼通常存取這個屬性。應該當地語系化的錯誤訊息。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當例外狀況序列化，以建立包含例外狀況相關序列化資料的例外狀況狀態物件時，就會發生此事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外狀況狀態物件會實作<xref:System.Runtime.Serialization.ISafeSerializationData>介面。  
  
 當<xref:System.Exception.SerializeObjectState>訂閱事件，會還原序列化例外狀況，並將其建立為空的例外狀況。 例外狀況的建構函式無法執行，而且也會還原序列化例外狀況狀態。 <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A>回呼方法的例外狀況狀態物件然後收到通知，讓它可以將已還原序列化的資料推送至空的例外狀況。  
  
 <xref:System.Exception.SerializeObjectState>事件可讓透明的例外狀況型別序列化和還原序列化例外狀況資料。 透明程式碼可以運作中，在權限集合界限內執行命令，但無法執行、 呼叫、 衍生自，或包含關鍵程式碼。  
  
 如果<xref:System.Exception.SerializeObjectState>事件未訂閱，還原序列化發生如往常般使用<xref:System.Exception.%23ctor%2A>建構函式。  
  
 通常，處理常式<xref:System.Exception.SerializeObjectState>其序列化為提供的例外狀況的建構函式中加入事件。 但因為不是建構函式時執行<xref:System.Exception.SerializeObjectState>事件處理常式執行、 序列化已還原序列化的例外狀況可能會擲回<xref:System.Runtime.Serialization.SerializationException>例外狀況，當您嘗試還原序列化例外狀況。 若要避免這個問題，您也應該加入的處理常式<xref:System.Exception.SerializeObjectState>中的事件<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>方法。 請參閱 < 範例 > 一節。  
  
   
  
## Examples  
 下列範例會定義`BadDivisionException`可處理<xref:System.Exception.SerializeObjectState>事件。 它也包含狀態的物件，也就是巢狀結構名為`BadDivisionExceptionState`實作<xref:System.Runtime.Serialization.ISafeSerializationData>介面。  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException`浮點除數為零，就會發生時擲回例外狀況。 在第一個除數為零，此範例會具現化`BadDivisionException`物件序列化，並擲回例外狀況。 當發生除以零的後續部門時，例如先前已序列化的物件還原序列化，這和擲回例外狀況。 若要提供物件序列化、 還原序列化、 介紹雷同和還原序列化，此範例會將<xref:System.Exception.SerializeObjectState>中的事件處理常式這兩個`BadDivisionException`類別建構函式和<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>實作。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果此事件是訂閱，並使用，請遵循繼承階層架構中的所有衍生型別必須實作相同的序列化機制。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定造成錯誤的應用程式或物件的名稱。</summary>
        <value>造成錯誤的應用程式或物件的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Exception.Source%2A>屬性未明確設定、 執行階段會自動將其設為例外狀況的來源組件的名稱。  
  
   
  
## Examples  
 下列範例會擲回`Exception`設定`Source`屬性，其建構函式，然後攔截例外狀況，並顯示`Source`。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">此物件必須是執行階段 <see cref="N:System.Reflection" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得呼叫堆疊上即時運算框架的字串表示。</summary>
        <value>字串，描述呼叫堆疊的立即框架。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行堆疊會持續追蹤指定的執行個體的所有執行中方法。 方法呼叫的追蹤稱為堆疊追蹤。 堆疊追蹤清單可遵循的行號，在方法中發生例外狀況呼叫堆疊。  
  
 <xref:System.Exception.StackTrace%2A>屬性傳回的呼叫堆疊框架源自於擲回例外狀況所在的位置。 您可以藉由建立的新執行個體取得呼叫堆疊中的其他框架的相關資訊<xref:System.Diagnostics.StackTrace?displayProperty=nameWithType>類別，並使用其<xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType>方法。  
  
 每當應用程式程式碼中擲回例外狀況時，common language runtime (CLR) 會更新堆疊追蹤 (使用`throw`關鍵字)。 如果是不同方法較它原先擲回所在的方法中重新擲回例外狀況，堆疊追蹤包含其中原先擲回例外狀況，方法中的位置和方法中發生例外狀況所在的位置重新擲回。 如果例外狀況會擲回，並稍後重新擲回，在相同方法中，堆疊追蹤只會包含重新擲回例外狀況和不包含其中原先擲回例外狀況的位置的位置。  
  
 <xref:System.Exception.StackTrace%2A>屬性可能不會報告許多預期方法呼叫轉換之程式碼，因為這類內嵌 （inline)，發生在最佳化期間。  
  
   
  
## Examples  
 下列程式碼範例會擲回`Exception`然後攔截它，並顯示堆疊追蹤使用`StackTrace`屬性。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="StackTrace" />需要控制堆疊追蹤內容或格式的類別中覆寫屬性。根據預設，堆疊追蹤會擷取之前擲回例外狀況物件。使用<see cref="P:System.Environment.StackTrace" />時不擲回任何例外狀況取得的堆疊追蹤資訊。</para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得擲回目前例外狀況的方法。</summary>
        <value>擲回目前例外狀況的 <see cref="T:System.Reflection.MethodBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有擲回這個例外狀況的方法和堆疊追蹤不是 null 參考 (`Nothing`在 Visual Basic 中)，<xref:System.Exception.TargetSite%2A>從堆疊追蹤取得方法。 如果堆疊追蹤是 null 參考，<xref:System.Exception.TargetSite%2A> 也就會傳回 null 參考。  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A>屬性可能不正確地回報中擲回例外狀況的例外狀況處理常式處理例外狀況跨應用程式網域界限，如果方法的名稱。  
  
   
  
## Examples  
 下列程式碼範例會擲回`Exception`然後攔截它，並顯示原始的方法使用`TargetSite`屬性。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立並傳回目前例外狀況的字串表示。</summary>
        <returns>目前例外狀況的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> 傳回表示目前例外狀況，為了能讓人瞭解。 其中區分文化特性的資料包含的例外狀況，所傳回的字串表示`ToString`無須考慮目前的系統文化特性。 雖然傳回之字串的格式沒有實際上的需求，但它應該嘗試反映使用者了解物件的值。  
  
 預設實作<xref:System.Exception.ToString%2A>會擲回目前例外狀況、 訊息、 呼叫類別的名稱取得<xref:System.Exception.ToString%2A>內部的例外狀況，以及呼叫<xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>。 如果有任何這些成員為`null`，其值不包含在傳回的字串。  
  
 如果沒有任何錯誤訊息，或者它是空字串 ("")，則會不傳回任何錯誤訊息。 如果它們不是，內部例外狀況和堆疊追蹤的名稱就會傳回`null`。  
  
 這個方法覆寫 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會發生例外狀況，並顯示呼叫<xref:System.Exception.ToString%2A>上該例外狀況。 請注意，<xref:System.Exception.ToString%2A?displayProperty=nameWithType>的引數清單中出現的例外狀況類別執行個體時隱含地呼叫方法<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>