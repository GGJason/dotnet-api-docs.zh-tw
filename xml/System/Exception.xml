<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9bca5f5214750b835d04842898d3fa2db2cd075b" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55393932" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表應用程式執行期間所發生的錯誤。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別是所有的例外狀況的基底類別。 發生錯誤時，「 系統 」 或 「 目前正在執行的應用程式會報告它藉由擲回例外狀況，其中包含錯誤的相關資訊。 擲回例外狀況之後，它會處理應用程式或預設的例外狀況處理常式。  
  
 本節內容：  
  
 [錯誤和例外狀況](#Errors)   
 [Try/catch 區塊](#TryCatch)   
 [例外狀況類型的功能](#Features)   
 [例外狀況類別屬性](#Properties)   
 [效能考量](#Performance)   
 [重新擲回例外狀況](#Rethrow)   
 [選擇標準例外狀況](#Standard)   
 [實作自訂的例外狀況](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>錯誤和例外狀況  
 有許多原因可能會發生執行階段錯誤。 不過，並非所有的錯誤應該處理為您的程式碼中的例外狀況。 以下是一些類別，可以在執行的階段和適當的方式來回應它們出現的錯誤。  
  
-   **使用方式錯誤。** 使用方式錯誤表示在可能會導致例外狀況的程式邏輯中的錯誤。 不過，不是透過例外狀況處理，但藉由修改錯誤的程式碼，應該解決錯誤。 例如的覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，在下列範例會假設`obj`引數必須永遠為非 null。  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException>產生的例外狀況時`obj`是`null`被消除，可以修改原始程式碼，以明確地測試是否為 null，然後再呼叫<xref:System.Object.Equals%2A?displayProperty=nameWithType>覆寫和重新編譯。 下列範例包含已更正的原始程式碼，可處理`null`引數。  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     除了使用例外狀況處理的使用方式錯誤，您可以使用<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType>方法，以找出偵錯組建中的使用方式錯誤和<xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType>方法，以找出使用方式錯誤，在偵錯和發行組建。 如需詳細資訊，請參閱[受控碼中的判斷提示](/visualstudio/debugger/assertions-in-managed-code)。  
  
-   **程式錯誤。** 程式錯誤是一定無法避免撰寫無 bug 的程式碼的執行階段錯誤。  
  
     在某些情況下，程式錯誤可能會反映預期或例行的錯誤狀況。 在此情況下，建議您避免使用例外狀況處理程式錯誤處理，並改為重試此作業。 例如，如果使用者只需要輸入特定格式的日期，您可以剖析日期字串藉由呼叫<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法，以傳回<xref:System.Boolean>值，指出是否剖析作業成功，而不是使用<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法，就會擲回<xref:System.FormatException>例外狀況，如果日期字串無法轉換成<xref:System.DateTime>值。 同樣地，如果使用者嘗試開啟不存在的檔案，您可以先呼叫<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>方法來檢查檔案是否存在，然後，如果沒有出現，請提示使用者是否想要建立它。  
  
     在其他情況下，程式錯誤會反映您的程式碼中可以處理非預期的錯誤狀況。 比方說，即使您已檢查，以確保檔案存在，它可能會刪除之前，您可以開啟它，或它可能已損毀。 在此情況下，嘗試開啟檔案，藉由執行個體化<xref:System.IO.StreamReader>物件或呼叫<xref:System.IO.File.Open%2A>方法可能會擲回<xref:System.IO.FileNotFoundException>例外狀況。 在這些情況下，您應該使用例外狀況處理來從錯誤復原。  
  
-   **系統失敗。** 在系統失敗是無法有意義的方式以程式設計方式處理執行階段錯誤。 例如，任何方法可以擲回<xref:System.OutOfMemoryException>例外狀況，如果 common language runtime 無法配置額外的記憶體。 一般情況下，使用例外狀況處理不會處理系統失敗。 相反地，您可以使用事件，例如<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>並呼叫<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>記錄例外狀況資訊，並通知失敗的使用者，應用程式終止之前的方法。  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try/catch 區塊  
 Common language runtime 提供的例外狀況處理模型為基礎的例外狀況物件，表示和的程式碼和例外狀況處理程式碼分隔`try`區塊和`catch`區塊。 可以有一或多個`catch`區塊，每個設計用來處理特定類型的例外狀況或一個設計用來攔截更特定的例外狀況，比另一個區塊的區塊。  
  
 如果應用程式處理的應用程式程式碼區塊在執行期間發生的例外狀況，程式碼必須放`try`陳述式，稱為`try`區塊。 處理所擲回的例外狀況的應用程式程式碼`try`區塊會放置在`catch`陳述式，稱為`catch`區塊。 零或多個`catch`區塊相關聯`try`區塊，以及每個`catch`區塊包含型別篩選條件，判斷它所處理的例外狀況的類型。  
  
 當發生例外狀況`try`區塊中，系統會搜尋相關聯`catch`區塊，以它們出現在應用程式程式碼，直到它找到的順序`catch`區塊處理例外狀況。 A`catch`區塊處理例外狀況型別的`T`如果指定的 catch 區塊的型別篩選`T`或任何型別`T`衍生自。 系統會停止搜尋之後找到的第一個`catch`區塊處理例外狀況。 基於這個理由，在應用程式程式碼`catch`之前，必須指定處理類型的區塊`catch`處理其基底類型，接下來這一節的範例所示的區塊。 Catch 區塊處理`System.Exception`指定上一次。  
  
 如果沒有任何`catch`目前相關聯的區塊`try`區塊處理例外狀況和目前`try`區塊的巢狀在其他`try`在目前的呼叫中，會封鎖`catch`區塊相關聯的下一步封入`try`區塊會搜尋。 如果沒有`catch`找不到例外狀況區塊時，系統會搜尋目前的呼叫中先前的巢狀層級。 如果沒有`catch`封鎖目前的呼叫中找到的例外狀況，例外狀況呼叫堆疊中向上傳遞，且一個堆疊框架中搜尋`catch`區塊處理例外狀況。 呼叫堆疊的搜尋會繼續直到例外狀況處理或呼叫堆疊上不存在任何框架。 如果呼叫堆疊的頂端尋找沒有達到`catch`區塊處理例外狀況，預設的例外狀況處理常式處理它，且應用程式終止。  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>例外狀況類型的功能  
 例外狀況類型支援下列功能：  
  
-   人類看得懂的文字描述錯誤。 發生例外狀況時，執行階段就會建立可用來通知使用者錯誤的本質，以及建議的動作文字訊息來解決問題。 此文字訊息會保留在<xref:System.Exception.Message%2A>例外狀況物件的屬性。 在例外狀況物件建立時，您可以傳遞文字字串的建構函式，來描述該特定的例外狀況詳細資料。 如果任何錯誤訊息引數不提供給建構函式，會使用預設的錯誤訊息。 如需詳細資訊，請參閱 <xref:System.Exception.Message%2A> 屬性 (Property)。  
  
-   呼叫堆疊時擲回例外狀況的狀態。 <xref:System.Exception.StackTrace%2A>屬性包含可用來判斷程式碼中發生錯誤的堆疊追蹤。 堆疊追蹤會列出所有被呼叫的方法和原始程式檔進行的呼叫中的行號。  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>例外狀況類別屬性  
 <xref:System.Exception>類別包含數個屬性，可協助識別程式碼位置、 類型、 說明檔，以及例外狀況的原因： <xref:System.Exception.StackTrace%2A>， <xref:System.Exception.InnerException%2A>， <xref:System.Exception.Message%2A>， <xref:System.Exception.HelpLink%2A>， <xref:System.Exception.HResult%2A>， <xref:System.Exception.Source%2A>，<xref:System.Exception.TargetSite%2A>，和<xref:System.Exception.Data%2A>。  
  
 當兩個或多個例外狀況之間的因果關係存在<xref:System.Exception.InnerException%2A>屬性維護這項資訊。 以回應這個內部例外狀況擲回外部例外狀況。 處理外部例外狀況的程式碼可以使用從先前的內部例外的資訊，以更適當地處理錯誤。 例外狀況的相關補充資訊可以儲存為索引鍵/值組的集合<xref:System.Exception.Data%2A>屬性。  
  
 傳遞至建構函式的例外狀況物件建立期間的錯誤訊息字串應該當地語系化，而且可以藉由提供從資源檔<xref:System.Resources.ResourceManager>類別。 如需當地語系化資源的詳細資訊，請參閱[建立附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)並[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主題。  
  
 為使用者提供大量資訊的例外狀況發生的原因，<xref:System.Exception.HelpLink%2A>屬性可以保留的 URL （或 URN） 的說明檔。  
  
 <xref:System.Exception>類別會使用 HRESULT COR_E_EXCEPTION，其值 0x80131500。  
  
 如需執行個體的初始屬性值的清單<xref:System.Exception>類別，請參閱<xref:System.Exception.%23ctor%2A>建構函式。  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>效能考量  
 擲回或處理的例外狀況會耗用大量系統資源和執行時間。 擲回例外狀況，才能處理真正的異常狀況，不能處理可預測的事件，或流量控制。 比方說，在某些情況下，例如當您正在開發類別庫，它是合理的方法引數無效，因為您預期您用有效的參數來呼叫的方法擲回例外狀況。 無效的方法引數，如果它不是結果的使用方式錯誤，表示發生某個非經常性 」。 相反地，並不會擲回例外狀況如果使用者輸入無效，因為您可以預期使用者偶爾輸入無效的資料。 相反地，提供重試機制，讓使用者可以輸入有效的輸入。 也不應該使用例外狀況來處理使用方式錯誤。 請改用[判斷提示](/visualstudio/debugger/assertions-in-managed-code)找出並改正用法錯誤。  
  
 颾魤 ㄛ 並不會擲回例外狀況時傳回的程式碼就已足夠;無法轉換成例外狀況，傳回碼和不定期執行 catch 例外狀況、 忽略它，並繼續處理。  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>重新擲回例外狀況  
 在許多情況下，例外狀況處理常式只是想要傳遞至呼叫端的例外狀況。 此狀況通常發生在：  
  
-   接著會包裝在.NET Framework 類別庫或其他類別庫中的方法呼叫類別庫。  
  
-   應用程式或遇到嚴重的例外狀況的程式庫。 例外狀況處理常式可以記錄例外狀況，並接著重新擲回例外狀況。  
  
 重新擲回例外狀況的建議的方式是直接使用[擲回](~/docs/csharp/language-reference/keywords/throw.md)C# 中的陳述式並[擲回](~/docs/visual-basic/language-reference/statements/throw-statement.md)Visual Basic 中的陳述式，但不包含運算式。 這可確保呼叫端傳播例外狀況時，會保留所有的呼叫堆疊資訊。 下列範例將說明這點。 字串擴充方法`FindOccurrences`，將一或多個呼叫包裝<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>而不事先驗證其引數。  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 呼叫者接著會呼叫`FindOccurrences`兩次。 第二個呼叫中`FindOccurrences`，呼叫端傳遞`null`做為搜尋字串，哪些案例<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentNullException>例外狀況。 這個例外狀況由`FindOccurrences`方法來回傳遞給呼叫者。 因為 throw 陳述式用沒有運算式，此範例的輸出會顯示呼叫堆疊會保留。  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 相反地，如果使用重新擲回例外狀況  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 陳述式中，完整的呼叫堆疊不會保留，與此範例會產生下列輸出：  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 稍微更麻煩的替代做法是擲回新的例外狀況，並保留在內部例外狀況的原始的例外狀況呼叫堆疊資訊。 呼叫者接著可以使用新的例外狀況<xref:System.Exception.InnerException%2A>屬性，以擷取堆疊框架和原始的例外狀況的其他資訊。 在此案例中，是 throw 陳述式：  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 處理例外狀況的使用者程式碼必須知道<xref:System.Exception.InnerException%2A>屬性包含原始的例外狀況的相關資訊，如下列的例外狀況處理常式所示。  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>選擇標準例外狀況  
 當您有會擲回例外狀況時，您可以經常使用現有的例外狀況類型，在.NET Framework，而不是實作自訂的例外狀況。 您應該使用這兩項條件底下的標準例外狀況類型：  
  
-   您會擲回例外狀況造成的使用方式錯誤 (也就是由開發人員會呼叫您的方法所做的程式邏輯中的錯誤)。 一般而言，您會擲回例外狀況這類<xref:System.ArgumentException>， <xref:System.ArgumentNullException>， <xref:System.InvalidOperationException>，或<xref:System.NotSupportedException>。 字串，提供例外狀況物件的建構函式時具現化的例外狀況物件應該描述錯誤，以便開發人員可以修正此問題。 如需詳細資訊，請參閱 <xref:System.Exception.Message%2A> 屬性 (Property)。  
  
-   您要處理錯誤，以告知現有的.NET Framework 例外狀況的呼叫者。 您應該擲回的可能最具衍生性的例外狀況。 例如，如果方法需要的是有效的列舉類型成員的引數，則應該擲回<xref:System.ComponentModel.InvalidEnumArgumentException>（最多衍生類別），而非<xref:System.ArgumentException>。  
  
 下表列出常見的例外狀況類型以及下您會擲回它們的條件。  
  
|例外|條件|  
|---------------|---------------|  
|<xref:System.ArgumentException>|傳遞至方法的非 null 引數無效。|  
|<xref:System.ArgumentNullException>|傳遞至方法的引數是`null`。|  
|<xref:System.ArgumentOutOfRangeException>|引數超出有效值的範圍。|  
|<xref:System.IO.DirectoryNotFoundException>|部分目錄路徑不是有效的。|  
|<xref:System.DivideByZeroException>|整數中的分母或<xref:System.Decimal>除法運算為零。|  
|<xref:System.IO.DriveNotFoundException>|磁碟機無法使用，或不存在。|  
|<xref:System.IO.FileNotFoundException>|檔案不存在。|  
|<xref:System.FormatException>|值不是適當的格式來轉換從字串轉換方法這類`Parse`。|  
|<xref:System.IndexOutOfRangeException>|索引超出陣列或集合的界限。|  
|<xref:System.InvalidOperationException>|物件的目前狀態無效方法呼叫。|  
|<xref:System.Collections.Generic.KeyNotFoundException>|找不到指定的索引鍵來存取集合中的成員。|  
|<xref:System.NotImplementedException>|未實作方法或作業。|  
|<xref:System.NotSupportedException>|不支援方法或作業。|  
|<xref:System.ObjectDisposedException>|已處置的物件上執行作業。|  
|<xref:System.OverflowException>|算術、 轉型或轉換作業造成溢位。|  
|<xref:System.IO.PathTooLongException>|路徑或檔案名稱超過系統定義的最大長度。|  
|<xref:System.PlatformNotSupportedException>|在目前的平台上不支援此作業。|  
|<xref:System.RankException>|具有錯誤維度數目的陣列會傳遞至方法。|  
|<xref:System.TimeoutException>|分配給作業的時間間隔已過期。|  
|<xref:System.UriFormatException>|無效的統一資源識別元 (URI) 會使用。|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>實作自訂的例外狀況  
 在下列情況中，使用現有的.NET Framework 例外狀況處理錯誤狀況不足夠：  
  
-   當例外狀況會反映無法對應至現有的.NET Framework 例外狀況的唯一程式錯誤。  
  
-   需要處理的是不同於適用於現有的.NET Framework 例外狀況或例外狀況處理的例外狀況須從類似的例外狀況。 例如，如果您擲回<xref:System.ArgumentOutOfRangeException>例外狀況時剖析字串，超出範圍的目標的整數類資料類型的數值表示，您不想使用相同的例外狀況的錯誤所產生的呼叫端不提供呼叫方法時適當限制的值。  
  
 <xref:System.Exception>類別是.NET Framework 中的所有例外狀況的基底類別。 許多衍生的類別會依賴之成員的繼承行為<xref:System.Exception>類別; 它們不覆寫的成員<xref:System.Exception>，也不要定義任何唯一的成員。  
  
 若要定義您自己的例外狀況類別：  
  
1.  定義類別繼承自<xref:System.Exception>。 如有必要，您的類別提供有關例外狀況的其他資訊所需的任何唯一成員的定義。 例如，<xref:System.ArgumentException>類別包含<xref:System.ArgumentException.ParamName%2A>屬性，指定其引數造成例外狀況，參數名稱和<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>屬性包含<xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A>屬性，指出逾時間隔。  
  
2.  如有需要，覆寫任何繼承的成員您想要變更或修改其功能。 請注意，大部分現有的衍生類別<xref:System.Exception>不會覆寫繼承的成員的行為。  
  
3.  判斷是否可序列化您自訂的例外狀況物件。 序列化可讓您儲存例外狀況的相關資訊，並允許遠端執行功能的內容中共用的一部伺服器和用戶端 proxy 的例外狀況資訊。 若要讓例外狀況物件的可序列化，加以標示<xref:System.SerializableAttribute>屬性。  
  
4.  定義例外狀況類別的建構函式。 通常，例外狀況類別具有一或多個下列建構函式：  
  
    -   <xref:System.Exception.%23ctor>會使用預設值來初始化新的例外狀況物件的屬性。  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>其中，初始化新的例外狀況物件，使用指定的錯誤訊息。  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>其中，初始化新的例外狀況物件，使用指定的錯誤訊息和內部例外狀況。  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>這是`protected`建構函式，初始化新的例外狀況物件，從序列化資料。 如果您選擇要讓例外狀況物件的可序列化，您應該實作這個建構函式。  
  
 下列範例說明如何使用自訂例外狀況類別。 它會定義`NotPrimeException`用戶端嘗試藉由指定起始的數字不是質數，擷取一連串的質數時擲回的例外狀況。 例外狀況會定義新的屬性， `NonPrime`，傳回非-質數造成例外狀況。 除了實作的受保護的無參數建構函式和的建構函式<xref:System.Runtime.Serialization.SerializationInfo>並<xref:System.Runtime.Serialization.StreamingContext>進行序列化，參數`NotPrimeException`類別會定義三個額外的建構函式來支援`NonPrime`屬性。  每個建構函式呼叫的基底類別建構函式，除了保留值的非質數數字。 `NotPrimeException`類別也標示有<xref:System.SerializableAttribute>屬性。  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator`下列範例所示的類別會使用 Sieve Eratosthenes 計算質數 2 限制，用戶端在其類別建構函式呼叫中指定的順序。 `GetPrimesFrom`方法會傳回大於或等於指定的較低限制的所有質數，但會擲回`NotPrimeException`如果該下限不是質數。  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 下列範例使兩個呼叫`GetPrimesFrom`方法與非質數，其中之一跨越應用程式定義域界限。 在這兩種情況下，會擲回例外狀況，並將其成功處理用戶端程式碼中。  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 執行階段和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 在 [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]針對[!INCLUDE[win8](~/includes/win8-md.md)]，某些例外狀況資訊時，通常是遺失的例外狀況就會透過非.NET Framework 的堆疊框架。 開頭[!INCLUDE[net_v451](~/includes/net-v451-md.md)]並[!INCLUDE[win81](~/includes/win81-md.md)]，通用語言執行平台會繼續使用原始<xref:System.Exception>除非非.NET Framework 的堆疊框架中修改該例外狀況已擲回物件。  
  
   
  
## Examples  
 下列範例示範`catch`定義要處理的區塊<xref:System.ArithmeticException>錯誤。 這`catch`封鎖也可捕捉<xref:System.DivideByZeroException>錯誤，因為<xref:System.DivideByZeroException>衍生自<xref:System.ArithmeticException>，而且沒有任何`catch`明確定義的區塊<xref:System.DivideByZeroException>錯誤。  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">處理和擲回例外狀況</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">在桌面應用程式中封裝和部署資源</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">Managed 程式碼中的判斷提示</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會將新執行個體的 <xref:System.Exception.Message%2A> 屬性初始化為系統提供的訊息，該訊息會描述錯誤並考量目前系統的文化特性。  
  
 所有衍生的類別應該提供此預設建構函式。 下表顯示 <xref:System.Exception> 執行個體的初始屬性值。  
  
|屬性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 參考 (在 Visual Basic 中為 `Nothing`)。|  
|<xref:System.Exception.Message%2A>|系統提供的當地語系化描述。|  
  
   
  
## Examples  
 下列程式碼範例衍生`Exception`使用預先定義的訊息。 程式碼示範使用無參數的建構函式，衍生的類別和基底`Exception`類別。  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">描述錯誤的訊息。</param>
        <summary>使用指定的錯誤訊息，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式初始化<xref:System.Exception.Message%2A>屬性所使用的新執行個體`message`參數。 如果`message`參數是`null`，這等同於呼叫<xref:System.Exception.%23ctor%2A>建構函式。  
  
 下表顯示 <xref:System.Exception> 執行個體的初始屬性值。  
  
|屬性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|null 參考 (在 Visual Basic 中為 `Nothing`)。|  
|<xref:System.Exception.Message%2A>|錯誤訊息字串。|  
  
   
  
## Examples  
 下列程式碼範例衍生`Exception`是否符合特定條件。 程式碼示範如何使用建構函式採用呼叫者指定訊息做為參數，衍生的類別和基底`Exception`類別。  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" />，包含所擲回之例外狀況的相關序列化物件資料。</param>
        <param name="context">包含有關來源或目的端內容資訊的 <see cref="T:System.Runtime.Serialization.StreamingContext" />。</param>
        <summary>使用序列化資料，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 進行還原序列化 (Deserialization) 期間會呼叫這個建構函式，以便重新構成經由資料流傳送的例外狀況物件。 如需詳細資訊，請參閱 < [XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。  
  
   
  
## Examples  
 下列程式碼範例會定義衍生可序列化`Exception`類別。 強制除以-0 錯誤的程式碼，並接著會建立衍生的例外狀況使用的執行個體 (<xref:System.Runtime.Serialization.SerializationInfo>， <xref:System.Runtime.Serialization.StreamingContext>) 建構函式。 程式碼將序列化至檔案的執行個體、 將檔案還原序列化新的例外狀況，就會擲回，則會攔截，並顯示例外狀況的資料。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">類別名稱為 <see langword="null" /> 或 <see cref="P:System.Exception.HResult" /> 為零 (0)。</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML 和 SOAP 序列化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">解釋例外狀況原因的錯誤訊息。</param>
        <param name="innerException">造成目前例外狀況的例外狀況，若未指定內部例外狀況，則為 null 參考 (Visual Basic 中為 <see langword="Nothing" />)。</param>
        <summary>使用指定的錯誤訊息以及造成此例外狀況的內部例外狀況的參考，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 被擲回以做為前一個例外狀況直接結果的例外狀況，應該在 <xref:System.Exception.InnerException%2A> 屬性中包含對前一個例外狀況的參考。 <xref:System.Exception.InnerException%2A> 屬性會傳回與傳入建構函式中相同的值；如果 `Nothing` 屬性不提供內部例外值給建構函式，則傳回 null 參考 (在 Visual Basic 中為 <xref:System.Exception.InnerException%2A>)。  
  
 下表顯示 <xref:System.Exception> 執行個體的初始屬性值。  
  
|屬性|值|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|內部例外狀況參考。|  
|<xref:System.Exception.Message%2A>|錯誤訊息字串。|  
  
   
  
## Examples  
 下列程式碼範例衍生`Exception`是否符合特定條件。 程式碼示範如何使用採用訊息和內部例外狀況做為參數，衍生的類別和基底建構函式`Exception`類別。  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得提供例外狀況之其他使用者定義相關資訊的索引鍵/值組集合。</summary>
        <value>實作 <see cref="T:System.Collections.IDictionary" /> 介面的物件，含有由使用者定義之索引鍵/值組所組成的集合。 預設為空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Collections.IDictionary?displayProperty=nameWithType>所傳回的物件<xref:System.Exception.Data%2A>來儲存和擷取例外狀況相關的補充資訊的屬性。 資訊是任意數目的使用者定義索引鍵/值組的形式。 每個索引鍵/值組的關鍵元件通常是物件的識別的字串，而組的值元件可以是物件的任何類型。  
  
## <a name="keyvalue-pair-security"></a>索引鍵/值組的安全性  
 儲存在所傳回的集合中的索引鍵/值組<xref:System.Exception.Data%2A>屬性並不安全。 如果您的應用程式呼叫巢狀的一連串的常式，而且每個常式包含例外狀況處理常式，則產生的呼叫堆疊會包含這些例外狀況處理常式的階層。 如果較低層級常式擲回例外狀況，呼叫堆疊階層中的任何上層例外狀況處理常式可以讀取及/或修改任何其他的例外狀況處理常式儲存在集合中的索引鍵/值組。 這表示您必須保證中的索引鍵/值組的資訊不是機密，如果索引鍵/值組中的資訊已損毀您的應用程式將會正確運作。  
  
## <a name="key-conflicts"></a>金鑰衝突  
 不同的例外狀況處理常式指定相同的金鑰來存取的索引鍵/值組，就會產生索引鍵衝突。 開發您的應用程式，因為索引鍵衝突的結果較低層級例外狀況處理常式可以與更高層級的例外狀況處理常式，不小心進行通訊，且此通訊可能會導致難以察覺的程式錯誤時，請務必小心。 不過，如果您注意您可以使用索引鍵衝突來增強您的應用程式。  
  
## <a name="avoiding-key-conflicts"></a>避免索引鍵衝突  
 採用以產生唯一的索引鍵的索引鍵/值配對的命名慣例，以避免索引鍵衝突。 例如，命名慣例可能會產生包含句號分隔的名稱，您的應用程式的金鑰、 提供配對和唯一識別碼的補充資訊的方法。  
  
 假設兩個應用程式，名為產品和供應商，各有名稱為 Sales 的方法。 產品應用程式中的銷售方法會提供產品的識別碼 （存貨保持單元或 SKU）。 供應商應用程式中的銷售方法提供識別碼或供應商的 SID。 因此，此範例中的命名慣例，會產生 「 Products.Sales.SKU"和"Suppliers.Sales.SID"索引鍵。  
  
## <a name="exploiting-key-conflicts"></a>利用金鑰衝突  
 使用一或多個特殊的按照預先安排的金鑰存在來控制處理，以利用索引鍵衝突。 假設在一個案例中，在呼叫堆疊階層架構中最高的層級的例外狀況處理常式會攔截所有較低層級例外狀況處理常式所擲回的例外狀況。 高層級的例外狀況處理常式有特殊的索引鍵的索引鍵/值組格式中剩餘的索引鍵/值組<xref:System.Collections.IDictionary>某種非標準的方式; 物件，否則為將剩餘的索引鍵/值組格式以一般方式。  
  
 現在假設，在另一個案例中，每個階層的層級呼叫堆疊的例外狀況處理常式會攔截由下一個較低層級的例外狀況處理常式所擲回的例外狀況。 此外，每個例外狀況處理常式知道所傳回的集合<xref:System.Exception.Data%2A>屬性包含一組可存取的索引鍵/值組的按照預先安排的一組金鑰。  
  
 每個例外狀況處理常式會使用按照預先安排的金鑰組，使用唯一的例外狀況處理常式的資訊來更新相對應的索引鍵/值組的值元件。 在更新程序完成之後，例外狀況處理常式會擲回下一個較高層級的例外狀況處理常式的例外狀況。 最後，最高的層級的例外狀況處理常式會存取的索引鍵/值組，並顯示所有較低層級的例外狀況處理常式的彙總的更新資訊。  
  
   
  
## Examples  
 下列範例示範如何新增和擷取資訊使用<xref:System.Exception.Data%2A>屬性。  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，傳回一或多個後續的例外狀況的根本原因 <see cref="T:System.Exception" />。</summary>
        <returns>例外狀況鏈中擲回的第一個例外狀況。 如果目前的例外狀況的 <see cref="P:System.Exception.InnerException" /> 屬性為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，則這個屬性會傳回目前的例外狀況。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 做為參考中的例外狀況直接結果擲回的鏈結中的每個例外狀況，例外狀況的集合組成的例外狀況鏈結其`InnerException`屬性。 指定的鏈結，可能會有一個是鏈結中的所有例外狀況的根本原因的例外狀況。 這個例外狀況會呼叫基底例外狀況並將其`InnerException`屬性永遠會包含 null 參考。  
  
 所有的例外狀況鏈結中的例外狀況，`GetBaseException`方法必須傳回相同的物件 （基底例外狀況）。  
  
 使用`GetBaseException`方法，當您想要尋找例外狀況的根本原因，但不是需要目前的例外狀況與第一個例外狀況所發生的例外狀況的相關資訊。  
  
   
  
## Examples  
 下列程式碼範例會定義兩個衍生`Exception`類別。 它會強制例外狀況則會擲回它一次與每個衍生的類別。 程式碼示範如何使用`GetBaseException`方法來擷取原始的例外狀況。  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="GetBaseException" />需要控制例外狀況內容或格式的類別中覆寫方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" />，包含所擲回之例外狀況的相關序列化物件資料。</param>
        <param name="context">包含有關來源或目的端內容資訊的 <see cref="T:System.Runtime.Serialization.StreamingContext" />。</param>
        <summary>在衍生類別中覆寫時，使用例外狀況的資訊設定 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` 會使用所有指定要序列化的例外狀況物件資料來設定 <xref:System.Runtime.Serialization.SerializationInfo>。 在還原序列化期間，從在資料流上傳輸的 `SerializationInfo` 重新組成例外狀況。  
  
   
  
## Examples  
 下列程式碼範例會定義衍生可序列化`Exception`可實作類別`GetObjectData`這樣會微幅變更兩個屬性，然後呼叫的基底類別進行序列化。 此範例會強制除以-0 的錯誤，並接著會建立衍生的例外狀況的執行個體。 程式碼將序列化至檔案的執行個體、 將檔案還原序列化新的例外狀況，就會擲回，則會攔截，並顯示例外狀況的資料。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 參數為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得目前執行個體的執行階段類型。</summary>
        <returns><see cref="T:System.Type" /> 物件，代表目前執行個體的確實執行階段類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A>方法來支援.NET Framework 基礎結構存在，且在內部叫用基本的方法， <xref:System.Object.GetType%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個例外狀況相關聯的說明檔連結。</summary>
        <value>統一資源名稱 (URN) 或統一資源定位器 (URL)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用來表示說明檔的傳回值為 URN 或 URL。 比方說，`HelpLink`值可以是：  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 下列程式碼範例會擲回`Exception`如此`HelpLink`屬性，其建構函式，然後攔截到例外狀況並顯示`HelpLink`。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 HRESULT，它是指派給特定例外狀況的編碼數值。</summary>
        <value>HRESULT 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT 是 32 位元值，分成三個不同的欄位： 嚴重性代碼、 設備碼和錯誤碼。 嚴重性代碼指出傳回的值是否代表資訊、 警告或錯誤。 設備碼指出系統對錯誤負責的區域。 錯誤碼是指派給代表例外狀況的唯一號碼。 每個例外狀況會對應至不同的 HRESULT。 當 managed 程式碼擲回例外狀況時，則執行階段會將 HRESULT 給 COM 用戶端。 當 unmanaged 程式碼會傳回錯誤時，HRESULT 會轉換成例外狀況，則會擲回執行階段中。 HRESULT 值和其對應的.NET Framework 例外狀況的相關資訊，請參閱[How to:對應 Hresult 和例外狀況](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。 請參閱[常見的 HRESULT 值](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)Windows 文件的清單，您最有可能會遇到的值中。  
  
 開頭[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，則<xref:System.Exception.HResult%2A>屬性的 setter 受到保護，而其 getter 是公用的。  在舊版的.NET Framework 中，會受到保護 getter 和 setter。  
  
   
  
## Examples  
 下列程式碼範例會定義衍生`Exception`設定的類別`HResult`屬性設為其建構函式中的自訂值。  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">如何：對應 HRESULT 和例外狀況</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">常見的 HRESULT 值</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得造成目前例外狀況的 <see cref="T:System.Exception" /> 執行個體。</summary>
        <value>物件，描述造成目前例外狀況的錯誤。 <see cref="P:System.Exception.InnerException" /> 屬性會傳回與傳遞到 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> 建構函式中相同的值；如果沒有提供內部例外狀況值給建構函式，則傳回 <see langword="null" />。 這個屬性是唯讀的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當例外狀況`X`做為先前的例外狀況直接結果擲回`Y`，則<xref:System.Exception.InnerException%2A>屬性`X`應該包含的參考`Y`。  
  
 您可以使用 <xref:System.Exception.InnerException%2A> 屬性來取得造成目前例外狀況的例外狀況集合。  
  
 您可以建立新的例外狀況攔截較早的例外狀況。 處理第二個例外狀況可以使用從先前的例外狀況的其他資訊以更適當地處理錯誤的程式碼。  
  
 假設有讀取檔案，並將該檔案中的資料格式的函式。 在此範例中，為程式碼嘗試讀取檔案，<xref:System.IO.IOException>就會擲回。 此函式會攔截<xref:System.IO.IOException>則會擲回<xref:System.IO.FileNotFoundException>。 <xref:System.IO.IOException>無法存入<xref:System.Exception.InnerException%2A>屬性<xref:System.IO.FileNotFoundException>，啟用程式碼，以攔截<xref:System.IO.FileNotFoundException>檢查初始錯誤的原因。  
  
 <xref:System.Exception.InnerException%2A>屬性，其中包含內部例外狀況的參考，會設定例外狀況物件初始化時。  
  
   
  
## Examples  
 下列範例示範擲回和攔截例外狀況參考內部例外狀況。  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得描述目前例外狀況的訊息。</summary>
        <value>解釋例外狀況原因的錯誤訊息，或空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 錯誤訊息為目標的開發人員正在處理的例外狀況。 文字<xref:System.Exception.Message%2A>屬性應該完整描述錯誤，可能的話，應該也會說明如何修正錯誤。 最上層的例外狀況處理常式可能會顯示訊息給使用者，因此您應確定它是文法正確，而且訊息的每個句子是以句號結尾。 請勿使用問號或驚嘆號。 如果您的應用程式會使用當地語系化的例外狀況訊息，您應該確保它們會正確轉譯。  
  
> [!IMPORTANT]
>  不公開的例外狀況訊息中的機密資訊而不檢查適當的權限。  
  
 值<xref:System.Exception.Message%2A>屬性是否包含在所傳回的資訊<xref:System.Exception.ToString%2A>。<xref:System.Exception.Message%2A>只有在建立時，才設定屬性<xref:System.Exception>。 如果目前的執行個體的建構函式提供的任何訊息，因此系統會不提供預設的訊息，使用目前的系統文化特性進行格式化。  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 執行階段和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 開頭[!INCLUDE[net_v451](~/includes/net-v451-md.md)]和[!INCLUDE[win81](~/includes/win81-md.md)]，從 Windows 執行階段型別和成員不是.NET Framework 的一部分傳播的例外狀況錯誤訊息的精確度已獲得改善。 特別是，例外狀況訊息 Visual c + + 元件擴充功能 (C + + /CX) 現在會傳播回.NET Framework<xref:System.Exception>物件。  
  
   
  
## Examples  
 下列程式碼範例會擲回，然後捕捉<xref:System.Exception>例外狀況，並顯示例外狀況的文字訊息使用<xref:System.Exception.Message%2A>屬性。
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果您擲回的例外狀況屬性，而且您需要參考中的文字<see cref="P:System.Exception.Message" />您設定或取得屬性引數，請使用 「 值 」 做為屬性引數的名稱。</para></block>
        <block subset="none" type="overrides"><para><see cref="P:System.Exception.Message" />需要控制訊息內容或格式的類別中覆寫屬性。 需要顯示已攔截的例外狀況的相關資訊時，應用程式程式碼通常會存取這個屬性。  
  
應該當地語系化錯誤訊息。</para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當例外狀況序列化，以建立包含例外狀況相關序列化資料的例外狀況狀態物件時，就會發生此事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外狀況狀態物件會實作<xref:System.Runtime.Serialization.ISafeSerializationData>介面。  
  
 當<xref:System.Exception.SerializeObjectState>訂閱事件、 例外狀況是還原序列化，並建立成空的例外狀況。 例外狀況的建構函式時不執行，並也會還原序列化的例外狀況狀態。 <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A>回呼方法的例外狀況的狀態物件再收到通知，讓它可以將已還原序列化的資料推送至空的例外狀況。  
  
 <xref:System.Exception.SerializeObjectState>事件可讓透明的例外狀況型別序列化和還原序列化例外狀況資料。 透明程式碼可以執行它正在運作中的權限集合的範圍內的命令，但無法執行、 呼叫、 衍生自或包含關鍵程式碼。  
  
 如果<xref:System.Exception.SerializeObjectState>事件沒有訂閱，還原序列化發生如往常般使用<xref:System.Exception.%23ctor%2A>建構函式。  
  
 一般而言，處理常式<xref:System.Exception.SerializeObjectState>提供其序列化的例外狀況的建構函式中加入事件。 但因為建構函式不是執行的時機<xref:System.Exception.SerializeObjectState>事件處理常式執行時，序列化的已還原序列化的例外狀況可能會擲回<xref:System.Runtime.Serialization.SerializationException>當您嘗試還原序列化例外狀況的例外狀況。 若要避免這個問題，您還應該加入的處理常式<xref:System.Exception.SerializeObjectState>中的事件<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>方法。 請參閱圖範例 > 一節。  
  
   
  
## Examples  
 下列範例會定義`BadDivisionException`處理<xref:System.Exception.SerializeObjectState>事件。 它也包含狀態的物件，也就是巢狀結構，名為`BadDivisionExceptionState`實作<xref:System.Runtime.Serialization.ISafeSerializationData>介面。  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException`浮點的除數為零，就會發生時擲回例外狀況。 第一個除數為零，在此範例會具現化`BadDivisionException`物件序列化，並擲回例外狀況。 為零的後續部門發生時，此範例會將先前序列化的物件還原序列化、 這，並擲回例外狀況。 若要提供物件序列化、 還原序列化、 雷同和還原序列化，此範例會新增<xref:System.Exception.SerializeObjectState>事件處理常式這兩個`BadDivisionException`類別建構函式和<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>實作。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果此事件是訂閱，並使用，請依照下列繼承階層架構中的所有衍生型別必須實作相同的序列化機制。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定造成錯誤的應用程式或物件的名稱。</summary>
        <value>造成錯誤的應用程式或物件的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Exception.Source%2A>屬性未明確設定、 執行階段會自動設定它的例外狀況的來源組件名稱。  
  
   
  
## Examples  
 下列範例會擲回`Exception`如此`Source`屬性，其建構函式，然後攔截到例外狀況並顯示`Source`。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">此物件必須是執行階段 <see cref="N:System.Reflection" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得呼叫堆疊上即時運算框架的字串表示。</summary>
        <value>字串，描述呼叫堆疊的立即框架。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行堆疊會持續追蹤指定的執行個體的所有執行中方法。 方法呼叫的追蹤稱為堆疊追蹤。 堆疊追蹤清單可用來遵循此方法中的行號發生例外狀況呼叫堆疊。  
  
 <xref:System.Exception.StackTrace%2A>屬性會傳回呼叫堆疊的框架，顯示源自於擲回的例外狀況的位置。 您可以建立的新執行個體，以取得其他框架呼叫堆疊中的相關資訊<xref:System.Diagnostics.StackTrace?displayProperty=nameWithType>類別，並使用其<xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType>方法。  
  
 每當應用程式程式碼中擲回例外狀況時，common language runtime (CLR) 會更新的堆疊追蹤 (使用`throw`關鍵字)。 如果是不同的方法，它原來擲回的方法中擲回例外狀況，堆疊追蹤包含其中原先擲回例外狀況，方法中的位置及方法中發生例外狀況的所在位置重新擲回。 如果擲回，且稍後重新擲回，在相同的方法中，例外狀況堆疊追蹤只會包含例外狀況重新擲回，並不包含其中原先擲回例外狀況的位置的位置。  
  
 <xref:System.Exception.StackTrace%2A>屬性可能不會報告多個方法呼叫，如預期般運作的程式碼轉換，因為這類內嵌 （inline)，在最佳化期間會發生。  
  
   
  
## Examples  
 下列程式碼範例會擲回`Exception`然後攔截它，並顯示堆疊追蹤使用`StackTrace`屬性。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see langword="StackTrace" />需要控制的堆疊追蹤內容或格式的類別中覆寫屬性。  
  
根據預設，堆疊追蹤會擷取之前就會擲回例外狀況物件。 使用<see cref="P:System.Environment.StackTrace" />時所擲不回任何例外狀況取得堆疊追蹤資訊。</para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得擲回目前例外狀況的方法。</summary>
        <value>擲回目前例外狀況的 <see cref="T:System.Reflection.MethodBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果擲回這個例外狀況的方法不提供和堆疊追蹤不是 null 參考 (`Nothing`在 Visual Basic 中)，<xref:System.Exception.TargetSite%2A>從堆疊追蹤取得方法。 如果堆疊追蹤是 null 參考，<xref:System.Exception.TargetSite%2A> 也就會傳回 null 參考。  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A>屬性可能不會準確地報告中已擲回例外狀況的例外狀況處理常式處理例外狀況跨應用程式定義域界限的方法名稱。  
  
   
  
## Examples  
 下列程式碼範例會擲回`Exception`然後攔截它，並顯示原始的方法使用`TargetSite`屬性。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立並傳回目前例外狀況的字串表示。</summary>
        <returns>目前例外狀況的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> 傳回表示目前的例外狀況，目的是讓人了解。 例外狀況包含區分文化特性的資料，所傳回的字串表示`ToString`需要納入考量目前系統文化特性。 雖然傳回之字串的格式沒有實際上的需求，但它應該嘗試反映做使用者察覺到物件的值。  
  
 預設實作<xref:System.Exception.ToString%2A>取得擲回目前例外狀況、 訊息、 呼叫的類別名稱<xref:System.Exception.ToString%2A>上的內部例外狀況，並呼叫<xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>。 如果有任何這些成員是`null`，其值不包含在傳回的字串。  
  
 如果沒有任何錯誤訊息，或者它是空字串 ("")，則會不傳回任何錯誤訊息。 如果它們不是，會傳回內部例外狀況和堆疊追蹤的名稱`null`。  
  
 這個方法會覆寫 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會導致例外狀況，並顯示呼叫<xref:System.Exception.ToString%2A>該例外狀況。 請注意，<xref:System.Exception.ToString%2A?displayProperty=nameWithType>的引數清單中出現的例外狀況類別執行個體時隱含地呼叫方法<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>