<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="849d30aa85e6c854b68c1ba21c0d2b2f5b5886ce" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52385598" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="d685c-101">代表應用程式執行期間所發生的錯誤。</span>
      <span class="sxs-lookup">
        <span data-stu-id="d685c-101">Represents errors that occur during application execution.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-102">這個類別是所有的例外狀況的基底類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-102">This class is the base class for all exceptions.</span></span> <span data-ttu-id="d685c-103">發生錯誤時，「 系統 」 或 「 目前正在執行的應用程式會報告它藉由擲回例外狀況，其中包含錯誤的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="d685c-103">When an error occurs, either the system or the currently executing application reports it by throwing an exception that contains information about the error.</span></span> <span data-ttu-id="d685c-104">擲回例外狀況之後，它會處理應用程式或預設的例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="d685c-104">After an exception is thrown, it is handled by the application or by the default exception handler.</span></span>  
  
 <span data-ttu-id="d685c-105">本節內容：</span><span class="sxs-lookup"><span data-stu-id="d685c-105">In this section:</span></span>  
  
 <span data-ttu-id="d685c-106">[錯誤和例外狀況](#Errors) </span><span class="sxs-lookup"><span data-stu-id="d685c-106">[Errors and exceptions](#Errors) </span></span>  
 <span data-ttu-id="d685c-107">[Try/catch 區塊](#TryCatch) </span><span class="sxs-lookup"><span data-stu-id="d685c-107">[Try/catch blocks](#TryCatch) </span></span>  
 <span data-ttu-id="d685c-108">[例外狀況類型的功能](#Features) </span><span class="sxs-lookup"><span data-stu-id="d685c-108">[Exception type features](#Features) </span></span>  
 <span data-ttu-id="d685c-109">[例外狀況類別屬性](#Properties) </span><span class="sxs-lookup"><span data-stu-id="d685c-109">[Exception class properties](#Properties) </span></span>  
 <span data-ttu-id="d685c-110">[效能考量](#Performance) </span><span class="sxs-lookup"><span data-stu-id="d685c-110">[Performance considerations](#Performance) </span></span>  
 <span data-ttu-id="d685c-111">[重新擲回例外狀況](#Rethrow) </span><span class="sxs-lookup"><span data-stu-id="d685c-111">[Re-throwing an exception](#Rethrow) </span></span>  
 <span data-ttu-id="d685c-112">[選擇標準例外狀況](#Standard) </span><span class="sxs-lookup"><span data-stu-id="d685c-112">[Choosing standard exceptions](#Standard) </span></span>  
 [<span data-ttu-id="d685c-113">實作自訂的例外狀況</span><span class="sxs-lookup"><span data-stu-id="d685c-113">Implementing custom exceptions</span></span>](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a><span data-ttu-id="d685c-114">錯誤和例外狀況</span><span class="sxs-lookup"><span data-stu-id="d685c-114">Errors and exceptions</span></span>  
 <span data-ttu-id="d685c-115">有許多原因可能會發生執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-115">Run-time errors can occur for a variety of reasons.</span></span> <span data-ttu-id="d685c-116">不過，並非所有的錯誤應該處理為您的程式碼中的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-116">However, not all errors should be handled as exceptions in your code.</span></span> <span data-ttu-id="d685c-117">以下是一些類別，可以在執行的階段和適當的方式來回應它們出現的錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-117">Here are some categories of errors that can occur at run time and the appropriate ways to respond to them.</span></span>  
  
-   <span data-ttu-id="d685c-118">**使用方式錯誤。**</span><span class="sxs-lookup"><span data-stu-id="d685c-118">**Usage errors.**</span></span> <span data-ttu-id="d685c-119">使用方式錯誤表示在可能會導致例外狀況的程式邏輯中的錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-119">A usage error represents an error in program logic that can result in an exception.</span></span> <span data-ttu-id="d685c-120">不過，不是透過例外狀況處理，但藉由修改錯誤的程式碼，應該解決錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-120">However, the error should be addressed not through exception handling but by modifying the faulty code.</span></span> <span data-ttu-id="d685c-121">例如的覆寫<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，在下列範例會假設`obj`引數必須永遠為非 null。</span><span class="sxs-lookup"><span data-stu-id="d685c-121">For example, the override of the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method in the following example assumes that the `obj` argument must always be non-null.</span></span>  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <span data-ttu-id="d685c-122"><xref:System.NullReferenceException>產生的例外狀況時`obj`是`null`被消除，可以修改原始程式碼，以明確地測試是否為 null，然後再呼叫<xref:System.Object.Equals%2A?displayProperty=nameWithType>覆寫和重新編譯。</span><span class="sxs-lookup"><span data-stu-id="d685c-122">The <xref:System.NullReferenceException> exception that results when `obj` is `null` can be eliminated by modifying the source code to explicitly test for null before calling the <xref:System.Object.Equals%2A?displayProperty=nameWithType> override and then re-compiling.</span></span> <span data-ttu-id="d685c-123">下列範例包含已更正的原始程式碼，可處理`null`引數。</span><span class="sxs-lookup"><span data-stu-id="d685c-123">The following example contains the corrected source code that handles a `null` argument.</span></span>  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     <span data-ttu-id="d685c-124">除了使用例外狀況處理的使用方式錯誤，您可以使用<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType>方法，以找出偵錯組建中的使用方式錯誤和<xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType>方法，以找出使用方式錯誤，在偵錯和發行組建。</span><span class="sxs-lookup"><span data-stu-id="d685c-124">Instead of using exception handling for usage errors, you can use the <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> method to identify usage errors in debug builds, and the <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> method to identify usage errors in both debug and release builds.</span></span> <span data-ttu-id="d685c-125">如需詳細資訊，請參閱 < [Managed 程式碼中的判斷提示](/visualstudio/debugger/assertions-in-managed-code)。</span><span class="sxs-lookup"><span data-stu-id="d685c-125">For more information, see [Assertions in Managed Code](/visualstudio/debugger/assertions-in-managed-code).</span></span>  
  
-   <span data-ttu-id="d685c-126">**程式錯誤。**</span><span class="sxs-lookup"><span data-stu-id="d685c-126">**Program errors.**</span></span> <span data-ttu-id="d685c-127">程式錯誤是一定無法避免撰寫無 bug 的程式碼的執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-127">A program error is a run-time error that cannot necessarily be avoided by writing bug-free code.</span></span>  
  
     <span data-ttu-id="d685c-128">在某些情況下，程式錯誤可能會反映預期或例行的錯誤狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-128">In some cases, a program error may reflect an expected or routine error condition.</span></span> <span data-ttu-id="d685c-129">在此情況下，建議您避免使用例外狀況處理程式錯誤處理，並改為重試此作業。</span><span class="sxs-lookup"><span data-stu-id="d685c-129">In this case, you may want to avoid using exception handling to deal with the program error and instead retry the operation.</span></span> <span data-ttu-id="d685c-130">例如，如果使用者只需要輸入特定格式的日期，您可以剖析日期字串藉由呼叫<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法，以傳回<xref:System.Boolean>值，指出是否剖析作業成功，而不是使用<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法，就會擲回<xref:System.FormatException>例外狀況，如果日期字串無法轉換成<xref:System.DateTime>值。</span><span class="sxs-lookup"><span data-stu-id="d685c-130">For example, if the user is expected to input a date in a particular format, you can parse the date string by calling the <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> method, which returns a <xref:System.Boolean> value that indicates whether the parse operation succeeded, instead of using the <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> method, which throws a <xref:System.FormatException> exception if the date string cannot be converted to a <xref:System.DateTime> value.</span></span> <span data-ttu-id="d685c-131">同樣地，如果使用者嘗試開啟不存在的檔案，您可以先呼叫<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>方法來檢查檔案是否存在，然後，如果沒有出現，請提示使用者是否想要建立它。</span><span class="sxs-lookup"><span data-stu-id="d685c-131">Similarly, if a user tries to open a file that does not exist, you can first call the <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> method to check whether the file exists and, if it does not, prompt the user whether he or she wants to create it.</span></span>  
  
     <span data-ttu-id="d685c-132">在其他情況下，程式錯誤會反映您的程式碼中可以處理非預期的錯誤狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-132">In other cases, a program error reflects an unexpected error condition that can be handled in your code.</span></span> <span data-ttu-id="d685c-133">比方說，即使您已檢查，以確保檔案存在，它可能會刪除之前，您可以開啟它，或它可能已損毀。</span><span class="sxs-lookup"><span data-stu-id="d685c-133">For example, even if you've checked to ensure that a file exists, it may be deleted before you can open it, or it may be corrupted.</span></span> <span data-ttu-id="d685c-134">在此情況下，嘗試開啟檔案，藉由執行個體化<xref:System.IO.StreamReader>物件或呼叫<xref:System.IO.File.Open%2A>方法可能會擲回<xref:System.IO.FileNotFoundException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-134">In that case, trying to open the file by instantiating a <xref:System.IO.StreamReader> object or calling the <xref:System.IO.File.Open%2A> method may throw a <xref:System.IO.FileNotFoundException> exception.</span></span> <span data-ttu-id="d685c-135">在這些情況下，您應該使用例外狀況處理來從錯誤復原。</span><span class="sxs-lookup"><span data-stu-id="d685c-135">In these cases, you should use exception handling to recover from the error.</span></span>  
  
-   <span data-ttu-id="d685c-136">**系統失敗。**</span><span class="sxs-lookup"><span data-stu-id="d685c-136">**System failures.**</span></span> <span data-ttu-id="d685c-137">在系統失敗是無法有意義的方式以程式設計方式處理執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-137">A system failure is a run-time error that cannot be handled programmatically in a meaningful way.</span></span> <span data-ttu-id="d685c-138">例如，任何方法可以擲回<xref:System.OutOfMemoryException>例外狀況，如果 common language runtime 無法配置額外的記憶體。</span><span class="sxs-lookup"><span data-stu-id="d685c-138">For example, any method can throw an <xref:System.OutOfMemoryException> exception if the common language runtime is unable to allocate additional memory.</span></span> <span data-ttu-id="d685c-139">一般情況下，使用例外狀況處理不會處理系統失敗。</span><span class="sxs-lookup"><span data-stu-id="d685c-139">Ordinarily, system failures are not handled by using exception handling.</span></span> <span data-ttu-id="d685c-140">相反地，您可以使用事件，例如<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>並呼叫<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>記錄例外狀況資訊，並通知失敗的使用者，應用程式終止之前的方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-140">Instead, you may be able to use an event such as <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> and call the <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> method to log exception information and notify the user of the failure before the application terminates.</span></span>  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a><span data-ttu-id="d685c-141">Try/catch 區塊</span><span class="sxs-lookup"><span data-stu-id="d685c-141">Try/catch blocks</span></span>  
 <span data-ttu-id="d685c-142">Common language runtime 提供的例外狀況處理模型為基礎的例外狀況物件，表示和的程式碼和例外狀況處理程式碼分隔`try`區塊和`catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="d685c-142">The common language runtime provides an exception handling model that is based on the representation of exceptions as objects, and the separation of program code and exception handling code into `try` blocks and `catch` blocks.</span></span> <span data-ttu-id="d685c-143">可以有一或多個`catch`區塊，每個設計用來處理特定類型的例外狀況或一個設計用來攔截更特定的例外狀況，比另一個區塊的區塊。</span><span class="sxs-lookup"><span data-stu-id="d685c-143">There can be one or more `catch` blocks, each designed to handle a particular type of exception, or one block designed to catch a more specific exception than another block.</span></span>  
  
 <span data-ttu-id="d685c-144">如果應用程式處理的應用程式程式碼區塊在執行期間發生的例外狀況，程式碼必須放`try`陳述式，稱為`try`區塊。</span><span class="sxs-lookup"><span data-stu-id="d685c-144">If an application handles exceptions that occur during the execution of a block of application code, the code must be placed within a `try` statement and is called a `try` block.</span></span> <span data-ttu-id="d685c-145">處理所擲回的例外狀況的應用程式程式碼`try`區塊會放置在`catch`陳述式，稱為`catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="d685c-145">Application code that handles exceptions thrown by a `try` block is placed within a `catch` statement and is called a `catch` block.</span></span> <span data-ttu-id="d685c-146">零或多個`catch`區塊相關聯`try`區塊，以及每個`catch`區塊包含型別篩選條件，判斷它所處理的例外狀況的類型。</span><span class="sxs-lookup"><span data-stu-id="d685c-146">Zero or more `catch` blocks are associated with a `try` block, and each `catch` block includes a type filter that determines the types of exceptions it handles.</span></span>  
  
 <span data-ttu-id="d685c-147">當發生例外狀況`try`區塊中，系統會搜尋相關聯`catch`區塊，以它們出現在應用程式程式碼，直到它找到的順序`catch`區塊處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-147">When an exception occurs in a `try` block, the system searches the associated `catch` blocks in the order they appear in application code, until it locates a `catch` block that handles the exception.</span></span> <span data-ttu-id="d685c-148">A`catch`區塊處理例外狀況型別的`T`如果指定的 catch 區塊的型別篩選`T`或任何型別`T`衍生自。</span><span class="sxs-lookup"><span data-stu-id="d685c-148">A `catch` block handles an exception of type `T` if the type filter of the catch block specifies `T` or any type that `T` derives from.</span></span> <span data-ttu-id="d685c-149">系統會停止搜尋之後找到的第一個`catch`區塊處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-149">The system stops searching after it finds the first `catch` block that handles the exception.</span></span> <span data-ttu-id="d685c-150">基於這個理由，在應用程式程式碼`catch`之前，必須指定處理類型的區塊`catch`處理其基底類型，接下來這一節的範例所示的區塊。</span><span class="sxs-lookup"><span data-stu-id="d685c-150">For this reason, in application code, a `catch` block that handles a type must be specified before a `catch` block that handles its base types, as demonstrated in the example that follows this section.</span></span> <span data-ttu-id="d685c-151">Catch 區塊處理`System.Exception`指定上一次。</span><span class="sxs-lookup"><span data-stu-id="d685c-151">A catch block that handles `System.Exception` is specified last.</span></span>  
  
 <span data-ttu-id="d685c-152">如果沒有任何`catch`目前相關聯的區塊`try`區塊處理例外狀況和目前`try`區塊的巢狀在其他`try`在目前的呼叫中，會封鎖`catch`區塊相關聯的下一步封入`try`區塊會搜尋。</span><span class="sxs-lookup"><span data-stu-id="d685c-152">If none of the `catch` blocks associated with the current `try` block handle the exception, and the current `try` block is nested within other `try` blocks in the current call, the `catch` blocks associated with the next enclosing `try` block are searched.</span></span> <span data-ttu-id="d685c-153">如果沒有`catch`找不到例外狀況區塊時，系統會搜尋目前的呼叫中先前的巢狀層級。</span><span class="sxs-lookup"><span data-stu-id="d685c-153">If no `catch` block for the exception is found, the system searches previous nesting levels in the current call.</span></span> <span data-ttu-id="d685c-154">如果沒有`catch`封鎖目前的呼叫中找到的例外狀況，例外狀況呼叫堆疊中向上傳遞，且一個堆疊框架中搜尋`catch`區塊處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-154">If no `catch` block for the exception is found in the current call, the exception is passed up the call stack, and the previous stack frame is searched for a `catch` block that handles the exception.</span></span> <span data-ttu-id="d685c-155">呼叫堆疊的搜尋會繼續直到例外狀況處理或呼叫堆疊上不存在任何框架。</span><span class="sxs-lookup"><span data-stu-id="d685c-155">The search of the call stack continues until the exception is handled or until no more frames exist on the call stack.</span></span> <span data-ttu-id="d685c-156">如果呼叫堆疊的頂端尋找沒有達到`catch`區塊處理例外狀況，預設的例外狀況處理常式處理它，且應用程式終止。</span><span class="sxs-lookup"><span data-stu-id="d685c-156">If the top of the call stack is reached without finding a `catch` block that handles the exception, the default exception handler handles it and the application terminates.</span></span>  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a><span data-ttu-id="d685c-157">例外狀況類型的功能</span><span class="sxs-lookup"><span data-stu-id="d685c-157">Exception type features</span></span>  
 <span data-ttu-id="d685c-158">例外狀況類型支援下列功能：</span><span class="sxs-lookup"><span data-stu-id="d685c-158">Exception types support the following features:</span></span>  
  
-   <span data-ttu-id="d685c-159">人類看得懂的文字描述錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-159">Human-readable text that describes the error.</span></span> <span data-ttu-id="d685c-160">發生例外狀況時，執行階段就會建立可用來通知使用者錯誤的本質，以及建議的動作文字訊息來解決問題。</span><span class="sxs-lookup"><span data-stu-id="d685c-160">When an exception occurs, the runtime makes a text message available to inform the user of the nature of the error and to suggest action to resolve the problem.</span></span> <span data-ttu-id="d685c-161">此文字訊息會保留在<xref:System.Exception.Message%2A>例外狀況物件的屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-161">This text message is held in the <xref:System.Exception.Message%2A> property of the exception object.</span></span> <span data-ttu-id="d685c-162">在例外狀況物件建立時，您可以傳遞文字字串的建構函式，來描述該特定的例外狀況詳細資料。</span><span class="sxs-lookup"><span data-stu-id="d685c-162">During the creation of the exception object, you can pass a text string to the constructor to describe the details of that particular exception.</span></span> <span data-ttu-id="d685c-163">如果任何錯誤訊息引數不提供給建構函式，會使用預設的錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="d685c-163">If no error message argument is supplied to the constructor, the default error message is used.</span></span> <span data-ttu-id="d685c-164">如需詳細資訊，請參閱 <xref:System.Exception.Message%2A> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="d685c-164">For more information, see the <xref:System.Exception.Message%2A> property.</span></span>  
  
-   <span data-ttu-id="d685c-165">呼叫堆疊時擲回例外狀況的狀態。</span><span class="sxs-lookup"><span data-stu-id="d685c-165">The state of the call stack when the exception was thrown.</span></span> <span data-ttu-id="d685c-166"><xref:System.Exception.StackTrace%2A>屬性包含可用來判斷程式碼中發生錯誤的堆疊追蹤。</span><span class="sxs-lookup"><span data-stu-id="d685c-166">The <xref:System.Exception.StackTrace%2A> property carries a stack trace that can be used to determine where the error occurs in the code.</span></span> <span data-ttu-id="d685c-167">堆疊追蹤會列出所有被呼叫的方法和原始程式檔進行的呼叫中的行號。</span><span class="sxs-lookup"><span data-stu-id="d685c-167">The stack trace lists all the called methods and the line numbers in the source file where the calls are made.</span></span>  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a><span data-ttu-id="d685c-168">例外狀況類別屬性</span><span class="sxs-lookup"><span data-stu-id="d685c-168">Exception class properties</span></span>  
 <span data-ttu-id="d685c-169"><xref:System.Exception>類別包含數個屬性，可協助識別程式碼位置、 類型、 說明檔，以及例外狀況的原因： <xref:System.Exception.StackTrace%2A>， <xref:System.Exception.InnerException%2A>， <xref:System.Exception.Message%2A>， <xref:System.Exception.HelpLink%2A>， <xref:System.Exception.HResult%2A>， <xref:System.Exception.Source%2A>，<xref:System.Exception.TargetSite%2A>，和<xref:System.Exception.Data%2A>。</span><span class="sxs-lookup"><span data-stu-id="d685c-169">The <xref:System.Exception> class includes a number of properties that help identify the code location, the type, the help file, and the reason for the exception: <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, and <xref:System.Exception.Data%2A>.</span></span>  
  
 <span data-ttu-id="d685c-170">當兩個或多個例外狀況之間的因果關係存在<xref:System.Exception.InnerException%2A>屬性維護這項資訊。</span><span class="sxs-lookup"><span data-stu-id="d685c-170">When a causal relationship exists between two or more exceptions, the <xref:System.Exception.InnerException%2A> property maintains this information.</span></span> <span data-ttu-id="d685c-171">以回應這個內部例外狀況擲回外部例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-171">The outer exception is thrown in response to this inner exception.</span></span> <span data-ttu-id="d685c-172">處理外部例外狀況的程式碼可以使用從先前的內部例外的資訊，以更適當地處理錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-172">The code that handles the outer exception can use the information from the earlier inner exception to handle the error more appropriately.</span></span> <span data-ttu-id="d685c-173">例外狀況的相關補充資訊可以儲存為索引鍵/值組的集合<xref:System.Exception.Data%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-173">Supplementary information about the exception can be stored as a collection of key/value pairs in the <xref:System.Exception.Data%2A> property.</span></span>  
  
 <span data-ttu-id="d685c-174">傳遞至建構函式的例外狀況物件建立期間的錯誤訊息字串應該當地語系化，而且可以藉由提供從資源檔<xref:System.Resources.ResourceManager>類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-174">The error message string that is passed to the constructor during the creation of the exception object should be localized and can be supplied from a resource file by using the <xref:System.Resources.ResourceManager> class.</span></span> <span data-ttu-id="d685c-175">如需當地語系化資源的詳細資訊，請參閱[建立附屬組件](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)並[封裝和部署資源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主題。</span><span class="sxs-lookup"><span data-stu-id="d685c-175">For more information about localized resources, see the [Creating Satellite Assemblies](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) and [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) topics.</span></span>  
  
 <span data-ttu-id="d685c-176">為使用者提供大量資訊的例外狀況發生的原因，<xref:System.Exception.HelpLink%2A>屬性可以保留的 URL （或 URN） 的說明檔。</span><span class="sxs-lookup"><span data-stu-id="d685c-176">To provide the user with extensive information about why the exception occurred, the <xref:System.Exception.HelpLink%2A> property can hold a URL (or URN) to a help file.</span></span>  
  
 <span data-ttu-id="d685c-177"><xref:System.Exception>類別會使用 HRESULT COR_E_EXCEPTION，其值 0x80131500。</span><span class="sxs-lookup"><span data-stu-id="d685c-177">The <xref:System.Exception> class uses the HRESULT COR_E_EXCEPTION, which has the value 0x80131500.</span></span>  
  
 <span data-ttu-id="d685c-178">如需執行個體的初始屬性值的清單<xref:System.Exception>類別，請參閱<xref:System.Exception.%23ctor%2A>建構函式。</span><span class="sxs-lookup"><span data-stu-id="d685c-178">For a list of initial property values for an instance of the <xref:System.Exception> class, see the <xref:System.Exception.%23ctor%2A> constructors.</span></span>  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a><span data-ttu-id="d685c-179">效能考量</span><span class="sxs-lookup"><span data-stu-id="d685c-179">Performance considerations</span></span>  
 <span data-ttu-id="d685c-180">擲回或處理的例外狀況會耗用大量系統資源和執行時間。</span><span class="sxs-lookup"><span data-stu-id="d685c-180">Throwing or handling an exception consumes a significant amount of system resources and execution time.</span></span> <span data-ttu-id="d685c-181">擲回例外狀況，才能處理真正的異常狀況，不能處理可預測的事件，或流量控制。</span><span class="sxs-lookup"><span data-stu-id="d685c-181">Throw exceptions only to handle truly extraordinary conditions, not to handle predictable events or flow control.</span></span> <span data-ttu-id="d685c-182">比方說，在某些情況下，例如當您正在開發類別庫，它是合理的方法引數無效，因為您預期您用有效的參數來呼叫的方法擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-182">For example, in some cases, such as when you're developing a class library, it's reasonable to throw an exception if a method argument is invalid, because you expect your method to be called with valid parameters.</span></span> <span data-ttu-id="d685c-183">無效的方法引數，如果它不是結果的使用方式錯誤，表示發生某個非經常性 」。</span><span class="sxs-lookup"><span data-stu-id="d685c-183">An invalid method argument, if it is not the result of a usage error, means that something extraordinary has occurred.</span></span> <span data-ttu-id="d685c-184">相反地，並不會擲回例外狀況如果使用者輸入無效，因為您可以預期使用者偶爾輸入無效的資料。</span><span class="sxs-lookup"><span data-stu-id="d685c-184">Conversely, do not throw an exception if user input is invalid, because you can expect users to occasionally enter invalid data.</span></span> <span data-ttu-id="d685c-185">相反地，提供重試機制，讓使用者可以輸入有效的輸入。</span><span class="sxs-lookup"><span data-stu-id="d685c-185">Instead, provide a retry mechanism so users can enter valid input.</span></span> <span data-ttu-id="d685c-186">也不應該使用例外狀況來處理使用方式錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-186">Nor should you use exceptions to handle usage errors.</span></span> <span data-ttu-id="d685c-187">請改用[判斷提示](/visualstudio/debugger/assertions-in-managed-code)找出並改正用法錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-187">Instead, use [assertions](/visualstudio/debugger/assertions-in-managed-code) to identify and correct usage errors.</span></span>  
  
 <span data-ttu-id="d685c-188">颾魤 ㄛ 並不會擲回例外狀況時傳回的程式碼就已足夠;無法轉換成例外狀況，傳回碼和不定期執行 catch 例外狀況、 忽略它，並繼續處理。</span><span class="sxs-lookup"><span data-stu-id="d685c-188">In addition, do not throw an exception when a return code is sufficient; do not convert a return code to an exception; and do not routinely catch an exception, ignore it, and then continue processing.</span></span>  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a><span data-ttu-id="d685c-189">重新擲回例外狀況</span><span class="sxs-lookup"><span data-stu-id="d685c-189">Re-throwing an exception</span></span>  
 <span data-ttu-id="d685c-190">在許多情況下，例外狀況處理常式只是想要傳遞至呼叫端的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-190">In many cases, an exception handler simply wants to pass the exception on to the caller.</span></span> <span data-ttu-id="d685c-191">此狀況通常發生在：</span><span class="sxs-lookup"><span data-stu-id="d685c-191">This most often occurs in:</span></span>  
  
-   <span data-ttu-id="d685c-192">接著會包裝在.NET Framework 類別庫或其他類別庫中的方法呼叫類別庫。</span><span class="sxs-lookup"><span data-stu-id="d685c-192">A class library that in turn wraps calls to methods in the .NET Framework class library or other class libraries.</span></span>  
  
-   <span data-ttu-id="d685c-193">應用程式或遇到嚴重的例外狀況的程式庫。</span><span class="sxs-lookup"><span data-stu-id="d685c-193">An application or library that encounters a fatal exception.</span></span> <span data-ttu-id="d685c-194">例外狀況處理常式可以記錄例外狀況，並接著重新擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-194">The exception handler can log the exception and then re-throw the exception.</span></span>  
  
 <span data-ttu-id="d685c-195">重新擲回例外狀況的建議的方式是直接使用[擲回](~/docs/csharp/language-reference/keywords/throw.md)C# 中的陳述式並[擲回](~/docs/visual-basic/language-reference/statements/throw-statement.md)Visual Basic 中的陳述式，但不包含運算式。</span><span class="sxs-lookup"><span data-stu-id="d685c-195">The recommended way to re-throw an exception is to simply use the [throw](~/docs/csharp/language-reference/keywords/throw.md) statement in C# and the [Throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) statement in Visual Basic without including an expression.</span></span> <span data-ttu-id="d685c-196">這可確保呼叫端傳播例外狀況時，會保留所有的呼叫堆疊資訊。</span><span class="sxs-lookup"><span data-stu-id="d685c-196">This ensures that all call stack information is preserved when the exception is propagated to the caller.</span></span> <span data-ttu-id="d685c-197">下列範例將說明這點。</span><span class="sxs-lookup"><span data-stu-id="d685c-197">The following example illustrates this.</span></span> <span data-ttu-id="d685c-198">字串擴充方法`FindOccurrences`，將一或多個呼叫包裝<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>而不事先驗證其引數。</span><span class="sxs-lookup"><span data-stu-id="d685c-198">A string extension method, `FindOccurrences`, wraps one or more calls to <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> without validating its arguments beforehand.</span></span>  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 <span data-ttu-id="d685c-199">呼叫者接著會呼叫`FindOccurrences`兩次。</span><span class="sxs-lookup"><span data-stu-id="d685c-199">A caller then calls `FindOccurrences` twice.</span></span> <span data-ttu-id="d685c-200">第二個呼叫中`FindOccurrences`，呼叫端傳遞`null`做為搜尋字串，哪些案例<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentNullException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-200">In the second call to `FindOccurrences`, the caller passes a `null` as the search string, which cases the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> method to throw an <xref:System.ArgumentNullException> exception.</span></span> <span data-ttu-id="d685c-201">這個例外狀況由`FindOccurrences`方法來回傳遞給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="d685c-201">This exception is handled by the `FindOccurrences` method and passed back to the caller.</span></span> <span data-ttu-id="d685c-202">因為 throw 陳述式用沒有運算式，此範例的輸出會顯示呼叫堆疊會保留。</span><span class="sxs-lookup"><span data-stu-id="d685c-202">Because the throw statement is used with no expression, the output from the example shows that the call stack is preserved.</span></span>  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 <span data-ttu-id="d685c-203">相反地，如果使用重新擲回例外狀況</span><span class="sxs-lookup"><span data-stu-id="d685c-203">In contrast, if the exception is re-thrown by using the</span></span>  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 <span data-ttu-id="d685c-204">陳述式中，完整的呼叫堆疊不會保留，與此範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="d685c-204">statement, the full call stack is not preserved, and the example would generate the following output:</span></span>  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 <span data-ttu-id="d685c-205">稍微更麻煩的替代做法是擲回新的例外狀況，並保留在內部例外狀況的原始的例外狀況呼叫堆疊資訊。</span><span class="sxs-lookup"><span data-stu-id="d685c-205">A slightly more cumbersome alternative is to throw a new exception, and to preserve the original exception's call stack information in an inner exception.</span></span> <span data-ttu-id="d685c-206">呼叫者接著可以使用新的例外狀況<xref:System.Exception.InnerException%2A>屬性，以擷取堆疊框架和原始的例外狀況的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="d685c-206">The caller can then use the new exception's <xref:System.Exception.InnerException%2A> property to retrieve stack frame and other information about the original exception.</span></span> <span data-ttu-id="d685c-207">在此案例中，是 throw 陳述式：</span><span class="sxs-lookup"><span data-stu-id="d685c-207">In this case, the throw statement is:</span></span>  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 <span data-ttu-id="d685c-208">處理例外狀況的使用者程式碼必須知道<xref:System.Exception.InnerException%2A>屬性包含原始的例外狀況的相關資訊，如下列的例外狀況處理常式所示。</span><span class="sxs-lookup"><span data-stu-id="d685c-208">The user code that handles the exception has to know that the <xref:System.Exception.InnerException%2A> property contains information about the original exception, as the following exception handler illustrates.</span></span>  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a><span data-ttu-id="d685c-209">選擇標準例外狀況</span><span class="sxs-lookup"><span data-stu-id="d685c-209">Choosing standard exceptions</span></span>  
 <span data-ttu-id="d685c-210">當您有會擲回例外狀況時，您可以經常使用現有的例外狀況類型，在.NET Framework，而不是實作自訂的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-210">When you have to throw an exception, you can often use an existing exception type in the .NET Framework instead of implementing a custom exception.</span></span> <span data-ttu-id="d685c-211">您應該使用這兩項條件底下的標準例外狀況類型：</span><span class="sxs-lookup"><span data-stu-id="d685c-211">You should use a standard exception type under these two conditions:</span></span>  
  
-   <span data-ttu-id="d685c-212">您會擲回例外狀況造成的使用方式錯誤 (也就是由開發人員會呼叫您的方法所做的程式邏輯中的錯誤)。</span><span class="sxs-lookup"><span data-stu-id="d685c-212">You are throwing an exception that is caused by a usage error (that is, by an error in program logic made by the developer who is calling your method).</span></span> <span data-ttu-id="d685c-213">一般而言，您會擲回例外狀況這類<xref:System.ArgumentException>， <xref:System.ArgumentNullException>， <xref:System.InvalidOperationException>，或<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="d685c-213">Typically, you would throw an exception such as <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, or <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="d685c-214">字串，提供例外狀況物件的建構函式時具現化的例外狀況物件應該描述錯誤，以便開發人員可以修正此問題。</span><span class="sxs-lookup"><span data-stu-id="d685c-214">The string you supply to the exception object's constructor when instantiating the exception object should describe the error so that the developer can fix it.</span></span> <span data-ttu-id="d685c-215">如需詳細資訊，請參閱 <xref:System.Exception.Message%2A> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="d685c-215">For more information, see the <xref:System.Exception.Message%2A> property.</span></span>  
  
-   <span data-ttu-id="d685c-216">您要處理錯誤，以告知現有的.NET Framework 例外狀況的呼叫者。</span><span class="sxs-lookup"><span data-stu-id="d685c-216">You are handling an error that can be communicated to the caller with an existing .NET Framework exception.</span></span> <span data-ttu-id="d685c-217">您應該擲回的可能最具衍生性的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-217">You should throw the most derived exception possible.</span></span> <span data-ttu-id="d685c-218">例如，如果方法需要的是有效的列舉類型成員的引數，則應該擲回<xref:System.ComponentModel.InvalidEnumArgumentException>（最多衍生類別），而非<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="d685c-218">For example, if a method requires an argument to be a valid member of an enumeration type, you should throw an <xref:System.ComponentModel.InvalidEnumArgumentException> (the most derived class) rather than an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="d685c-219">下表列出常見的例外狀況類型以及下您會擲回它們的條件。</span><span class="sxs-lookup"><span data-stu-id="d685c-219">The following table lists common exception types and the conditions under which you would throw them.</span></span>  
  
|<span data-ttu-id="d685c-220">例外</span><span class="sxs-lookup"><span data-stu-id="d685c-220">Exception</span></span>|<span data-ttu-id="d685c-221">條件</span><span class="sxs-lookup"><span data-stu-id="d685c-221">Condition</span></span>|  
|---------------|---------------|  
|<xref:System.ArgumentException>|<span data-ttu-id="d685c-222">傳遞至方法的非 null 引數無效。</span><span class="sxs-lookup"><span data-stu-id="d685c-222">A non-null argument that is passed to a method is invalid.</span></span>|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="d685c-223">傳遞至方法的引數是`null`。</span><span class="sxs-lookup"><span data-stu-id="d685c-223">An argument that is passed to a method is `null`.</span></span>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="d685c-224">引數超出有效值的範圍。</span><span class="sxs-lookup"><span data-stu-id="d685c-224">An argument is outside the range of valid values.</span></span>|  
|<xref:System.IO.DirectoryNotFoundException>|<span data-ttu-id="d685c-225">部分目錄路徑不是有效的。</span><span class="sxs-lookup"><span data-stu-id="d685c-225">Part of a directory path is not valid.</span></span>|  
|<xref:System.DivideByZeroException>|<span data-ttu-id="d685c-226">整數中的分母或<xref:System.Decimal>除法運算為零。</span><span class="sxs-lookup"><span data-stu-id="d685c-226">The denominator in an integer or <xref:System.Decimal> division operation is zero.</span></span>|  
|<xref:System.IO.DriveNotFoundException>|<span data-ttu-id="d685c-227">磁碟機無法使用，或不存在。</span><span class="sxs-lookup"><span data-stu-id="d685c-227">A drive is unavailable or does not exist.</span></span>|  
|<xref:System.IO.FileNotFoundException>|<span data-ttu-id="d685c-228">檔案不存在。</span><span class="sxs-lookup"><span data-stu-id="d685c-228">A file does not exist.</span></span>|  
|<xref:System.FormatException>|<span data-ttu-id="d685c-229">值不是適當的格式來轉換從字串轉換方法這類`Parse`。</span><span class="sxs-lookup"><span data-stu-id="d685c-229">A value is not in an appropriate format to be converted from a string by a conversion method such as `Parse`.</span></span>|  
|<xref:System.IndexOutOfRangeException>|<span data-ttu-id="d685c-230">索引超出陣列或集合的界限。</span><span class="sxs-lookup"><span data-stu-id="d685c-230">An index is outside the bounds of an array or collection.</span></span>|  
|<xref:System.InvalidOperationException>|<span data-ttu-id="d685c-231">物件的目前狀態無效方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="d685c-231">A method call is invalid in an object's current state.</span></span>|  
|<xref:System.Collections.Generic.KeyNotFoundException>|<span data-ttu-id="d685c-232">找不到指定的索引鍵來存取集合中的成員。</span><span class="sxs-lookup"><span data-stu-id="d685c-232">The specified key for accessing a member in a collection cannot be found.</span></span>|  
|<xref:System.NotImplementedException>|<span data-ttu-id="d685c-233">未實作方法或作業。</span><span class="sxs-lookup"><span data-stu-id="d685c-233">A method or operation is not implemented.</span></span>|  
|<xref:System.NotSupportedException>|<span data-ttu-id="d685c-234">不支援方法或作業。</span><span class="sxs-lookup"><span data-stu-id="d685c-234">A method or operation is not supported.</span></span>|  
|<xref:System.ObjectDisposedException>|<span data-ttu-id="d685c-235">已處置的物件上執行作業。</span><span class="sxs-lookup"><span data-stu-id="d685c-235">An operation is performed on an object that has been disposed.</span></span>|  
|<xref:System.OverflowException>|<span data-ttu-id="d685c-236">算術、 轉型或轉換作業造成溢位。</span><span class="sxs-lookup"><span data-stu-id="d685c-236">An arithmetic, casting, or conversion operation results in an overflow.</span></span>|  
|<xref:System.IO.PathTooLongException>|<span data-ttu-id="d685c-237">路徑或檔案名稱超過系統定義的最大長度。</span><span class="sxs-lookup"><span data-stu-id="d685c-237">A path or file name exceeds the maximum system-defined length.</span></span>|  
|<xref:System.PlatformNotSupportedException>|<span data-ttu-id="d685c-238">在目前的平台上不支援此作業。</span><span class="sxs-lookup"><span data-stu-id="d685c-238">The operation is not supported on the current platform.</span></span>|  
|<xref:System.RankException>|<span data-ttu-id="d685c-239">具有錯誤維度數目的陣列會傳遞至方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-239">An array with the wrong number of dimensions is passed to a method.</span></span>|  
|<xref:System.TimeoutException>|<span data-ttu-id="d685c-240">分配給作業的時間間隔已過期。</span><span class="sxs-lookup"><span data-stu-id="d685c-240">The time interval allotted to an operation has expired.</span></span>|  
|<xref:System.UriFormatException>|<span data-ttu-id="d685c-241">無效的統一資源識別元 (URI) 會使用。</span><span class="sxs-lookup"><span data-stu-id="d685c-241">An invalid Uniform Resource Identifier (URI) is used.</span></span>|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a><span data-ttu-id="d685c-242">實作自訂的例外狀況</span><span class="sxs-lookup"><span data-stu-id="d685c-242">Implementing custom exceptions</span></span>  
 <span data-ttu-id="d685c-243">在下列情況中，使用現有的.NET Framework 例外狀況處理錯誤狀況不足夠：</span><span class="sxs-lookup"><span data-stu-id="d685c-243">In the following cases, using an existing .NET Framework exception to handle an error condition is not adequate:</span></span>  
  
-   <span data-ttu-id="d685c-244">當例外狀況會反映無法對應至現有的.NET Framework 例外狀況的唯一程式錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-244">When the exception reflects a unique program error that cannot be mapped to an existing .NET Framework exception.</span></span>  
  
-   <span data-ttu-id="d685c-245">需要處理的是不同於適用於現有的.NET Framework 例外狀況或例外狀況處理的例外狀況須從類似的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-245">When the exception requires handling that is different from the handling that is appropriate for an existing .NET Framework exception, or the exception must be disambiguated from a similar exception.</span></span> <span data-ttu-id="d685c-246">例如，如果您擲回<xref:System.ArgumentOutOfRangeException>例外狀況時剖析字串，超出範圍的目標的整數類資料類型的數值表示，您不想使用相同的例外狀況的錯誤所產生的呼叫端不提供呼叫方法時適當限制的值。</span><span class="sxs-lookup"><span data-stu-id="d685c-246">For example, if you throw an <xref:System.ArgumentOutOfRangeException> exception when parsing the numeric representation of a string that is out of range of the target integral type, you would not want to use the same exception for an error that results from the caller not supplying the appropriate constrained values when calling the method.</span></span>  
  
 <span data-ttu-id="d685c-247"><xref:System.Exception>類別是.NET Framework 中的所有例外狀況的基底類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-247">The <xref:System.Exception> class is the base class of all exceptions in the .NET Framework.</span></span> <span data-ttu-id="d685c-248">許多衍生的類別會依賴之成員的繼承行為<xref:System.Exception>類別; 它們不覆寫的成員<xref:System.Exception>，也不要定義任何唯一的成員。</span><span class="sxs-lookup"><span data-stu-id="d685c-248">Many derived classes rely on the inherited behavior of the members of the <xref:System.Exception> class; they do not override the members of <xref:System.Exception>, nor do they define any unique members.</span></span>  
  
 <span data-ttu-id="d685c-249">若要定義您自己的例外狀況類別：</span><span class="sxs-lookup"><span data-stu-id="d685c-249">To define your own exception class:</span></span>  
  
1.  <span data-ttu-id="d685c-250">定義類別繼承自<xref:System.Exception>。</span><span class="sxs-lookup"><span data-stu-id="d685c-250">Define a class that inherits from <xref:System.Exception>.</span></span> <span data-ttu-id="d685c-251">如有必要，您的類別提供有關例外狀況的其他資訊所需的任何唯一成員的定義。</span><span class="sxs-lookup"><span data-stu-id="d685c-251">If necessary, define any unique members needed by your class to provide additional information about the exception.</span></span> <span data-ttu-id="d685c-252">例如，<xref:System.ArgumentException>類別包含<xref:System.ArgumentException.ParamName%2A>屬性，指定其引數造成例外狀況，參數名稱和<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>屬性包含<xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A>屬性，指出逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="d685c-252">For example, the <xref:System.ArgumentException> class includes a <xref:System.ArgumentException.ParamName%2A> property that specifies the name of the parameter whose argument caused the exception, and the <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> property includes a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> property that indicates the time-out interval.</span></span>  
  
2.  <span data-ttu-id="d685c-253">如有需要，覆寫任何繼承的成員您想要變更或修改其功能。</span><span class="sxs-lookup"><span data-stu-id="d685c-253">If necessary, override any inherited members whose functionality you want to change or modify.</span></span> <span data-ttu-id="d685c-254">請注意，大部分現有的衍生類別<xref:System.Exception>不會覆寫繼承的成員的行為。</span><span class="sxs-lookup"><span data-stu-id="d685c-254">Note that most existing derived classes of <xref:System.Exception> do not override the behavior of inherited members.</span></span>  
  
3.  <span data-ttu-id="d685c-255">判斷是否可序列化您自訂的例外狀況物件。</span><span class="sxs-lookup"><span data-stu-id="d685c-255">Determine whether your custom exception object is serializable.</span></span> <span data-ttu-id="d685c-256">序列化可讓您儲存例外狀況的相關資訊，並允許遠端執行功能的內容中共用的一部伺服器和用戶端 proxy 的例外狀況資訊。</span><span class="sxs-lookup"><span data-stu-id="d685c-256">Serialization enables you to save information about the exception and permits exception information to be shared by a server and a client proxy in a remoting context.</span></span> <span data-ttu-id="d685c-257">若要讓例外狀況物件的可序列化，加以標示<xref:System.SerializableAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-257">To make the exception object serializable, mark it with the <xref:System.SerializableAttribute> attribute.</span></span>  
  
4.  <span data-ttu-id="d685c-258">定義例外狀況類別的建構函式。</span><span class="sxs-lookup"><span data-stu-id="d685c-258">Define the constructors of your exception class.</span></span> <span data-ttu-id="d685c-259">通常，例外狀況類別具有一或多個下列建構函式：</span><span class="sxs-lookup"><span data-stu-id="d685c-259">Typically, exception classes have one or more of the following constructors:</span></span>  
  
    -   <span data-ttu-id="d685c-260"><xref:System.Exception.%23ctor>會使用預設值來初始化新的例外狀況物件的屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-260"><xref:System.Exception.%23ctor>, which uses default values to initialize the properties of a new exception object.</span></span>  
  
    -   <span data-ttu-id="d685c-261"><xref:System.Exception.%23ctor%28System.String%29>其中，初始化新的例外狀況物件，使用指定的錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="d685c-261"><xref:System.Exception.%23ctor%28System.String%29>, which initializes a new exception object with a specified error message.</span></span>  
  
    -   <span data-ttu-id="d685c-262"><xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>其中，初始化新的例外狀況物件，使用指定的錯誤訊息和內部例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-262"><xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, which initializes a new exception object with a specified error message and inner exception.</span></span>  
  
    -   <span data-ttu-id="d685c-263"><xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>這是`protected`建構函式，初始化新的例外狀況物件，從序列化資料。</span><span class="sxs-lookup"><span data-stu-id="d685c-263"><xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, which is a `protected` constructor that initializes a new exception object from serialized data.</span></span> <span data-ttu-id="d685c-264">如果您選擇要讓例外狀況物件的可序列化，您應該實作這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="d685c-264">You should implement this constructor if you've chosen to make your exception object serializable.</span></span>  
  
 <span data-ttu-id="d685c-265">下列範例說明如何使用自訂例外狀況類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-265">The following example illustrates the use of a custom exception class.</span></span> <span data-ttu-id="d685c-266">它會定義`NotPrimeException`用戶端嘗試藉由指定起始的數字不是質數，擷取一連串的質數時擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-266">It defines a `NotPrimeException` exception that is thrown when a client tries to retrieve a sequence of prime numbers by specifying a starting number that is not prime.</span></span> <span data-ttu-id="d685c-267">例外狀況會定義新的屬性， `NonPrime`，傳回非-質數造成例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-267">The exception defines a new property, `NonPrime`, that returns the non-prime number that caused the exception.</span></span> <span data-ttu-id="d685c-268">除了實作的受保護的無參數建構函式和的建構函式<xref:System.Runtime.Serialization.SerializationInfo>並<xref:System.Runtime.Serialization.StreamingContext>進行序列化，參數`NotPrimeException`類別會定義三個額外的建構函式來支援`NonPrime`屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-268">Besides implementing a protected parameterless constructor and a constructor with <xref:System.Runtime.Serialization.SerializationInfo> and <xref:System.Runtime.Serialization.StreamingContext> parameters for serialization, the `NotPrimeException` class defines three additional constructors to support the `NonPrime` property.</span></span>  <span data-ttu-id="d685c-269">每個建構函式呼叫的基底類別建構函式，除了保留值的非質數數字。</span><span class="sxs-lookup"><span data-stu-id="d685c-269">Each constructor calls a base class constructor in addition to preserving the value of the non-prime number.</span></span> <span data-ttu-id="d685c-270">`NotPrimeException`類別也標示有<xref:System.SerializableAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-270">The `NotPrimeException` class is also marked with the <xref:System.SerializableAttribute> attribute.</span></span>  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 <span data-ttu-id="d685c-271">`PrimeNumberGenerator`下列範例所示的類別會使用 Sieve Eratosthenes 計算質數 2 限制，用戶端在其類別建構函式呼叫中指定的順序。</span><span class="sxs-lookup"><span data-stu-id="d685c-271">The `PrimeNumberGenerator` class shown in the following example uses the Sieve of Eratosthenes to calculate the sequence of prime numbers from 2 to a limit specified by the client in the call to its class constructor.</span></span> <span data-ttu-id="d685c-272">`GetPrimesFrom`方法會傳回大於或等於指定的較低限制的所有質數，但會擲回`NotPrimeException`如果該下限不是質數。</span><span class="sxs-lookup"><span data-stu-id="d685c-272">The `GetPrimesFrom` method returns all prime numbers that are greater than or equal to a specified lower limit, but throws a `NotPrimeException` if that lower limit is not a prime number.</span></span>  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 <span data-ttu-id="d685c-273">下列範例使兩個呼叫`GetPrimesFrom`方法與非質數，其中之一跨越應用程式定義域界限。</span><span class="sxs-lookup"><span data-stu-id="d685c-273">The following example makes two calls to the `GetPrimesFrom` method with non-prime numbers, one of which crosses application domain boundaries.</span></span> <span data-ttu-id="d685c-274">在這兩種情況下，會擲回例外狀況，並將其成功處理用戶端程式碼中。</span><span class="sxs-lookup"><span data-stu-id="d685c-274">In both cases, the exception is thrown and successfully handled in client code.</span></span>  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a><span data-ttu-id="d685c-275">Windows 執行階段和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span><span class="sxs-lookup"><span data-stu-id="d685c-275">Windows Runtime and [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span></span>  
 <span data-ttu-id="d685c-276">在 [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]針對[!INCLUDE[win8](~/includes/win8-md.md)]，某些例外狀況資訊時，通常是遺失的例外狀況就會透過非.NET Framework 的堆疊框架。</span><span class="sxs-lookup"><span data-stu-id="d685c-276">In [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] for [!INCLUDE[win8](~/includes/win8-md.md)], some exception information is typically lost when an exception is propagated through non-.NET Framework stack frames.</span></span> <span data-ttu-id="d685c-277">開頭[!INCLUDE[net_v451](~/includes/net-v451-md.md)]並[!INCLUDE[win81](~/includes/win81-md.md)]，通用語言執行平台會繼續使用原始<xref:System.Exception>除非非.NET Framework 的堆疊框架中修改該例外狀況已擲回物件。</span><span class="sxs-lookup"><span data-stu-id="d685c-277">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)] and [!INCLUDE[win81](~/includes/win81-md.md)], the common language runtime continues to use the original <xref:System.Exception> object that was thrown unless that exception was modified in a non-.NET Framework stack frame.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-278">下列範例示範`catch`定義要處理的區塊<xref:System.ArithmeticException>錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-278">The following example demonstrates a `catch` block that is defined to handle <xref:System.ArithmeticException> errors.</span></span> <span data-ttu-id="d685c-279">這`catch`封鎖也可捕捉<xref:System.DivideByZeroException>錯誤，因為<xref:System.DivideByZeroException>衍生自<xref:System.ArithmeticException>，而且沒有任何`catch`明確定義的區塊<xref:System.DivideByZeroException>錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-279">This `catch` block also catches <xref:System.DivideByZeroException> errors, because <xref:System.DivideByZeroException> derives from <xref:System.ArithmeticException> and there is no `catch` block explicitly defined for <xref:System.DivideByZeroException> errors.</span></span>  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">
      <span data-ttu-id="d685c-280">處理和擲回例外狀況</span>
      <span class="sxs-lookup">
        <span data-stu-id="d685c-280">Handling and Throwing Exceptions</span>
      </span>
    </related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">
      <span data-ttu-id="d685c-281">在桌面應用程式中封裝和部署資源</span>
      <span class="sxs-lookup">
        <span data-stu-id="d685c-281">Packaging and Deploying Resources in Desktop Apps</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">
      <span data-ttu-id="d685c-282">Managed 程式碼中的判斷提示</span>
      <span class="sxs-lookup">
        <span data-stu-id="d685c-282">Assertions in Managed Code</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-283">初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-283">Initializes a new instance of the <see cref="T:System.Exception" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d685c-284">初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-284">Initializes a new instance of the <see cref="T:System.Exception" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-285">這個建構函式會將新執行個體的 <xref:System.Exception.Message%2A> 屬性初始化為系統提供的訊息，該訊息會描述錯誤並考量目前系統的文化特性。</span><span class="sxs-lookup"><span data-stu-id="d685c-285">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance to a system-supplied message that describes the error and takes into account the current system culture.</span></span>  
  
 <span data-ttu-id="d685c-286">所有衍生的類別應該提供此預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="d685c-286">All the derived classes should provide this default constructor.</span></span> <span data-ttu-id="d685c-287">下表顯示 <xref:System.Exception> 執行個體的初始屬性值。</span><span class="sxs-lookup"><span data-stu-id="d685c-287">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="d685c-288">屬性</span><span class="sxs-lookup"><span data-stu-id="d685c-288">Property</span></span>|<span data-ttu-id="d685c-289">值</span><span class="sxs-lookup"><span data-stu-id="d685c-289">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="d685c-290">null 參考 (在 Visual Basic 中為 `Nothing`)。</span><span class="sxs-lookup"><span data-stu-id="d685c-290">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="d685c-291">系統提供的當地語系化描述。</span><span class="sxs-lookup"><span data-stu-id="d685c-291">A system-supplied localized description.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d685c-292">下列程式碼範例衍生`Exception`使用預先定義的訊息。</span><span class="sxs-lookup"><span data-stu-id="d685c-292">The following code example derives an `Exception` that uses a predefined message.</span></span> <span data-ttu-id="d685c-293">程式碼示範使用無參數的建構函式，衍生的類別和基底`Exception`類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-293">The code demonstrates the use of the parameterless constructor for the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">
          <span data-ttu-id="d685c-294">描述錯誤的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-294">The message that describes the error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d685c-295">使用指定的錯誤訊息，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-295">Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-296">這個建構函式初始化<xref:System.Exception.Message%2A>屬性所使用的新執行個體`message`參數。</span><span class="sxs-lookup"><span data-stu-id="d685c-296">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance by using the `message` parameter.</span></span> <span data-ttu-id="d685c-297">如果`message`參數是`null`，這等同於呼叫<xref:System.Exception.%23ctor%2A>建構函式。</span><span class="sxs-lookup"><span data-stu-id="d685c-297">If the `message` parameter is `null`, this is the same as calling the <xref:System.Exception.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="d685c-298">下表顯示 <xref:System.Exception> 執行個體的初始屬性值。</span><span class="sxs-lookup"><span data-stu-id="d685c-298">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="d685c-299">屬性</span><span class="sxs-lookup"><span data-stu-id="d685c-299">Property</span></span>|<span data-ttu-id="d685c-300">值</span><span class="sxs-lookup"><span data-stu-id="d685c-300">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="d685c-301">null 參考 (在 Visual Basic 中為 `Nothing`)。</span><span class="sxs-lookup"><span data-stu-id="d685c-301">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="d685c-302">錯誤訊息字串。</span><span class="sxs-lookup"><span data-stu-id="d685c-302">The error message string.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d685c-303">下列程式碼範例衍生`Exception`是否符合特定條件。</span><span class="sxs-lookup"><span data-stu-id="d685c-303">The following code example derives an `Exception` for a specific condition.</span></span> <span data-ttu-id="d685c-304">程式碼示範如何使用建構函式採用呼叫者指定訊息做為參數，衍生的類別和基底`Exception`類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-304">The code demonstrates the use of the constructor that takes a caller-specified message as a parameter, for both the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="d685c-305">
            <see cref="T:System.Runtime.Serialization.SerializationInfo" />，包含所擲回之例外狀況的相關序列化物件資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-305">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="d685c-306">包含有關來源或目的端內容資訊的 <see cref="T:System.Runtime.Serialization.StreamingContext" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-306">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d685c-307">使用序列化資料，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-307">Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-308">進行還原序列化 (Deserialization) 期間會呼叫這個建構函式，以便重新構成經由資料流傳送的例外狀況物件。</span><span class="sxs-lookup"><span data-stu-id="d685c-308">This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</span></span> <span data-ttu-id="d685c-309">如需詳細資訊，請參閱 < [XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="d685c-309">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-310">下列程式碼範例會定義衍生可序列化`Exception`類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-310">The following code example defines a derived serializable `Exception` class.</span></span> <span data-ttu-id="d685c-311">強制除以-0 錯誤的程式碼，並接著會建立衍生的例外狀況使用的執行個體 (<xref:System.Runtime.Serialization.SerializationInfo>， <xref:System.Runtime.Serialization.StreamingContext>) 建構函式。</span><span class="sxs-lookup"><span data-stu-id="d685c-311">The code forces a divide-by-0 error and then creates an instance of the derived exception using the (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) constructor.</span></span> <span data-ttu-id="d685c-312">程式碼將序列化至檔案的執行個體、 將檔案還原序列化新的例外狀況，就會擲回，則會攔截，並顯示例外狀況的資料。</span><span class="sxs-lookup"><span data-stu-id="d685c-312">The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</span></span>  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d685c-313">
            <paramref name="info" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-313">The <paramref name="info" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <span data-ttu-id="d685c-314">類別名稱為 <see langword="null" /> 或 <see cref="P:System.Exception.HResult" /> 為零 (0)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-314">The class name is <see langword="null" /> or <see cref="P:System.Exception.HResult" /> is zero (0).</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">
          <span data-ttu-id="d685c-315">XML 和 SOAP 序列化</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-315">XML and SOAP Serialization</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">
          <span data-ttu-id="d685c-316">解釋例外狀況原因的錯誤訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-316">The error message that explains the reason for the exception.</span>
          </span>
        </param>
        <param name="innerException">
          <span data-ttu-id="d685c-317">造成目前例外狀況的例外狀況，若未指定內部例外狀況，則為 null 參考 (Visual Basic 中為 <see langword="Nothing" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-317">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" /> in Visual Basic) if no inner exception is specified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d685c-318">使用指定的錯誤訊息以及造成此例外狀況的內部例外狀況的參考，初始化 <see cref="T:System.Exception" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-318">Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-319">被擲回以做為前一個例外狀況直接結果的例外狀況，應該在 <xref:System.Exception.InnerException%2A> 屬性中包含對前一個例外狀況的參考。</span><span class="sxs-lookup"><span data-stu-id="d685c-319">An exception that is thrown as a direct result of a previous exception should include a reference to the previous exception in the <xref:System.Exception.InnerException%2A> property.</span></span> <span data-ttu-id="d685c-320"><xref:System.Exception.InnerException%2A> 屬性會傳回與傳入建構函式中相同的值；如果 `Nothing` 屬性不提供內部例外值給建構函式，則傳回 null 參考 (在 Visual Basic 中為 <xref:System.Exception.InnerException%2A>)。</span><span class="sxs-lookup"><span data-stu-id="d685c-320">The <xref:System.Exception.InnerException%2A> property returns the same value that is passed into the constructor, or a null reference (`Nothing` in Visual Basic) if the <xref:System.Exception.InnerException%2A> property does not supply the inner exception value to the constructor.</span></span>  
  
 <span data-ttu-id="d685c-321">下表顯示 <xref:System.Exception> 執行個體的初始屬性值。</span><span class="sxs-lookup"><span data-stu-id="d685c-321">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="d685c-322">屬性</span><span class="sxs-lookup"><span data-stu-id="d685c-322">Property</span></span>|<span data-ttu-id="d685c-323">值</span><span class="sxs-lookup"><span data-stu-id="d685c-323">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="d685c-324">內部例外狀況參考。</span><span class="sxs-lookup"><span data-stu-id="d685c-324">The inner exception reference.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="d685c-325">錯誤訊息字串。</span><span class="sxs-lookup"><span data-stu-id="d685c-325">The error message string.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d685c-326">下列程式碼範例衍生`Exception`是否符合特定條件。</span><span class="sxs-lookup"><span data-stu-id="d685c-326">The following code example derives an `Exception` for a specific condition.</span></span> <span data-ttu-id="d685c-327">程式碼示範如何使用採用訊息和內部例外狀況做為參數，衍生的類別和基底建構函式`Exception`類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-327">The code demonstrates the use of the constructor that takes a message and an inner exception as parameters, for both the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-328">取得提供例外狀況之其他使用者定義相關資訊的索引鍵/值組集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-328">Gets a collection of key/value pairs that provide additional user-defined information about the exception.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d685c-329">實作 <see cref="T:System.Collections.IDictionary" /> 介面的物件，含有由使用者定義之索引鍵/值組所組成的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-329">An object that implements the <see cref="T:System.Collections.IDictionary" /> interface and contains a collection of user-defined key/value pairs.</span>
          </span>
          <span data-ttu-id="d685c-330">預設為空集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-330">The default is an empty collection.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-331">使用<xref:System.Collections.IDictionary?displayProperty=nameWithType>所傳回的物件<xref:System.Exception.Data%2A>來儲存和擷取例外狀況相關的補充資訊的屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-331">Use the <xref:System.Collections.IDictionary?displayProperty=nameWithType> object returned by the <xref:System.Exception.Data%2A> property to store and retrieve supplementary information relevant to the exception.</span></span> <span data-ttu-id="d685c-332">資訊是任意數目的使用者定義索引鍵/值組的形式。</span><span class="sxs-lookup"><span data-stu-id="d685c-332">The information is in the form of an arbitrary number of user-defined key/value pairs.</span></span> <span data-ttu-id="d685c-333">每個索引鍵/值組的關鍵元件通常是物件的識別的字串，而組的值元件可以是物件的任何類型。</span><span class="sxs-lookup"><span data-stu-id="d685c-333">The key component of each key/value pair is typically an identifying string, whereas the value component of the pair can be any type of object.</span></span>  
  
## <a name="keyvalue-pair-security"></a><span data-ttu-id="d685c-334">索引鍵/值組的安全性</span><span class="sxs-lookup"><span data-stu-id="d685c-334">Key/Value Pair Security</span></span>  
 <span data-ttu-id="d685c-335">儲存在所傳回的集合中的索引鍵/值組<xref:System.Exception.Data%2A>屬性並不安全。</span><span class="sxs-lookup"><span data-stu-id="d685c-335">The key/value pairs stored in the collection returned by the <xref:System.Exception.Data%2A> property are not secure.</span></span> <span data-ttu-id="d685c-336">如果您的應用程式呼叫巢狀的一連串的常式，而且每個常式包含例外狀況處理常式，則產生的呼叫堆疊會包含這些例外狀況處理常式的階層。</span><span class="sxs-lookup"><span data-stu-id="d685c-336">If your application calls a nested series of routines, and each routine contains exception handlers, the resulting call stack contains a hierarchy of those exception handlers.</span></span> <span data-ttu-id="d685c-337">如果較低層級常式擲回例外狀況，呼叫堆疊階層中的任何上層例外狀況處理常式可以讀取及/或修改任何其他的例外狀況處理常式儲存在集合中的索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="d685c-337">If a lower-level routine throws an exception, any upper-level exception handler in the call stack hierarchy can read and/or modify the key/value pairs stored in the collection by any other exception handler.</span></span> <span data-ttu-id="d685c-338">這表示您必須保證中的索引鍵/值組的資訊不是機密，如果索引鍵/值組中的資訊已損毀您的應用程式將會正確運作。</span><span class="sxs-lookup"><span data-stu-id="d685c-338">This means you must guarantee that the information in the key/value pairs is not confidential and that your application will operate correctly if the information in the key/value pairs is corrupted.</span></span>  
  
## <a name="key-conflicts"></a><span data-ttu-id="d685c-339">金鑰衝突</span><span class="sxs-lookup"><span data-stu-id="d685c-339">Key Conflicts</span></span>  
 <span data-ttu-id="d685c-340">不同的例外狀況處理常式指定相同的金鑰來存取的索引鍵/值組，就會產生索引鍵衝突。</span><span class="sxs-lookup"><span data-stu-id="d685c-340">A key conflict occurs when different exception handlers specify the same key to access a key/value pair.</span></span> <span data-ttu-id="d685c-341">開發您的應用程式，因為索引鍵衝突的結果較低層級例外狀況處理常式可以與更高層級的例外狀況處理常式，不小心進行通訊，且此通訊可能會導致難以察覺的程式錯誤時，請務必小心。</span><span class="sxs-lookup"><span data-stu-id="d685c-341">Use caution when developing your application because the consequence of a key conflict is that lower-level exception handlers can inadvertently communicate with higher-level exception handlers, and this communication might cause subtle program errors.</span></span> <span data-ttu-id="d685c-342">不過，如果您注意您可以使用索引鍵衝突來增強您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d685c-342">However, if you are cautious you can use key conflicts to enhance your application.</span></span>  
  
## <a name="avoiding-key-conflicts"></a><span data-ttu-id="d685c-343">避免索引鍵衝突</span><span class="sxs-lookup"><span data-stu-id="d685c-343">Avoiding Key Conflicts</span></span>  
 <span data-ttu-id="d685c-344">採用以產生唯一的索引鍵的索引鍵/值配對的命名慣例，以避免索引鍵衝突。</span><span class="sxs-lookup"><span data-stu-id="d685c-344">Avoid key conflicts by adopting a naming convention to generate unique keys for key/value pairs.</span></span> <span data-ttu-id="d685c-345">例如，命名慣例可能會產生包含句號分隔的名稱，您的應用程式的金鑰、 提供配對和唯一識別碼的補充資訊的方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-345">For example, a naming convention might yield a key that consists of the period-delimited name of your application, the method that provides supplementary information for the pair, and a unique identifier.</span></span>  
  
 <span data-ttu-id="d685c-346">假設兩個應用程式，名為產品和供應商，各有名稱為 Sales 的方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-346">Suppose two applications, named Products and Suppliers, each has a method named Sales.</span></span> <span data-ttu-id="d685c-347">產品應用程式中的銷售方法會提供產品的識別碼 （存貨保持單元或 SKU）。</span><span class="sxs-lookup"><span data-stu-id="d685c-347">The Sales method in the Products application provides the identification number (the stock keeping unit or SKU) of a product.</span></span> <span data-ttu-id="d685c-348">供應商應用程式中的銷售方法提供識別碼或供應商的 SID。</span><span class="sxs-lookup"><span data-stu-id="d685c-348">The Sales method in the Suppliers application provides the identification number, or SID, of a supplier.</span></span> <span data-ttu-id="d685c-349">因此，此範例中的命名慣例，會產生 「 Products.Sales.SKU"和"Suppliers.Sales.SID"索引鍵。</span><span class="sxs-lookup"><span data-stu-id="d685c-349">Consequently, the naming convention for this example yields the keys, "Products.Sales.SKU" and "Suppliers.Sales.SID".</span></span>  
  
## <a name="exploiting-key-conflicts"></a><span data-ttu-id="d685c-350">利用金鑰衝突</span><span class="sxs-lookup"><span data-stu-id="d685c-350">Exploiting Key Conflicts</span></span>  
 <span data-ttu-id="d685c-351">使用一或多個特殊的按照預先安排的金鑰存在來控制處理，以利用索引鍵衝突。</span><span class="sxs-lookup"><span data-stu-id="d685c-351">Exploit key conflicts by using the presence of one or more special, prearranged keys to control processing.</span></span> <span data-ttu-id="d685c-352">假設在一個案例中，在呼叫堆疊階層架構中最高的層級的例外狀況處理常式會攔截所有較低層級例外狀況處理常式所擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-352">Suppose, in one scenario, the highest level exception handler in the call stack hierarchy catches all exceptions thrown by lower-level exception handlers.</span></span> <span data-ttu-id="d685c-353">高層級的例外狀況處理常式有特殊的索引鍵的索引鍵/值組格式中剩餘的索引鍵/值組<xref:System.Collections.IDictionary>某種非標準的方式; 物件，否則為將剩餘的索引鍵/值組格式以一般方式。</span><span class="sxs-lookup"><span data-stu-id="d685c-353">If a key/value pair with a special key exists, the high-level exception handler formats the remaining key/value pairs in the <xref:System.Collections.IDictionary> object in some nonstandard way; otherwise, the remaining key/value pairs are formatted in some normal manner.</span></span>  
  
 <span data-ttu-id="d685c-354">現在假設，在另一個案例中，每個階層的層級呼叫堆疊的例外狀況處理常式會攔截由下一個較低層級的例外狀況處理常式所擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-354">Now suppose, in another scenario, the exception handler at each level of the call stack hierarchy catches the exception thrown by the next lower-level exception handler.</span></span> <span data-ttu-id="d685c-355">此外，每個例外狀況處理常式知道所傳回的集合<xref:System.Exception.Data%2A>屬性包含一組可存取的索引鍵/值組的按照預先安排的一組金鑰。</span><span class="sxs-lookup"><span data-stu-id="d685c-355">In addition, each exception handler knows the collection returned by the <xref:System.Exception.Data%2A> property contains a set of key/value pairs that can be accessed with a prearranged set of keys.</span></span>  
  
 <span data-ttu-id="d685c-356">每個例外狀況處理常式會使用按照預先安排的金鑰組，使用唯一的例外狀況處理常式的資訊來更新相對應的索引鍵/值組的值元件。</span><span class="sxs-lookup"><span data-stu-id="d685c-356">Each exception handler uses the prearranged set of keys to update the value component of the corresponding key/value pair with information unique to that exception handler.</span></span> <span data-ttu-id="d685c-357">在更新程序完成之後，例外狀況處理常式會擲回下一個較高層級的例外狀況處理常式的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-357">After the update process is complete, the exception handler throws the exception to the next higher-level exception handler.</span></span> <span data-ttu-id="d685c-358">最後，最高的層級的例外狀況處理常式會存取的索引鍵/值組，並顯示所有較低層級的例外狀況處理常式的彙總的更新資訊。</span><span class="sxs-lookup"><span data-stu-id="d685c-358">Finally, the highest level exception handler accesses the key/value pairs and displays the consolidated update information from all the lower-level exception handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-359">下列範例示範如何新增和擷取資訊使用<xref:System.Exception.Data%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-359">The following example demonstrates how to add and retrieve information using the <xref:System.Exception.Data%2A> property.</span></span>  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d685c-360">在衍生類別中覆寫時，傳回一或多個後續的例外狀況的根本原因 <see cref="T:System.Exception" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-360">When overridden in a derived class, returns the <see cref="T:System.Exception" /> that is the root cause of one or more subsequent exceptions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d685c-361">例外狀況鏈中擲回的第一個例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-361">The first exception thrown in a chain of exceptions.</span>
          </span>
          <span data-ttu-id="d685c-362">如果目前的例外狀況的 <see cref="P:System.Exception.InnerException" /> 屬性為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)，則這個屬性會傳回目前的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-362">If the <see cref="P:System.Exception.InnerException" /> property of the current exception is a null reference (<see langword="Nothing" /> in Visual Basic), this property returns the current exception.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-363">做為參考中的例外狀況直接結果擲回的鏈結中的每個例外狀況，例外狀況的集合組成的例外狀況鏈結其`InnerException`屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-363">A chain of exceptions consists of a set of exceptions such that each exception in the chain was thrown as a direct result of the exception referenced in its `InnerException` property.</span></span> <span data-ttu-id="d685c-364">指定的鏈結，可能會有一個是鏈結中的所有例外狀況的根本原因的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-364">For a given chain, there can be exactly one exception that is the root cause of all other exceptions in the chain.</span></span> <span data-ttu-id="d685c-365">這個例外狀況會呼叫基底例外狀況並將其`InnerException`屬性永遠會包含 null 參考。</span><span class="sxs-lookup"><span data-stu-id="d685c-365">This exception is called the base exception and its `InnerException` property always contains a null reference.</span></span>  
  
 <span data-ttu-id="d685c-366">所有的例外狀況鏈結中的例外狀況，`GetBaseException`方法必須傳回相同的物件 （基底例外狀況）。</span><span class="sxs-lookup"><span data-stu-id="d685c-366">For all exceptions in a chain of exceptions, the `GetBaseException` method must return the same object (the base exception).</span></span>  
  
 <span data-ttu-id="d685c-367">使用`GetBaseException`方法，當您想要尋找例外狀況的根本原因，但不是需要目前的例外狀況與第一個例外狀況所發生的例外狀況的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="d685c-367">Use the `GetBaseException` method when you want to find the root cause of an exception but do not need information about exceptions that may have occurred between the current exception and the first exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-368">下列程式碼範例會定義兩個衍生`Exception`類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-368">The following code example defines two derived `Exception` classes.</span></span> <span data-ttu-id="d685c-369">它會強制例外狀況則會擲回它一次與每個衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="d685c-369">It forces an exception and then throws it again with each of the derived classes.</span></span> <span data-ttu-id="d685c-370">程式碼示範如何使用`GetBaseException`方法來擷取原始的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-370">The code shows the use of the `GetBaseException` method to retrieve the original exception.</span></span>  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="d685c-371">
              <see langword="GetBaseException" />需要控制例外狀況內容或格式的類別中覆寫方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-371">The <see langword="GetBaseException" /> method is overridden in classes that require control over the exception content or format.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="d685c-372">
            <see cref="T:System.Runtime.Serialization.SerializationInfo" />，包含所擲回之例外狀況的相關序列化物件資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-372">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="d685c-373">包含有關來源或目的端內容資訊的 <see cref="T:System.Runtime.Serialization.StreamingContext" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-373">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d685c-374">在衍生類別中覆寫時，使用例外狀況的資訊設定 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-374">When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-375">`GetObjectData` 會使用所有指定要序列化的例外狀況物件資料來設定 <xref:System.Runtime.Serialization.SerializationInfo>。</span><span class="sxs-lookup"><span data-stu-id="d685c-375">`GetObjectData` sets a <xref:System.Runtime.Serialization.SerializationInfo> with all the exception object data targeted for serialization.</span></span> <span data-ttu-id="d685c-376">在還原序列化期間，從在資料流上傳輸的 `SerializationInfo` 重新組成例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-376">During deserialization, the exception is reconstituted from the `SerializationInfo` transmitted over the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-377">下列程式碼範例會定義衍生可序列化`Exception`可實作類別`GetObjectData`這樣會微幅變更兩個屬性，然後呼叫的基底類別進行序列化。</span><span class="sxs-lookup"><span data-stu-id="d685c-377">The following code example defines a derived serializable `Exception` class that implements `GetObjectData`, which makes minor changes to two properties and then calls the base class to perform the serialization.</span></span> <span data-ttu-id="d685c-378">此範例會強制除以-0 的錯誤，並接著會建立衍生的例外狀況的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d685c-378">The example forces a divide-by-0 error and then creates an instance of the derived exception.</span></span> <span data-ttu-id="d685c-379">程式碼將序列化至檔案的執行個體、 將檔案還原序列化新的例外狀況，就會擲回，則會攔截，並顯示例外狀況的資料。</span><span class="sxs-lookup"><span data-stu-id="d685c-379">The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</span></span>  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d685c-380">
            <paramref name="info" /> 參數為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-380">The <paramref name="info" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d685c-381">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-381">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d685c-382">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-382">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d685c-383">取得目前執行個體的執行階段類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-383">Gets the runtime type of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d685c-384">
            <see cref="T:System.Type" /> 物件，代表目前執行個體的確實執行階段類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-384">A <see cref="T:System.Type" /> object that represents the exact runtime type of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-385"><xref:System.Exception.GetType%2A>方法來支援.NET Framework 基礎結構存在，且在內部叫用基本的方法， <xref:System.Object.GetType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d685c-385">The <xref:System.Exception.GetType%2A> method exists to support the .NET Framework infrastructure, and internally invokes the fundamental method, <xref:System.Object.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-386">取得或設定與這個例外狀況相關聯的說明檔連結。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-386">Gets or sets a link to the help file associated with this exception.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d685c-387">統一資源名稱 (URN) 或統一資源定位器 (URL)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-387">The Uniform Resource Name (URN) or Uniform Resource Locator (URL).</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-388">用來表示說明檔的傳回值為 URN 或 URL。</span><span class="sxs-lookup"><span data-stu-id="d685c-388">The return value, which represents a help file, is a URN or URL.</span></span> <span data-ttu-id="d685c-389">比方說，`HelpLink`值可以是：</span><span class="sxs-lookup"><span data-stu-id="d685c-389">For example, the `HelpLink` value could be:</span></span>  
  
 <span data-ttu-id="d685c-390">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</span><span class="sxs-lookup"><span data-stu-id="d685c-390">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-391">下列程式碼範例會擲回`Exception`如此`HelpLink`屬性，其建構函式，然後攔截到例外狀況並顯示`HelpLink`。</span><span class="sxs-lookup"><span data-stu-id="d685c-391">The following code example throws an `Exception` that sets the `HelpLink` property in its constructor and then catches the exception and displays `HelpLink`.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-392">取得或設定 HRESULT，它是指派給特定例外狀況的編碼數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-392">Gets or sets HRESULT, a coded numerical value that is assigned to a specific exception.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d685c-393">HRESULT 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-393">The HRESULT value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-394">HRESULT 是 32 位元值，分成三個不同的欄位： 嚴重性代碼、 設備碼和錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="d685c-394">HRESULT is a 32-bit value, divided into three different fields: a severity code, a facility code, and an error code.</span></span> <span data-ttu-id="d685c-395">嚴重性代碼指出傳回的值是否代表資訊、 警告或錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-395">The severity code indicates whether the return value represents information, warning, or error.</span></span> <span data-ttu-id="d685c-396">設備碼指出系統對錯誤負責的區域。</span><span class="sxs-lookup"><span data-stu-id="d685c-396">The facility code identifies the area of the system responsible for the error.</span></span> <span data-ttu-id="d685c-397">錯誤碼是指派給代表例外狀況的唯一號碼。</span><span class="sxs-lookup"><span data-stu-id="d685c-397">The error code is a unique number that is assigned to represent the exception.</span></span> <span data-ttu-id="d685c-398">每個例外狀況會對應至不同的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d685c-398">Each exception is mapped to a distinct HRESULT.</span></span> <span data-ttu-id="d685c-399">當 managed 程式碼擲回例外狀況時，則執行階段會將 HRESULT 給 COM 用戶端。</span><span class="sxs-lookup"><span data-stu-id="d685c-399">When managed code throws an exception, the runtime passes the HRESULT to the COM client.</span></span> <span data-ttu-id="d685c-400">當 unmanaged 程式碼會傳回錯誤時，HRESULT 會轉換成例外狀況，則會擲回執行階段中。</span><span class="sxs-lookup"><span data-stu-id="d685c-400">When unmanaged code returns an error, the HRESULT is converted to an exception, which is then thrown by the runtime.</span></span> <span data-ttu-id="d685c-401">HRESULT 值和其對應的.NET Framework 例外狀況的相關資訊，請參閱[如何： 對應 Hresult 和例外狀況](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。</span><span class="sxs-lookup"><span data-stu-id="d685c-401">For information about HRESULT values and their corresponding .NET Framework exceptions, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span> <span data-ttu-id="d685c-402">請參閱[常見的 HRESULT 值](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)Windows 文件的清單，您最有可能會遇到的值中。</span><span class="sxs-lookup"><span data-stu-id="d685c-402">See [Common HRESULT Values](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) in the Windows documentation for a list of the values you are most likely to encounter.</span></span>  
  
 <span data-ttu-id="d685c-403">開頭[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，則<xref:System.Exception.HResult%2A>屬性的 setter 受到保護，而其 getter 是公用的。</span><span class="sxs-lookup"><span data-stu-id="d685c-403">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Exception.HResult%2A> property's setter is protected, whereas its getter is public.</span></span>  <span data-ttu-id="d685c-404">在舊版的.NET Framework 中，會受到保護 getter 和 setter。</span><span class="sxs-lookup"><span data-stu-id="d685c-404">In previous versions of the .NET Framework, both getter and setter are protected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-405">下列程式碼範例會定義衍生`Exception`設定的類別`HResult`屬性設為其建構函式中的自訂值。</span><span class="sxs-lookup"><span data-stu-id="d685c-405">The following code example defines a derived `Exception` class that sets the `HResult` property to a custom value in its constructor.</span></span>  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">
          <span data-ttu-id="d685c-406">如何：對應 HRESULT 和例外狀況</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-406">How to: Map HRESULTs and Exceptions</span>
          </span>
        </related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">
          <span data-ttu-id="d685c-407">常見的 HRESULT 值</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-407">Common HRESULT Values</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-408">取得造成目前例外狀況的 <see cref="T:System.Exception" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-408">Gets the <see cref="T:System.Exception" /> instance that caused the current exception.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d685c-409">物件，描述造成目前例外狀況的錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-409">An object that describes the error that caused the current exception.</span>
          </span>
          <span data-ttu-id="d685c-410">
            <see cref="P:System.Exception.InnerException" /> 屬性會傳回與傳遞到 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> 建構函式中相同的值；如果沒有提供內部例外狀況值給建構函式，則傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-410">The <see cref="P:System.Exception.InnerException" /> property returns the same value as was passed into the <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> constructor, or <see langword="null" /> if the inner exception value was not supplied to the constructor.</span>
          </span>
          <span data-ttu-id="d685c-411">這個屬性是唯讀的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-411">This property is read-only.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-412">當例外狀況`X`做為先前的例外狀況直接結果擲回`Y`，則<xref:System.Exception.InnerException%2A>屬性`X`應該包含的參考`Y`。</span><span class="sxs-lookup"><span data-stu-id="d685c-412">When an exception `X` is thrown as a direct result of a previous exception `Y`, the <xref:System.Exception.InnerException%2A> property of `X` should contain a reference to `Y`.</span></span>  
  
 <span data-ttu-id="d685c-413">您可以使用 <xref:System.Exception.InnerException%2A> 屬性來取得造成目前例外狀況的例外狀況集合。</span><span class="sxs-lookup"><span data-stu-id="d685c-413">Use the <xref:System.Exception.InnerException%2A> property to obtain the set of exceptions that led to the current exception.</span></span>  
  
 <span data-ttu-id="d685c-414">您可以建立新的例外狀況攔截較早的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-414">You can create a new exception that catches an earlier exception.</span></span> <span data-ttu-id="d685c-415">處理第二個例外狀況可以使用從先前的例外狀況的其他資訊以更適當地處理錯誤的程式碼。</span><span class="sxs-lookup"><span data-stu-id="d685c-415">The code that handles the second exception can make use of the additional information from the earlier exception to handle the error more appropriately.</span></span>  
  
 <span data-ttu-id="d685c-416">假設有讀取檔案，並將該檔案中的資料格式的函式。</span><span class="sxs-lookup"><span data-stu-id="d685c-416">Suppose that there is a function that reads a file and formats the data from that file.</span></span> <span data-ttu-id="d685c-417">在此範例中，為程式碼嘗試讀取檔案，<xref:System.IO.IOException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="d685c-417">In this example, as the code tries to read the file, an <xref:System.IO.IOException> is thrown.</span></span> <span data-ttu-id="d685c-418">此函式會攔截<xref:System.IO.IOException>則會擲回<xref:System.IO.FileNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="d685c-418">The function catches the <xref:System.IO.IOException> and throws a <xref:System.IO.FileNotFoundException>.</span></span> <span data-ttu-id="d685c-419"><xref:System.IO.IOException>無法存入<xref:System.Exception.InnerException%2A>屬性<xref:System.IO.FileNotFoundException>，啟用程式碼，以攔截<xref:System.IO.FileNotFoundException>檢查初始錯誤的原因。</span><span class="sxs-lookup"><span data-stu-id="d685c-419">The <xref:System.IO.IOException> could be saved in the <xref:System.Exception.InnerException%2A> property of the <xref:System.IO.FileNotFoundException>, enabling the code that catches the <xref:System.IO.FileNotFoundException> to examine the cause of the initial error.</span></span>  
  
 <span data-ttu-id="d685c-420"><xref:System.Exception.InnerException%2A>屬性，其中包含內部例外狀況的參考，會設定例外狀況物件初始化時。</span><span class="sxs-lookup"><span data-stu-id="d685c-420">The <xref:System.Exception.InnerException%2A> property, which holds a reference to the inner exception, is set upon initialization of the exception object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-421">下列範例示範擲回和攔截例外狀況參考內部例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-421">The following example demonstrates throwing and catching an exception that references an inner exception.</span></span>  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-422">取得描述目前例外狀況的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-422">Gets a message that describes the current exception.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d685c-423">解釋例外狀況原因的錯誤訊息，或空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-423">The error message that explains the reason for the exception, or an empty string ("").</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-424">錯誤訊息為目標的開發人員正在處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-424">Error messages target the developer who is handling the exception.</span></span> <span data-ttu-id="d685c-425">文字<xref:System.Exception.Message%2A>屬性應該完整描述錯誤，可能的話，應該也會說明如何修正錯誤。</span><span class="sxs-lookup"><span data-stu-id="d685c-425">The text of the <xref:System.Exception.Message%2A> property should completely describe the error and, when possible, should also explain how to correct the error.</span></span> <span data-ttu-id="d685c-426">最上層的例外狀況處理常式可能會顯示訊息給使用者，因此您應確定它是文法正確，而且訊息的每個句子是以句號結尾。</span><span class="sxs-lookup"><span data-stu-id="d685c-426">Top-level exception handlers may display the message to end-users, so you should ensure that it is grammatically correct and that each sentence of the message ends with a period.</span></span> <span data-ttu-id="d685c-427">請勿使用問號或驚嘆號。</span><span class="sxs-lookup"><span data-stu-id="d685c-427">Do not use question marks or exclamation points.</span></span> <span data-ttu-id="d685c-428">如果您的應用程式會使用當地語系化的例外狀況訊息，您應該確保它們會正確轉譯。</span><span class="sxs-lookup"><span data-stu-id="d685c-428">If your application uses localized exception messages, you should ensure that they are accurately translated.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d685c-429">不公開的例外狀況訊息中的機密資訊而不檢查適當的權限。</span><span class="sxs-lookup"><span data-stu-id="d685c-429">Do not disclose sensitive information in exception messages without checking for the appropriate permissions.</span></span>  
  
 <span data-ttu-id="d685c-430">值<xref:System.Exception.Message%2A>屬性是否包含在所傳回的資訊<xref:System.Exception.ToString%2A>。<xref:System.Exception.Message%2A>只有在建立時，才設定屬性<xref:System.Exception>。</span><span class="sxs-lookup"><span data-stu-id="d685c-430">The value of the <xref:System.Exception.Message%2A> property is included in the information returned by <xref:System.Exception.ToString%2A>.The <xref:System.Exception.Message%2A> property is set only when creating an <xref:System.Exception>.</span></span> <span data-ttu-id="d685c-431">如果目前的執行個體的建構函式提供的任何訊息，因此系統會不提供預設的訊息，使用目前的系統文化特性進行格式化。</span><span class="sxs-lookup"><span data-stu-id="d685c-431">If no message was supplied to the constructor for the current instance, the system supplies a default message that is formatted using the current system culture.</span></span>  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a><span data-ttu-id="d685c-432">Windows 執行階段和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span><span class="sxs-lookup"><span data-stu-id="d685c-432">Windows Runtime and [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span></span>  
 <span data-ttu-id="d685c-433">開頭[!INCLUDE[net_v451](~/includes/net-v451-md.md)]和[!INCLUDE[win81](~/includes/win81-md.md)]，從 Windows 執行階段型別和成員不是.NET Framework 的一部分傳播的例外狀況錯誤訊息的精確度已獲得改善。</span><span class="sxs-lookup"><span data-stu-id="d685c-433">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)] and [!INCLUDE[win81](~/includes/win81-md.md)], the fidelity of error messages from exceptions that are propagated from Windows Runtime types and members that are not part of the .NET Framework is improved.</span></span> <span data-ttu-id="d685c-434">特別是，例外狀況訊息 Visual c + + 元件擴充功能 (C + + /CX) 現在會傳播回.NET Framework<xref:System.Exception>物件。</span><span class="sxs-lookup"><span data-stu-id="d685c-434">In particular, exception messages from Visual C++ component extensions (C++/CX) are now propagated back into .NET Framework <xref:System.Exception> objects.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-435">下列程式碼範例會擲回，然後捕捉<xref:System.Exception>例外狀況，並顯示例外狀況的文字訊息使用<xref:System.Exception.Message%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-435">The following code example throws and then catches an <xref:System.Exception> exception and displays the exception's text message using the <xref:System.Exception.Message%2A> property.</span></span>
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="d685c-436">如果您擲回的例外狀況屬性，而且您需要參考中的文字<see cref="P:System.Exception.Message" />您設定或取得屬性引數，請使用 「 值 」 做為屬性引數的名稱。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-436">If you throw an exception from a property, and you need to refer in the text of <see cref="P:System.Exception.Message" /> to the property argument that you set or get, use "value" as the name of the property argument.</span>
            </span>
          </para>
        </block>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="d685c-437">
              <see cref="P:System.Exception.Message" />需要控制訊息內容或格式的類別中覆寫屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-437">The <see cref="P:System.Exception.Message" /> property is overridden in classes that require control over message content or format.</span>
            </span>
            <span data-ttu-id="d685c-438">需要顯示已攔截的例外狀況的相關資訊時，應用程式程式碼通常會存取這個屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-438">Application code typically accesses this property when it needs to display information about an exception that has been caught.</span>
            </span>
            <span data-ttu-id="d685c-439">應該當地語系化錯誤訊息。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-439">The error message should be localized.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-440">當例外狀況序列化，以建立包含例外狀況相關序列化資料的例外狀況狀態物件時，就會發生此事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-440">Occurs when an exception is serialized to create an exception state object that contains serialized data about the exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-441">例外狀況狀態物件會實作<xref:System.Runtime.Serialization.ISafeSerializationData>介面。</span><span class="sxs-lookup"><span data-stu-id="d685c-441">The exception state object implements the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.</span></span>  
  
 <span data-ttu-id="d685c-442">當<xref:System.Exception.SerializeObjectState>訂閱事件、 例外狀況是還原序列化，並建立成空的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-442">When the <xref:System.Exception.SerializeObjectState> event is subscribed to, the exception is deserialized and created as an empty exception.</span></span> <span data-ttu-id="d685c-443">例外狀況的建構函式時不執行，並也會還原序列化的例外狀況狀態。</span><span class="sxs-lookup"><span data-stu-id="d685c-443">The exception's constructor is not run, and the exception state is also deserialized.</span></span> <span data-ttu-id="d685c-444"><xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A>回呼方法的例外狀況的狀態物件再收到通知，讓它可以將已還原序列化的資料推送至空的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-444">The <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> callback method of the exception state object is then notified so that it can push deserialized data into the empty exception.</span></span>  
  
 <span data-ttu-id="d685c-445"><xref:System.Exception.SerializeObjectState>事件可讓透明的例外狀況型別序列化和還原序列化例外狀況資料。</span><span class="sxs-lookup"><span data-stu-id="d685c-445">The <xref:System.Exception.SerializeObjectState> event enables transparent exception types to serialize and deserialize exception data.</span></span> <span data-ttu-id="d685c-446">透明程式碼可以執行它正在運作中的權限集合的範圍內的命令，但無法執行、 呼叫、 衍生自或包含關鍵程式碼。</span><span class="sxs-lookup"><span data-stu-id="d685c-446">Transparent code can execute commands within the bounds of the permission set it is operating within, but cannot execute, call, derive from, or contain critical code.</span></span>  
  
 <span data-ttu-id="d685c-447">如果<xref:System.Exception.SerializeObjectState>事件沒有訂閱，還原序列化發生如往常般使用<xref:System.Exception.%23ctor%2A>建構函式。</span><span class="sxs-lookup"><span data-stu-id="d685c-447">If the <xref:System.Exception.SerializeObjectState> event is not subscribed to, deserialization occurs as usual using the <xref:System.Exception.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="d685c-448">一般而言，處理常式<xref:System.Exception.SerializeObjectState>提供其序列化的例外狀況的建構函式中加入事件。</span><span class="sxs-lookup"><span data-stu-id="d685c-448">Typically, a handler for the <xref:System.Exception.SerializeObjectState> event is added in the exception's constructor to provide for its serialization.</span></span> <span data-ttu-id="d685c-449">但因為建構函式不是執行的時機<xref:System.Exception.SerializeObjectState>事件處理常式執行時，序列化的已還原序列化的例外狀況可能會擲回<xref:System.Runtime.Serialization.SerializationException>當您嘗試還原序列化例外狀況的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-449">But because the constructor is not executed when the <xref:System.Exception.SerializeObjectState> event handler executes, serializing a deserialized exception can throw a <xref:System.Runtime.Serialization.SerializationException> exception when you try to deserialize the exception.</span></span> <span data-ttu-id="d685c-450">若要避免這個問題，您還應該加入的處理常式<xref:System.Exception.SerializeObjectState>中的事件<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-450">To avoid this, you should also add the handler for the <xref:System.Exception.SerializeObjectState> event in the <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d685c-451">請參閱圖範例 > 一節。</span><span class="sxs-lookup"><span data-stu-id="d685c-451">See the Examples section for an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-452">下列範例會定義`BadDivisionException`處理<xref:System.Exception.SerializeObjectState>事件。</span><span class="sxs-lookup"><span data-stu-id="d685c-452">The following example defines a `BadDivisionException` that handles the <xref:System.Exception.SerializeObjectState> event.</span></span> <span data-ttu-id="d685c-453">它也包含狀態的物件，也就是巢狀結構，名為`BadDivisionExceptionState`實作<xref:System.Runtime.Serialization.ISafeSerializationData>介面。</span><span class="sxs-lookup"><span data-stu-id="d685c-453">It also contains a state object, which is a nested structure named `BadDivisionExceptionState` that implements the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.</span></span>  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 <span data-ttu-id="d685c-454">`BadDivisionException`浮點的除數為零，就會發生時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-454">The `BadDivisionException` exception is thrown when a floating-point division by zero occurs.</span></span> <span data-ttu-id="d685c-455">第一個除數為零，在此範例會具現化`BadDivisionException`物件序列化，並擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-455">During the first division by zero, the example instantiates a `BadDivisionException` object, serializes it, and throws the exception.</span></span> <span data-ttu-id="d685c-456">為零的後續部門發生時，此範例會將先前序列化的物件還原序列化、 這，並擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-456">When subsequent divisions by zero occur, the example deserializes the  previously serialized object, reserializes it, and throws the exception.</span></span> <span data-ttu-id="d685c-457">若要提供物件序列化、 還原序列化、 雷同和還原序列化，此範例會新增<xref:System.Exception.SerializeObjectState>事件處理常式這兩個`BadDivisionException`類別建構函式和<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>實作。</span><span class="sxs-lookup"><span data-stu-id="d685c-457">To provide for object serialization, deserialization, reserialization, and deserialization, the example adds the <xref:System.Exception.SerializeObjectState> event handler both in the `BadDivisionException` class constructor and in the <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="d685c-458">如果此事件是訂閱，並使用，請依照下列繼承階層架構中的所有衍生型別必須實作相同的序列化機制。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-458">If this event is subscribed to and used, all derived types that follow in the inheritance hierarchy must implement the same serialization mechanism.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-459">取得或設定造成錯誤的應用程式或物件的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-459">Gets or sets the name of the application or the object that causes the error.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d685c-460">造成錯誤的應用程式或物件的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-460">The name of the application or the object that causes the error.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-461">如果<xref:System.Exception.Source%2A>屬性未明確設定、 執行階段會自動設定它的例外狀況的來源組件名稱。</span><span class="sxs-lookup"><span data-stu-id="d685c-461">If the <xref:System.Exception.Source%2A> property is not set explicitly, the runtime automatically sets it to the name of the assembly in which the exception originated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-462">下列範例會擲回`Exception`如此`Source`屬性，其建構函式，然後攔截到例外狀況並顯示`Source`。</span><span class="sxs-lookup"><span data-stu-id="d685c-462">The following example throws an `Exception` that sets the `Source` property in its constructor and then catches the exception and displays `Source`.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d685c-463">此物件必須是執行階段 <see cref="N:System.Reflection" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-463">The object must be a runtime <see cref="N:System.Reflection" /> object</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-464">取得呼叫堆疊上即時運算框架的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-464">Gets a string representation of the immediate frames on the call stack.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d685c-465">字串，描述呼叫堆疊的立即框架。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-465">A string that describes the immediate frames of the call stack.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-466">執行堆疊會持續追蹤指定的執行個體的所有執行中方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-466">The execution stack keeps track of all the methods that are in execution at a given instant.</span></span> <span data-ttu-id="d685c-467">方法呼叫的追蹤稱為堆疊追蹤。</span><span class="sxs-lookup"><span data-stu-id="d685c-467">A trace of the method calls is called a stack trace.</span></span> <span data-ttu-id="d685c-468">堆疊追蹤清單可用來遵循此方法中的行號發生例外狀況呼叫堆疊。</span><span class="sxs-lookup"><span data-stu-id="d685c-468">The stack trace listing provides a way to follow the call stack to the line number in the method where the exception occurs.</span></span>  
  
 <span data-ttu-id="d685c-469"><xref:System.Exception.StackTrace%2A>屬性會傳回呼叫堆疊的框架，顯示源自於擲回的例外狀況的位置。</span><span class="sxs-lookup"><span data-stu-id="d685c-469">The <xref:System.Exception.StackTrace%2A> property returns the frames of the call stack that originate at the location where the exception was thrown.</span></span> <span data-ttu-id="d685c-470">您可以建立的新執行個體，以取得其他框架呼叫堆疊中的相關資訊<xref:System.Diagnostics.StackTrace?displayProperty=nameWithType>類別，並使用其<xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-470">You can obtain information about additional frames in the call stack by creating a new instance of the <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> class and using its <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="d685c-471">每當應用程式程式碼中擲回例外狀況時，common language runtime (CLR) 會更新的堆疊追蹤 (使用`throw`關鍵字)。</span><span class="sxs-lookup"><span data-stu-id="d685c-471">The common language runtime (CLR) updates the stack trace whenever an exception is thrown in application code (by using the `throw` keyword).</span></span> <span data-ttu-id="d685c-472">如果是不同的方法，它原來擲回的方法中擲回例外狀況，堆疊追蹤包含其中原先擲回例外狀況，方法中的位置及方法中發生例外狀況的所在位置重新擲回。</span><span class="sxs-lookup"><span data-stu-id="d685c-472">If the exception was rethrown in a method that is different than the method where it was originally thrown, the stack trace contains both the location in the method where the exception was originally thrown, and the location in the method where the exception was rethrown.</span></span> <span data-ttu-id="d685c-473">如果擲回，且稍後重新擲回，在相同的方法中，例外狀況堆疊追蹤只會包含例外狀況重新擲回，並不包含其中原先擲回例外狀況的位置的位置。</span><span class="sxs-lookup"><span data-stu-id="d685c-473">If the exception is thrown, and later rethrown, in the same method, the stack trace only contains the location where the exception was rethrown and does not include the location where the exception was originally thrown.</span></span>  
  
 <span data-ttu-id="d685c-474"><xref:System.Exception.StackTrace%2A>屬性可能不會報告多個方法呼叫，如預期般運作的程式碼轉換，因為這類內嵌 （inline)，在最佳化期間會發生。</span><span class="sxs-lookup"><span data-stu-id="d685c-474">The <xref:System.Exception.StackTrace%2A> property may not report as many method calls as expected because of code transformations, such as inlining, that occur during optimization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-475">下列程式碼範例會擲回`Exception`然後攔截它，並顯示堆疊追蹤使用`StackTrace`屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-475">The following code example throws an `Exception` and then catches it and displays a stack trace using the `StackTrace` property.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="d685c-476">
              <see langword="StackTrace" />需要控制的堆疊追蹤內容或格式的類別中覆寫屬性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-476">The <see langword="StackTrace" /> property is overridden in classes that require control over the stack trace content or format.</span>
            </span>
            <span data-ttu-id="d685c-477">根據預設，堆疊追蹤會擷取之前就會擲回例外狀況物件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-477">By default, the stack trace is captured immediately before an exception object is thrown.</span>
            </span>
            <span data-ttu-id="d685c-478">使用<see cref="P:System.Environment.StackTrace" />時所擲不回任何例外狀況取得堆疊追蹤資訊。</span>
            <span class="sxs-lookup">
              <span data-stu-id="d685c-478">Use <see cref="P:System.Environment.StackTrace" /> to get stack trace information when no exception is being thrown.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d685c-479">取得擲回目前例外狀況的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-479">Gets the method that throws the current exception.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d685c-480">擲回目前例外狀況的 <see cref="T:System.Reflection.MethodBase" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-480">The <see cref="T:System.Reflection.MethodBase" /> that threw the current exception.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-481">如果擲回這個例外狀況的方法不提供和堆疊追蹤不是 null 參考 (`Nothing`在 Visual Basic 中)，<xref:System.Exception.TargetSite%2A>從堆疊追蹤取得方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-481">If the method that throws this exception is not available and the stack trace is not a null reference (`Nothing` in Visual Basic), <xref:System.Exception.TargetSite%2A> obtains the method from the stack trace.</span></span> <span data-ttu-id="d685c-482">如果堆疊追蹤是 null 參考，<xref:System.Exception.TargetSite%2A> 也就會傳回 null 參考。</span><span class="sxs-lookup"><span data-stu-id="d685c-482">If the stack trace is a null reference, <xref:System.Exception.TargetSite%2A> also returns a null reference.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d685c-483"><xref:System.Exception.TargetSite%2A>屬性可能不會準確地報告中已擲回例外狀況的例外狀況處理常式處理例外狀況跨應用程式定義域界限的方法名稱。</span><span class="sxs-lookup"><span data-stu-id="d685c-483">The <xref:System.Exception.TargetSite%2A> property may not accurately report the name of the method in which an exception was thrown if the exception handler handles an exception across application domain boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-484">下列程式碼範例會擲回`Exception`然後攔截它，並顯示原始的方法使用`TargetSite`屬性。</span><span class="sxs-lookup"><span data-stu-id="d685c-484">The following code example throws an `Exception` and then catches it and displays the originating method using the `TargetSite` property.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d685c-485">建立並傳回目前例外狀況的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-485">Creates and returns a string representation of the current exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d685c-486">目前例外狀況的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d685c-486">A string representation of the current exception.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d685c-487"><xref:System.Exception.ToString%2A> 傳回表示目前的例外狀況，目的是讓人了解。</span><span class="sxs-lookup"><span data-stu-id="d685c-487"><xref:System.Exception.ToString%2A> returns a representation of the current exception that is intended to be understood by humans.</span></span> <span data-ttu-id="d685c-488">例外狀況包含區分文化特性的資料，所傳回的字串表示`ToString`需要納入考量目前系統文化特性。</span><span class="sxs-lookup"><span data-stu-id="d685c-488">Where the exception contains culture-sensitive data, the string representation returned by `ToString` is required to take into account the current system culture.</span></span> <span data-ttu-id="d685c-489">雖然傳回之字串的格式沒有實際上的需求，但它應該嘗試反映做使用者察覺到物件的值。</span><span class="sxs-lookup"><span data-stu-id="d685c-489">Although there are no exact requirements for the format of the returned string, it should attempt to reflect the value of the object as perceived by the user.</span></span>  
  
 <span data-ttu-id="d685c-490">預設實作<xref:System.Exception.ToString%2A>取得擲回目前例外狀況、 訊息、 呼叫的類別名稱<xref:System.Exception.ToString%2A>上的內部例外狀況，並呼叫<xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d685c-490">The default implementation of <xref:System.Exception.ToString%2A> obtains the name of the class that threw the current exception, the message, the result of calling <xref:System.Exception.ToString%2A> on the inner exception, and the result of calling <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d685c-491">如果有任何這些成員是`null`，其值不包含在傳回的字串。</span><span class="sxs-lookup"><span data-stu-id="d685c-491">If any of these members is `null`, its value is not included in the returned string.</span></span>  
  
 <span data-ttu-id="d685c-492">如果沒有任何錯誤訊息，或者它是空字串 ("")，則會不傳回任何錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="d685c-492">If there is no error message or if it is an empty string (""), then no error message is returned.</span></span> <span data-ttu-id="d685c-493">如果它們不是，會傳回內部例外狀況和堆疊追蹤的名稱`null`。</span><span class="sxs-lookup"><span data-stu-id="d685c-493">The name of the inner exception and the stack trace are returned only if they are not `null`.</span></span>  
  
 <span data-ttu-id="d685c-494">這個方法會覆寫 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d685c-494">This method overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d685c-495">下列範例會導致例外狀況，並顯示呼叫<xref:System.Exception.ToString%2A>該例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d685c-495">The following example causes an exception and displays the result of calling <xref:System.Exception.ToString%2A> on that exception.</span></span> <span data-ttu-id="d685c-496">請注意，<xref:System.Exception.ToString%2A?displayProperty=nameWithType>的引數清單中出現的例外狀況類別執行個體時隱含地呼叫方法<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="d685c-496">Note that the <xref:System.Exception.ToString%2A?displayProperty=nameWithType> method is called implicitly when the Exception class instance appears in the argument list of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>