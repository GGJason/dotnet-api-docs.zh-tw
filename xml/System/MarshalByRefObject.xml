<Type Name="MarshalByRefObject" FullName="System.MarshalByRefObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a11abc75f8da0008ceec8aae4b01f3240aff0074" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52360547" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MarshalByRefObject" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MarshalByRefObject extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MarshalByRefObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarshalByRefObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarshalByRefObject abstract" />
  <TypeSignature Language="F#" Value="type MarshalByRefObject = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f3c32-101">在支援遠端處理的應用程式中啟用跨應用程式定義域界限存取物件。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f3c32-101">Enables access to objects across application domain boundaries in applications that support remoting.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3c32-102">應用程式定義域是一或多個應用程式所在的作業系統處理序中的分割區。</span><span class="sxs-lookup"><span data-stu-id="f3c32-102">An application domain is a partition in an operating system process where one or more applications reside.</span></span> <span data-ttu-id="f3c32-103">在相同的應用程式定義域中的物件直接通訊。</span><span class="sxs-lookup"><span data-stu-id="f3c32-103">Objects in the same application domain communicate directly.</span></span> <span data-ttu-id="f3c32-104">跨應用程式定義域界限，傳輸物件的複本，或使用 proxy 來交換訊息，不同的應用程式定義域中的物件進行通訊。</span><span class="sxs-lookup"><span data-stu-id="f3c32-104">Objects in different application domains communicate either by transporting copies of objects across application domain boundaries, or by using a proxy to exchange messages.</span></span>  
  
 <span data-ttu-id="f3c32-105"><xref:System.MarshalByRefObject> 正在交換訊息來跨應用程式定義域界限進行通訊的物件的基底類別使用的 proxy。</span><span class="sxs-lookup"><span data-stu-id="f3c32-105"><xref:System.MarshalByRefObject> is the base class for objects that communicate across application domain boundaries by exchanging messages using a proxy.</span></span> <span data-ttu-id="f3c32-106">物件，不是繼承自<xref:System.MarshalByRefObject>會隱含地封送處理的值。</span><span class="sxs-lookup"><span data-stu-id="f3c32-106">Objects that do not inherit from <xref:System.MarshalByRefObject> are implicitly marshal by value.</span></span> <span data-ttu-id="f3c32-107">當遠端應用程式的值物件參考封送處理時，跨應用程式定義域界限傳遞物件的複本。</span><span class="sxs-lookup"><span data-stu-id="f3c32-107">When a remote application references a marshal by value object, a copy of the object is passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="f3c32-108"><xref:System.MarshalByRefObject> 直接在本機的應用程式定義域界限存取物件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-108"><xref:System.MarshalByRefObject> objects are accessed directly within the boundaries of the local application domain.</span></span> <span data-ttu-id="f3c32-109">在遠端應用程式第一次應用程式定義域存取<xref:System.MarshalByRefObject>，proxy 會傳遞至遠端應用程式。</span><span class="sxs-lookup"><span data-stu-id="f3c32-109">The first time an application in a remote application domain accesses a <xref:System.MarshalByRefObject>, a proxy is passed to the remote application.</span></span> <span data-ttu-id="f3c32-110">在 proxy 上的後續呼叫會封送處理回位於本機的應用程式定義域中的物件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-110">Subsequent calls on the proxy are marshaled back to the object residing in the local application domain.</span></span>  
  
 <span data-ttu-id="f3c32-111">類型必須繼承自<xref:System.MarshalByRefObject>當類型可跨應用程式定義域界限，並必須不會複製物件的狀態，因為物件的成員不是當初建立它們的應用程式定義域外使用。</span><span class="sxs-lookup"><span data-stu-id="f3c32-111">Types must inherit from <xref:System.MarshalByRefObject> when the type is used across application domain boundaries, and the state of the object must not be copied because the members of the object are not usable outside the application domain where they were created.</span></span>  
  
 <span data-ttu-id="f3c32-112">當您衍生的物件從<xref:System.MarshalByRefObject>跨應用程式定義域界限使用，您不應該覆寫它的任何成員，也不應該您直接呼叫其方法。</span><span class="sxs-lookup"><span data-stu-id="f3c32-112">When you derive an object from <xref:System.MarshalByRefObject> for use across application domain boundaries, you should not override any of its members, nor should you call its methods directly.</span></span> <span data-ttu-id="f3c32-113">執行階段會辨識類別衍生自<xref:System.MarshalByRefObject>應該跨應用程式定義域界限封送處理。</span><span class="sxs-lookup"><span data-stu-id="f3c32-113">The runtime recognizes that classes derived from  <xref:System.MarshalByRefObject> should be marshaled across app domain boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3c32-114">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="f3c32-114">This section contains two code examples.</span></span> <span data-ttu-id="f3c32-115">第一個程式碼範例示範如何建立另一個應用程式定義域中的類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="f3c32-115">The first code example shows how to create an instance of a class in another application domain.</span></span> <span data-ttu-id="f3c32-116">第二個程式碼範例顯示的簡單類別，可用於遠端處理。</span><span class="sxs-lookup"><span data-stu-id="f3c32-116">The second code example shows a simple class that can be used for remoting.</span></span>  
  
 <span data-ttu-id="f3c32-117">**範例 1**</span><span class="sxs-lookup"><span data-stu-id="f3c32-117">**Example 1**</span></span>  
  
 <span data-ttu-id="f3c32-118">下列程式碼範例示範另一個應用程式定義域中執行程式碼最簡單的方式。</span><span class="sxs-lookup"><span data-stu-id="f3c32-118">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="f3c32-119">此範例會定義名為類別`Worker`繼承<xref:System.MarshalByRefObject>的方法，顯示它正在執行的應用程式定義域的名稱。</span><span class="sxs-lookup"><span data-stu-id="f3c32-119">The example defines a class named `Worker` that inherits <xref:System.MarshalByRefObject>, with a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="f3c32-120">此範例會建立的執行個體`Worker`在預設應用程式定義域和新的應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="f3c32-120">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f3c32-121">包含的組件`Worker`必須載入到兩個應用程式定義域，但它無法載入其他會只存在於新的應用程式定義域的組件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-121">The assembly that contains `Worker` must be loaded into both application domains, but it could load other assemblies that would exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 <span data-ttu-id="f3c32-122">**範例 2**</span><span class="sxs-lookup"><span data-stu-id="f3c32-122">**Example 2**</span></span>  
  
 <span data-ttu-id="f3c32-123">下列範例示範衍生自<xref:System.MarshalByRefObject>也就是使用更新版本中的遠端執行功能。</span><span class="sxs-lookup"><span data-stu-id="f3c32-123">The following example demonstrates a class derived from <xref:System.MarshalByRefObject> that is used later in remoting.</span></span>  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f3c32-124">初始化 <see cref="T:System.MarshalByRefObject" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-124">Initializes a new instance of the <see cref="T:System.MarshalByRefObject" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjRef">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.ObjRef CreateObjRef (Type requestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjRef CreateObjRef(class System.Type requestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.CreateObjRef(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjRef (requestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjRef ^ CreateObjRef(Type ^ requestedType);" />
      <MemberSignature Language="F#" Value="abstract member CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef&#xA;override this.CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef" Usage="marshalByRefObject.CreateObjRef requestedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="requestedType">
          <span data-ttu-id="f3c32-125">物件的 <see cref="T:System.Type" />，新的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 將參考這個型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-125">The <see cref="T:System.Type" /> of the object that the new <see cref="T:System.Runtime.Remoting.ObjRef" /> will reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f3c32-126">建立包含所有相關資訊的物件，這些資訊是產生用來與遠端物件通訊的所需 Proxy。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-126">Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f3c32-127">產生 Proxy 時所需要的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-127">Information required to generate a proxy.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3c32-128"><xref:System.MarshalByRefObject.CreateObjRef%2A>方法透過呼叫遠端物件的建立方法這類<xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType>和<xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f3c32-128">The <xref:System.MarshalByRefObject.CreateObjRef%2A> method is called by remote object creation methods such as <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f3c32-129">在大部分情況下，沒有需要覆寫這個方法。</span><span class="sxs-lookup"><span data-stu-id="f3c32-129">In most cases, there is no need to override this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <span data-ttu-id="f3c32-130">這個執行個體不是有效的遠端物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-130">This instance is not a valid remoting object.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f3c32-131">立即呼叫端沒有基礎結構使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-131">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f3c32-132">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-132">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f3c32-133">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-133">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public object GetLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.GetLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member GetLifetimeService : unit -&gt; obj&#xA;override this.GetLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.GetLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f3c32-134">擷取控制這個執行個體存留期 (Lifetime) 原則的目前存留期服務物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-134">Retrieves the current lifetime service object that controls the lifetime policy for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f3c32-135">型別 <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> 的物件，用來控制這個執行個體的存留期原則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-135">An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> used to control the lifetime policy for this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3c32-136">如需有關存留期服務的詳細資訊，請參閱<xref:System.Runtime.Remoting.Lifetime.LifetimeServices>類別。</span><span class="sxs-lookup"><span data-stu-id="f3c32-136">For more information about lifetime services, see the <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f3c32-137">立即呼叫端沒有基礎結構使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-137">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f3c32-138">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-138">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f3c32-139">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-139">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public virtual object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member InitializeLifetimeService : unit -&gt; obj&#xA;override this.InitializeLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f3c32-140">取得存留期服務物件，以控制這個執行個體的存留期原則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-140">Obtains a lifetime service object to control the lifetime policy for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f3c32-141">型別 <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> 的物件，用來控制這個執行個體的存留期原則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-141">An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> used to control the lifetime policy for this instance.</span>
          </span>
          <span data-ttu-id="f3c32-142">如果存在目前存留期服務物件，則這是這個執行個體的目前存留期服務物件，否則為新的存留期服務物件，其初始化為 <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" /> 屬性 (Property) 的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-142">This is the current lifetime service object for this instance if one exists; otherwise, a new lifetime service object initialized to the value of the <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" /> property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3c32-143">如需有關存留期服務的詳細資訊，請參閱<xref:System.Runtime.Remoting.Lifetime.LifetimeServices>類別。</span><span class="sxs-lookup"><span data-stu-id="f3c32-143">For more information about lifetime services, see the <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f3c32-144">下列程式碼範例示範如何建立使用期。</span><span class="sxs-lookup"><span data-stu-id="f3c32-144">The following code example demonstrates creating a lease.</span></span>  
  
 [!code-cpp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CS/source.cs#1)]
 [!code-vb[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f3c32-145">立即呼叫端沒有基礎結構使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-145">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f3c32-146">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-146">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f3c32-147">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-147">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberwiseClone">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f3c32-148">建立目前物件的淺層複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-148">Creates a shallow copy of the current object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject MemberwiseClone (bool cloneIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.MemberwiseClone(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone (cloneIdentity As Boolean) As MarshalByRefObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject ^ MemberwiseClone(bool cloneIdentity);" />
      <MemberSignature Language="F#" Value="override this.MemberwiseClone : bool -&gt; MarshalByRefObject" Usage="marshalByRefObject.MemberwiseClone cloneIdentity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.MarshalByRefObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cloneIdentity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cloneIdentity">
          <span data-ttu-id="f3c32-149">
            <see langword="false" />，刪除目前 <see cref="T:System.MarshalByRefObject" /> 物件的識別 (Identity)，則會在跨遠端界限進行封送處理時將新的識別指定給物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-149">
              <see langword="false" /> to delete the current <see cref="T:System.MarshalByRefObject" /> object's identity, which will cause the object to be assigned a new identity when it is marshaled across a remoting boundary.</span>
          </span>
          <span data-ttu-id="f3c32-150">
            <see langword="false" /> 的值通常是適當的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-150">A value of <see langword="false" /> is usually appropriate.</span>
          </span>
          <span data-ttu-id="f3c32-151">
            <see langword="true" /> 表示會將目前 <see cref="T:System.MarshalByRefObject" /> 物件的識別複製到其複製品，而造成將遠端用戶端呼叫傳送至遠端伺服器物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-151">
              <see langword="true" /> to copy the current <see cref="T:System.MarshalByRefObject" /> object's identity to its clone, which will cause remoting client calls to be routed to the remote server object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f3c32-152">建立目前 <see cref="T:System.MarshalByRefObject" /> 物件的淺層複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-152">Creates a shallow copy of the current <see cref="T:System.MarshalByRefObject" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f3c32-153">目前 <see cref="T:System.MarshalByRefObject" /> 物件的淺層複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f3c32-153">A shallow copy of the current <see cref="T:System.MarshalByRefObject" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f3c32-154"><xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29>方法來建立新建立的淺層複製<xref:System.MarshalByRefObject>物件，然後再複製目前的非靜態欄位<xref:System.MarshalByRefObject>物件與新的物件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-154">The <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> method creates a shallow copy by creating a new <xref:System.MarshalByRefObject> object, and then copying the nonstatic fields of the current <xref:System.MarshalByRefObject> object to the new object.</span></span> <span data-ttu-id="f3c32-155">如果欄位是實值型別，則會執行位元欄位的複本。</span><span class="sxs-lookup"><span data-stu-id="f3c32-155">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="f3c32-156">如果欄位是參考型別，則會複製參考，但參考的物件不;因此，原始的物件和其複製品參考相同的物件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-156">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="f3c32-157">例如，假設<xref:System.MarshalByRefObject>呼叫參考物件 A 和 B 的 X 物件，則是參照物件 c。X 的淺層複本建立新物件，X2，也會參考物件 A 和 b。相反地，X 的深層複本建立新物件 X2 A2 和 B2，也就是 A 的複本的新物件和 B.B2，則是參照複本 C.使用可實作類別的新物件 C2、<xref:System.ICloneable>介面，以執行深層或淺層 c複製的物件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-157">For example, consider a <xref:System.MarshalByRefObject> object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy C. Use a class that implements the <xref:System.ICloneable> interface to perform a deep or shallow copy of an object.</span></span>  
  
 <span data-ttu-id="f3c32-158">識別<xref:System.MarshalByRefObject>物件會定義為目標的遠端用戶端呼叫遠端伺服器物件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-158">The identity of a <xref:System.MarshalByRefObject> object is defined as the remote server object that is the target of a remoting client call.</span></span> <span data-ttu-id="f3c32-159">根據預設，成員複製品<xref:System.MarshalByRefObject>物件具有相同的身分識別與原始物件，而且通常不會跨遠端界限與用戶端會封送處理的伺服器端物件的複製正確的行為。</span><span class="sxs-lookup"><span data-stu-id="f3c32-159">By default, the memberwise clone of a <xref:System.MarshalByRefObject> object has the same identity as the original object, which is typically not the correct behavior for clones of server-side objects that are marshaled across a remoting boundary to the client side.</span></span> <span data-ttu-id="f3c32-160">指定`false`，這通常是適當，刪除複製的身分識別，並導致複製會跨遠端界限，封送處理時，指派新的身分識別或`true`導致保留的原始身分識別複製<xref:System.MarshalByRefObject>物件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-160">Specify `false`, which is usually appropriate, to delete the identity of the clone and cause a new identity to be assigned when the clone is marshaled across a remoting boundary, or `true` to cause the clone to retain the identity of the original <xref:System.MarshalByRefObject> object.</span></span> <span data-ttu-id="f3c32-161"><xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29>方法要供開發人員實作遠端伺服器物件。</span><span class="sxs-lookup"><span data-stu-id="f3c32-161">The <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> method is intended to be used by developers implementing remote server objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>