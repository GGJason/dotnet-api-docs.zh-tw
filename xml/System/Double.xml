<Type Name="Double" FullName="System.Double">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3341113ad2f5877991385e44636466bbbe74d1fc" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57931385" /></Metadata><TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示雙精度浮點數。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double>實值型別代表值範圍從負 1.79769313486232e308 到正 1.79769313486232 e 308，以及正或負 0、 雙精確度 64 位元數字<xref:System.Double.PositiveInfinity>， <xref:System.Double.NegativeInfinity>，並不是數字 (<xref:System.Double.NaN>). 它用來代表值，是極大 （例如行星或個之間的距離） 或極小 （在公斤物質分子大量），通常並不精確 （例如距離地球另一個太陽系），<xref:System.Double>類型符合 IEC 60559:1989 (IEEE 754) 二進位浮點運算的標準。  
  
 本主題包含下列章節：  
  
-   [浮點數表示和有效位數](#Precision)  
  
-   [測試相等](#Equality)  
  
-   [浮點值和例外狀況](#Exceptions)  
  
-   [型別轉換和雙精確度結構](#Conversions)  
  
-   [浮點數的功能](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>浮點數表示和有效位數  
 <xref:System.Double>資料型別雙精確度浮點值 64 位元二進位格式儲存下, 表所示：  
  
|組件|Bits|  
|----------|----------|  
|有效數字或尾數|0-51|  
|指數|52-62|  
|符號 (0 = 正數、 1 = 負)|63|  
  
 如同小數無法精確地表示有些小數值 (例如 1/3 或<xref:System.Math.PI?displayProperty=nameWithType>)，二進位分數是無法代表某些小數的值。 例如，1/10，精確地由.1 以小數表示，被以.001100110011 為二進位分數，使用模式"0011"重複為無限大。 在此情況下，浮點值會提供它所代表的數字不精確表示法。 經常執行額外的數學運算的原始浮點數的值通常會提高其缺乏精確度。 比方說，如果我們比較結果乘以.1 10 新增.1 到.1 九次，我們會看到加入，因為它已牽涉到八個更多的作業，已產生較不精確的結果。 請注意，此差異是只有當我們顯示兩個明顯<xref:System.Double>使用"R"的值[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)，如果需要，將會顯示所有 17 位數支援<xref:System.Double>型別。  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 因為小的二進位數值無法完全代表一些數字，浮點數可以只近似實際數字。  
  
 所有的浮點數也會有有限的數目的有效位數，其中也會決定如何精確的浮點值接近實際數字。   A<xref:System.Double>值具有最多 15 個有效小數位數，雖然內部維護最多 17 個位數。 這表示某些浮點運算可能缺少有效位數變更為浮點值。 下列範例提供一個實例。 它定義非常大的浮點值，並將新增的產品<xref:System.Double.Epsilon?displayProperty=nameWithType>和它的其中一個大關。 不過，「 產品 」 是太小，無法修改原始的浮點值。 其最小顯著性數字是千分之一秒，而中產品的最高有效位數是 10<sup>-309</sup>。  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 浮點數限制有效位數有數個結果：  
  
-   因為其最小有效位數不同，會出現特定的有效位數相等的兩個浮點數可能不比較相等。 在下列範例中，一系列數字加在一起，，以及其總計相較於其預期的總和。 雖然兩個值會出現相同，呼叫`Equals`方法表示它們不是。  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     如果您變更中的格式項目<xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType>陳述式，從`{0}`和`{1}`來`{0:R}`並`{1:R}`以顯示所有的有效位數，兩個<xref:System.Double>很清楚兩個值相等的值，因為失去了在加法作業期間的有效位數。 在此情況下，解決問題，藉由呼叫<xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType>要捨入方法<xref:System.Double>到所需的精確度，然後再執行比較的值。  
  
-   使用浮點數數學或比較運算可能不會產生相同的結果使用十進位數字時，如果因為二進位浮點數可能不等於的十進位數字。 上述範例說明這顯示結果乘以.1 10，並加入.1 的時間。  
  
     當精確度與小數值的數字作業中很重要時，您可以使用<xref:System.Decimal>而非<xref:System.Double>型別。 當數字的操作，具有超過範圍的整數值的精確度<xref:System.Int64>或<xref:System.UInt64>型別是重要的是，使用<xref:System.Numerics.BigInteger>型別。  
  
-   值可能不會反覆存取如果牽涉到浮點數。 如果作業會將原始浮點數轉換成另一種形式，反運算將轉換回浮點數，轉換的形式，而且最終浮點數不等於原始值，即稱為反覆存取浮點數。 來回行程可能會失敗，因為一或多個最低有效位數遺失或轉換變更。 在下列範例中，三個<xref:System.Double>值被轉換成字串並儲存在檔案中。 如輸出所示，不過，即使值看起來相同，則還原的值不相等為原始值。  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     在此情況下，值可以是成功的來回時間使用"G17"[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)保留完整的有效位數的<xref:System.Double>值，如下列範例所示。  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  當搭配<xref:System.Double>值，"R"格式規範，在某些情況下無法成功地反覆存取原始值。 若要確定<xref:System.Double>值成功地反覆存取，使用"G17"格式規範。

-   <xref:System.Single> 值有較少精確度卻高於<xref:System.Double>值。 A<xref:System.Single>值轉換成看似相當<xref:System.Double>通常不等於<xref:System.Double>因為有效位數的差異值。 在下列範例中，相同的除法運算的結果指派給<xref:System.Double>和<xref:System.Single>值。 在後<xref:System.Single>的值轉換為<xref:System.Double>，比較兩個值會顯示不相等。  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     若要避免這個問題，請使用<xref:System.Double>代替<xref:System.Single>資料類型或使用<xref:System.Math.Round%2A>方法，讓這兩個值具有相同的有效位數。  
  
 此外，與算術和指派作業的結果<xref:System.Double>值可能稍有不同的平台的有效位數遺失因為<xref:System.Double>型別。 例如，指派常值的結果<xref:System.Double>值而異的 32 位元和 64 位元版本的.NET framework 中。 下列範例說明這點差異時常值-4.42330604244772E-305 和變數，其值為-4.42330604244772E-305 指派給<xref:System.Double>變數。 請注意，結果<xref:System.Double.Parse%28System.String%29>方法在此情況下不會發生遺失有效位數。  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>測試相等  
 若要才會被視為相等，兩個<xref:System.Double>值必須代表相同的值。 不過，因為在精確度值之間的差異，或因為遺失一或兩個值的有效位數，應該通常是相同的浮點值變得不相等因為其最小有效位數的差異。 如此一來，呼叫<xref:System.Double.Equals%2A>方法，以判斷兩個值是否相等或呼叫<xref:System.Double.CompareTo%2A>方法，以判斷兩個之間的關聯性<xref:System.Double>值，通常會產生非預期的結果。 這是出現在下列範例中，其中兩個明顯等於<xref:System.Double>值變得不相等因為第一個有 15 個位數的精確度，第二個有 17。  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 導出的值，通常當做不同的方式，遵循不同的程式碼路徑，並且證明不相等。 在下列範例中，一個<xref:System.Double>平方值，並計算再還原為原始值的平方根。 第二個<xref:System.Double>會乘以 3.51 和平方之前 3.51 還原為原始值除以結果的平方根。 雖然兩個值看起來相同，但呼叫<xref:System.Double.Equals%28System.Double%29>方法指出它們是否不相等。 傳回顯示的每個雙精度浮點數值的所有有效位數的結果字串中使用"R"標準格式字串會顯示第二個值是.0000000000001 第一個大於或等於。  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 中的情況下遺失有效位數可能會影響比較的結果，您可以採用任何下列的替代方案，於呼叫<xref:System.Double.Equals%2A>或<xref:System.Double.CompareTo%2A>方法：  
  
-   呼叫<xref:System.Math.Round%2A?displayProperty=nameWithType>方法，以確保這兩個值都有相同的精確度。 下列範例會修改先前的範例，為使用這種方法，讓兩個小數值相等。  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     不過要注意的是，有效位數的問題，仍適用於的中點值捨入。 如需詳細資訊，請參閱 <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> 方法。  
  
-   近似相等測試而不是等號比較。 這需要您定義的其中一個絕對數量的兩個值可以用不同，但仍視為相等，或您定義相對量的較小的值可以偏離較大的值。  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> 有時會作為兩個之間距離的絕對單位<xref:System.Double>值時測試是否相等。  不過，<xref:System.Double.Epsilon?displayProperty=nameWithType>測量的最小的可能值，可以新增或減去，<xref:System.Double>其值為零。 為大部分的正數和負數<xref:System.Double>的值，而值<xref:System.Double.Epsilon?displayProperty=nameWithType>太小而無法偵測到。 因此，除了為零的值，我們不建議在測試相等。  
  
     下列範例會使用第二種方法來定義`IsApproximatelyEqual`方法，來測試兩個值之間的相對差異。 它也會對照的呼叫結果`IsApproximatelyEqual`方法和<xref:System.Double.Equals%28System.Double%29>方法。  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>浮點值和例外狀況  
 不同於使用整數類資料類型，在溢位或不合法的作業，例如部門的情況下擲回例外狀況為零，作業具有浮點值的作業不擲回例外狀況。 相反地，例外的情況下，在浮點運算的結果是零，正無限大、 負無限大或不是數字 (NaN):  
  
-   如果浮點運算的結果太小，目的格式，則結果會是零。 這可能會乘以兩個非常小的數字，如下列範例所示。  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   浮點運算的結果大小超過目的格式的範圍，作業的結果是否<xref:System.Double.PositiveInfinity>或<xref:System.Double.NegativeInfinity>視需要結果的正負號。 溢位運算的結果<xref:System.Double.MaxValue?displayProperty=nameWithType>已<xref:System.Double.PositiveInfinity>，並造成溢位運算的結果<xref:System.Double.MinValue?displayProperty=nameWithType>是<xref:System.Double.NegativeInfinity>，如下列範例所示。  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> 也產生除以零正值被除數，與和<xref:System.Double.NegativeInfinity>除法運算結果與負被除數為零。  
  
-   如果浮點運算無效，作業的結果是<xref:System.Double.NaN>。 比方說，<xref:System.Double.NaN>天時，下列作業：  
  
    -   除數為零與被除數為零。 請注意除法的其他情況下，在零結果<xref:System.Double.PositiveInfinity>或<xref:System.Double.NegativeInfinity>。  
  
-   與無效輸入任何浮點運算。 例如，呼叫<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>以負數值的方法會傳回<xref:System.Double.NaN>，如未呼叫<xref:System.Math.Acos%2A?displayProperty=nameWithType>值大於 1 或更少負一的方法。  
  
-   使用引數，其值的任何作業<xref:System.Double.NaN?displayProperty=nameWithType>。  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>型別轉換和雙精確度結構  
 <xref:System.Double>結構並未定義任何明確或隱含的轉換運算子; 相反地，轉換會由編譯器實作。  
  
 轉換至任何基本數值類型的值<xref:System.Double>是擴展轉換，因此不需要明確轉換運算子或呼叫轉換方法，除非編譯器明確需要。 例如，C# 編譯器轉換需要轉型運算子<xref:System.Decimal>至<xref:System.Double>，而 Visual Basic 編譯器並不會。 下列範例會轉換至其他基本數值類型的最小值或最大值<xref:System.Double>。  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 颾魤 ㄛ<xref:System.Single>值<xref:System.Single.NaN?displayProperty=nameWithType>， <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>，以及<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>轉換到<xref:System.Double.NaN?displayProperty=nameWithType>， <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>分別。  
  
 請注意，某些數字型別，值的轉換<xref:System.Double>值可能會涉及遺失有效位數。 如範例所示，遺失有效位數時，可能轉換<xref:System.Decimal>， <xref:System.Int64>， <xref:System.Single>，以及<xref:System.UInt64>值<xref:System.Double>值。  
  
 轉換<xref:System.Double>值與任何其他基本的數值資料類型的值是縮小轉換，而且需要轉換運算子 （在 C# 中)、 （在 Visual Basic) 的轉換方法或呼叫<xref:System.Convert>方法。 值超出範圍的目標資料類型，都由目標類型的定義`MinValue`和`MaxValue`屬性，行為如下表所示。  
  
|目標類型|結果|  
|-----------------|------------|  
|任何整數類資料類型|<xref:System.OverflowException>轉換檢查的內容中發生的例外狀況。<br /><br /> 如果在 unchecked 內容中 （C# 中的預設值），就會發生轉換，轉換作業成功，但值溢位。|  
|<xref:System.Decimal>|<xref:System.OverflowException> 例外狀況。|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> 負數的值。<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> 正數值。|  
  
 颾魤 ㄛ <xref:System.Double.NaN?displayProperty=nameWithType>， <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>，並<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>擲回<xref:System.OverflowException>checked 的內容中，但這些值的溢位時轉換成在 unchecked 內容中的整數的整數的轉換。 轉換成<xref:System.Decimal>，則一律會擲回<xref:System.OverflowException>。 轉換成<xref:System.Single>，它們會轉換成<xref:System.Single.NaN?displayProperty=nameWithType>， <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>分別。  
  
 請注意，遺失有效位數可能會使轉換<xref:System.Double>成另一個數值類型的值。 在將非整數的轉換的情況下<xref:System.Double>值，如範例輸出所示，小數部分時遺失<xref:System.Double>值四捨五入 （就像在 Visual Basic) 或截斷 （例如 C# 中)。 轉換成<xref:System.Decimal>並<xref:System.Single>的值，<xref:System.Double>值不能精確的表示法中的目標資料類型。  
  
 下列範例會將許多<xref:System.Double>數個其他數值類型的值。 在 Visual Basic （預設值），和在 C# 中檢查的內容中會發生轉換 (因為[檢查](~/docs/csharp/language-reference/keywords/checked.md)關鍵字)。 此範例的輸出會顯示轉換的結果中這兩個核取核取的內容。 您也可以使用編譯在 unchecked 內容中 Visual Basic 中執行的轉換`/removeintchecks+`編譯器參數和 C# 註解`checked`陳述式。  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 如需有關轉換的數字類型的詳細資訊，請參閱[.NET Framework 中的類型轉換](~/docs/standard/base-types/type-conversion.md)並[類型轉換表](~/docs/standard/base-types/conversion-tables.md)。  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>浮點數的功能  
 <xref:System.Double>結構和相關的型別提供方法來執行作業，在下列區域：  
  
-   **值的比較**。 您可以呼叫<xref:System.Double.Equals%2A>方法，以判斷兩個<xref:System.Double>值相等，或<xref:System.Double.CompareTo%2A>方法，以判斷兩個值之間的關聯性。  
  
     <xref:System.Double>結構也支援一組完整的比較運算子。 例如，您可以測試相等或不等，或判斷某個值是否大於或等於另一個。 如果其中一個運算元不是數值的型別<xref:System.Double>，則會轉換成<xref:System.Double>之前執行比較。  
  
    > [!WARNING]
    >  有效位數，因此兩個<xref:System.Double>您預期是相等的值可能會變得不相等，這會影響比較的結果。 請參閱[測試是否相等](#Equality)如需有關比較兩個區段<xref:System.Double>值。  
  
     您也可以呼叫<xref:System.Double.IsNaN%2A>， <xref:System.Double.IsInfinity%2A>， <xref:System.Double.IsPositiveInfinity%2A>，和<xref:System.Double.IsNegativeInfinity%2A>來測試這些特殊值的方法。  
  
-   **數學運算**。 常用的算術運算，例如加法、 減法、 乘法和除法、 會實作由語言編譯器和通用中間語言 (CIL) 的指示，而非<xref:System.Double>方法。 如果其中一個數學運算的運算元不是數值的型別<xref:System.Double>，則會轉換成<xref:System.Double>之前執行此作業。 作業的結果也是<xref:System.Double>值。  
  
     可以藉由呼叫執行其他數學運算`static`(`Shared` Visual Basic 中) 中的方法<xref:System.Math?displayProperty=nameWithType>類別。 它包含常用的算術運算的其他方法 (例如<xref:System.Math.Abs%2A?displayProperty=nameWithType>， <xref:System.Math.Sign%2A?displayProperty=nameWithType>，和<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>)，幾何 (例如<xref:System.Math.Cos%2A?displayProperty=nameWithType>和<xref:System.Math.Sin%2A?displayProperty=nameWithType>)，和微積分 (例如<xref:System.Math.Log%2A?displayProperty=nameWithType>)。  
  
     您也可以使用操作中的個別位元<xref:System.Double>值。 <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType>方法會保留<xref:System.Double>值的位元模式中的 64 位元整數。 <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType>方法會傳回其位元模式中的位元組陣列。  
  
-   **捨入**。 捨入通常用於一種技術以減少的差異值的浮點數表示和精確度的問題所造成的影響。 您可以藉由四捨五入<xref:System.Double>值，藉由呼叫<xref:System.Math.Round%2A?displayProperty=nameWithType>方法。  
  
-   **格式化**。 您可以將轉換<xref:System.Double>值為其字串表示，藉由呼叫<xref:System.Double.ToString%2A>方法或使用複合格式功能。 如需格式字串的浮點值的字串表示的控制方式，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)主題。  
  
-   **剖析字串**。 您可以將轉換的浮點值的字串表示<xref:System.Double>值，藉由呼叫<xref:System.Double.Parse%2A>或<xref:System.Double.TryParse%2A>方法。 如果剖析作業失敗，<xref:System.Double.Parse%2A>方法會擲回例外狀況，而<xref:System.Double.TryParse%2A>方法會傳回`false`。  
  
-   **類型轉換**。 <xref:System.Double>結構提供的明確介面實作<xref:System.IConvertible>介面支援任何兩個標準的.NET Framework 資料類型之間轉換。 語言編譯器也支援的所有其他標準數字型別，值隱含轉換<xref:System.Double>值。 任何標準的數字型別，若要將值轉換<xref:System.Double>是擴展轉換，而且不需要轉型運算子或轉換方法，使用者  
  
     不過，轉換<xref:System.Int64>和<xref:System.Single>值可能是遺失有效位數。 下表列出的每一種類型的有效位數的差異：  
  
    |類型|最大有效位數|內部的有效位數|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 的十進位數字|19 的十進位數字|  
    |<xref:System.Single>|7 的十進位數字|9 的十進位數字|  
  
     有效位數的問題通常會影響<xref:System.Single>值轉換成<xref:System.Double>值。 在下列範例中，相同的除法運算所產生的兩個值相等因為其中一個值是單精確度浮點數值轉換成<xref:System.Double>。  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別的所有成員都是安全執行緒。 若要修改執行個體狀態會顯示的成員實際上會傳回新的值進行初始化的新執行個體。 為與任何其他型別，讀取和寫入共用的變數，其中包含這個型別的執行個體必須受到鎖定，以確保執行緒安全性。</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">範例：.NET Framework 4 格式化公用程式</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比較這個執行個體與指定的物件或 <see cref="T:System.Double" /> 物件，並傳回整數，以表示此執行個體的值小於、等於或大於指定之物件或 <see cref="T:System.Double" /> 物件的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要比較的雙精確度浮點數。</param>
        <summary>比較這個執行個體與雙精確度的浮點數值，並且傳回一個整數，指出這個執行個體的值是小於、等於或大於特定的雙精確度浮點數值。</summary>
        <returns>帶正負號的數字，指出這個執行個體與 <paramref name="value" /> 的相對值。  
  
 <list type="table"><listheader><term> 傳回值 
 </term><description> 描述 
 </description></listheader><item><term> 小於零 
 </term><description> 這個執行個體小於 <paramref name="value" />。  
  
-或- 
這個執行個體是非數字 (<see cref="F:System.Double.NaN" />)，而且 <paramref name="value" /> 是數字。  
  
 </description></item><item><term> 零 
 </term><description> 這個執行個體等於 <paramref name="value" />。  
  
-或- 
這個執行個體和 <paramref name="value" /> 都不會是數字 (<see cref="F:System.Double.NaN" />)、<see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" />。  
  
 </description></item><item><term> 大於零 
 </term><description> 這個執行個體大於 <paramref name="value" />。  
  
-或- 
這個執行個體是數字，而且 <paramref name="value" /> 為非數字 (<see cref="F:System.Double.NaN" />)。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值必須相同才會被視為相等。 尤其是浮點數的值取決於多個數學運算，通常會遺失有效位數和其值必須是幾乎完全相同，除了其最小有效位數。 因為這個緣故，傳回值<xref:System.Double.CompareTo%2A>方法有時候可能會很驚訝。 例如，乘法依特定值後面除法相同的值應該產生原始值。 在下列範例中，不過，計算的值其實可以大於原始值。 使用"R"顯示兩個值的所有有效位數[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)表示從其最小有效位數中的原始值，不同的計算的值。 如需處理這類比較的詳細資訊，請參閱 < 備註 > 一節<xref:System.Double.Equals%28System.Double%29>方法。  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 這個方法會實作<xref:System.IComparable%601?displayProperty=nameWithType>介面並執行稍微優於<xref:System.Double.CompareTo%2A?displayProperty=nameWithType>方法因為並沒有將`value`物件的參數。  
  
 請注意，雖然物件，其值為<xref:System.Double.NaN>不等於另一個物件，其值為<xref:System.Double.NaN>（甚至是本身），<xref:System.IComparable%601>介面需要`A.CompareTo(A)`傳回零。  
  
## <a name="widening-conversions"></a>擴展轉換  
 根據您的程式語言，可能是程式碼可能<xref:System.Double.CompareTo%2A>方法的參數類型具有較少的位元的位置 （較窄） 與執行個體類型。 這可能是因為有些程式語言會執行隱含的擴展轉換，將參數表示為型別具有相同位元數與執行個體。  
  
 例如，假設此執行個體類型是<xref:System.Double>，且參數類型為<xref:System.Int32>。 Microsoft C# 編譯器會產生代表做為參數的值的指示<xref:System.Double>物件，則會產生<xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType>比較執行個體的值和擴大的表示參數的方法。  
  
 請參閱您的程式語言的文件，以判斷其編譯器是否會執行隱含的擴展轉換的數字類型。 如需詳細資訊，請參閱 <<c0> [ 類型轉換表](~/docs/standard/base-types/conversion-tables.md)主題。  
  
## <a name="precision-in-comparisons"></a>在比較中的有效位數  
 超過記載的精確度的浮點數的有效位數是特定實作] 和 [.NET Framework 版本。 因此，比較兩個特定的數字可能會變更.NET Framework 版本之間的有效位數的數字的內部表示法可能會變更。  
  
   
  
## Examples  
 下列程式碼範例示範泛型和非泛型版本<xref:System.Double.CompareTo%2A>數的值和參考類型的方法。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要比較的物件或 <see langword="null" />。</param>
        <summary>比較這個執行個體與特定物件，並且傳回一個整數，指出這個執行個體的值是小於、等於或大於特定物件的值。</summary>
        <returns>帶正負號的數字，指出這個執行個體與 <paramref name="value" /> 的相對值。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 描述 
 </description></listheader><item><term> 負整數 
 </term><description> 這個執行個體小於 <paramref name="value" />。  
  
-或- 
這個執行個體是非數字 (<see cref="F:System.Double.NaN" />)，而且 <paramref name="value" /> 是數字。  
  
 </description></item><item><term> 零 
 </term><description> 這個執行個體等於 <paramref name="value" />。  
  
-或- 
這個執行個體和 <paramref name="value" /> 都是 <see langword="Double.NaN" />、<see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> 正整數 
 </term><description> 這個執行個體大於 <paramref name="value" />。  
  
-或- 
這個執行個體是數字，而且 <paramref name="value" /> 為非數字 (<see cref="F:System.Double.NaN" />)。  
  
-或- 
 <paramref name="value" /> 為 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`參數必須是`null`或執行個體`Double`，否則會擲回例外狀況。 任何執行個體<xref:System.Double>，不論其值會被視為大於`null`。  
  
 值必須相同才會被視為相等。 尤其是浮點數的值取決於多個數學運算，通常會遺失有效位數和其值必須是幾乎完全相同，除了其最小有效位數。 因為這個緣故，傳回值<xref:System.Double.CompareTo%2A>方法有時候可能會很驚訝。 例如，乘法依特定值後面除法相同的值應該產生原始值。 在下列範例中，不過，計算的值其實可以大於原始值。 使用"R"顯示兩個值的所有有效位數[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)表示從其最小有效位數中的原始值，不同的計算的值。 如需處理這類比較的詳細資訊，請參閱 < 備註 > 一節<xref:System.Double.Equals%28System.Double%29>方法。  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 這個方法會實作以支援<xref:System.IComparable>介面。 請注意，雖然<xref:System.Double.NaN>不等於另一個<xref:System.Double.NaN>（甚至是本身），<xref:System.IComparable>介面需要`A.CompareTo(A)`傳回零。  
  
## <a name="precision-in-comparisons"></a>在比較中的有效位數  
 超過記載的精確度的浮點數的有效位數是特定實作] 和 [.NET Framework 版本。 因此，比較兩個特定的數字可能會變更.NET Framework 版本之間的有效位數的數字的內部表示法可能會變更。  
  
   
  
## Examples  
 下列程式碼範例示範如何將`CompareTo`的內容中`Double`。  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是 <see cref="T:System.Double" />。</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>代表大於零的最小正 <see cref="T:System.Double" /> 值。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Double.Epsilon>屬性會反映最小正<xref:System.Double>數字的操作或比較中佔有相當大的值時的值<xref:System.Double>執行個體是零。 例如，下列程式碼所示的零和<xref:System.Double.Epsilon>會被視為不相等的值，而零和一半的值<xref:System.Double.Epsilon>會被視為相等。  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 更精確地說，浮點格式包含號、 52 位元尾數或有效位數和 11 位元的指數的點。 如下列範例所示，零會有的-1022年指數和尾數為 0。 <xref:System.Double.Epsilon> 有的-1022年指數和尾數的 1。 這表示<xref:System.Double.Epsilon>是最小正<xref:System.Double>值小於或等於零，並代表可能的最小值和最小可能的遞增量<xref:System.Double>其指數，是-1022年。  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 不過，<xref:System.Double.Epsilon>屬性不是一般的量值的有效位數<xref:System.Double>類型; 它只適用於<xref:System.Double>有值為 0 或-1022年的指數的執行個體。  
  
> [!NOTE]
>  值<xref:System.Double.Epsilon>屬性不等於機器 epsilon、 表示相對的錯誤，因為在浮點算術捨入上限。  
  
 這個常數的值是 4.94065645841247-324。  
  
 兩個明顯的對等的浮點數進行比較時可能並不相等，這是因為其最小有效位數的差異。 例如，C# 運算式`(double)1/3 == (double)0.33333`，不會比較相等因為除法運算，在左側有最大有效位數，而右邊的常數只能精確到指定的數字。 如果您建立自訂的演算法來決定是否可以視為兩個浮點數相等時，我們不建議的值根據的演算法<xref:System.Double.Epsilon>常數，以建立可接受的絕對邊界的不同之處兩個值被視為相等。  (一般而言，該邊界的差異大於多次<xref:System.Double.Epsilon>。)比較兩個雙精確度浮點值的相關資訊，請參閱<xref:System.Double>和<xref:System.Double.Equals%28System.Double%29>。  
  
## <a name="platform-notes"></a>平台注意事項  
 在 ARM 系統上，windows 7<xref:System.Double.Epsilon>常數太小而無法偵測到，因此它等同於零。 您可以定義替代 epsilon 值等於 2.2250738585072014 e-308 改。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回數值，指示 <see cref="T:System.Double" /> 的兩個執行個體是否表示相同的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要與這個執行個體相比較的 <see cref="T:System.Double" /> 物件。</param>
        <summary>傳回數值，指示這個執行個體和指定的 <see cref="T:System.Double" /> 物件是否表示相同的值。</summary>
        <returns>如果 <see langword="true" /> 等於這個執行個體則為 <paramref name="obj" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作<xref:System.IEquatable%601?displayProperty=nameWithType>介面，並執行稍微優於<xref:System.Double.Equals%2A>因為並沒有將`obj`物件的參數。  
  
## <a name="widening-conversions"></a>擴展轉換  
 根據您的程式語言，可能是程式碼可能<xref:System.Double.Equals%2A>方法的參數類型具有較少的位元的位置 （較窄） 與執行個體類型。 這可能是因為有些程式語言會執行隱含的擴展轉換，將參數表示為型別具有相同位元數與執行個體。  
  
 例如，假設此執行個體類型是<xref:System.Double>，且參數類型為<xref:System.Int32>。 Microsoft C# 編譯器會產生代表做為參數的值的指示<xref:System.Double>物件，則會產生<xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType>比較執行個體的值和擴大的表示參數的方法。  
  
 請參閱您的程式語言的文件，以判斷其編譯器是否會執行隱含的擴展轉換的數字類型。 如需詳細資訊，請參閱 <<c0> [ 類型轉換表](~/docs/standard/base-types/conversion-tables.md)主題。  
  
## <a name="precision-in-comparisons"></a>在比較中的有效位數  
 <xref:System.Double.Equals%2A>方法應該小心使用，因為兩個明顯的對等的值可能會因為不同的有效位數的兩個值不相等。 下列範例會回報<xref:System.Double>值.333333 和<xref:System.Double>1 除以 3 傳回的值不相等。  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 而不是比較相等性，其中一種技術牽涉到定義可接受的相對界的兩個值之間的差異 (例如。 001%的其中一個值)。 如果兩個值之間差異的絕對值是小於或等於該邊界，差別有可能是因為有效位數的差異，因此，值為可能會相等。 下列範例會使用這項技術來比較.33333 和 1/3，這兩個<xref:System.Double>先前的程式碼範例，請參閱元的值。 在此情況下，值相等。  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  因為<xref:System.Double.Epsilon>會定義最小值運算式的正數值，其範圍是幾乎為零，兩個類似值之間差異的邊界必須大於<xref:System.Double.Epsilon>。 一般來說，這是許多倍<xref:System.Double.Epsilon>。 因為這個緣故，我們建議您不要使用<xref:System.Double.Epsilon>比較時<xref:System.Double>值是否相等。  
  
 第二種技術牽涉到比較兩個浮點數，與一些絕對值之間的差異。 差別在於小於或等於該絕對值的數字相等。 如果是更大，則數字不相等。 有一個替代方法是任意選取 絕對值。 這是有問題，不過，因為差異可接受界取決於大小的<xref:System.Double>值。 第二個替代方案會利用浮點數格式的設計功能：兩個浮點值的整數表示之間的差異表示可能的浮點值的數目，顯示分隔。 比方說，0.0 之間的差異並<xref:System.Double.Epsilon>為 1，因為<xref:System.Double.Epsilon>是可顯示的最小值，當使用<xref:System.Double>其值為零。 下列範例會使用這項技術來比較.33333 和 1/3，也就是這兩個<xref:System.Double>值，先前的程式碼範例，但<xref:System.Double.Equals%28System.Double%29>方法發現不相等。 請注意，此範例會使用<xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType>方法，將雙精確度浮點值轉換為其整數表示。  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 超過記載的精確度的浮點數的有效位數是特定實作] 和 [.NET Framework 版本。 因此，比較兩個特定的數字可能會變更.NET Framework 版本之間的有效位數的數字的內部表示法可能會變更。  
  
 如果兩個<xref:System.Double.NaN?displayProperty=nameWithType>藉由呼叫測試值是否相等<xref:System.Double.Equals%2A>方法，此方法會傳回`true`。 不過，如果兩個<xref:System.Double.NaN>值會使用等號比較運算子來測試是否相等，則運算子會傳回`false`。 當您想要判斷是否的值<xref:System.Double>不是數字 (NaN)，另一個方法是呼叫<xref:System.Double.IsNaN%2A>方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>編譯器多載解析可能會說明行為中的兩個明顯的差別<see cref="M:System.Double.Equals(System.Object)" />方法多載。 如果之間的隱含轉換<paramref name="obj" />引數和<see cref="T:System.Double" />定義和引數型別不是作為<see cref="T:System.Object" />，編譯器可能會執行隱含轉換和呼叫<see cref="M:System.Double.Equals(System.Double)" />方法。 否則，呼叫<see cref="M:System.Double.Equals(System.Object)" />方法，它一定會傳回<see langword="false" />如果其<paramref name="obj" />引數不是<see cref="T:System.Double" />值。 下列範例說明這兩個方法多載之間的行為差異。 如果除外的所有基本數值型別<see cref="T:System.Decimal" />，並在 C# 中，傳回第一個比較<see langword="true" />因為編譯器會自動執行擴展轉換和呼叫<see cref="M:System.Double.Equals(System.Double)" />方法，而第二個比較會傳回<see langword="false" />因為編譯器會呼叫<see cref="M:System.Double.Equals(System.Object)" />方法。  
  
[!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">與這個執行個體相互比較的物件。</param>
        <summary>傳回值，指出這個執行個體 (Instance) 是否和指定的物件相等。</summary>
        <returns>如果 <see langword="true" /> 是 <paramref name="obj" /> 的執行個體，並且等於這個執行個體的值，則為 <see cref="T:System.Double" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.Equals%2A>方法應該小心使用，因為兩個明顯的對等的值可能會因為不同的有效位數的兩個值不相等。 下列範例會回報<xref:System.Double>值.3333 和<xref:System.Double>傳回除以 1 3 不相等。  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 呼叫的替代方案<xref:System.Double.Equals%2A>方法，請參閱文件<xref:System.Double.Equals%28System.Double%29>多載。  
  
> [!NOTE]
>  因為<xref:System.Double.Epsilon>會定義最小值運算式的正數值，其範圍是幾乎為零，兩個類似值之間差異的邊界必須大於<xref:System.Double.Epsilon>。 一般來說，這是許多倍<xref:System.Double.Epsilon>。  
  
 超過記載的精確度的浮點數的有效位數是特定實作] 和 [.NET Framework 版本。 因此，比較兩個特定的數字可能會變更.NET Framework 版本之間的有效位數的數字的內部表示法可能會變更。  
  
 如果兩個<xref:System.Double.NaN?displayProperty=nameWithType>藉由呼叫測試值是否相等<xref:System.Double.Equals%2A>方法，此方法會傳回`true`。 不過，如果兩個<xref:System.Double.NaN>值會使用等號比較運算子來測試是否相等，則運算子會傳回`false`。 當您想要判斷是否的值<xref:System.Double>不是數字 (NaN)，另一個方法是呼叫<xref:System.Double.IsNaN%2A>方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>編譯器多載解析可能會說明行為中的兩個明顯的差別<see cref="M:System.Double.Equals(System.Object)" />方法多載。 如果之間的隱含轉換<paramref name="obj" />引數和<see cref="T:System.Double" />定義和引數型別不是作為<see cref="T:System.Object" />，編譯器可能會執行隱含轉換和呼叫<see cref="M:System.Double.Equals(System.Double)" />方法。 否則，呼叫<see cref="M:System.Double.Equals(System.Object)" />方法，它一定會傳回<see langword="false" />如果其<paramref name="obj" />引數不是<see cref="T:System.Double" />值。 下列範例說明這兩個方法多載之間的行為差異。 如果除外的所有基本數值型別<see cref="T:System.Decimal" />，並在 C# 中，傳回第一個比較<see langword="true" />因為編譯器會自動執行擴展轉換和呼叫<see cref="M:System.Double.Equals(System.Double)" />方法，而第二個比較會傳回<see langword="false" />因為編譯器會呼叫<see cref="M:System.Double.Equals(System.Object)" />方法。  
  
[!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個執行個體的雜湊碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回實值類型 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.Double" />。</summary>
        <returns>列舉常數 <see cref="F:System.TypeCode.Double" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">雙精確度浮點數。</param>
        <summary>傳回值，指出指定的數字是否計算結果為負或正的無限大。</summary>
        <returns>如果 <paramref name="d" /> 計算結果為 <see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮點數的作業會傳回<xref:System.Double.PositiveInfinity>或<xref:System.Double.NegativeInfinity>發出信號的溢位狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">雙精確度浮點數。</param>
        <summary>傳回值，這個值表示指定的值是否不是數字 (<see cref="F:System.Double.NaN" />)。</summary>
        <returns>如果 <paramref name="d" /> 計算結果為 <see cref="F:System.Double.NaN" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮點運算傳回<xref:System.Double.NaN>來表示作業的結果是未定義。 例如，除以 0.0 的 0.0 會導致<xref:System.Double.NaN>。  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> 會傳回`false`如果<xref:System.Double>值為<xref:System.Double.PositiveInfinity>或<xref:System.Double.NegativeInfinity>。 若要測試這些值，請使用<xref:System.Double.IsInfinity%2A>， <xref:System.Double.IsPositiveInfinity%2A>，和<xref:System.Double.IsNegativeInfinity%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">雙精確度浮點數。</param>
        <summary>傳回值，指出指定的數字是否計算結果為負的無限大。</summary>
        <returns>如果 <paramref name="d" /> 計算結果為 <see cref="F:System.Double.NegativeInfinity" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮點運算傳回<xref:System.Double.NegativeInfinity>發出信號的溢位狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">雙精確度浮點數。</param>
        <summary>傳回值，指出指定數字是否計算結果為正的無限大。</summary>
        <returns>如果 <paramref name="d" /> 計算結果為 <see cref="F:System.Double.PositiveInfinity" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮點運算傳回<xref:System.Double.PositiveInfinity>發出信號的溢位狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>表示 <see cref="T:System.Double" /> 最大的可能值。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個常數的值是正數 1.7976931348623157 e + 308。  
  
 超過作業的結果<xref:System.Double.MaxValue?displayProperty=nameWithType>是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。 在下列範例中，<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>時結果超出加法、 乘法和乘冪運算的結果<xref:System.Double.MaxValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>表示 <see cref="T:System.Double" /> 最小的可能值。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個常數的值是負的 1.7976931348623157 e + 308。  
  
 是作業的結果小於<xref:System.Double.MinValue?displayProperty=nameWithType>是<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。 在下列範例中，<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>時的結果是減法以及乘法運算的結果小於<xref:System.Double.MinValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>代表不是數字 (<see langword="NaN" />) 的值。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法或運算子傳回<xref:System.Double.NaN>時未定義作業的結果。 比方說，零除以零的結果是<xref:System.Double.NaN>，如下列範例所示。 (但請注意，除以零的非零的數字傳回其中一個<xref:System.Double.PositiveInfinity>或<xref:System.Double.NegativeInfinity>，取決於除數的正負號。)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 此外，方法呼叫，其<xref:System.Double.NaN>值或上的作業<xref:System.Double.NaN>值傳回<xref:System.Double.NaN>，如下列範例所示。  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 使用<xref:System.Double.IsNaN%2A>方法，以判斷值是否不是數字。 <xref:System.Double.op_Equality%2A>運算子會將視為兩個<xref:System.Double.NaN>值必須是另一個不相等。 一般情況下，<xref:System.Double>運算子不能用來比較<xref:System.Double.NaN?displayProperty=nameWithType>與其他<xref:System.Double>值，雖然比較方法 (例如<xref:System.Double.Equals%2A>和<xref:System.Double.CompareTo%2A>) 可以。 下列範例說明行為之間的差異<xref:System.Double>比較運算子和方法。  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 下列範例示範如何使用 <xref:System.Double.NaN>：  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>表示負無限大。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個常數的值是負數除以零的結果。  
  
 作業的結果時，這個常數會傳回小於<xref:System.Double.MinValue>。  
  
 使用<xref:System.Double.IsNegativeInfinity%2A>來判斷值是否計算結果為負無限大方向。  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示兩個指定的 <see cref="T:System.Double" /> 值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Equality%2A>方法來定義等號比較運算子<xref:System.Double>值。  
  
 如果兩個<xref:System.Double.NaN?displayProperty=nameWithType>值會使用等號比較運算子來測試是否相等，則結果為`false`; 兩個<xref:System.Double.NaN?displayProperty=nameWithType>值不會被視為相等。 如果它們藉由呼叫進行測試是否相等<xref:System.Double.Equals%2A>方法，結果是`true`。  當您想要判斷是否的值<xref:System.Double>不是數字 (NaN)，另一個方法是呼叫<xref:System.Double.IsNaN%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示指定的 <see cref="T:System.Double" /> 值是否大於另一個指定的 <see cref="T:System.Double" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThan%2A>方法定義作業的較大者為比運算子<xref:System.Double>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示指定的 <see cref="T:System.Double" /> 值是否大於或等於另一個指定的 <see cref="T:System.Double" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 大於或等於 <paramref name="right" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThanOrEqual%2A>方法來定義 「 大於或等於運算子的作業<xref:System.Double>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示兩個指定的 <see cref="T:System.Double" /> 值是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Inequality%2A>方法定義的不等比較運算子<xref:System.Double>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示指定的 <see cref="T:System.Double" /> 值是否小於另一個指定的 <see cref="T:System.Double" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThan%2A>方法定義的無作業-運算子的<xref:System.Double>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示指定的 <see cref="T:System.Double" /> 值是否小於或等於另一個指定的 <see cref="T:System.Double" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於或等於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThanOrEqual%2A>方法定義之小於-或-等於運算子的作業<xref:System.Double>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將數字的字串表示轉換為其相等的雙精確度浮點數。</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <summary>將數字的字串表示轉換為其相等的雙精確度浮點數。</summary>
        <returns>雙精確度浮點數，與 <paramref name="s" /> 中指定的數值或符號相等。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s`參數可以包含目前的文化特性<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>，或格式的字串：  
  
 [*ws*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的泛空白字元。|  
|*簽署*|負號符號 （-） 或正號符號 （+）。 可以用前置正負號。|  
|*integral-digits*|一系列數字範圍從 0 到 9 的指定數目的整數部分。 執行*整數位數*可以依群組分隔符號進行分割。 比方說，在某些文化特性逗號 （，） 分隔的千分位的群組。 *整數位數*項目可以是若字串包含*小數位數*項目。|  
|,|特定文化特性的千位分隔符號。|  
|。|特定文化特性的貨幣符號。|  
|*fractional-digits*|一系列數字範圍從 0 到 9 的指定數字的小數部分。|  
|E|"E"或者"E"字元，表示代表的值時，會以指數 （科學記號） 標記法。|  
|*exponential-digits*|一系列的範圍從 0 到 9 指定指數的數字。|  
  
 `s`參數會使用的組合來解譯<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。 這表示泛空白字元和千位分隔符號可以，比方說，雖然不是貨幣符號。 針對更控制透過樣式中允許的項目`s`剖析作業成功，呼叫<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>或<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 `s`參數會解譯使用中的格式設定資訊<xref:System.Globalization.NumberFormatInfo>初始化目前執行緒文化特性的物件。 如需詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>。 若要剖析字串，使用其他文化特性格式資訊，請呼叫<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>或<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
 一般情況下，如果您傳遞<xref:System.Double.Parse%2A?displayProperty=nameWithType>字串，由呼叫的方法<xref:System.Double.ToString%2A?displayProperty=nameWithType>方法中，原始<xref:System.Double>會傳回值。 不過，因為遺失有效位數，值可能不會相等。 此外，嘗試剖析的字串表示法<xref:System.Double.MinValue>或是<xref:System.Double.MaxValue>就會擲回<xref:System.OverflowException>，如下列範例所示。  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 如果出現在分隔符號`s`參數在剖析作業中，在適用的貨幣或十進位數字期間及群組分隔符號相同，則剖析作業會假設分隔符號是小數分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 在下列程式碼中，說明了如何使用 <xref:System.Double.Parse%28System.String%29> 方法。  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不是格式有效的數字。</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> 代表小於 <see cref="F:System.Double.MinValue" /> 或大於 <see cref="F:System.Double.MaxValue" /> 的數字。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">在 .NET 中剖析數值字串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <param name="style">列舉值的位元組合，表示 <paramref name="s" /> 中可以存在的樣式項目。 要指定的一般值為 <see cref="F:System.Globalization.NumberStyles.Float" /> 與 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的組合。</param>
        <summary>將數字的字串表示 (使用指定樣式) 轉換為其相等的雙精確度浮點數。</summary>
        <returns>雙精確度浮點數，與 <paramref name="s" /> 中指定的數值或符號相等。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`參數定義的樣式項目 (例如空格、 千分位分隔符號和貨幣符號) 中允許`s`剖析作業成功的參數。 它必須是從位元旗標的組合<xref:System.Globalization.NumberStyles>列舉型別。 下列<xref:System.Globalization.NumberStyles>不支援的成員：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`參數可以包含目前的文化特性<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>，或<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>。 值而定`style`，它也可以採用格式：  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的泛空白字元。 空白字元可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標，也可以顯示在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。|  
|$|特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>目前文化特性的屬性。 目前的文化特性的貨幣符號會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。|  
|*簽署*|負號符號 （-） 或正號符號 （+）。 符號可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，也可以顯示在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 可用於括號`s`表示負值`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。|  
|*integral-digits*|一系列數字範圍從 0 到 9 的指定數目的整數部分。 *整數位數*項目可以是若字串包含*小數位數*項目。|  
|,|特定文化特性的群組分隔符號。 目前的文化特性的群組分隔符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標|  
|。|特定文化特性的貨幣符號。 目前的文化特性的貨幣符號會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|*fractional-digits*|一系列數字範圍從 0 到 9 的指定數字的小數部分。 小數點後數字可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|E|"E"或者"E"字元，表示代表的值時，會以指數 （科學記號） 標記法。 `s`參數可代表指數標記法之數字，如果`style`包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*exponential-digits*|一系列的範圍從 0 到 9 指定指數的數字。|  
  
> [!NOTE]
> 中的任何終止 NUL (u+0000) 字元`s`剖析作業中，不論值會忽略`style`引數。

 只有數字的字串 (對應至<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>樣式) 一律會成功剖析。 其餘<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成員控制可能存在，但不是一定要出現在輸入字串的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>旗標會影響可能會出現在項目`s`。  
  
|NumberStyles 值|中的項目允許`s`除了數字|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整數位數*只有項目。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小數點 (*。*) 和*小數位數*項目。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或者"E"字元，這表示指數標記法。 這個旗標本身支援值形式*數字*E*數字*; 其他旗標才能成功剖析項目像是正或負號和小數點符號的字串。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*號*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*號*結尾的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*號*括號括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|千分位分隔符號 （，） 項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|貨幣 （$） 的項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有項目。 不過，`s`無法表示十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*元素的開頭或結尾`s`，*登*開頭`s`，且小數點 （.） 的符號。 `s`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千分位 （，） 符號和小數點 （.） 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有項目。 不過，`s`無法代表十六進位數字。|  
  
 `s`參數會剖析使用的格式設定資訊中<xref:System.Globalization.NumberFormatInfo>初始化目前系統文化特性的物件。 如需詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>。  
  
 一般情況下，如果您傳遞<xref:System.Double.Parse%2A?displayProperty=nameWithType>字串，由呼叫的方法<xref:System.Double.ToString%2A?displayProperty=nameWithType>方法中，原始<xref:System.Double>會傳回值。 不過，因為遺失有效位數，值可能不會相等。 此外，嘗試剖析的字串表示法<xref:System.Double.MinValue>或是<xref:System.Double.MaxValue>就會擲回<xref:System.OverflowException>，如下列範例所示。  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 如果出現在分隔符號`s`參數在剖析作業中，在適用的貨幣或十進位數字期間及群組分隔符號相同，則剖析作業會假設分隔符號是小數分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法來剖析的字串表示<xref:System.Double>使用 EN-US 文化特性值。  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不是格式有效的數字。</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> 代表小於 <see cref="F:System.Double.MinValue" /> 或大於 <see cref="F:System.Double.MaxValue" /> 的數字。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
-或- 
 <paramref name="style" /> 包含 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">在 .NET 中剖析數值字串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <param name="provider">物件，提供關於 <paramref name="s" /> 的特定文化特性格式資訊。</param>
        <summary>將數字的字串表示 (使用指定的特定文化特性格式) 轉換為其相等的雙精確度浮點數。</summary>
        <returns>雙精確度浮點數，與 <paramref name="s" /> 中指定的數值或符號相等。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29>方法通常用來將各種不同的方式來格式化的文字轉換<xref:System.Double>值。 比方說，它可以用來轉換使用者 HTML 文字方塊中輸入數值的文字。  
  
 `s`參數會使用的組合來解譯<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。 `s`參數可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>，或<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>所指定的文化特性`provider`，也可以包含格式的字串：  
  
 [*ws*][*sign*]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 選擇性的項目包覆在方括號 （[和]）。 包含詞彙 「 數字 」 的項目是由一系列的範圍從 0 到 9 的數字字元所組成。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的泛空白字元。|  
|*簽署*|負號符號 （-） 或正號符號 （+）。|  
|*integral-digits*|一系列數字範圍從 0 到 9 的指定數目的整數部分。 執行*整數位數*可以依群組分隔符號進行分割。 比方說，在某些文化特性逗號 （，） 分隔的千分位的群組。 *整數位數*項目可以是若字串包含*小數位數*項目。|  
|。|特定文化特性的貨幣符號。|  
|*fractional-digits*|一系列數字範圍從 0 到 9 的指定數字的小數部分。|  
|E|"E"或者"E"字元，表示代表的值時，會以指數 （科學記號） 標記法。|  
|*exponential-digits*|一系列的範圍從 0 到 9 指定指數的數字。|  
  
 如需有關數值格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)主題。  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性的資訊用於解譯的格式`s`。 一般來說，這是<xref:System.Globalization.NumberFormatInfo>或<xref:System.Globalization.CultureInfo>物件。 如果`provider`已`null`或<xref:System.Globalization.NumberFormatInfo>無法取得，格式設定資訊會使用目前的系統文化特性。  
  
 一般情況下，如果您傳遞<xref:System.Double.Parse%2A?displayProperty=nameWithType>字串，由呼叫的方法<xref:System.Double.ToString%2A?displayProperty=nameWithType>方法中，原始<xref:System.Double>會傳回值。 不過，因為遺失有效位數，值可能不會相等。 此外，嘗試剖析的字串表示法<xref:System.Double.MinValue>或是<xref:System.Double.MaxValue>就會擲回<xref:System.OverflowException>，如下列範例所示。  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 如果出現在分隔符號`s`參數在剖析作業中，在適用的貨幣或十進位數字期間及群組分隔符號相同，則剖析作業會假設分隔符號是小數分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例是按鈕 click 事件處理常式的 Web 表單。 它會使用所傳回的陣列<xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType>屬性來判斷使用者的地區設定。 它接著會執行個體化<xref:System.Globalization.CultureInfo>對應至該地區設定物件。 <xref:System.Globalization.NumberFormatInfo>所屬的物件<xref:System.Globalization.CultureInfo>物件會傳遞至<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29>方法，將轉換使用者輸入的目標<xref:System.Double>值。  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不是格式有效的數字。</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> 代表小於 <see cref="F:System.Double.MinValue" /> 或大於 <see cref="F:System.Double.MaxValue" /> 的數字。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">在 .NET 中剖析數值字串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <param name="style">列舉值的位元組合，表示 <paramref name="s" /> 中可以存在的樣式項目。 要指定的一般值為 <see cref="F:System.Globalization.NumberStyles.Float" /> 和 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的組合。</param>
        <param name="provider">物件，提供關於 <paramref name="s" /> 的特定文化特性格式資訊。</param>
        <summary>使用指定樣式和特定文化特性格式，將數字的字串表示轉換為其相等的雙精確度浮點數。</summary>
        <returns>雙精確度浮點數，與 <paramref name="s" /> 中指定的數值或符號相等。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`參數定義的樣式項目 (例如空格、 千分位分隔符號和貨幣符號) 中允許`s`剖析作業成功的參數。 它必須是從位元旗標的組合<xref:System.Globalization.NumberStyles>列舉型別。 下列<xref:System.Globalization.NumberStyles>不支援的成員：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`參數可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>，或<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>所指定的文化特性`provider`。 值而定`style`，它也可以採用格式：  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 在方括號 （[和]） 是選用項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的泛空白字元。 空白字元可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標，也可以顯示在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。|  
|$|特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>目前文化特性的屬性。 目前的文化特性的貨幣符號會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。|  
|*簽署*|負號符號 （-） 或正號符號 （+）。 符號可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，也可以顯示在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 可用於括號`s`表示負值`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。|  
|*integral-digits*|一系列數字範圍從 0 到 9 的指定數目的整數部分。 *整數位數*項目可以是若字串包含*小數位數*項目。|  
|,|特定文化特性的群組分隔符號。 目前的文化特性的群組分隔符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標|  
|。|特定文化特性的貨幣符號。 目前的文化特性的貨幣符號會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|*fractional-digits*|一系列數字範圍從 0 到 9 的指定數字的小數部分。 小數點後數字可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|E|"E"或者"E"字元，表示代表的值時，會以指數 （科學記號） 標記法。 `s`參數可代表指數標記法之數字，如果`style`包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*exponential-digits*|一系列的範圍從 0 到 9 指定指數的數字。|  
  
> [!NOTE]
> 中的任何終止 NUL (u+0000) 字元`s`剖析作業中，不論值會忽略`style`引數。

 只有數字的字串 (對應至<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>樣式) 一律會成功剖析。 其餘<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成員控制可能存在，但不是一定要出現在輸入字串的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>旗標會影響可能會出現在項目`s`。  
  
|NumberStyles 值|中的項目允許`s`除了數字|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整數位數*只有項目。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小數點 (*。*) 和*小數位數*項目。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或者"E"字元，這表示指數標記法。 這個旗標本身支援值形式*數字*E*數字*; 其他旗標才能成功剖析項目像是正或負號和小數點符號的字串。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*號*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*號*結尾的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*號*括號括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|千分位分隔符號 （，） 項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|貨幣 （$） 的項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有項目。 不過，`s`無法表示十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*元素的開頭或結尾`s`，*登*開頭`s`，且小數點 （.） 的符號。 `s`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千分位 （，） 符號和小數點 （.） 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有項目。 不過，`s`無法代表十六進位數字。|  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性的資訊用於解譯的格式`s`。 一般來說，這是<xref:System.Globalization.NumberFormatInfo>或<xref:System.Globalization.CultureInfo>物件。 如果`provider`已`null`或<xref:System.Globalization.NumberFormatInfo>無法取得，格式設定資訊會使用目前的系統文化特性。  
  
 一般情況下，如果您傳遞<xref:System.Double.Parse%2A?displayProperty=nameWithType>字串，由呼叫的方法<xref:System.Double.ToString%2A?displayProperty=nameWithType>方法中，原始<xref:System.Double>會傳回值。 不過，因為遺失有效位數，值可能不會相等。 此外，嘗試剖析的字串表示法<xref:System.Double.MinValue>或是<xref:System.Double.MaxValue>就會擲回<xref:System.OverflowException>，如下列範例所示。  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 如果出現在分隔符號`s`參數在剖析作業中，在適用的貨幣或十進位數字期間及群組分隔符號相同，則剖析作業會假設分隔符號是小數分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法，以指派的溫度值的多個字串表示`Temperature`物件。  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不代表數字。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
-或- 
 <paramref name="style" /> 是 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> 代表小於 <see cref="F:System.Double.MinValue" /> 或大於 <see cref="F:System.Double.MaxValue" /> 的數字。</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">在 .NET 中剖析數值字串</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>表示正無限大。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個常數的值是正數除以零的結果。  
  
 大於運算的結果時，會傳回這個常數<xref:System.Double.MaxValue>。  
  
 使用<xref:System.Double.IsPositiveInfinity%2A>來判斷值是否計算結果為正無限大。  
  
   
  
## Examples  
 下列程式碼範例示範如何將<xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</summary>
        <returns>如果目前執行個體的值不是零，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Byte" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>不支援這個轉換。 嘗試使用這個方法會擲回 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>不支援這個轉換。 沒有傳回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情況下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>不支援這個轉換。 嘗試使用這個方法會擲回 <see cref="T:System.InvalidCastException" /></summary>
        <returns>不支援這個轉換。 沒有傳回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情況下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Decimal" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，未變更。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Int16" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Int32" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Int64" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.SByte" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.Single" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Double" /> 值轉換所得的類型。</param>
        <param name="provider"><see cref="T:System.IFormatProvider" /> 實作，提供傳回值格式的相關特定文化特性資訊。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <paramref name="type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫`static`(`Shared` Visual Basic 中)<xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.UInt16" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.UInt32" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">這個參數已忽略。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</summary>
        <returns>目前執行個體的值，轉換為 <see cref="T:System.UInt64" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Double> 執行個體轉換成 <xref:System.IConvertible> 介面時，才能使用這個成員。 建議的替代做法是呼叫<xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將這個執行個體的數值轉換為它的相等字串表示。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將這個執行個體的數值轉換為它的相等字串表示。</summary>
        <returns>這個執行個體值的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString>方法格式<xref:System.Double>值預設值 （"G"或一般） 目前的文化特性的格式。 如果您想要指定不同的格式、 有效位數或文化特性，使用的其他多載<xref:System.Double.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用多載|  
|-------------------|-----------------|----------------------|  
|預設值 ("G") 格式|特定文化特性|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定的格式或有效位數|預設值 （目前） 的文化特性|<xref:System.Double.ToString%28System.String%29>|  
|特定的格式或有效位數|特定文化特性|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 傳回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或格式的字串：  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 選擇性的項目包覆在方括號 （[和]）。 包含詞彙 「 數字 」 的項目是由一系列的範圍從 0 到 9 的數字字元所組成。 支援下表列出的項目。  
  
|元素|描述|  
|-------------|-----------------|  
|*簽署*|負號或正號。|  
|*integral-digits*|一系列數字指定數目的整數部分。 整數數字，可不存在有小數位數。|  
|'*.*'|特定文化特性的貨幣符號。|  
|*fractional-digits*|指定數字之小數點後的數字。|  
|'*e*'|小寫字元 'e'，表示指數 （科學記號） 標記法。|  
|*exponential-digits*|一系列指定指數的數字。|  
  
 傳回值的一些範例包括"100"、"-123,456,789"，"123.45 e + 6"、"500"、"3.1416"、"600"、"-0.123"和"-Infinity"。  
  
 .NET Framework 會提供廣泛的格式化支援，這會在下列格式化主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需有關格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
   
  
## Examples  
 下列範例會使用預設值<xref:System.Double.ToString?displayProperty=nameWithType>方法，以顯示的數字的字串表示<xref:System.Double>值。  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 下列範例示範如何將<xref:System.Double.ToString%2A>。  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>使用指定的特定文化特性格式資訊，將這個執行個體的數值轉換成它的相等字串表示。</summary>
        <returns>這個執行個體值的字串表示，如同 <paramref name="provider" /> 所指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.IFormatProvider%29>方法格式<xref:System.Double>值預設值 （"G"或一般） 中指定的文化特性的格式。 如果您想要指定不同的格式或文化特性，使用的其他多載<xref:System.Double.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用多載|  
|-------------------|-----------------|----------------------|  
|預設值 ("G") 格式|預設值 （目前）|<xref:System.Double.ToString>|  
|特定的格式或有效位數|預設值 （目前） 的文化特性|<xref:System.Double.ToString%28System.String%29>|  
|特定的格式或有效位數|特定文化特性|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 傳回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或格式的字串：  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 選擇性的項目包覆在方括號 （[和]）。 包含詞彙 「 數字 」 的項目是由一系列的範圍從 0 到 9 的數字字元所組成。 支援下表列出的項目。  
  
|元素|描述|  
|-------------|-----------------|  
|*簽署*|負號或正號。|  
|*integral-digits*|一系列數字指定數目的整數部分。 整數數字，可不存在有小數位數。|  
|'*.*'|特定文化特性的貨幣符號。|  
|*fractional-digits*|指定數字之小數點後的數字。|  
|'*e*'|小寫字元 'e'，表示指數 （科學記號） 標記法。|  
|*exponential-digits*|一系列指定指數的數字。|  
  
 傳回值的一些範例包括"100"、"-123,456,789"，"123.45 e + 6"、"500"、"3.1416"、"600"、"-0.123"和"-Infinity"。  
  
 這個執行個體是以一般的數值格式規範 ("G") 格式。  
  
 .NET Framework 會提供廣泛的格式化支援，這會在下列格式化主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需有關格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件。 通常`provider`已<xref:System.Globalization.CultureInfo>物件或<xref:System.Globalization.NumberFormatInfo>物件。 `provider`參數提供格式化使用的特定文化特性資訊。 如果`provider`已`null`，傳回值的格式使用<xref:System.Globalization.NumberFormatInfo>目前的文化特性的物件。  
  
   
  
## Examples  
 下列範例顯示兩個的字串表示法<xref:System.Double>值使用<xref:System.Globalization.CultureInfo>代表數個不同的文化特性的物件。  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 下列範例示範如何將<xref:System.Double.ToString%2A>、 正在接受<xref:System.String>和<xref:System.IFormatProvider>做為參數。  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">數值格式字串。</param>
        <summary>使用指定格式，將這個執行個體的數值轉換成它的相等字串表示。</summary>
        <returns>這個執行個體值的字串表示，如同 <paramref name="format" /> 所指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%29>方法格式<xref:System.Double>值中指定的格式，使用目前的文化特性的慣例。 如果您想要指定不同的格式或文化特性，使用的其他多載<xref:System.Double.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用多載|  
|-------------------|-----------------|----------------------|  
|預設值 ("G") 格式|預設值 （目前） 的文化特性|<xref:System.Double.ToString>|  
|預設值 ("G") 格式|特定文化特性|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定的格式或有效位數|特定文化特性|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 傳回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或數字，所指定的字串表示`format`。  
  
 `format`參數可以是任何有效的標準數值格式規範，除了 D 和 X，以及自訂數值格式規範的任何組合。 如果`format`是`null`或空字串，傳回的值會格式化為有一般的數值格式規範 ("G")。  
  
 .NET Framework 會提供廣泛的格式化支援，這會在下列格式化主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需有關格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 根據預設，傳回的值只包含 15 個位數的精確度雖然內部維護最多 17 個位數。 如果這個執行個體的值必須大於 15 位數，<xref:System.Double.ToString%2A>會傳回<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>或<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>而不是預期的數目。 如果您需要更多有效位數時，指定`format`"G17"格式規格，它一定會傳回 17 個位數的有效位數或"R"，它會傳回 15 位數如果數目可以使用 17 位數來表示，如果只能是數字表示使用最大有效位數。  
  
   
  
## Examples  
 下列範例會定義數字的值和其格式化為貨幣值，藉由使用"C"標準數值格式字串和數值到三個小數位數為使用"N"標準數值格式字串。 使用 EN-US 文化特性的慣例格式化的結果字串。 如需有關數值格式字串的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 下列範例會顯示數個<xref:System.Double>使用支援標準數值格式規範，以及三個自訂數值格式字串值。 這些自訂格式字串的其中一個說明如何將填補<xref:System.Single>加上前置零的值。 此外，此範例會使用有效位數規範，與每個標準格式規範，除了"R"。 有效位數規範範圍從 0 到 3 的值。 若要將數字的值轉換成字串，此範例會使用 EN-US 文化特性的格式化慣例。  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。</exception>
        <block subset="none" type="usage"><para>在某些情況下，使用 "R" 標準數值格式字串格式化的 <see cref="T:System.Double" /> 值，如果使用 <see langword="/platform:x64" /> 或 <see langword="/platform:anycpu" /> 參數編譯並在 64 位元系統上執行，則不會成功地反覆存取。 若要解決這個問題，您可以使用 "G17" 標準數值格式字串來格式化 <see cref="T:System.Double" /> 值。 下列範例使用 "R" 格式字串，搭配不會成功反覆存取的 <see cref="T:System.Double" /> 值，並且也會使用 "G17" 格式字串來成功反覆存取原始值。  
  
[!code-csharp[System.Double.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)] [!code-vb[System.Double.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">如何：以前置字元零來填補數字</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">數值格式字串。</param>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>使用指定的格式和特定文化特性格式資訊，將這個執行個體的數值轉換成它的相等字串表示。</summary>
        <returns>這個執行個體值的字串表示，如同 <paramref name="format" /> 和 <paramref name="provider" /> 所指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>方法格式<xref:System.Double>中指定的格式，指定文化特性值。 如果您想要指定不同的格式或文化特性，使用的其他多載<xref:System.Double.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用多載|  
|-------------------|-----------------|----------------------|  
|預設值 ("G") 格式|預設值 （目前） 的文化特性|<xref:System.Double.ToString>|  
|預設值 ("G") 格式|特定文化特性|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定的格式或有效位數|預設值 （目前） 的文化特性|<xref:System.Double.ToString%28System.String%29>|  
  
 傳回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或數字，所指定的字串表示`format`。  
  
 `format`參數可以是任何有效的標準數值格式規範，除了 D 和 X，以及自訂數值格式規範的任何組合。 如果`format`是`null`或空字串，這個執行個體的傳回值會格式化為有一般的數值格式規範 ("G")。  
  
 .NET Framework 會提供廣泛的格式化支援，這會在下列格式化主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需有關格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件。 通常`provider`已<xref:System.Globalization.CultureInfo>物件或<xref:System.Globalization.NumberFormatInfo>物件。 `provider`參數提供格式化使用的特定文化特性資訊。 如果`provider`已`null`，傳回值的格式使用<xref:System.Globalization.NumberFormatInfo>目前的文化特性的物件。  
  
 根據預設，傳回的值只包含 15 個位數的精確度雖然內部維護最多 17 個位數。 如果這個執行個體的值必須大於 15 位數，<xref:System.Double.ToString%2A>會傳回<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>或<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>而不是預期的數目。 如果您需要更多有效位數時，指定`format`"G17"格式規格，它一定會傳回 17 個位數的有效位數或"R"，它會傳回 15 位數如果數目可以使用 17 位數來表示，如果只能是數字表示使用最大有效位數。  
  
   
  
## Examples  
 下列範例會顯示<xref:System.Double>值使用每個支援標準數值格式規範的數個不同的文化特性。  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 下列範例示範如何將<xref:System.Double.ToString%2A>、 正在接受<xref:System.String>和<xref:System.IFormatProvider>做為參數。  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>在某些情況下，使用 "R" 標準數值格式字串格式化的 <see cref="T:System.Double" /> 值，如果使用 <see langword="/platform:x64" /> 或 <see langword="/platform:anycpu" /> 參數編譯並在 64 位元系統上執行，則不會成功地反覆存取。 若要解決這個問題，您可以使用 "G17" 標準數值格式字串來格式化 <see cref="T:System.Double" /> 值。 下列範例使用 "R" 格式字串，搭配不會成功反覆存取的 <see cref="T:System.Double" /> 值，並且也會使用 "G17" 格式字串來成功反覆存取原始值。  
  
[!code-csharp[System.Double.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)] [!code-vb[System.Double.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">如何：以前置字元零來填補數字</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">範例：.NET Framework 4 格式化公用程式</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將數字的字串表示轉換為其相等的雙精確度浮點數。 傳回值會指出轉換成功或失敗。</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <param name="result">如果轉換成功，這個方法傳回時會包含相當於 <paramref name="s" /> 參數的雙精確度浮點數，如果轉換失敗則為零。 如果 <paramref name="s" /> 參數為 <see langword="null" /> 或 <see cref="F:System.String.Empty" />、不是有效格式的數字，或者代表小於 <see cref="F:System.Double.MinValue" /> 或大於 <see cref="F:System.Double.MaxValue" /> 的數字，這項轉換就會失敗。 這個參數未初始化便傳遞，<paramref name="result" /> 中原始提供的任何值都將遭到覆寫。</param>
        <summary>將數字的字串表示轉換為其相等的雙精確度浮點數。 傳回值會指出轉換成功或失敗。</summary>
        <returns>如果 <see langword="true" /> 轉換成功，則為 <paramref name="s" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載不同於<xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType>藉由傳回布林值，指出是否剖析作業成功而不是傳回的已剖析的數字值的方法。 它就不需要使用例外狀況處理來測試<xref:System.FormatException>萬一`s`無效，無法成功剖析。  
  
 `s`參數可以包含目前的文化特性<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> （則字串比較是區分大小寫），或格式的字串：  
  
 [ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的泛空白字元。|  
|*簽署*|負號或正號。|  
|*integral-digits*|一連串的數字的字元範圍從 0 到 9 的指定數目的整數部分。 整數數字，可不存在有小數位數。|  
|*、*|特定文化特性的群組分隔符號。|  
|*.*|特定文化特性的貨幣符號。|  
|*fractional-digits*|一連串的範圍從 0 到 9 的指定數字的小數部分的數字字元。|  
|*E*|大寫或小寫字元 'e'，表示指數 （科學記號） 標記法。|  
|*exponential-digits*|一連串的範圍從 0 到 9 指定指數的數字字元。|  
  
 如需有關數值格式的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 `s`參數使用的組合來解譯<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。 這表示泛空白字元和千位分隔符號允許但不是貨幣符號。 若要明確定義的項目 (例如貨幣符號、 千位分隔符號，以及空白字元) 就會出現在`s`，使用<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType>方法多載。  
  
 `s`參數會剖析使用的格式設定資訊中<xref:System.Globalization.NumberFormatInfo>初始化目前系統文化特性的物件。 如需詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。 若要將字串剖析使用一些其他的格式設定資訊指定文化特性，請使用<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType>方法多載。  
  
 一般情況下，如果您傳遞<xref:System.Double.TryParse%2A?displayProperty=nameWithType>字串，由呼叫的方法<xref:System.Double.ToString%2A?displayProperty=nameWithType>方法中，原始<xref:System.Double>會傳回值。 不過，因為遺失有效位數，值可能不會相等。 此外，嘗試剖析的字串表示法<xref:System.Double.MinValue>或是<xref:System.Double.MaxValue>就會擲回<xref:System.OverflowException>，如下列範例所示。  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 如果出現在分隔符號`s`期間在剖析作業中和十進位和群組分隔符號的參數都相同，則剖析作業會假設分隔符號是小數分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29>方法，將數值的字串表示轉換<xref:System.Double>值。 它會假設該 EN-US 是目前的文化特性。  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">在 .NET 中剖析數值字串</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">範例：.NET Framework 4 格式化公用程式</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要轉換的數字。</param>
        <param name="style"><see cref="T:System.Globalization.NumberStyles" /> 值的位元組合，表示 <paramref name="s" /> 的允許格式。 要指定的一般值為 <see cref="F:System.Globalization.NumberStyles.Float" /> 和 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的組合。</param>
        <param name="provider"><see cref="T:System.IFormatProvider" />，提供 <paramref name="s" /> 的相關特定文化特性格式資訊。</param>
        <param name="result">當此方法傳回時，若轉換成功，包含相當於 <paramref name="s" /> 中包含之數值或符號的雙精確度浮點數；若轉換失敗，則為零。 轉換失敗的狀況包括：如果 <paramref name="s" /> 參數是 <see langword="null" /> 或 <see cref="F:System.String.Empty" />、不是符合 <paramref name="style" /> 的格式、代表小於 <see cref="F:System.SByte.MinValue" /> 或大於 <see cref="F:System.SByte.MaxValue" /> 的數字，或 <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 列舉常數的有效組合。 這個參數未初始化便傳遞，<paramref name="result" /> 中原始提供的任何值都將遭到覆寫。</param>
        <summary>使用指定樣式和特定文化特性格式，將數字的字串表示轉換為其相等的雙精確度浮點數。 傳回值會指出轉換成功或失敗。</summary>
        <returns>如果 <see langword="true" /> 轉換成功，則為 <paramref name="s" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.TryParse%2A>方法就像<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法，但是這個方法不會擲回例外狀況如果轉換失敗。 如果轉換成功，傳回的值是`true`而`result`參數設定為轉換的結果。 如果轉換失敗，傳回的值是`false`而`result`參數設為零。 這就不需要使用例外狀況處理來測試<xref:System.FormatException>萬一`s`無效，無法成功剖析。  
  
 `style`參數會定義允許的格式的`s`剖析作業成功的參數。 它必須是從位元旗標的組合<xref:System.Globalization.NumberStyles>列舉型別。 下列<xref:System.Globalization.NumberStyles>不支援的成員：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s`參數可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>，或<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>所指定的文化特性`provider`。 此外，根據的值`style`，則`s`參數可能包括下列項目：  
  
 [ws] [$] [sign][integral-digits,]integral-digits[.fractional-digits][e[sign]exponential-digits][ws]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|選擇性的泛空白字元。 空白字元可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標。 它可以出現在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。|  
|*$*|特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>或是<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>的屬性<xref:System.Globalization.NumberFormatInfo>所傳回的物件<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>方法`provider`參數。 貨幣符號會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。|  
|*簽署*|選擇性正負號。 符號可以出現在開頭`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，也可以顯示在結尾`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 可用於括號`s`表示負值`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。|  
|*integral-digits*|一系列數字範圍從 0 到 9 的指定數目的整數部分。 整數數字，可不存在有小數位數。|  
|*、*|特定文化特性的千位分隔符號。 目前的文化特性的千分位分隔符號可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。|  
|*.*|特定文化特性的貨幣符號。 目前的文化特性的貨幣符號會出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|*fractional-digits*|一系列數字範圍從 0 到 9 的指定數字的小數部分。 小數點後數字可以出現在`s`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|*e*|E 或 E 字元，表示`s`可以代表使用指數標記法的數字。 `s`參數可代表指數標記法之數字，如果樣式包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*exponential-digits*|一系列的範圍從 0 到 9 指定指數的數字。|  
  
> [!NOTE]
> 中的任何終止 NUL (u+0000) 字元`s`剖析作業中，不論值會忽略`style`引數。

 只有數字的字串 (對應至<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>樣式) 一律會成功剖析。 其餘<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成員控制可能，但不是一定要出現在輸入字串的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>旗標會影響可能會出現在項目`s`。  
  
|NumberStyles 值|允許 s 除了數字中的項目|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整數位數*只有項目。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* 並*小數位數*項目。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s`參數也可以使用指數標記法。 這個旗標本身支援值形式*整數位數*E*指數數字*; 其他旗標才能成功剖析字串以使用這類項目，做為指數標記法正或負號和小數點符號。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*號*開頭的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*號*結尾的項目`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*號*括號括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*，* 項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|*$* 項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|全部。 `s`參數不能代表十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*元素的開頭或結尾`s`，*登*開頭`s`，和 *。* 符號。 `s`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千分位分隔符號 (*，)，* 和 小數位數 (*。*) 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有的樣式，除了`s`無法代表十六進位數字。|  
  
 `provider`參數是<xref:System.IFormatProvider>實作，例如<xref:System.Globalization.NumberFormatInfo>或<xref:System.Globalization.CultureInfo>物件。 `provider`參數提供用於剖析的特定文化特性資訊。 如果`provider`已`null`或<xref:System.Globalization.NumberFormatInfo>無法取得物件，會使用目前文化特性格式資訊。  
  
 如果轉換會失敗`s`參數是`null`或非數值的值，`provider`參數不會產生<xref:System.Globalization.NumberFormatInfo>物件，或有`style`參數不是從位元旗標的組合<xref:System.Globalization.NumberStyles>列舉型別。  
  
 一般情況下，如果您傳遞<xref:System.Double.TryParse%2A?displayProperty=nameWithType>字串，由呼叫的方法<xref:System.Double.ToString%2A?displayProperty=nameWithType>方法中，原始<xref:System.Double>會傳回值。 不過，因為遺失有效位數，值可能不會相等。 此外，嘗試剖析的字串表示法<xref:System.Double.MinValue>或是<xref:System.Double.MaxValue>就會擲回<xref:System.OverflowException>，如下列範例所示。  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 如果出現在分隔符號`s`參數在剖析作業中，在適用的貨幣或十進位數字期間及群組分隔符號相同，則剖析作業會假設分隔符號是小數分隔符號，而不是群組分隔符號。 如需分隔符號的詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType>方法來剖析具有特定樣式，並使用特定文化特性的慣例格式化的數字的字串表示。  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
-或- 
 <paramref name="style" /> 包含 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">在 .NET 中剖析數值字串</related>
      </Docs>
    </Member>
  </Members>
</Type>