<Type Name="Module" FullName="System.Reflection.Module">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7e44325ef5b3af5671d9bd28885d3d54eef547d6" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52384415" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Module = class&#xA;    interface ISerializable&#xA;    interface ICustomAttributeProvider&#xA;    interface _Module" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>在模組上執行反映。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 模組是可攜式的可執行檔，諸如 type.dll 或 application.exe，其中包含一或多個類別和介面。 多個命名空間可能包含在單一模組中，並且命名空間可以擴展多個模組。  
  
 已部署為一個單元的一個或多個模組會組成組件。 使用多個模組建立組件的詳細資訊，請參閱[多檔案組件](~/docs/framework/app-domains/multifile-assemblies.md)。  
  
 請注意，.NET Framework 模組不程式設計人員用來組織函式和副程式的應用程式中的 Visual Basic 中的模組相同。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用反映來取得模組的相關資訊：  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">針對繼承者完全信任。 這個類別無法繼承由部分信任的程式碼。</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Reflection.Module" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會由衍生類別叫用的建構期間<xref:System.Reflection.Module>物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Module.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 <see cref="T:System.Reflection.Assembly" /> 執行個體的合適 <see cref="T:System.Reflection.Module" />。</summary>
        <value>
          <see langword="Assembly" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示所指定模組中指定的組件的完整名稱。  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Module.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含此模組之自訂屬性的集合。</summary>
        <value>包含此模組之自訂屬性的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="module.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">與這個執行個體相互比較的物件。</param>
        <summary>判斷這個模組和指定的物件是否相等。</summary>
        <returns>如果 <see langword="true" /> 等於這個執行個體則為 <paramref name="o" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterTypeName : System.Reflection.TypeFilter" Usage="System.Reflection.Module.FilterTypeName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="TypeFilter" /> 物件，其會根據名稱來篩選此模組中定義的類型清單。 這個欄位會區分大小寫且為唯讀狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 篩選器可讓您支援尾端"*"萬用字元。  
  
   
  
## Examples  
 下列範例會顯示符合指定的搜尋準則的模組名稱。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterTypeNameIgnoreCase : System.Reflection.TypeFilter" Usage="System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="TypeFilter" /> 物件，其會根據名稱來篩選此模組中定義的類型清單。 這個欄位是不區分大小寫且為唯讀狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 篩選器可讓您支援尾端"*"萬用字元。  
  
   
  
## Examples  
 下列範例會顯示符合指定的搜尋條件，忽略大小寫的模組名稱。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindTypes : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindTypes : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="module.FindTypes (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">用來篩選類別的委派。</param>
        <param name="filterCriteria">用來篩選類別的物件。</param>
        <summary>傳回指定篩選器和篩選準則所接受的類別陣列。</summary>
        <returns>類型 <see langword="Type" /> 的陣列，其中包含篩選器所接受的類別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ReflectionTypeLoadException> 是特殊類別載入例外狀況。 `ReflectionTypeLoadException.Types`屬性包含的模組中所定義，且已載入類別之陣列。 這個陣列可包含部分 null 值。 `ReflectionTypeLoadException.LoaderExceptions`屬性為陣列，代表類別載入器擲回的例外狀況的例外狀況。 類別陣列漏洞產品有例外狀況。  
  
 所指定的委派`filter`會呼叫每個類別，在模組中，傳遞`Type`物件，表示類別，以及指定`filterCriteria`。 如果`filter`傳回特定類別，該類別將會包含在傳回的陣列。 如果`filter`會傳回`null`，會傳回所有類別和`filterCriteria`會被忽略。  
  
 `FindTypes` 不能用於查詢參數化的型別，例如陣列。  
  
   
  
## Examples  
 下列範例示範`FindTypes`方法。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">無法載入模組中的一或多個類別。</exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedName : string" Usage="System.Reflection.Module.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示這個模組完整名稱和路徑的字串。</summary>
        <value>完整的模組名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得不含路徑名稱，請使用<xref:System.Reflection.Module.Name%2A>。  
  
 如果此模組的組件是從位元組陣列載入然後`FullyQualifiedName`模組將會：\<不明 >。  
  
> [!NOTE]
>  模組名稱的大小寫會平台而異。  
  
   
  
## Examples  
 下列範例會顯示指定的模組完整的名稱。  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑中的資訊。 關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回自訂屬性 (Attribute)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="module.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>傳回所有自訂屬性。</summary>
        <returns>
          <see langword="Object" /> 型別的陣列，包含所有自訂屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示符合指定的搜尋準則的模組名稱。  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="module.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">要取得的屬性型別。</param>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>取得指定型別的自訂屬性。</summary>
        <returns>
          <see langword="Object" /> 型別的陣列，包含指定型別的所有自訂屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示符合指定的搜尋準則的模組名稱的指定的型別。  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> 不是執行階段所提供的 <see cref="T:System.Type" /> 物件。 例如，<paramref name="attributeType" /> 是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="module.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前模組的 <see cref="T:System.Reflection.CustomAttributeData" /> 物件清單，這些物件可用於僅限反映的內容中。</summary>
        <returns>
          <see cref="T:System.Reflection.CustomAttributeData" /> 物件的泛型清單，表示已套用至目前模組之屬性的資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要檢查的自訂屬性中僅限反映的內容，在其中已載入至僅限反映內容的程式碼中定義的自訂屬性本身的情況下的程式碼中使用這個方法。 這類方法<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>和<xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType>不能在這種情況下，因為它們會產生屬性的執行個體。 無法執行僅限反映內容中的程式碼。 如需詳細資訊和範例程式碼，請參閱<xref:System.Reflection.CustomAttributeData>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定的欄位。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="module.GetField name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">欄位名稱。</param>
        <summary>傳回具有指定名稱的欄位。</summary>
        <returns>具有指定名稱的 <see langword="FieldInfo" /> 物件，或者，如果欄位不存在，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="module.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">欄位名稱。</param>
        <param name="bindingAttr">其中一個 <see langword="BindingFlags" /> 位元旗標，用來控制搜尋。</param>
        <summary>傳回具有指定名稱和繫結屬性的欄位。</summary>
        <returns>具有指定名稱和繫結屬性的 <see langword="FieldInfo" /> 物件，或者，如果欄位不存在，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回模組中定義的全域欄位。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="module.GetFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回模組中定義的全域欄位。</summary>
        <returns>
          <see cref="T:System.Reflection.FieldInfo" /> 物件的陣列，代表模組中定義的全域欄位；如果沒有全域欄位，則會傳回空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Module.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於欄位會傳回的順序，由於該順序可能有所不同。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="module.GetFields bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">限制搜尋範圍之 <see cref="T:System.Reflection.BindingFlags" /> 值的位元組合。</param>
        <summary>傳回定義於模組上且符合指定繫結旗標的全域欄位。</summary>
        <returns>類型 <see cref="T:System.Reflection.FieldInfo" /> 的陣列，代表定義於模組上且符合指定繫結旗標的全域欄位；如果沒有任何全域欄位符合繫結旗標，即會傳回空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Module.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序或依宣告順序。 您的程式碼不得相依於欄位會傳回的順序，由於該順序可能有所不同。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="module.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個執行個體的雜湊碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回方法，具有指定準則。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">方法名稱。</param>
        <summary>傳回具有指定名稱的方法。</summary>
        <returns>具有指定名稱的 <see langword="MethodInfo" /> 物件，或者，如果方法不存在，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">方法名稱。</param>
        <param name="types">要搜尋的參數類型。</param>
        <summary>傳回具有指定名稱及參數類型的方法。</summary>
        <returns>符合指定準則的 <see langword="MethodInfo" /> 物件；若方法不存在，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />；<paramref name="types" /> 為 <see langword="null" />；或 <paramref name="types" /> (i) 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">方法名稱。</param>
        <param name="bindingAttr">其中一個 <see langword="BindingFlags" /> 位元旗標，用來控制搜尋。</param>
        <param name="binder">該物件會實作 <see langword="Binder" />，其中包含與此方法相關的屬性。</param>
        <param name="callConvention">方法的呼叫慣例。</param>
        <param name="types">要搜尋的參數類型。</param>
        <param name="modifiers">參數修飾詞的陣列，用來進行與參數簽章的繫結工作，其中該參數簽章的類別已修改。</param>
        <summary>傳回方法，該方法具有指定的名稱、繫結資訊、呼叫慣例和參數類型及修飾詞。</summary>
        <returns>符合指定準則的 <see langword="MethodInfo" /> 物件；若方法不存在，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />；<paramref name="types" /> 為 <see langword="null" />；或 <paramref name="types" /> (i) 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">方法名稱。</param>
        <param name="bindingAttr">其中一個 <see langword="BindingFlags" /> 位元旗標，用來控制搜尋。</param>
        <param name="binder">該物件會實作 <see langword="Binder" />，其中包含與此方法相關的屬性。</param>
        <param name="callConvention">方法的呼叫慣例。</param>
        <param name="types">要搜尋的參數類型。</param>
        <param name="modifiers">參數修飾詞的陣列，用來進行與參數簽章的繫結工作，其中該參數簽章的類別已修改。</param>
        <summary>傳回方法實作，根據指定準則。</summary>
        <returns>
          <see langword="MethodInfo" /> 物件，包含所指定的實作資訊；如果方法不存在，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <paramref name="types" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回在模組上定義的全域方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="module.GetMethods " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回模組中定義的全域方法。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> 物件的陣列，代表模組中定義的所有全域方法；如果沒有全域方法，則會傳回空陣列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="module.GetMethods bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">限制搜尋範圍之 <see cref="T:System.Reflection.BindingFlags" /> 值的位元組合。</param>
        <summary>傳回定義於模組上且符合指定繫結旗標的全域方法。</summary>
        <returns>類型 <see cref="T:System.Reflection.MethodInfo" /> 的陣列，代表定義於模組上且符合指定繫結旗標的全域方法；如果沒有任何全域方法符合繫結旗標，即會傳回空陣列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="module.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">序列化或還原序列化物件所需的資訊和資料。</param>
        <param name="context">序列化的內容。</param>
        <summary>提供序列化物件的 <see cref="T:System.Runtime.Serialization.ISerializable" /> 實作。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberSignature Language="F#" Value="abstract member GetPEKind :  *  -&gt; unit&#xA;override this.GetPEKind :  *  -&gt; unit" Usage="module.GetPEKind (peKind, machine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">這個方法會傳回 <see cref="T:System.Reflection.PortableExecutableKinds" /> 值的組合，表示模組中的程式碼性質。</param>
        <param name="machine">這個方法會傳回其中一個 <see cref="T:System.Reflection.ImageFileMachine" /> 值，表示模組的目標平台。</param>
        <summary>取得值組，表示模組中的程式碼性質，以及模組的目標平台。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberSignature Language="F#" Value="abstract member GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate&#xA;override this.GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate" Usage="module.GetSignerCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see langword="X509Certificate" /> 物件，對應到這個模組所屬之組件的 Authenticode 簽章中所包含的憑證。 如果組件還未經 Authenticode 簽名，則傳回 <see langword="null" />。</summary>
        <returns>
          <see langword="X509Certificate" /> 物件；如果這個模組所屬的組件還未經 Authenticode 簽名，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定的型別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="module.GetType className" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">要尋找的類型名稱。 名稱必須是命名空間的完整名稱。</param>
        <summary>執行區分大小寫的搜尋，傳回指定的類型。</summary>
        <returns>
          <see langword="Type" /> 物件，如果指定的類型位於此模組中，則代表該類型；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果類型已轉送至另一個組件，它仍會傳回這個方法。 類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 型別可以擷取從特定模組使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>。 呼叫<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>於模組上且包含資訊清單不會搜尋整個組件。 若要擷取類型從組件，不論哪一個模組是在中，您必須呼叫<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會顯示所指定模組中的型別名稱。  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用了類別初始設定式，並擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> 是零長度字串。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="className" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="className" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="className" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="className" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="module.GetType (className, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">要尋找的類型名稱。 名稱必須是命名空間的完整名稱。</param>
        <param name="ignoreCase">
          <see langword="true" /> 以進行不區分大小寫的搜尋；否則為 <see langword="false" />。</param>
        <summary>傳回指定的類型，使用指定的大小寫搜尋模組。</summary>
        <returns>
          <see langword="Type" /> 物件，如果指定的類型位於此模組中，則代表該類型；否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果類型已轉送至另一個組件，它仍會傳回這個方法。 類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 型別可以擷取從特定模組使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>。 呼叫<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>於模組上且包含資訊清單不會搜尋整個組件。 若要擷取類型從組件，不論哪一個模組是在中，您必須呼叫<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例顯示類型的名稱在指定的模組中，指定`false`針對`ignoreCase`參數，因此不會忽略這種情況。  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用了類別初始設定式，並擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> 是零長度字串。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="className" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="className" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="className" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="className" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="module.GetType (className, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">要尋找的類型名稱。 名稱必須是命名空間的完整名稱。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。</param>
        <param name="ignoreCase">
          <see langword="true" /> 以進行不區分大小寫的搜尋；否則為 <see langword="false" />。</param>
        <summary>傳回指定的型別，並指定是否要對模組進行區分大小寫的搜尋，以及是否要在找不到型別時擲回例外狀況。</summary>
        <returns>如果在這個模組中宣告型別，則為表示指定之型別的 <see cref="T:System.Type" /> 物件，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `throwOnError`參數會影響只會發生什麼事時找不到類型。 它不會影響其他可能會擲回的例外狀況。 特別是，如果找到的型別，但無法載入，<xref:System.TypeLoadException>可能會擲回即使`throwOnError`是`false`。  
  
> [!NOTE]
>  如果類型已轉送至另一個組件，它仍會傳回這個方法。 類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 型別可以擷取從特定模組使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>。 呼叫<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>於模組上且包含資訊清單不會搜尋整個組件。 若要擷取類型從組件，不論哪一個模組是在中，您必須呼叫<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會顯示所指定模組中的型別名稱。 `throwOnError`並`ignoreCase`參數指定為`false`。  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用了類別初始設定式，並擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> 是零長度字串。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="className" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="className" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="className" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="className" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="module.GetTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回此模組中定義的所有類型。</summary>
        <returns>類型 <see langword="Type" /> 的陣列，其中包含這個執行個體所反映之模組中定義的類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException` 是特殊的負載的例外狀況。 `ReflectionTypeLoadException.Types`屬性包含的模組中所定義，以及已載入的型別陣列。 這個陣列可包含部分 null 值。 `ReflectionTypeLoadException.LoaderExceptions`屬性為陣列，代表載入器擲回的例外狀況的例外狀況。 類別陣列漏洞產品有例外狀況。  
  
 例如，如果其中一個類別的類別初始設定式擲回例外狀況，它載入時，`TargetInvocationException`中的對應項目會儲存`LoaderExceptions`陣列。  
  
> [!NOTE]
>  如果類型已轉送至另一個組件，它不包含傳回陣列中。 類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">無法載入模組中的一或多個類別。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">在目前模組的反映權限。</permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="module.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">所要測試之自訂屬性的型別。</param>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>傳回值，這個值表示指定的屬性型別是否已套用至此模組。</summary>
        <returns>如果一個或多個 <paramref name="attributeType" /> 的執行個體已套用至這個模組，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範使用`IsDefined`方法。  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> 不是執行階段所提供的 <see cref="T:System.Type" /> 物件。 例如，<paramref name="attributeType" /> 是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberSignature Language="F#" Value="abstract member IsResource : unit -&gt; bool&#xA;override this.IsResource : unit -&gt; bool" Usage="module.IsResource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得值，指出物件是否為資源。</summary>
        <returns>如果物件為資源，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範使用`IsResource`方法。  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MDStreamVersion : int" Usage="System.Reflection.Module.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得中繼資料流的版本。</summary>
        <value>32 位元的整數，表示中繼資料流的版本。 高順序的兩位元表示主要的版本號碼，而低順序的兩位元則表示次要的版本號碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需有關中繼資料標頭的詳細資訊，請參閱 Common Language Infrastructure (CLI) 文件中的"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.Module.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得語彙基元，可識別中繼資料中的模組。</summary>
        <value>整數語彙基元，可識別中繼資料中的目前模組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性取得的權杖可以傳遞至 unmanaged 反映 API。 如需詳細資訊，請參閱 < [Unmanaged 反映 API](https://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleHandle : ModuleHandle" Usage="System.Reflection.Module.ModuleHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得模組的控制代碼。</summary>
        <value>目前模組的 <see cref="T:System.ModuleHandle" /> 結構。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleVersionId : Guid" Usage="System.Reflection.Module.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可用來區別兩個模組版本的全域唯一識別碼 (UUID)。</summary>
        <value>
          <see cref="T:System.Guid" />，可用來區別兩個模組版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由，在未受管理的中繼資料，傳回的 GUID<xref:System.Reflection.Module.ModuleVersionId%2A>屬性指`mvid`，而且會儲存在 GUID 堆積。  
  
> [!NOTE]
>  Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 > 中，可以找到中繼資料的詳細資訊。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Module.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see langword="String" />，表示路徑已移除的模組名稱。</summary>
        <value>沒有路徑的模組名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Name` 是一個平台相依的字串。  
  
 如果此模組的組件是從位元組陣列載入然後`FullyQualifiedName`模組將會：\<不明 >。  
  
 若要取得的名稱和路徑，請使用<xref:System.Reflection.Module.FullyQualifiedName%2A>。  
  
   
  
## Examples  
 此範例中顯示的效果`ScopeName`， `FullyQualifiedName`，和`Name`屬性。  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Module * System.Reflection.Module -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個物件。</param>
        <param name="right">要比較的第二個物件。</param>
        <summary>表示兩個 <see cref="T:System.Reflection.Module" /> 物件是否相等。</summary>
        <returns>如果 <see langword="true" /> 等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Module * System.Reflection.Module -&gt; bool" Usage="System.Reflection.Module.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個物件。</param>
        <param name="right">要比較的第二個物件。</param>
        <summary>表示兩個 <see cref="T:System.Reflection.Module" /> 物件是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回中繼資料語彙基元所識別的欄位。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveField : int -&gt; System.Reflection.FieldInfo" Usage="module.ResolveField metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內欄位的中繼資料語彙基元。</param>
        <summary>傳回指定之中繼資料語彙基元所識別的欄位。</summary>
        <returns>
          <see cref="T:System.Reflection.FieldInfo" /> 物件，表示指定之中繼資料語彙基元所識別的欄位。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要解決的父代的識別欄位的中繼資料語彙基元`TypeSpec`具有簽章包含項目型別`ELEMENT_TYPE_VAR`或是`ELEMENT_TYPE_MVAR`，使用<xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法多載，可讓您提供必要的內容。 也就是當您正在解決的欄位，取決於泛型型別和 （或） 權杖會內嵌的泛型方法的泛型類型參數的中繼資料語彙基元，您必須使用可讓您提供這些型別參數的多載。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組範圍中不是欄位的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 可識別欄位，而此欄位的父代 <see langword="TypeSpec" /> 具有包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數) 的簽章。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo&#xA;override this.ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo" Usage="module.ResolveField (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內欄位的中繼資料語彙基元。</param>
        <param name="genericTypeArguments">
          <see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之型別的泛型型別引數，如果該型別不是泛型，則為 <see langword="null" />。</param>
        <param name="genericMethodArguments">
          <see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之方法的泛型型別引數，如果該方法不是泛型，則為 <see langword="null" />。</param>
        <summary>以指定之泛型型別參數所定義的內容，傳回指定之中繼資料語彙基元所識別的欄位。</summary>
        <returns>
          <see cref="T:System.Reflection.FieldInfo" /> 物件，表示指定之中繼資料語彙基元所識別的欄位。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型別上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 使用<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 您總是安全地提供這些引數，即使不需要它們。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組範圍中不是欄位的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 可識別欄位，而此欄位的父代 <see langword="TypeSpec" /> 具有包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)，且未提供 <paramref name="genericTypeArguments" /> 和 <paramref name="genericMethodArguments" /> 其一或兩者的必要泛型型別引數。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回中繼資料語彙基元所識別的型別或成員。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveMember : int -&gt; System.Reflection.MemberInfo" Usage="module.ResolveMember metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內型別或成員的中繼資料語彙基元。</param>
        <summary>傳回指定之中繼資料語彙基元所識別的型別或成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件，表示指定之中繼資料語彙基元所識別的型別或成員。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要解決的中繼資料語彙基元`MethodSpec`或是`TypeSpec`其簽章包含項目型別`ELEMENT_TYPE_VAR`或`ELEMENT_TYPE_MVAR`，使用<xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法多載，可讓您提供必要的內容。 也就是當您的成員取決於泛型型別和 （或） 權杖會內嵌的泛型方法的泛型類型參數，解析中繼資料語彙基元，您必須使用可讓您提供這些型別參數的多載。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組的範圍中不是型別或成員的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="MethodSpec" /> 或 <see langword="TypeSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的可別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)。  
  
-或- 
 <paramref name="metadataToken" /> 識別屬性或事件。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo&#xA;override this.ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo" Usage="module.ResolveMember (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內型別或成員的中繼資料語彙基元。</param>
        <param name="genericTypeArguments">
          <see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之型別的泛型型別引數，如果該型別不是泛型，則為 <see langword="null" />。</param>
        <param name="genericMethodArguments">
          <see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之方法的泛型型別引數，如果該方法不是泛型，則為 <see langword="null" />。</param>
        <summary>以指定之泛型型別參數所定義的內容，傳回指定之中繼資料語彙基元所識別的型別或成員。</summary>
        <returns>
          <see cref="T:System.Reflection.MemberInfo" /> 物件，表示指定之中繼資料語彙基元所識別的型別或成員。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型別上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 使用<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 您總是安全地提供這些引數，即使不需要它們。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組的範圍中不是型別或成員的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="MethodSpec" /> 或 <see langword="TypeSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)，且未提供 <paramref name="genericTypeArguments" /> 和 <paramref name="genericMethodArguments" /> 其一或兩者的必要泛型型別引數。  
  
-或- 
 <paramref name="metadataToken" /> 識別屬性或事件。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回中繼資料語彙基元所識別的方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveMethod : int -&gt; System.Reflection.MethodBase" Usage="module.ResolveMethod metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內方法或建構函式的中繼資料語彙基元。</param>
        <summary>傳回指定之中繼資料語彙基元所識別的方法或建構函式。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodBase" /> 物件，表示指定之中繼資料語彙基元所識別的方法或建構函式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要解決的中繼資料語彙基元`MethodSpec`其簽章包含項目型別`ELEMENT_TYPE_VAR`或是`ELEMENT_TYPE_MVAR`，使用<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法多載，可讓您提供必要的內容。 也就是說，當您正在解決的方法，取決於泛型類型的泛型類型參數及/或權杖會內嵌的泛型方法的中繼資料語彙基元，您必須使用可讓您提供這些型別參數的多載。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
   
  
## Examples  
 下列範例示範如何使用兩個多載<xref:System.Reflection.Module.ResolveMethod%2A>泛型和非泛型的內容中的方法來解析中繼資料語彙基元，從呼叫站台。  
  
 此程式碼範例會定義兩個泛型型別，`G1<Tg1>`並`G2<Tg2>`(`G1(Of Tg1)`和`G2(Of Tg2)`Visual Basic 中)，每個都有泛型方法。 `G1<Tg1>` 也有 使用類型參數 přepisuje neobecnou metodu`Tg1`其參數。 泛型方法`GM2<Tgm2>`型別中`G2<Tg2>`包含數個方法呼叫：  
  
-   案例 1： 泛型方法`GM1<Tgm1>`呼叫時，使用的類型參數`G2<Tg2>`和`GM2<Tgm2>`做為型別引數。 換句話說，呼叫方法的參數型別取決於用來建構封閉式的泛型型別中的類型定義的型別`G2<Tg2>`。  
  
-   案例 2: Přepisuje neobecnou metodu`M1`呼叫。 會使用定義的類型，類型參數，此方法的參數`G1<Tg1>`，這由封入類型，型別參數在此情況下取代`G2<Tg2>`。  
  
-   案例 3： 泛型方法`GM1<Tgm1>`呼叫時，指定<xref:System.Int32>和<xref:System.Object>的型別引數的泛型型別和泛型的方法，分別。 這個方法呼叫不會相依於封入型別或方法的型別參數。  
  
-   案例 4: Přepisuje neobecnou metodu`M1`的`Example`類別稱為。 這個方法呼叫不會相依於封入型別或方法的型別參數。  
  
 此外，此範例會定義非泛型`Example`類別。 此類別具有方法`M`，它會呼叫泛型方法：  
  
-   案例 5： 泛型方法`GM1`呼叫時，指定<xref:System.Int32>和<xref:System.Object>的型別引數的泛型型別和泛型的方法，分別。 這個方法的內容有沒有封入泛型類型或泛型方法。  
  
 針對每個案例中，此範例先建構<xref:System.Reflection.MethodInfo>表示所呼叫的方法，然後會將權杖使用解析<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法多載，使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>並<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法，以取得的值`genericTypeArguments`和`genericMethodArguments`參數。 這項技術的運作方式在所有情況下，因為方法會傳回<xref:System.Type.EmptyTypes?displayProperty=nameWithType>非泛型內容。 這個範例會比較已解析<xref:System.Reflection.MethodInfo>與建構<xref:System.Reflection.MethodInfo>。  
  
 此範例會嘗試使用<xref:System.Reflection.Module.ResolveMethod%28System.Int32%29>方法多載來解析權杖。 這是在 3、 4 和 5 的情況下，因為方法呼叫不相依於一般的內容。 在 1 和 2 的情況下，因為資訊不足，無法解析語彙基元，會擲回例外狀況。  
  
 中繼資料語彙基元的值為硬式編碼為列舉型別。 如果您變更此程式碼範例，語彙基元的值可能會變更。 若要判斷新的權杖值，編譯程式碼，並使用與 Ildasm.exe **/權杖**來檢查組件的選項。 語彙基元位於呼叫點。 將新的值插入至列舉型別，並重新編譯範例。  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組的範圍中不是方法或建構函式的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="MethodSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase&#xA;override this.ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase" Usage="module.ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內方法或建構函式的中繼資料語彙基元。</param>
        <param name="genericTypeArguments">
          <see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之型別的泛型型別引數，如果該型別不是泛型，則為 <see langword="null" />。</param>
        <param name="genericMethodArguments">
          <see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之方法的泛型型別引數，如果該方法不是泛型，則為 <see langword="null" />。</param>
        <summary>以指定之泛型型別參數所定義的內容，傳回指定之中繼資料語彙基元所識別的方法或建構函式。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodBase" /> 物件，表示指定之中繼資料語彙基元所識別的方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型別上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 使用<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericMethodArguments`。 您總是安全地提供這些引數，即使不需要它們。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
   
  
## Examples  
 下列範例示範如何使用兩個多載<xref:System.Reflection.Module.ResolveMethod%2A>泛型和非泛型的內容中的方法來解析中繼資料語彙基元，從呼叫站台。  
  
 此程式碼範例會定義兩個泛型型別，`G1<Tg1>`和`G2<Tg2>`，每個都有泛型方法。 `G1<Tg1>` 也有 使用類型參數 přepisuje neobecnou metodu`Tg1`其參數。 泛型方法`GM2<Tgm2>`型別中`G2<Tg2>`包含數個方法呼叫：  
  
-   案例 1： 泛型方法`GM1<Tgm1>`呼叫時，使用的類型參數`G2<Tg2>`和`GM2<Tgm2>`做為型別引數。 換句話說，呼叫方法的參數型別取決於用來建構封閉式的泛型型別中的類型定義的型別`G2<Tg2>`。  
  
-   案例 2: Přepisuje neobecnou metodu`M1`呼叫。 會使用定義的類型，類型參數，此方法的參數`G1<Tg1>`，這由封入類型，型別參數在此情況下取代`G2<Tg2>`。  
  
-   案例 3： 泛型方法`GM1<Tgm1>`呼叫時，指定<xref:System.Int32>和<xref:System.Object>的型別引數的泛型型別和泛型的方法，分別。 這個方法呼叫不會相依於封入型別或方法的型別參數。  
  
-   案例 4: Přepisuje neobecnou metodu`M1`的`Example`類別稱為。 這個方法呼叫不會相依於封入型別或方法的型別參數。  
  
 此外，此範例會定義非泛型`Example`類別。 此類別具有方法`M`，它會呼叫泛型方法。  
  
-   案例 5： 泛型方法`GM1<Tgm1>`呼叫時，指定<xref:System.Int32>和<xref:System.Object>的型別引數的泛型型別和泛型的方法，分別。 這個方法的內容有沒有封入泛型類型或泛型方法。  
  
 針對每個案例中，此範例先建構<xref:System.Reflection.MethodInfo>表示所呼叫的方法，然後會將權杖使用解析<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法多載，使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>並<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法，以取得的值`genericTypeArguments`和`genericMethodArguments`參數。 這項技術的運作方式在所有情況下，因為方法會傳回<xref:System.Type.EmptyTypes?displayProperty=nameWithType>非泛型內容。 這個範例會比較已解析<xref:System.Reflection.MethodInfo>與建構<xref:System.Reflection.MethodInfo>。  
  
 此範例會嘗試使用<xref:System.Reflection.Module.ResolveMethod%28System.Int32%29>方法多載來解析權杖。 這是在 3、 4 和 5 的情況下，因為方法呼叫不相依於一般的內容。 在 1 和 2 的情況下，因為資訊不足，無法解析語彙基元，會擲回例外狀況。  
  
 中繼資料語彙基元的值為硬式編碼為列舉型別。 如果您變更此程式碼範例，語彙基元的值可能會變更。 若要判斷新的權杖值，編譯程式碼，並使用與 Ildasm.exe **/權杖**來檢查組件的選項。 語彙基元位於呼叫點。 將新的值插入至列舉型別，並重新編譯範例。  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組的範圍中不是方法或建構函式的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="MethodSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)，且未提供 <paramref name="genericTypeArguments" /> 和 <paramref name="genericMethodArguments" /> 其一或兩者的泛型型別引數。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberSignature Language="F#" Value="abstract member ResolveSignature : int -&gt; byte[]&#xA;override this.ResolveSignature : int -&gt; byte[]" Usage="module.ResolveSignature metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內簽章的中繼資料語彙基元。</param>
        <summary>傳回中繼資料語彙基元所識別的簽章 Blob (二進位大型物件)。</summary>
        <returns>位元組的陣列，表示簽章 Blob。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  中繼資料語彙基元和簽章的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" />在目前模組的範圍中不是有效的 <see langword="MemberRef" />、<see langword="MethodDef" />、<see langword="TypeSpec" />、簽章或 <see langword="FieldDef" /> 語彙基元。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberSignature Language="F#" Value="abstract member ResolveString : int -&gt; string&#xA;override this.ResolveString : int -&gt; string" Usage="module.ResolveString metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">中繼資料語彙基元，可識別模組字串堆積中的字串。</param>
        <summary>傳回指定之中繼資料語彙基元所識別的字串。</summary>
        <returns>
          <see cref="T:System.String" />，包含中繼資料字串堆積中的字串值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組範圍中不是字串的語彙基元。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回中繼資料語彙基元所識別的型別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveType : int -&gt; Type" Usage="module.ResolveType metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內型別的中繼資料語彙基元。</param>
        <summary>傳回指定之中繼資料語彙基元所識別的型別。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，表示指定之中繼資料語彙基元所識別的型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要解決的中繼資料語彙基元`TypeSpec`其簽章包含`ELEMENT_TYPE_VAR`或是`ELEMENT_TYPE_MVAR`，使用<xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法多載，可讓您提供必要的內容。 也就是當您正在解決取決於泛型型別和 （或） 權杖會內嵌的泛型方法的泛型類型參數的型別中繼資料語彙基元，您必須使用可讓您提供這些型別參數的多載。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組的範圍中不是型別的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="TypeSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveType : int * Type[] * Type[] -&gt; Type&#xA;override this.ResolveType : int * Type[] * Type[] -&gt; Type" Usage="module.ResolveType (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內型別的中繼資料語彙基元。</param>
        <param name="genericTypeArguments">
          <see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之型別的泛型型別引數，如果該型別不是泛型，則為 <see langword="null" />。</param>
        <param name="genericMethodArguments">
          <see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之方法的泛型型別引數，如果該方法不是泛型，則為 <see langword="null" />。</param>
        <summary>以指定之泛型型別參數所定義的內容，傳回指定之中繼資料語彙基元所識別的型別。</summary>
        <returns>
          <see cref="T:System.Type" /> 物件，表示指定之中繼資料語彙基元所識別的型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型別上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 使用<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 您總是安全地提供這些引數，即使不需要它們。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 在目前模組的範圍中不是型別的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="TypeSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)，且未提供 <paramref name="genericTypeArguments" /> 和 <paramref name="genericMethodArguments" /> 其一或兩者的泛型型別引數。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScopeName : string" Usage="System.Reflection.Module.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示模組名稱的字串。</summary>
        <value>模組名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ScopeName`屬性不是由 common language runtime，但您可以使用它來儲存您想要的任何字串屬性中，當您發出模組使用的中繼資料 Api。 反映本身不允許您設定`ScopeName`屬性。  
  
   
  
## Examples  
 此範例中顯示的效果`ScopeName`， `FullyQualifiedName`，和`Name`屬性。  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應之傳入的名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，用於接收對應於名稱的 ID。</param>
        <summary>將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的類型資訊。</param>
        <param name="lcid">類型資訊的地區設定識別項。</param>
        <param name="ppTInfo">接收要求的類型資訊物件的指標。</param>
        <summary>擷取物件的類型資訊，可以用來取得介面的類型資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向接收物件提供的類型資訊介面數目的位置。</param>
        <summary>擷取物件提供的類型資訊介面數目 (0 或 1)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">辨識成員。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">結構的指標，此結構包含引數陣列、指名引數之 DispID 引數的陣列，以及陣列中項目數目的計數。</param>
        <param name="pVarResult">指向用於儲存結果之位置的指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊的結構指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>提供物件所公開的屬性和方法的存取權。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="module.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回模組名稱。</summary>
        <returns>表示這個模組名稱的 <see langword="String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範使用`ToString`方法。  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>