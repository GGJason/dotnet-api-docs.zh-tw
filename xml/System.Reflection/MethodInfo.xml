<Type Name="MethodInfo" FullName="System.Reflection.MethodInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fa0b21a34b53587ae25eeb6bf4e5a92373ec47ef" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55377942" /></Metadata><TypeSignature Language="C#" Value="public abstract class MethodInfo : System.Reflection.MethodBase, System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodInfo extends System.Reflection.MethodBase implements class System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodInfo&#xA;Inherits MethodBase&#xA;Implements _MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodInfo abstract : System::Reflection::MethodBase, System::Runtime::InteropServices::_MethodInfo" />
  <TypeSignature Language="F#" Value="type MethodInfo = class&#xA;    inherit MethodBase&#xA;    interface _MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodInfo))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a7423-101">探索方法的屬性 (Attribute) 並提供方法中繼資料 (Metadata) 的存取。</span><span class="sxs-lookup"><span data-stu-id="a7423-101">Discovers the attributes of a method and provides access to method metadata.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-102"><xref:System.Reflection.MethodInfo>類別代表類型的方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-102">The <xref:System.Reflection.MethodInfo> class represents a method of a type.</span></span> <span data-ttu-id="a7423-103">您可以使用<xref:System.Reflection.MethodInfo>物件取得該物件所代表之方法的相關資訊，並叫用方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-103">You can use a <xref:System.Reflection.MethodInfo> object to obtain information about the method that the object represents and to invoke the method.</span></span> <span data-ttu-id="a7423-104">例如：</span><span class="sxs-lookup"><span data-stu-id="a7423-104">For example:</span></span>  
  
-   <span data-ttu-id="a7423-105">您可以藉由擷取的值來判斷方法的可視性<xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>， <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>， <xref:System.Reflection.MethodBase.IsPrivate%2A>，和<xref:System.Reflection.MethodBase.IsPublic%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-105">You can determine the method's visibility by retrieving the values of the <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, <xref:System.Reflection.MethodBase.IsPrivate%2A>, and <xref:System.Reflection.MethodBase.IsPublic%2A> properties.</span></span>  
  
-   <span data-ttu-id="a7423-106">您可以探索哪些屬性會套用至方法所擷取的值<xref:System.Reflection.MethodBase.Attributes%2A>屬性或呼叫<xref:System.Reflection.Assembly.GetCustomAttributes%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-106">You can discover what attributes are applied to the method by retrieving the value of the <xref:System.Reflection.MethodBase.Attributes%2A> property or calling the <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method.</span></span>  
  
-   <span data-ttu-id="a7423-107">您可以判斷是否該方法是泛型方法、 開啟建構的泛型方法，或封閉式建構泛型方法，擷取的值<xref:System.Reflection.MethodBase.IsGenericMethod%2A>和<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-107">You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> and <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> properties.</span></span>  
  
-   <span data-ttu-id="a7423-108">您可以取得該方法之參數的相關資訊，並傳回類型從<xref:System.Reflection.MethodBase.GetParameters%2A>方法和<xref:System.Reflection.MethodInfo.ReturnParameter%2A>， <xref:System.Reflection.MethodInfo.ReturnType%2A>，和<xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-108">You can get information about the method's parameters and return type from the <xref:System.Reflection.MethodBase.GetParameters%2A> method and the <xref:System.Reflection.MethodInfo.ReturnParameter%2A>, <xref:System.Reflection.MethodInfo.ReturnType%2A>, and <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> properties.</span></span>  
  
-   <span data-ttu-id="a7423-109">您可以針對類別執行個體執行方法，藉由呼叫<xref:System.Reflection.MethodBase.Invoke%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-109">You can execute a method on a class instance by calling the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span>  
  
-   <span data-ttu-id="a7423-110">您可以具現化<xref:System.Reflection.MethodInfo>物件，表示建構的泛型方法的其中一個代表泛型方法定義，藉由呼叫<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-110">You can instantiate a <xref:System.Reflection.MethodInfo> object that represents a constructed generic method from one that represents a generic method definition by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 <span data-ttu-id="a7423-111">您可以具現化<xref:System.Reflection.MethodInfo>藉由呼叫的執行個體<xref:System.Type.GetMethods%2A?displayProperty=nameWithType>或是<xref:System.Type.GetMethod%2A?displayProperty=nameWithType>方法，或藉由呼叫<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.MethodInfo>物件，代表泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-111">You can instantiate a <xref:System.Reflection.MethodInfo> instances by calling the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> or <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> method, or by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
 <span data-ttu-id="a7423-112">如需泛型的方法特定的恆成立條件，請參閱<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-112">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="a7423-113">如需泛型反映中所使用的其他詞彙的非變異條件的清單，請參閱<xref:System.Type.IsGenericType%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-113">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="a7423-114">針對繼承者完全信任。</span><span class="sxs-lookup"><span data-stu-id="a7423-114">for full trust for inheritors.</span></span> <span data-ttu-id="a7423-115">這個類別無法繼承由部分信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="a7423-115">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="a7423-116">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="a7423-116">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="a7423-117">當您繼承自<see cref="T:System.Reflection.MethodInfo" />，您必須覆寫<see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />， <see cref="P:System.Reflection.MethodInfo.ReturnType" />， <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />， <see cref="M:System.Reflection.MethodBase.GetParameters" />， <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />， <see cref="P:System.Reflection.MethodBase.MethodHandle" />， <see cref="P:System.Reflection.MethodBase.Attributes" />， <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />， <see cref="P:System.Reflection.MemberInfo.Name" />， <see cref="P:System.Reflection.MemberInfo.MemberType" />， <see cref="P:System.Reflection.MemberInfo.DeclaringType" />， <see cref="P:System.Reflection.MemberInfo.ReflectedType" />， <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />， <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />，和<see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-117">When you inherit from <see cref="T:System.Reflection.MethodInfo" />, you must override <see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />, <see cref="P:System.Reflection.MethodInfo.ReturnType" />, <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />, <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span></span></para></block>
    <altmember cref="Overload:System.Type.GetMethods" />
    <altmember cref="Overload:System.Type.GetMethod" />
    <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7423-118">初始化 <see cref="T:System.Reflection.MethodInfo" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a7423-118">Initializes a new instance of the <see cref="T:System.Reflection.MethodInfo" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7423-119">從這個方法建立委派。</span><span class="sxs-lookup"><span data-stu-id="a7423-119">Creates a delegate from this method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDelegate : Type -&gt; Delegate&#xA;override this.CreateDelegate : Type -&gt; Delegate" Usage="methodInfo.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a7423-120">要建立之委派的類型。</span><span class="sxs-lookup"><span data-stu-id="a7423-120">The type of the delegate to create.</span></span></param>
        <summary><span data-ttu-id="a7423-121">從這個方法建立所指定類型的委派。</span><span class="sxs-lookup"><span data-stu-id="a7423-121">Creates a delegate of the specified type from this method.</span></span></summary>
        <returns><span data-ttu-id="a7423-122">這個方法的委派。</span><span class="sxs-lookup"><span data-stu-id="a7423-122">The delegate for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="abstract member CreateDelegate : Type * obj -&gt; Delegate&#xA;override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="methodInfo.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="a7423-123">要建立之委派的類型。</span><span class="sxs-lookup"><span data-stu-id="a7423-123">The type of the delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="a7423-124">委派的目標物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-124">The object targeted by the delegate.</span></span></param>
        <summary><span data-ttu-id="a7423-125">從這個方法以指定的目標建立所指定類型的委派。</span><span class="sxs-lookup"><span data-stu-id="a7423-125">Creates a delegate of the specified type with the specified target from this method.</span></span></summary>
        <returns><span data-ttu-id="a7423-126">這個方法的委派。</span><span class="sxs-lookup"><span data-stu-id="a7423-126">The delegate for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a7423-127">與這個執行個體相比較的物件，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-127">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="a7423-128">傳回值，這個值指出此執行個體是否與指定的物件相等。</span><span class="sxs-lookup"><span data-stu-id="a7423-128">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="a7423-129">如果 <see langword="true" /> 和這個執行個體具有相同的類型和值，則為 <paramref name="obj" />否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-129"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodInfo.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetBaseDefinition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7423-130">在衍生類別中覆寫時，為直接或間接基底類別 (也就是這個執行個體所代表的方法第一次被宣告的地方) 中的方法傳回 <see cref="T:System.Reflection.MethodInfo" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-130">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodInfo" /> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</span></span></summary>
        <returns><span data-ttu-id="a7423-131">這個方法首次實作的 <see cref="T:System.Reflection.MethodInfo" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-131">A <see cref="T:System.Reflection.MethodInfo" /> object for the first implementation of this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-132"><xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法會傳回指定之方法的第一個定義類別階層架構中。</span><span class="sxs-lookup"><span data-stu-id="a7423-132">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the first definition of the specified method in the class hierarchy.</span></span> <span data-ttu-id="a7423-133">您可以判斷在其之方法的第一個定義尋找所擷取的值之型別的<xref:System.Reflection.MemberInfo.DeclaringType%2A>屬性傳回的<xref:System.Reflection.MethodInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-133">You can determine the type on which the first definition of the method is found by retrieving the value of the <xref:System.Reflection.MemberInfo.DeclaringType%2A> property on the returned <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="a7423-134"><xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法的行為，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a7423-134">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method behaves as follows:</span></span>  
  
-   <span data-ttu-id="a7423-135">如果目前<xref:System.Reflection.MethodInfo>物件都代表介面實作，<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法會傳回目前<xref:System.Reflection.MethodInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-135">If the current <xref:System.Reflection.MethodInfo> object represents an interface implementation, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="a7423-136">如果目前<xref:System.Reflection.MethodInfo>物件表示的方法，會覆寫虛擬基底類別，定義<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法會傳回<xref:System.Reflection.MethodInfo>物件，表示虛擬的定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-136">If the current <xref:System.Reflection.MethodInfo> object represents a method that overrides a virtual definition in a base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the virtual definition.</span></span>  
  
-   <span data-ttu-id="a7423-137">如果目前<xref:System.Reflection.MethodInfo>物件表示指定的方法`new`C# 關鍵字或`Shadows`關鍵字在 Visual Basic 中的 (依照`newslot`所述，在[一般型別系統](~/docs/standard/base-types/common-type-system.md))， <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法會傳回目前<xref:System.Reflection.MethodInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-137">If the current <xref:System.Reflection.MethodInfo> object represents a method that is specified with the `new` keyword in C# or the `Shadows` keyword in Visual Basic (as in `newslot`, as described in [Common Type System](~/docs/standard/base-types/common-type-system.md)), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="a7423-138">如果目前<xref:System.Reflection.MethodInfo>物件都代表繼承的方法 （也就是目前的方法不會提供它自己的實作），<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法會傳回<xref:System.Reflection.MethodInfo>物件，表示在類別階層中最低的方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-138">If the current <xref:System.Reflection.MethodInfo> object represents an inherited method (that is, the current method does not provide its own implementation), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the lowest method in the class hierarchy.</span></span> <span data-ttu-id="a7423-139">比方說，如果`Base.ToString`會覆寫`Object.ToString`，並`Derived.ToString`覆寫`Base.ToString`，則呼叫<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法<xref:System.Reflection.MethodInfo>物件，表示`Derived.ToString`傳回<xref:System.Reflection.MethodInfo>物件，表示`Object.ToString`.</span><span class="sxs-lookup"><span data-stu-id="a7423-139">For example, if `Base.ToString` overrides `Object.ToString`, and `Derived.ToString` overrides `Base.ToString`, calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method on a <xref:System.Reflection.MethodInfo> object that represents `Derived.ToString` returns a <xref:System.Reflection.MethodInfo> object that represents `Object.ToString`.</span></span>  
  
-   <span data-ttu-id="a7423-140">如果目前<xref:System.Reflection.MethodInfo>物件表示的方法，不存在於任何基底類別<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法會傳回目前<xref:System.Reflection.MethodInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-140">If the current <xref:System.Reflection.MethodInfo> object represents a method that is not present in any base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="a7423-141">您可以判斷是否目前的方法覆寫基底類別中的方法呼叫<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-141">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span> <span data-ttu-id="a7423-142">下列範例會實作`IsOverride`作法的方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-142">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
 <span data-ttu-id="a7423-143">若要呼叫`GetBaseDefinition`方法：</span><span class="sxs-lookup"><span data-stu-id="a7423-143">To call the `GetBaseDefinition` method:</span></span>  
  
1.  <span data-ttu-id="a7423-144">取得<xref:System.Type>物件，表示包含屬性的型別 （類別或結構）。</span><span class="sxs-lookup"><span data-stu-id="a7423-144">Get a <xref:System.Type> object that represents the type (the class or structure) that contains the property.</span></span> <span data-ttu-id="a7423-145">如果您正在使用的物件 （類型的執行個體），您可以呼叫其<xref:System.Object.GetType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-145">If you are working with an object (an instance of a type), you can call its <xref:System.Object.GetType%2A> method.</span></span> <span data-ttu-id="a7423-146">否則，您可以使用 C# 運算子，或 Visual Basic 運算子，與範例說明。</span><span class="sxs-lookup"><span data-stu-id="a7423-146">Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</span></span>  
  
2.  <span data-ttu-id="a7423-147">取得<xref:System.Reflection.MethodInfo>物件，表示您想要的方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-147">Get a <xref:System.Reflection.MethodInfo> object that represents the method in which you're interested.</span></span> <span data-ttu-id="a7423-148">您可以藉由取得所有的方法，從陣列<xref:System.Type.GetMethods%2A?displayProperty=nameWithType>方法，然後逐一查看的項目陣列，或者您可以擷取<xref:System.Reflection.MethodInfo>物件，表示直接藉由呼叫的方法<xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType>方法並指定方法名稱。</span><span class="sxs-lookup"><span data-stu-id="a7423-148">You can do this by getting an array of all methods from the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> method and then iterating the elements in the array, or you can retrieve the <xref:System.Reflection.MethodInfo> object that represents the method directly by calling the <xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType> method and specifying the method name.</span></span>  
  
3.  <span data-ttu-id="a7423-149">呼叫<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法來取得的值<xref:System.Reflection.MethodInfo>代表基底方法定義的物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-149">Call the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method to get the value of the <xref:System.Reflection.MethodInfo> object that represents the base method definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7423-150">下列範例示範的行為<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-150">The following example demonstrates the behavior of the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/getbasedefinition1.cs#1)]
 [!code-vb[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/getbasedefinition1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/53c57c96-83e1-4ee3-9543-9ac832671a89"><span data-ttu-id="a7423-151">一般類型系統</span><span class="sxs-lookup"><span data-stu-id="a7423-151">Common Type System</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodInfo.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7423-152">傳回 <see cref="T:System.Type" /> 物件的陣列，這些物件代表泛型方法的型別引數，或泛型方法定義的型別參數。</span><span class="sxs-lookup"><span data-stu-id="a7423-152">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span></summary>
        <returns><span data-ttu-id="a7423-153"><see cref="T:System.Type" /> 物件的陣列，這些物件代表泛型方法的類型引數，或泛型方法定義的類型參數。</span><span class="sxs-lookup"><span data-stu-id="a7423-153">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span> <span data-ttu-id="a7423-154">如果目前的方法不是泛型方法，則會傳回空白陣列。</span><span class="sxs-lookup"><span data-stu-id="a7423-154">Returns an empty array if the current method is not a generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-155">傳回陣列中的項目會以其出現在清單中的泛型方法的型別參數的順序。</span><span class="sxs-lookup"><span data-stu-id="a7423-155">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="a7423-156">如果目前的方法是封閉式的建構的方法 (亦即<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性會傳回`false`)，所傳回的陣列<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>方法包含已指派給泛型方法的泛型類型參數的型別定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-156">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="a7423-157">如果目前的方法是泛型方法定義，陣列會包含型別參數。</span><span class="sxs-lookup"><span data-stu-id="a7423-157">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="a7423-158">如果目前的方法是開啟的建構的方法 (亦即<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性會傳回`true`) 中某些型別參數和型別已指派特定類型的封入泛型類型參數已指派給其他類型參數，陣列會包含型別和型別參數。</span><span class="sxs-lookup"><span data-stu-id="a7423-158">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="a7423-159">使用<xref:System.Type.IsGenericParameter%2A>辨別這兩者的屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-159">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="a7423-160">如需示範此案例中，請參閱的程式碼範例<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-160">For a demonstration of this scenario, see the code example for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="a7423-161">如需泛型的方法特定的恆成立條件，請參閱<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-161">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="a7423-162">如需泛型反映中所使用的其他詞彙的非變異條件的清單，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-162">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
## Examples  
 <span data-ttu-id="a7423-163">下列程式碼範例示範如何取得泛型方法的類型引數，並顯示它們。</span><span class="sxs-lookup"><span data-stu-id="a7423-163">The following code example shows how to get the type arguments of a generic method and display them.</span></span>  
  
 <span data-ttu-id="a7423-164">這個範例是針對提供之較大範例的一部分<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-164">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#8](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#8)]
 [!code-csharp[MethodInfo.Generics#8](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#8)]
 [!code-vb[MethodInfo.Generics#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a7423-165">不支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-165">This method is not supported.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="a7423-166">反映和泛用類型</span><span class="sxs-lookup"><span data-stu-id="a7423-166">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="a7423-167">泛型簡介 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="a7423-167">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodInfo.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7423-168">傳回代表泛型方法定義的 <see cref="T:System.Reflection.MethodInfo" /> 物件，利用這個泛型方法定義就可以建構出目前的方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-168">Returns a <see cref="T:System.Reflection.MethodInfo" /> object that represents a generic method definition from which the current method can be constructed.</span></span></summary>
        <returns><span data-ttu-id="a7423-169">傳回代表泛型方法定義的 <see cref="T:System.Reflection.MethodInfo" /> 物件，利用這個泛型方法定義就可以建構出目前的方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-169">A <see cref="T:System.Reflection.MethodInfo" /> object representing a generic method definition from which the current method can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-170">泛型方法定義是可從中建構方法的範本。</span><span class="sxs-lookup"><span data-stu-id="a7423-170">A generic method definition is a template from which methods can be constructed.</span></span> <span data-ttu-id="a7423-171">例如，從泛型方法定義`T M<T>(T t)`（以 C# 語法;`Function M(Of T)(ByVal tVal As T) As T`在 Visual Basic 中) 您可以建構，並叫用方法`int M<int>(int t)`(`Function M(Of Integer)(ByVal tVal As Integer) As Integer` Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="a7423-171">For example, from the generic method definition `T M<T>(T t)` (expressed in C# syntax; `Function M(Of T)(ByVal tVal As T) As T` in Visual Basic) you can construct and invoke the method `int M<int>(int t)` (`Function M(Of Integer)(ByVal tVal As Integer) As Integer` in Visual Basic).</span></span> <span data-ttu-id="a7423-172">給定<xref:System.Reflection.MethodInfo>表示這個物件之建構方法，<xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A>方法會傳回泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-172">Given a <xref:System.Reflection.MethodInfo> object representing this constructed method, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the generic method definition.</span></span>  
  
 <span data-ttu-id="a7423-173">如果兩個建構的方法從相同的泛型方法定義中，建立<xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A>方法會傳回相同<xref:System.Reflection.MethodInfo>這兩種方法的物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-173">If two constructed methods are created from the same generic method definition, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the same <xref:System.Reflection.MethodInfo> object for both methods.</span></span>  
  
 <span data-ttu-id="a7423-174">如果您呼叫<xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A>上<xref:System.Reflection.MethodInfo>已經代表泛型方法定義，它會傳回目前<xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="a7423-174">If you call <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> on a <xref:System.Reflection.MethodInfo> that already represents a generic method definition, it returns the current <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="a7423-175">如果是泛型方法定義包含宣告型別的泛型參數，則會是泛型方法定義專屬於每個建構的類型。</span><span class="sxs-lookup"><span data-stu-id="a7423-175">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="a7423-176">例如，請考慮下列 C#、 Visual Basic 和 c + + 程式碼：</span><span class="sxs-lookup"><span data-stu-id="a7423-176">For example, consider the following C#, Visual Basic, and C++ code:</span></span>  
  
```  
class B<U,V> {}  
class C<T> { public B<T,S> M<S>() {...}}  
  
Class B(Of U, V)  
End Class  
Class C(Of T)  
    Public Function M(Of S)() As B(Of T, S)  
        ...  
    End Function  
End Class   
  
generic <typename U, typename V> ref class B {};  
generic <typename T> ref class C  
{  
public:  
    generic <typename S> B<T,S>^ M() {...};  
};  
```  
  
 <span data-ttu-id="a7423-177">在建構的型別`C<int>`(`C(Of Integer)` Visual Basic 中)，泛型方法`M`傳回`B<int, S>`。</span><span class="sxs-lookup"><span data-stu-id="a7423-177">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method `M` returns `B<int, S>`.</span></span> <span data-ttu-id="a7423-178">在開啟的型別`C<T>`，`M`傳回`B<T, S>`。</span><span class="sxs-lookup"><span data-stu-id="a7423-178">In the open type `C<T>`, `M` returns `B<T, S>`.</span></span> <span data-ttu-id="a7423-179">在這兩種情況下，<xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A>屬性會傳回`true`for<xref:System.Reflection.MethodInfo>表示`M`，因此<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>兩者都可呼叫<xref:System.Reflection.MethodInfo>物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-179">In both cases, the <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `true` for the <xref:System.Reflection.MethodInfo> that represents `M`, so <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> can be called on both <xref:System.Reflection.MethodInfo> objects.</span></span> <span data-ttu-id="a7423-180">在建構的型別，用來呼叫的情況下<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>是<xref:System.Reflection.MethodInfo>，可以叫用。</span><span class="sxs-lookup"><span data-stu-id="a7423-180">In the case of the constructed type, the result of calling <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> is a <xref:System.Reflection.MethodInfo> that can be invoked.</span></span> <span data-ttu-id="a7423-181">在開啟的型別的情況下<xref:System.Reflection.MethodInfo>所傳回<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>無法叫用。</span><span class="sxs-lookup"><span data-stu-id="a7423-181">In the case of the open type, the <xref:System.Reflection.MethodInfo> returned by <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> cannot be invoked.</span></span>  
  
 <span data-ttu-id="a7423-182">如需泛型的方法特定的恆成立條件，請參閱<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-182">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="a7423-183">如需泛型反映中所使用的其他詞彙的非變異條件的清單，請參閱<xref:System.Type.IsGenericType%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-183">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7423-184">下列程式碼範例顯示具有泛型方法，並取得所需的程式碼的類別<xref:System.Reflection.MethodInfo>方法中，繫結的方法類型引數，然後從繫結的方法取得原始的泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-184">The following code example shows a class with a generic method and the code required to obtain a <xref:System.Reflection.MethodInfo> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</span></span>  
  
 <span data-ttu-id="a7423-185">這個範例是針對提供之較大範例的一部分<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-185">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#2](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#2)]
 [!code-csharp[MethodInfo.Generics#2](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#2)]
 [!code-vb[MethodInfo.Generics#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#2)]  
[!code-cpp[MethodInfo.Generics#3](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#3)]
[!code-csharp[MethodInfo.Generics#3](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#3)]
[!code-vb[MethodInfo.Generics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#3)]  
[!code-cpp[MethodInfo.Generics#4](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#4)]
[!code-csharp[MethodInfo.Generics#4](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#4)]
[!code-vb[MethodInfo.Generics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a7423-186">目前的方法不是泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-186">The current method is not a generic method.</span></span> <span data-ttu-id="a7423-187">亦即，<see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> 會傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-187">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a7423-188">不支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-188">This method is not supported.</span></span></exception>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="a7423-189">反映和泛用類型</span><span class="sxs-lookup"><span data-stu-id="a7423-189">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="a7423-190">泛型簡介 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="a7423-190">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7423-191">傳回這個執行個體的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="a7423-191">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="a7423-192">32 位元帶正負號的整數雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="a7423-192">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * obj[] -&gt; obj" Usage="methodInfo.Invoke (obj, parameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="parameters">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodInfo.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7423-193">取得值，指出目前的方法是否為泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-193">Gets a value indicating whether the current method is a generic method.</span></span></summary>
        <value><span data-ttu-id="a7423-194">如果目前的方法是泛型方法，則為 true否則為 false。</span><span class="sxs-lookup"><span data-stu-id="a7423-194">true if the current method is a generic method; otherwise, false.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7423-195">取得值，表示目前的 <see cref="T:System.Reflection.MethodInfo" />是否代表泛型方法的定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-195">Gets a value indicating whether the current <see cref="T:System.Reflection.MethodInfo" /> represents the definition of a generic method.</span></span></summary>
        <value><span data-ttu-id="a7423-196">如果 <see cref="T:System.Reflection.MethodInfo" /> 物件代表泛型方法的定義，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-196"><see langword="true" /> if the <see cref="T:System.Reflection.MethodInfo" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="a7423-197">如果目前<xref:System.Reflection.MethodInfo>代表泛型方法定義，然後：</span><span class="sxs-lookup"><span data-stu-id="a7423-197">If the current <xref:System.Reflection.MethodInfo> represents a generic method definition, then:</span></span>

  - <span data-ttu-id="a7423-198">`IsGenericMethodDefinition` 會傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="a7423-198">`IsGenericMethodDefinition` returns `true`.</span></span>

  - <span data-ttu-id="a7423-199">每個<xref:System.Type>中所傳回的陣列物件<xref:System.Reflection.MethodInfo.GetGenericArguments>方法：</span><span class="sxs-lookup"><span data-stu-id="a7423-199">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments> method:</span></span>

      - <span data-ttu-id="a7423-200"><xref:System.Type.IsGenericParameter?displayProperty=nameWithType> 屬性會傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="a7423-200">The <xref:System.Type.IsGenericParameter?displayProperty=nameWithType> property returns `true`.</span></span>

      - <span data-ttu-id="a7423-201"><xref:System.Type.DeclaringMethod?displayProperty=nameWithType>會傳回目前<xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="a7423-201">The <xref:System.Type.DeclaringMethod?displayProperty=nameWithType> returns the current <xref:System.Reflection.MethodInfo>.</span></span>

      - <span data-ttu-id="a7423-202"><xref:System.Type.GenericParameterPosition?displayProperty=nameWithType>屬性是相同的位置<xref:System.Type>陣列中的物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-202">The <xref:System.Type.GenericParameterPosition?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>

<span data-ttu-id="a7423-203">使用`IsGenericMethodDefinition`屬性來判斷型別引數是否已指派給類型參數的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-203">Use the `IsGenericMethodDefinition` property to determine whether type arguments have been assigned to the type parameters of a generic method.</span></span> <span data-ttu-id="a7423-204">如果已指派型別引數，`IsGenericMethodDefinition`屬性傳回 false，即使某些類型引數是<xref:System.Type>代表封入類型的型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-204">If type arguments have been assigned, the `IsGenericMethodDefinition` property returns false even if some of the type arguments are <xref:System.Type> objects that represent type parameters of enclosing types.</span></span> <span data-ttu-id="a7423-205">例如，請考慮下列 C\#，Visual Basic 和 c + + 程式碼：</span><span class="sxs-lookup"><span data-stu-id="a7423-205">For example, consider the following C\#, Visual Basic, and C++ code:</span></span>

    ```cs
    class C
    {
        T N<T,U>(T t, U u) {...}
        public V M<V>(V v)
        {
            return N<V,int>(v, 42);
        }
    }
    ```

    ```vb
    Class C
        Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T
            ...
        End Function
        Public Function M(Of V)(ByVal va As V ) As V
            Return N(Of V, Integer)(va, 42)
        End Function
    End Class
    ```

    ```cpp
    ref class C
    {
    private:
        generic <typename T, typename U> T N(T t, U u) {...}
    public:
        generic <typename V> V M(V v)
        {
            return N<V, int>(v, 42);
        }
    };
    ```

<span data-ttu-id="a7423-206">M 方法主體包含 N，M 和類型的型別參數的指定方法的呼叫<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="a7423-206">The method body of M contains a call to method N, specifying the type parameter of M and the type <xref:System.Int32>.</span></span> <span data-ttu-id="a7423-207">`IsGenericMethodDefinition`屬性會傳回 false 方法`N<V,int>`。</span><span class="sxs-lookup"><span data-stu-id="a7423-207">The `IsGenericMethodDefinition` property returns false for method `N<V,int>`.</span></span>

> [!NOTE]
> <span data-ttu-id="a7423-208">雖然開啟之建構方法`N<V,int>`會反映類別 C 中，不時發生，它必須產生使用<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>才能發出做為動態的類別 C。</span><span class="sxs-lookup"><span data-stu-id="a7423-208">Although the open constructed method `N<V,int>` is not encountered when reflecting over class C, it must be generated using <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> in order to emit C as a dynamic class.</span></span>


<span data-ttu-id="a7423-209">如果是泛型方法定義包含宣告型別的泛型參數，則會是泛型方法定義專屬於每個建構的類型。</span><span class="sxs-lookup"><span data-stu-id="a7423-209">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="a7423-210">例如，請考慮下列 C\#和 Visual Basic 程式碼：</span><span class="sxs-lookup"><span data-stu-id="a7423-210">For example, consider the following C\# and Visual Basic code:</span></span>

    ```csharp
    class B<U,V> {}
    class C<T> { public B<T,S> M<S>() {...}}
    ```

    ```vb
    Class B(Of U, V)
    End Class
    Class C(Of T)
        Public Function M(Of S)() As B(Of T, S)
            ...
        End Function
    End Class
    ```

    ```cpp
    generic <typename U, typename V> ref class B {};
    generic <typename T> ref class C
    {
    public:
        generic <typename S> B<T,S>^ M() {...};
    };
    ```

<span data-ttu-id="a7423-211">在建構的型別`C<int>`(`C(Of Integer)` Visual Basic 中)，傳回泛型的方法 M `B<int, S>`。</span><span class="sxs-lookup"><span data-stu-id="a7423-211">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method M returns `B<int, S>`.</span></span> <span data-ttu-id="a7423-212">在開啟的型別`C<T>`，M 傳回`B<T, S>`。</span><span class="sxs-lookup"><span data-stu-id="a7423-212">In the open type `C<T>`, M returns `B<T, S>`.</span></span> <span data-ttu-id="a7423-213">在這兩種情況下，`IsGenericMethodDefinition`屬性會傳回`true`如<xref:System.Reflection.MethodInfo>M 表示。</span><span class="sxs-lookup"><span data-stu-id="a7423-213">In both cases, the `IsGenericMethodDefinition` property returns `true` for the <xref:System.Reflection.MethodInfo> that represents M.</span></span>

<span data-ttu-id="a7423-214">如需泛型的方法特定的恆成立條件，請參閱<xref:System.Reflection.MethodInfo.IsGenericMethod>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-214">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod> property.</span></span> <span data-ttu-id="a7423-215">如需泛型反映中所使用的其他詞彙的非變異條件的清單，請參閱<xref:System.Type.IsGenericType>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-215">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType> property.</span></span>

## Examples  
<span data-ttu-id="a7423-216">下列程式碼範例會使用`IsGenericMethodDefinition`屬性來顯示訊息，指出是否<xref:System.Reflection.MethodInfo>代表泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-216">The following code example uses the `IsGenericMethodDefinition` property to display a message indicating whether a <xref:System.Reflection.MethodInfo> represents a generic method definition.</span></span>

<span data-ttu-id="a7423-217">這個範例是針對提供之較大範例的一部分<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-217">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>

```vb
Console.WriteLine(vbTab _
    & "Is this a generic method definition? {0}", _
    mi.IsGenericMethodDefinition)
```

```csharp
Console.WriteLine("\tIs this a generic method definition? {0}", 
    mi.IsGenericMethodDefinition);
```

```cpp
Console::WriteLine("\tIs this a generic method definition? {0}", 
    mi->IsGenericMethodDefinition);
```

]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="a7423-218">反映和泛用類型</span><span class="sxs-lookup"><span data-stu-id="a7423-218">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="a7423-219">泛型簡介 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="a7423-219">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodInfo.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="a7423-220">類型陣列，用來取代目前泛型方法定義的泛型類型。</span><span class="sxs-lookup"><span data-stu-id="a7423-220">An array of types to be substituted for the type parameters of the current generic method definition.</span></span></param>
        <summary><span data-ttu-id="a7423-221">使用類型陣列的項目取代目前泛型方法定義的類型參數，並傳回代表所產生之建構方法的 <see cref="T:System.Reflection.MethodInfo" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-221">Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <see cref="T:System.Reflection.MethodInfo" /> object representing the resulting constructed method.</span></span></summary>
        <returns><span data-ttu-id="a7423-222"><see cref="T:System.Reflection.MethodInfo" /> 物件，代表用 <paramref name="typeArguments" /> 的項目取代目前泛型方法定義之型別參數所得到的建構方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-222">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the constructed method formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic method definition.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-223"><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法可讓您撰寫程式碼，將特定類型指派給類型參數的泛型方法定義，因此建立<xref:System.Reflection.MethodInfo>物件，表示特定的建構的方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-223">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <xref:System.Reflection.MethodInfo> object that represents a particular constructed method.</span></span> <span data-ttu-id="a7423-224">如果<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性的<xref:System.Reflection.MethodInfo>物件會傳回`true`，您可以使用它來叫用方法，或建立叫用方法的委派。</span><span class="sxs-lookup"><span data-stu-id="a7423-224">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property of this <xref:System.Reflection.MethodInfo> object returns `true`, you can use it to invoke the method or to create a delegate to invoke the method.</span></span>  
  
 <span data-ttu-id="a7423-225">方法所建構<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>方法可以開啟，也就是某些其類型引數可以是封閉式泛型類型的型別參數。</span><span class="sxs-lookup"><span data-stu-id="a7423-225">Methods constructed with the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</span></span> <span data-ttu-id="a7423-226">當您產生動態組件時，您可以使用這類開放的建構的方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-226">You might use such open constructed methods when you generate dynamic assemblies.</span></span> <span data-ttu-id="a7423-227">例如，請考慮下列 C#、 Visual Basic 和 c + + 程式碼。</span><span class="sxs-lookup"><span data-stu-id="a7423-227">For example, consider the following C#, Visual Basic, and C++ code.</span></span>  
  
```  
class C  
{  
    T N<T,U>(T t, U u) {...}  
    public V M<V>(V v)  
    {  
        return N<V,int>(v, 42);  
    }  
}  
  
Class C  
    Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T  
        ...  
    End Function  
    Public Function M(Of V)(ByVal va As V ) As V  
        Return N(Of V, Integer)(va, 42)  
    End Function  
End Class  
  
ref class C  
{  
private:  
    generic <typename T, typename U> T N(T t, U u) {...}  
public:  
    generic <typename V> V M(V v)  
    {  
        return N<V, int>(v, 42);  
    }  
};  
```  
  
 <span data-ttu-id="a7423-228">方法主體`M`包含方法的呼叫`N`，指定的型別參數`M`並輸入<xref:System.Int32>。</span><span class="sxs-lookup"><span data-stu-id="a7423-228">The method body of `M` contains a call to method `N`, specifying the type parameter of `M` and the type <xref:System.Int32>.</span></span> <span data-ttu-id="a7423-229"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A>屬性會傳回`false`方法`N<V,int>`。</span><span class="sxs-lookup"><span data-stu-id="a7423-229">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `false` for method `N<V,int>`.</span></span> <span data-ttu-id="a7423-230"><xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性會傳回`true`，因此方法`N<V,int>`無法叫用。</span><span class="sxs-lookup"><span data-stu-id="a7423-230">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, so method `N<V,int>` cannot be invoked.</span></span>  
  
 <span data-ttu-id="a7423-231">如需泛型的方法特定的恆成立條件，請參閱<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-231">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="a7423-232">如需泛型反映中所使用的其他詞彙的非變異條件的清單，請參閱<xref:System.Type.IsGenericType%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-232">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7423-233">下列程式碼範例示範的屬性和方法<xref:System.Reflection.MethodInfo>支援泛型方法的檢查。</span><span class="sxs-lookup"><span data-stu-id="a7423-233">The following code example demonstrates the properties and methods of <xref:System.Reflection.MethodInfo> that support the examination of generic methods.</span></span> <span data-ttu-id="a7423-234">此範例會執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="a7423-234">The example does the following:</span></span>  
  
-   <span data-ttu-id="a7423-235">定義具有泛型方法的類別。</span><span class="sxs-lookup"><span data-stu-id="a7423-235">Defines a class that has a generic method.</span></span>  
  
-   <span data-ttu-id="a7423-236">建立<xref:System.Reflection.MethodInfo>，代表泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-236">Creates a <xref:System.Reflection.MethodInfo> that represents the generic method.</span></span>  
  
-   <span data-ttu-id="a7423-237">會顯示泛型方法定義的屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-237">Displays properties of the generic method definition.</span></span>  
  
-   <span data-ttu-id="a7423-238">指派類型的型別參數的引數<xref:System.Reflection.MethodInfo>，並叫用產生的建構泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-238">Assigns type arguments to the type parameters of the <xref:System.Reflection.MethodInfo>, and invokes the resulting constructed generic method.</span></span>  
  
-   <span data-ttu-id="a7423-239">顯示屬性的建構泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-239">Displays properties of the constructed generic method.</span></span>  
  
-   <span data-ttu-id="a7423-240">擷取建構方法的泛型方法定義，並將其比較的原始定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-240">Retrieves the generic method definition from the constructed method and compares it to the original definition.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a7423-241">目前的 <see cref="T:System.Reflection.MethodInfo" /> 不代表泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="a7423-241">The current <see cref="T:System.Reflection.MethodInfo" /> does not represent a generic method definition.</span></span> <span data-ttu-id="a7423-242">亦即，<see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> 會傳回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-242">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a7423-243"><paramref name="typeArguments" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-243"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="a7423-244">-或-</span><span class="sxs-lookup"><span data-stu-id="a7423-244">-or-</span></span> 
<span data-ttu-id="a7423-245"><paramref name="typeArguments" /> 的項目是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-245">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7423-246"><paramref name="typeArguments" /> 中的項目數和目前泛型方法定義的類型參數數目不同。</span><span class="sxs-lookup"><span data-stu-id="a7423-246">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters of the current generic method definition.</span></span>  
  
<span data-ttu-id="a7423-247">-或-</span><span class="sxs-lookup"><span data-stu-id="a7423-247">-or-</span></span> 
<span data-ttu-id="a7423-248"><paramref name="typeArguments" /> 的項目不符合目前泛型方法定義的對應類型參數所指定的條件約束。</span><span class="sxs-lookup"><span data-stu-id="a7423-248">An element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a7423-249">不支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-249">This method is not supported.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="a7423-250">反映和泛用類型</span><span class="sxs-lookup"><span data-stu-id="a7423-250">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="a7423-251">泛型簡介 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="a7423-251">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.MethodInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7423-252">取得 <see cref="T:System.Reflection.MemberTypes" /> 值，表示這個成員為方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-252">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span></span></summary>
        <value><span data-ttu-id="a7423-253"><see cref="T:System.Reflection.MemberTypes" /> 值，表示這個成員為方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-253">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-254">此屬性會覆寫<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a7423-254">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a7423-255">因此，當您檢查一組<xref:System.Reflection.MemberInfo>物件，例如，將所傳回的陣列<xref:System.Type.GetMembers%2A>-<xref:System.Reflection.MemberInfo.MemberType%2A>屬性會傳回<xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType>只有當指定的成員是一種方法。</span><span class="sxs-lookup"><span data-stu-id="a7423-255">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType> only when a given member is a method.</span></span>  
  
 <span data-ttu-id="a7423-256">若要取得`MemberType`屬性，第一次取得類別`Type`。</span><span class="sxs-lookup"><span data-stu-id="a7423-256">To get the `MemberType` property, first get the class `Type`.</span></span> <span data-ttu-id="a7423-257">從`Type`，取得`MethodInfo`。</span><span class="sxs-lookup"><span data-stu-id="a7423-257">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="a7423-258">從`MethodInfo`，取得`MemberType`。</span><span class="sxs-lookup"><span data-stu-id="a7423-258">From the `MethodInfo`, get the `MemberType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7423-259">下列範例會顯示指定成員的型別。</span><span class="sxs-lookup"><span data-stu-id="a7423-259">The following example displays the type of the specified member.</span></span>  
  
 [!code-cpp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a7423-260">要比較的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-260">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="a7423-261">要比較的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-261">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="a7423-262">表示兩個 <see cref="T:System.Reflection.MethodInfo" /> 物件是否相等。</span><span class="sxs-lookup"><span data-stu-id="a7423-262">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="a7423-263">如果 <see langword="true" /> 等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-263"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; bool" Usage="System.Reflection.MethodInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a7423-264">要比較的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-264">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="a7423-265">要比較的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-265">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="a7423-266">表示兩個 <see cref="T:System.Reflection.MethodInfo" /> 物件是否不相等。</span><span class="sxs-lookup"><span data-stu-id="a7423-266">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="a7423-267">如果 <see langword="true" /> 不等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a7423-267"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.MethodInfo.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7423-268">取得 <see cref="T:System.Reflection.ParameterInfo" /> 物件，這個物件包含方法之傳回型別的相關資訊，例如傳回型別是否具有自訂修飾詞。</span><span class="sxs-lookup"><span data-stu-id="a7423-268">Gets a <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</span></span></summary>
        <value><span data-ttu-id="a7423-269"><see cref="T:System.Reflection.ParameterInfo" /> 物件，包含傳回類型的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="a7423-269">A <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-270">編譯器設計人員可以使用<xref:System.Reflection.ParameterInfo>物件來探索是否有自訂屬性傳回的修飾詞，例如<xref:Microsoft.VisualC.IsConstModifier>，已套用至傳回的型別。</span><span class="sxs-lookup"><span data-stu-id="a7423-270">Compiler designers can use the <xref:System.Reflection.ParameterInfo> object returned by this property to discover whether custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, have been applied to the return type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a7423-271">這個方法尚未實作。</span><span class="sxs-lookup"><span data-stu-id="a7423-271">This method is not implemented.</span></span></exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public virtual Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.MethodInfo.ReturnType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7423-272">取得這個方法的傳回型別 (Return Type)。</span><span class="sxs-lookup"><span data-stu-id="a7423-272">Gets the return type of this method.</span></span></summary>
        <value><span data-ttu-id="a7423-273">這個方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a7423-273">The return type of this method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-274">若要取得的傳回型別屬性，請先取得類別`Type`。</span><span class="sxs-lookup"><span data-stu-id="a7423-274">To get the return type property, first get the class `Type`.</span></span> <span data-ttu-id="a7423-275">從`Type`，取得`MethodInfo`。</span><span class="sxs-lookup"><span data-stu-id="a7423-275">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="a7423-276">從`MethodInfo`，取得`ReturnType`。</span><span class="sxs-lookup"><span data-stu-id="a7423-276">From the `MethodInfo`, get the `ReturnType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7423-277">下列範例會顯示指定之方法的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="a7423-277">The following example displays the return type of the specified method.</span></span>  
  
 [!code-cpp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnTypeCustomAttributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7423-278">取得傳回型別的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-278">Gets the custom attributes for the return type.</span></span></summary>
        <value><span data-ttu-id="a7423-279"><see langword="ICustomAttributeProvider" /> 物件，代表傳回類型的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="a7423-279">An <see langword="ICustomAttributeProvider" /> object representing the custom attributes for the return type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="a7423-280">保留供未來使用。</span><span class="sxs-lookup"><span data-stu-id="a7423-280">Reserved for future use.</span></span> <span data-ttu-id="a7423-281">必須是 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="a7423-281">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="a7423-282">要對應之傳入的名稱陣列。</span><span class="sxs-lookup"><span data-stu-id="a7423-282">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="a7423-283">要對應的名稱計數。</span><span class="sxs-lookup"><span data-stu-id="a7423-283">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="a7423-284">用於解譯名稱的地區設定內容。</span><span class="sxs-lookup"><span data-stu-id="a7423-284">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="a7423-285">呼叫端配置的陣列，用於接收對應於名稱的 ID。</span><span class="sxs-lookup"><span data-stu-id="a7423-285">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="a7423-286">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</span><span class="sxs-lookup"><span data-stu-id="a7423-286">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-287">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="a7423-287">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a7423-288">如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="a7423-288">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a7423-289">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="a7423-289">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetType">
      <MemberSignature Language="C#" Value="Type _MethodInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodInfo.GetType() = System::Runtime::InteropServices::_MethodInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7423-290">提供 COM 之 <see cref="M:System.Object.GetType" /> 方法的存取。</span><span class="sxs-lookup"><span data-stu-id="a7423-290">Provides access to the <see cref="M:System.Object.GetType" /> method from COM.</span></span></summary>
        <returns><span data-ttu-id="a7423-291">代表 <see cref="T:System.Type" /> 類型的 <see cref="T:System.Reflection.MethodInfo" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="a7423-291">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.MethodInfo" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="a7423-292">要傳回的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="a7423-292">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="a7423-293">類型資訊的地區設定識別項。</span><span class="sxs-lookup"><span data-stu-id="a7423-293">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="a7423-294">接收要求的類型資訊物件的指標。</span><span class="sxs-lookup"><span data-stu-id="a7423-294">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="a7423-295">擷取物件的類型資訊，可以用來取得介面的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="a7423-295">Retrieves the type information for an object, which can be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-296">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="a7423-296">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a7423-297">如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="a7423-297">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a7423-298">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="a7423-298">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="a7423-299">指向接收物件提供的類型資訊介面數目的位置。</span><span class="sxs-lookup"><span data-stu-id="a7423-299">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="a7423-300">擷取物件提供的類型資訊介面數目 (0 或 1)。</span><span class="sxs-lookup"><span data-stu-id="a7423-300">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-301">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="a7423-301">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a7423-302">如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="a7423-302">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a7423-303">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="a7423-303">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.Invoke">
      <MemberSignature Language="C#" Value="void _MethodInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="a7423-304">辨識成員。</span><span class="sxs-lookup"><span data-stu-id="a7423-304">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="a7423-305">保留供未來使用。</span><span class="sxs-lookup"><span data-stu-id="a7423-305">Reserved for future use.</span></span> <span data-ttu-id="a7423-306">必須是 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="a7423-306">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="a7423-307">地區設定內容，用於解譯引數。</span><span class="sxs-lookup"><span data-stu-id="a7423-307">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="a7423-308">描述呼叫之內容的旗標。</span><span class="sxs-lookup"><span data-stu-id="a7423-308">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="a7423-309">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</span><span class="sxs-lookup"><span data-stu-id="a7423-309">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="a7423-310">指向用於儲存結果之位置的指標。</span><span class="sxs-lookup"><span data-stu-id="a7423-310">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="a7423-311">包含例外狀況資訊的結構指標。</span><span class="sxs-lookup"><span data-stu-id="a7423-311">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="a7423-312">第一個有錯誤的引數索引。</span><span class="sxs-lookup"><span data-stu-id="a7423-312">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="a7423-313">提供物件所公開的屬性和方法的存取權。</span><span class="sxs-lookup"><span data-stu-id="a7423-313">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7423-314">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="a7423-314">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a7423-315">如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="a7423-315">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a7423-316">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="a7423-316">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>