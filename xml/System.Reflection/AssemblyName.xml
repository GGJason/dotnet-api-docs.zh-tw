<Type Name="AssemblyName" FullName="System.Reflection.AssemblyName">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="63046c4a5e2fa477549ff1c772a38af5e9e6aaea" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36543661" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AssemblyName : ICloneable, System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AssemblyName extends System.Object implements class System.ICloneable, class System.Runtime.InteropServices._AssemblyName, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.AssemblyName" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AssemblyName&#xA;Implements _AssemblyName, ICloneable, IDeserializationCallback, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyName sealed : ICloneable, System::Runtime::InteropServices::_AssemblyName, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type AssemblyName = class&#xA;    interface ICloneable&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface _AssemblyName" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._AssemblyName</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyName))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Describes an assembly's unique identity in full.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.AssemblyName>物件包含的組件，您可以使用繫結至該組件相關資訊。 組件的識別是由下列項目所組成：  
  
-   簡單名稱。  
  
-   版本號碼。  
  
-   密碼編譯金鑰組。  
  
-   支援的文化特性。  
  
 簡單名稱通常是資訊清單檔案不含副檔名的檔案名稱。 金鑰組則包含公開和私密金鑰的金鑰，用來建立組件的強式名稱簽章。  
  
 支援通用語言執行平台的所有編譯器會都發出的簡單名稱的巢狀類別，並反映建構查詢時，根據下列慣例 mangled 的名稱。  
  
|分隔符號|意義|  
|---------------|-------------|  
|反斜線 (\\)|逸出字元。|  
|逗號 （，）|後面接著組件名稱。|  
|加號 （+）|之前的巢狀的類別。|  
  
 例如，類別的完整限定的名稱可能看起來像這樣：  
  
 ContainingClass + nestedclass 資料 MyAssembly  
  
 A"+ +"會變成"\\+\\+ 」，和 「\\能夠又 「 變"\\\\"。  
  
 這個限定的名稱可以保存下來，並稍後用來載入<xref:System.Type>。 搜尋並載入<xref:System.Type>，使用<xref:System.Type.GetType%2A>與型別名稱只有或組件限定的類型名稱。 <xref:System.Type.GetType%2A> 與類型名稱只會尋找<xref:System.Type>在呼叫者的組件，然後系統組件。 <xref:System.Type.GetType%2A> 與組件限定的類型名稱會尋找<xref:System.Type>任何組件中。  
  
 完整指定<xref:System.Reflection.AssemblyName>必須有主要版本、 次要版本、 組建編號和修訂編號的參數名稱、 文化特性、 公開金鑰語彙基元。 最後四個封裝在<xref:System.Version>型別。  
  
 若要建立簡單的名稱，建立<xref:System.Reflection.AssemblyName>物件使用預設建構函式，並設定<xref:System.Reflection.AssemblyName.Name%2A>。 其他屬性是選擇性的。  
  
 若要建立完整的強式名稱，建立<xref:System.Reflection.AssemblyName>物件使用預設建構函式，並設定<xref:System.Reflection.AssemblyName.Name%2A>和<xref:System.Reflection.AssemblyName.KeyPair%2A>。 其他屬性是選擇性的。 使用<xref:System.Reflection.AssemblyName.SetPublicKey%2A>和<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>設定的公開金鑰和強式名稱。 強式名稱簽署一律會使用<xref:System.Security.Cryptography.SHA1>雜湊演算法。  
  
 若要確保名稱正確建構，請使用下列屬性：  
  
-   <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>  
  
-   <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>  
  
 您也可以使用，取得名稱`/l`選項與[Gacutil.exe （全域組件快取工具）](~/docs/framework/tools/gacutil-exe-gac-tool.md)  
  
 部分指定強式名稱時，請建立<xref:System.Reflection.AssemblyName>物件使用預設建構函式，並設定名稱和公開金鑰。 建立使用這類的組件<xref:System.Reflection.AssemblyName>可以稍後使用組件連結器 (Al.exe) 簽署。  
  
 您可指定公開金鑰和<xref:System.Reflection.AssemblyName.KeyPair%2A>不一致的值。 這可以是開發人員的案例中很有用。 在此情況下，公用金鑰擷取<xref:System.Reflection.AssemblyName.GetPublicKey%2A>指定正確的公用金鑰，while<xref:System.Reflection.AssemblyName.KeyPair%2A>指定在開發期間使用的公用和私用的索引鍵。 當執行階段偵測到不符<xref:System.Reflection.AssemblyName.KeyPair%2A>和公開金鑰，它會查閱登錄中正確與公開金鑰相符的索引鍵。  
  
 顯示名稱的格式<xref:System.Reflection.AssemblyName>逗點分隔的 Unicode 字串的開頭名稱，如下所示：  
  
 `Name <,Culture = CultureInfo> <,Version = Major.Minor.Build.Revision> <, StrongName> <,PublicKeyToken> '\0'`  
  
 `Name` 為組件的文字的名稱。 `CultureInfo` 為 RFC1766 格式定義的文化特性。 `Major``Minor`， `Build`，和`Revision`是主要版本、 次要版本、 組建編號和修訂編號的組件。 `StrongName` 為十六進位編碼低序位 64 位元的使用 sha-1 雜湊演算法所產生的公開金鑰和公開金鑰所指定的雜湊值<xref:System.Reflection.AssemblyName.SetPublicKey%2A>。 `PublicKeyToken` 是十六進位編碼公開金鑰指定<xref:System.Reflection.AssemblyName.SetPublicKey%2A>。  
  
 十六進位編碼格式定義為每個位元組的二進位物件轉換為兩個十六進位字元，最小行進到最大顯著性位元組。 必要時，就會加入額外的顯示值。  
  
 如果已知完整公開金鑰，然後可能會取代 PublicKey 的 StrongName。  
  
 也請注意，除了`Name`這必須先出現，語彙參數的順序並不重要。 不過，任何參數 (`Version`， `Culture`，`StrongName`或`PublicKey`) 沒有特別設定會被視為省略，而<xref:System.Reflection.AssemblyName>則被視為部分。 在指定的部分資訊，則必須指定名稱參數，上面所述的順序。  
  
 提供顯示名稱，慣例時`StrongName =null`或`PublicKey= null`表示需要繫結，並符合針對簡單名稱的組件。 此外，慣例`Culture= ""`（代表空字串的雙引號括住），表示比對的預設文化特性。  
  
 下列範例所示<xref:System.Reflection.AssemblyName>簡單名稱的組件與預設文化特性。  
  
```  
ExampleAssembly, Culture=""  
```  
  
 下例顯示具有 "en" 文化特性之強式名稱組件的完整指定參考。  
  
```  
ExampleAssembly, Version=1.0.0.0, Culture=en, PublicKeyToken=a5d015c7d5a0b012  
```  
  
   
  
## Examples  
 這個範例示範如何使用不同的反映類別來分析的組件中包含的中繼資料。  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Version" />
    <altmember cref="M:System.Reflection.AssemblyName.GetPublicKey" />
    <altmember cref="M:System.Reflection.AssemblyName.GetPublicKeyToken" />
    <altmember cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />
    <altmember cref="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])" />
    <altmember cref="P:System.Type.FullName" />
    <altmember cref="M:System.Type.GetType" />
    <altmember cref="P:System.Type.AssemblyQualifiedName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AssemblyName();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立名為的動態組件`MyAssembly.exe`並將它儲存到硬碟。 之後執行此範例，您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)來檢查組件中繼資料。  
  
 [!code-cpp[AssemblyName_Constructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#1)]
 [!code-csharp[AssemblyName_Constructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#1)]
 [!code-vb[AssemblyName_Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (assemblyName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AssemblyName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="new System.Reflection.AssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="new System.Reflection.AssemblyName assemblyName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName" /> class with the specified display name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`assemblyName`會剖析和新的適當欄位<xref:System.Reflection.AssemblyName>初始化值的顯示名稱。 這是建議的方法來剖析顯示名稱。 建議您不要撰寫您自己的程式碼剖析顯示名稱。  
  
   
  
## Examples  
 下列範例會建立的執行個體<xref:System.Reflection.AssemblyName>從顯示的名稱。 顯示名稱的個別項目為屬性，會輸出到主控台<xref:System.Reflection.AssemblyName>物件。  
  
 [!code-cpp[AssemblyName_Constructor_2#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor_2/CPP/source.cpp#1)]
 [!code-csharp[AssemblyName_Constructor_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor_2/CS/source.cs#1)]
 [!code-vb[AssemblyName_Constructor_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor_2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> is a zero length string.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  </para>
          </block>  The referenced assembly could not be found, or could not be loaded.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="assemblyName.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes a copy of this <see cref="T:System.Reflection.AssemblyName" /> object.</summary>
        <returns>An object that is a copy of this <see cref="T:System.Reflection.AssemblyName" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立新物件，與原始的相同。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public string CodeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CodeBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string with get, set" Usage="System.Reflection.AssemblyName.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the location of the assembly as a URL.</summary>
        <value>字串是組件的 URL 位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 載入組件時，這個值也可以取得使用<xref:System.Reflection.Assembly.CodeBase%2A?displayProperty=nameWithType>屬性。  
  
 如果這個組件已載入做為位元組陣列，這個屬性會傳回呼叫者的位置<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%29>方法多載，不是載入的組件的位置。  
  
> [!NOTE]
>  請勿使用<xref:System.Reflection.AssemblyName>只含<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性集。 <xref:System.Reflection.AssemblyName.CodeBase%2A>屬性沒有提供任何項目 （例如名稱或版本） 的組件識別，因此載入不會發生負載所識別的規則，根據您所預期從<xref:System.Reflection.Assembly.Load%2A>方法。 相反地，載入組件使用載入來源的規則。 使用載入內容的缺點的相關資訊，請參閱<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法多載或[組件載入的最佳作法](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。  
  
   
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性用來指定的目錄儲存組件。  
  
 [!code-cpp[AssemblyName_CodeBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#1)]
 [!code-csharp[AssemblyName_CodeBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#1)]
 [!code-vb[AssemblyName_CodeBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyContentType ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyContentType ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As AssemblyContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::AssemblyContentType ContentType { System::Reflection::AssemblyContentType get(); void set(System::Reflection::AssemblyContentType value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : System.Reflection.AssemblyContentType with get, set" Usage="System.Reflection.AssemblyName.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyContentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates what type of content the assembly contains.</summary>
        <value>包含值，指出哪種類型的內容組件。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureInfo">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CultureInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CultureInfo" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property CultureInfo As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CultureInfo { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CultureInfo : System.Globalization.CultureInfo with get, set" Usage="System.Reflection.AssemblyName.CultureInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the culture supported by the assembly.</summary>
        <value>表示組件所支援的文化特性的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.CultureInfo%2A>屬性用來指定的文化特性的組件的顯示名稱的一部分。  
  
 [!code-cpp[AssemblyName_CodeBase#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#2)]
 [!code-csharp[AssemblyName_CodeBase#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#2)]
 [!code-vb[AssemblyName_CodeBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureName">
      <MemberSignature Language="C#" Value="public string CultureName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CultureName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureName" />
      <MemberSignature Language="VB.NET" Value="Public Property CultureName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CultureName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CultureName : string with get, set" Usage="System.Reflection.AssemblyName.CultureName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the culture associated with the assembly.</summary>
        <value>文化特性名稱。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.AssemblyName.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the URI, including escape characters, that represents the codebase.</summary>
        <value>具有逸出字元的 URI。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyNameFlags Flags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyNameFlags Flags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Property Flags As AssemblyNameFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::AssemblyNameFlags Flags { System::Reflection::AssemblyNameFlags get(); void set(System::Reflection::AssemblyNameFlags value); };" />
      <MemberSignature Language="F#" Value="member this.Flags : System.Reflection.AssemblyNameFlags with get, set" Usage="System.Reflection.AssemblyName.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyNameFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the attributes of the assembly.</summary>
        <value>值，代表組件的屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.Flags%2A>屬性用來指定組件的公開金鑰。  
  
 [!code-cpp[AssemblyName_KeyPair#4](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#4)]
 [!code-csharp[AssemblyName_KeyPair#4](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#4)]
 [!code-vb[AssemblyName_KeyPair#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.FullName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.AssemblyName.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the full name of the assembly, also known as the display name.</summary>
        <value>組件，也稱為顯示名稱的完整名稱字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顯示名稱通常是由簡單名稱、 版本號碼、 支援的文化特性和公開金鑰所組成。 例如:   
  
```  
mylib, Version=1.2.1900.0, Culture=neutral, PublicKeyToken=a14f3033def15840  
```  
  
 建議您不要撰寫您自己的程式碼剖析顯示名稱。 相反地，將顯示名稱，以傳遞<xref:System.Reflection.AssemblyName.%23ctor%2A>建構函式，它會剖析並於其中填入新的適當欄位<xref:System.Reflection.AssemblyName>。  
  
 載入組件時，這個值也可以取得使用<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性。  
  
   
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，程式碼範例會將設定<xref:System.Reflection.AssemblyName.Name%2A>， <xref:System.Reflection.AssemblyName.Version%2A>， <xref:System.Reflection.AssemblyName.CultureInfo%2A>，和<xref:System.Reflection.AssemblyName.KeyPair%2A>屬性，它們共同組成組件的完整名稱，或顯示名稱。 <xref:System.Reflection.AssemblyName.FullName%2A>屬性然後用來擷取顯示名稱。  
  
 [!code-cpp[AssemblyName_CodeBase#4](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#4)]
 [!code-csharp[AssemblyName_CodeBase#4](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#4)]
 [!code-vb[AssemblyName_CodeBase#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyFile As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Reflection.AssemblyName.GetAssemblyName assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">The path for the assembly whose <see cref="T:System.Reflection.AssemblyName" /> is to be returned.</param>
        <summary>Gets the <see cref="T:System.Reflection.AssemblyName" /> for a given file.</summary>
        <returns>An object that represents the given assembly file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這只適如果檔案包含組件資訊清單。 這個方法會讓檔案的開啟及關閉，但組件不會加入至這個網域。  
  
   
  
## Examples  
 下列範例會取得<xref:System.Reflection.AssemblyName>磁碟上的組件。 它才會執行取代字串"MyAssembly.exe 」 （包括路徑，如有必要） 的組件的檔案名稱與您的硬碟上。 或者，您可以編譯這個範例為"MyAssembly.exe"。  
  
 [!code-cpp[AssemblyName_GetAssemblyName#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CPP/assemblyname_getassemblyname.cpp#1)]
 [!code-csharp[AssemblyName_GetAssemblyName#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CS/assemblyname_getassemblyname.cs#1)]
 [!code-vb[AssemblyName_GetAssemblyName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_GetAssemblyName/VB/assemblyname_getassemblyname.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> is invalid, such as an assembly with an invalid culture.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> is not found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have path discovery permission.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> is not a valid assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">An assembly or module was loaded twice with two different sets of evidence.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取路徑中的資訊。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assemblyName.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">The object to be populated with serialization information.</param>
        <param name="context">The destination context of the serialization.</param>
        <summary>Gets serialization information with all the data needed to recreate an instance of this <see langword="AssemblyName" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKey">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKey" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPublicKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetPublicKey();" />
      <MemberSignature Language="F#" Value="member this.GetPublicKey : unit -&gt; byte[]" Usage="assemblyName.GetPublicKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the public key of the assembly.</summary>
        <returns>A byte array that contains the public key of the assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.SetPublicKey%2A>方法用來授與組件的公開金鑰。 <xref:System.Reflection.AssemblyName.GetPublicKey%2A>方法可用來擷取公開金鑰，這會顯示到主控台。  
  
 [!code-cpp[AssemblyName_KeyPair#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#2)]
 [!code-csharp[AssemblyName_KeyPair#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#2)]
 [!code-vb[AssemblyName_KeyPair#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">A public key was provided (for example, by using the <see cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" /> method), but no public key token was provided.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKeyToken">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKeyToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKeyToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKeyToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPublicKeyToken () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetPublicKeyToken();" />
      <MemberSignature Language="F#" Value="member this.GetPublicKeyToken : unit -&gt; byte[]" Usage="assemblyName.GetPublicKeyToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</summary>
        <returns>A byte array that contains the public key token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>方法用來設定組件的公開金鑰語彙基元。 <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>方法可用來擷取公開金鑰語彙基元，它會顯示到主控台。  
  
 [!code-cpp[AssemblyName_KeyPair#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#3)]
 [!code-csharp[AssemblyName_KeyPair#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#3)]
 [!code-vb[AssemblyName_KeyPair#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As AssemblyHashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::Assemblies::AssemblyHashAlgorithm HashAlgorithm { System::Configuration::Assemblies::AssemblyHashAlgorithm get(); void set(System::Configuration::Assemblies::AssemblyHashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Configuration.Assemblies.AssemblyHashAlgorithm with get, set" Usage="System.Reflection.AssemblyName.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyHashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the hash algorithm used by the assembly manifest.</summary>
        <value>使用組件資訊清單雜湊演算法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  從開始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>屬性<xref:System.Reflection.AssemblyName>所傳回的物件<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType>方法<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType>如果沒有雜湊演算法參考的組件，或所參考的雜湊演算法組件不由<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>列舉型別。 在舊版的.NET Framework 中，<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>屬性傳回<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType>在此情況下。  
  
   
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>屬性用來設定組件資訊清單的雜湊演算法。  
  
 [!code-cpp[AssemblyName_CodeBase#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#3)]
 [!code-csharp[AssemblyName_CodeBase#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#3)]
 [!code-vb[AssemblyName_CodeBase#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPair">
      <MemberSignature Language="C#" Value="public System.Reflection.StrongNameKeyPair KeyPair { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.StrongNameKeyPair KeyPair" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.KeyPair" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyPair As StrongNameKeyPair" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::StrongNameKeyPair ^ KeyPair { System::Reflection::StrongNameKeyPair ^ get(); void set(System::Reflection::StrongNameKeyPair ^ value); };" />
      <MemberSignature Language="F#" Value="member this.KeyPair : System.Reflection.StrongNameKeyPair with get, set" Usage="System.Reflection.AssemblyName.KeyPair" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.StrongNameKeyPair</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the public and private cryptographic key pair that is used to create a strong name signature for the assembly.</summary>
        <value>公用和私用密碼編譯金鑰組用來建立強式名稱組件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當執行階段載入組件時，不會設定<xref:System.Reflection.AssemblyName.KeyPair%2A>屬性。 Getter 屬性才有用，如果使用者在使用之前設定屬性<xref:System.Reflection.AssemblyName>物件來建立動態組件，並接著想要擷取的金鑰組。  
  
   
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.KeyPair%2A>屬性用來設定組件的公開金鑰和私密金鑰密碼編譯金鑰。 。  
  
 [!code-cpp[AssemblyName_KeyPair#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#1)]
 [!code-csharp[AssemblyName_KeyPair#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#1)]
 [!code-vb[AssemblyName_KeyPair#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Reflection.AssemblyName.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the simple name of the assembly. This is usually, but not necessarily, the file name of the manifest file of the assembly, minus its extension.</summary>
        <value>組件的簡單名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資訊清單檔案是包含組件資訊清單的檔案。  
  
 例如，名為"MyAssembly.dll 」 的單一檔案組件的簡單名稱是"MyAssembly"。  
  
   
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.Name%2A>屬性用來設定動態組件的簡單名稱。  
  
 [!code-cpp[AssemblyName_Constructor#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#2)]
 [!code-csharp[AssemblyName_Constructor#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#2)]
 [!code-vb[AssemblyName_Constructor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="assemblyName.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">The source of the deserialization event.</param>
        <summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and is called back by the deserialization event when deserialization is complete.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Reflection.AssemblyName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorArchitecture">
      <MemberSignature Language="C#" Value="public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.ProcessorArchitecture ProcessorArchitecture" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ProcessorArchitecture" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorArchitecture As ProcessorArchitecture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ProcessorArchitecture ProcessorArchitecture { System::Reflection::ProcessorArchitecture get(); void set(System::Reflection::ProcessorArchitecture value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorArchitecture : System.Reflection.ProcessorArchitecture with get, set" Usage="System.Reflection.AssemblyName.ProcessorArchitecture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ProcessorArchitecture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that identifies the processor and bits-per-word of the platform targeted by an executable.</summary>
        <value>其中一個列舉值，識別的處理器和位元每個字的可執行檔的目標平台。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，這個屬性永遠傳回<xref:System.Reflection.ProcessorArchitecture.None?displayProperty=nameWithType>參考組件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      </Docs>
    </Member>
    <Member MemberName="ReferenceMatchesDefinition">
      <MemberSignature Language="C#" Value="public static bool ReferenceMatchesDefinition (System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceMatchesDefinition(class System.Reflection.AssemblyName reference, class System.Reflection.AssemblyName definition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ReferenceMatchesDefinition(System.Reflection.AssemblyName,System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceMatchesDefinition (reference As AssemblyName, definition As AssemblyName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceMatchesDefinition(System::Reflection::AssemblyName ^ reference, System::Reflection::AssemblyName ^ definition);" />
      <MemberSignature Language="F#" Value="static member ReferenceMatchesDefinition : System.Reflection.AssemblyName * System.Reflection.AssemblyName -&gt; bool" Usage="System.Reflection.AssemblyName.ReferenceMatchesDefinition (reference, definition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reference" Type="System.Reflection.AssemblyName" />
        <Parameter Name="definition" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="reference">The reference assembly name.</param>
        <param name="definition">The assembly name that is compared to the reference assembly.</param>
        <summary>Returns a value indicating whether two assembly names are the same. The comparison is based on the simple assembly names.</summary>
        <returns>
          <see langword="true" /> if the simple assembly names are the same; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比較只取決於簡單的組件名稱。 它會忽略版本、 文化特性和公開金鑰語彙基元。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKey">
      <MemberSignature Language="C#" Value="public void SetPublicKey (byte[] publicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKey(unsigned int8[] publicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPublicKey (publicKey As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPublicKey(cli::array &lt;System::Byte&gt; ^ publicKey);" />
      <MemberSignature Language="F#" Value="member this.SetPublicKey : byte[] -&gt; unit" Usage="assemblyName.SetPublicKey publicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKey" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKey">A byte array containing the public key of the assembly.</param>
        <summary>Sets the public key identifying the assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您也必須使用<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>方法以提供公開金鑰語彙基元。 否則，<xref:System.Security.SecurityException>時擲回<xref:System.Reflection.AssemblyName.GetPublicKey%2A>方法呼叫。  
  
   
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.SetPublicKey%2A>方法用來授與組件的公開金鑰。 <xref:System.Reflection.AssemblyName.GetPublicKey%2A>方法可用來擷取公開金鑰，這會顯示到主控台。  
  
 [!code-cpp[AssemblyName_SetPublicKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CPP/assemblyname_setpublickey.cpp#1)]
 [!code-csharp[AssemblyName_SetPublicKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CS/assemblyname_setpublickey.cs#1)]
 [!code-vb[AssemblyName_SetPublicKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_SetPublicKey/VB/assemblyname_setpublickey.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKeyToken">
      <MemberSignature Language="C#" Value="public void SetPublicKeyToken (byte[] publicKeyToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKeyToken(unsigned int8[] publicKeyToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPublicKeyToken (publicKeyToken As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPublicKeyToken(cli::array &lt;System::Byte&gt; ^ publicKeyToken);" />
      <MemberSignature Language="F#" Value="member this.SetPublicKeyToken : byte[] -&gt; unit" Usage="assemblyName.SetPublicKeyToken publicKeyToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKeyToken" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKeyToken">A byte array containing the public key token of the assembly.</param>
        <summary>Sets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您設定的公開金鑰藉由呼叫<xref:System.Reflection.AssemblyName.SetPublicKey%2A>方法，您也必須使用<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>方法以提供公開金鑰語彙基元。 否則，<xref:System.Security.SecurityException>時擲回<xref:System.Reflection.AssemblyName.GetPublicKey%2A>方法呼叫。  
  
   
  
## Examples  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A>方法用來設定組件的公開金鑰語彙基元。 <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>方法可用來擷取公開金鑰語彙基元，它會顯示到主控台。  
  
 [!code-cpp[AssemblyName_SetPublicKey#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CPP/assemblyname_setpublickey.cpp#2)]
 [!code-csharp[AssemblyName_SetPublicKey#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CS/assemblyname_setpublickey.cs#2)]
 [!code-vb[AssemblyName_SetPublicKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_SetPublicKey/VB/assemblyname_setpublickey.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AssemblyName.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_AssemblyName::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array that receives the IDs corresponding to the names.</param>
        <summary>Maps a set of names to a corresponding set of dispatch identifiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AssemblyName.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_AssemblyName::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyName.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">Receives a pointer to the requested type information object.</param>
        <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AssemblyName.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_AssemblyName::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Points to a location that receives the number of type information interfaces provided by the object.</param>
        <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.Invoke">
      <MemberSignature Language="C#" Value="void _AssemblyName.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AssemblyName.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._AssemblyName.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_AssemblyName::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._AssemblyName.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifies the member.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>Provides access to properties and methods exposed by an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assemblyName.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the full name of the assembly, also known as the display name.</summary>
        <returns>The full name of the assembly, or the class name if the full name cannot be determined.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱描述<xref:System.Reflection.AssemblyName>傳回之字串的格式。  
  
   
  
## Examples  
 下列範例會取得<xref:System.Reflection.AssemblyName>假設物件`MyAssembly.exe`組件，然後再使用<xref:System.Reflection.AssemblyName.ToString%2A>方法來擷取完整的組件名稱，或顯示名稱。  
  
 [!code-cpp[AssemblyName_GetAssemblyName#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CPP/assemblyname_getassemblyname.cpp#2)]
 [!code-csharp[AssemblyName_GetAssemblyName#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CS/assemblyname_getassemblyname.cs#2)]
 [!code-vb[AssemblyName_GetAssemblyName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_GetAssemblyName/VB/assemblyname_getassemblyname.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public Version Version { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Version" />
      <MemberSignature Language="VB.NET" Value="Public Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ Version { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version with get, set" Usage="System.Reflection.AssemblyName.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the major, minor, build, and revision numbers of the assembly.</summary>
        <value>物件，表示主要、 次要、 組建和修訂編號的組件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有元件必須都是版本的大於或等於零的整數。 中繼資料會限制主要、 次要、 組建和組件的最大值的修訂元件<xref:System.UInt16.MaxValue?displayProperty=nameWithType>-1。 如果元件會超過此值，則會擲不回任何錯誤;不過，在動態組件，該元件為零。  
  
   
  
## Examples  
 本章節包含兩個範例。 第一個範例示範如何擷取目前正在執行的組件的版本。 第二個範例示範如何使用<xref:System.Reflection.AssemblyName.Version%2A>屬性來指定組件版本，當發出動態組件。  
  
 **範例 1**  
  
 下列範例會擷取並顯示目前正在執行的組件和包含的組件的版本號碼<xref:System.String>類別。  
  
 [!code-cpp[AssemblyName.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName.Version/cpp/Example.cpp#1)]
 [!code-csharp[AssemblyName.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName.Version/cs/Example.cs#1)]
 [!code-vb[AssemblyName.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName.Version/vb/Example.vb#1)]  
  
 **範例 2**  
  
 下列範例會發出動態組件，並將它儲存到目前的目錄。 建立組件時，<xref:System.Reflection.AssemblyName.Version%2A>屬性用來指定組件的版本資訊。  
  
 [!code-cpp[AssemblyName_Constructor#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#3)]
 [!code-csharp[AssemblyName_Constructor#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#3)]
 [!code-vb[AssemblyName_Constructor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VersionCompatibility">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.VersionCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Property VersionCompatibility As AssemblyVersionCompatibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::Assemblies::AssemblyVersionCompatibility VersionCompatibility { System::Configuration::Assemblies::AssemblyVersionCompatibility get(); void set(System::Configuration::Assemblies::AssemblyVersionCompatibility value); };" />
      <MemberSignature Language="F#" Value="member this.VersionCompatibility : System.Configuration.Assemblies.AssemblyVersionCompatibility with get, set" Usage="System.Reflection.AssemblyName.VersionCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyVersionCompatibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the information related to the assembly's compatibility with other assemblies.</summary>
        <value>值，表示與其他組件的組件的相容性的相關資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.AssemblyName.VersionCompatibility%2A> 資訊會指出，例如，組件無法透過裝置驅動程式執行與其他因衝突而產生的版本並存。  
  
 目前，<xref:System.Reflection.AssemblyName.VersionCompatibility%2A>一律會傳回<xref:System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine?displayProperty=nameWithType>，而且不會載入器。 這個屬性被保留供未來的功能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>