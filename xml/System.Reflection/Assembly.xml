<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="61e41f0ea0e2ba2b5b68e7d5dde114072003f536" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39726326" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="9629d-101">表示組件 (Assembly)，此組件是可重複使用、可控制版本和自我描述的 Common Language Runtime 應用程式建置區塊。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9629d-101">Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-102">使用<xref:System.Reflection.Assembly>類別來載入組件，來瀏覽組件，來探索組件中包含的型別，以及建立這些類型的執行個體的中繼資料和組成組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-102">Use the <xref:System.Reflection.Assembly> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</span></span>  
  
 <span data-ttu-id="9629d-103">若要取得的陣列<xref:System.Reflection.Assembly>物件代表目前的組件載入應用程式定義域 （比方說的預設應用程式定義域的簡單專案），使用<xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-103">To get an array of <xref:System.Reflection.Assembly> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="9629d-104">以動態方式載入組件<xref:System.Reflection.Assembly>類別提供下列靜態方法 (`Shared`方法在 Visual Basic 中的)。</span><span class="sxs-lookup"><span data-stu-id="9629d-104">To load assemblies dynamically, the <xref:System.Reflection.Assembly> class provides the following static methods (`Shared` methods in Visual Basic).</span></span> <span data-ttu-id="9629d-105">組件會載入應用程式定義域載入作業發生的位置。</span><span class="sxs-lookup"><span data-stu-id="9629d-105">Assemblies are loaded into the application domain where the load operation occurs.</span></span>  
  
-   <span data-ttu-id="9629d-106">載入組件的建議的方式是使用<xref:System.AppDomain.Load%2A>方法，用來識別要由其顯示名稱所載入的組件 (比方說，"System.Windows.Forms，version=2.0.0.0，Culture = neutral，publickeytoken=b77a5c561934e089")。</span><span class="sxs-lookup"><span data-stu-id="9629d-106">The recommended way to load assemblies is to use the <xref:System.AppDomain.Load%2A> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</span></span> <span data-ttu-id="9629d-107">組件的搜尋會遵循規則中所述[執行階段如何找出組件](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-107">The search for the assembly follows the rules described in [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span></span>  
  
-   <span data-ttu-id="9629d-108"><xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法可讓您載入組件反映，但不是執行。</span><span class="sxs-lookup"><span data-stu-id="9629d-108">The <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods enable you to load an assembly for reflection, but not for execution.</span></span> <span data-ttu-id="9629d-109">比方說，64 位元平台為目標的組件由 32 位元平台執行的程式碼進行檢查。</span><span class="sxs-lookup"><span data-stu-id="9629d-109">For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</span></span>  
  
-   <span data-ttu-id="9629d-110"><xref:System.Reflection.Assembly.LoadFile%2A>和<xref:System.Reflection.Assembly.LoadFrom%2A>方法提供極少數的情況下必須路徑所識別的組件中。</span><span class="sxs-lookup"><span data-stu-id="9629d-110">The <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A> methods are provided for rare scenarios in which an assembly must be identified by path.</span></span>  
  
 <span data-ttu-id="9629d-111">若要取得<xref:System.Reflection.Assembly>物件的目前執行的組件，用來使用<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-111">To get an <xref:System.Reflection.Assembly> object for the currently executing assembly, use the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method.</span></span>  
  
 <span data-ttu-id="9629d-112">許多成員的<xref:System.Reflection.Assembly>類別提供組件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="9629d-112">Many members of the <xref:System.Reflection.Assembly> class provide information about an assembly.</span></span> <span data-ttu-id="9629d-113">例如: </span><span class="sxs-lookup"><span data-stu-id="9629d-113">For example:</span></span>  
  
-   <span data-ttu-id="9629d-114"><xref:System.Reflection.Assembly.GetName%2A>方法會傳回<xref:System.Reflection.AssemblyName>提供存取組件的顯示名稱的組件的物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-114">The <xref:System.Reflection.Assembly.GetName%2A> method returns an <xref:System.Reflection.AssemblyName> object that provides access to the parts of the assembly display name.</span></span>  
  
-   <span data-ttu-id="9629d-115"><xref:System.Reflection.Assembly.GetCustomAttributes%2A>方法會列出套用至組件的屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-115">The <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method lists the attributes applied to the assembly.</span></span>  
  
-   <span data-ttu-id="9629d-116"><xref:System.Reflection.Assembly.GetFiles%2A>方法可以存取組件資訊清單中的檔案。</span><span class="sxs-lookup"><span data-stu-id="9629d-116">The <xref:System.Reflection.Assembly.GetFiles%2A> method provides access to the files in the assembly manifest.</span></span>  
  
-   <span data-ttu-id="9629d-117"><xref:System.Reflection.Assembly.GetManifestResourceNames%2A>方法提供的組件資訊清單中的資源名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-117">The <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> method provides the names of the resources in the assembly manifest.</span></span>  
  
 <span data-ttu-id="9629d-118"><xref:System.Reflection.Assembly.GetTypes%2A>方法列出組件中的所有型別。</span><span class="sxs-lookup"><span data-stu-id="9629d-118">The <xref:System.Reflection.Assembly.GetTypes%2A> method lists all the types in the assembly.</span></span> <span data-ttu-id="9629d-119"><xref:System.Reflection.Assembly.GetExportedTypes%2A>方法列出呼叫端組件外部可見的類型。</span><span class="sxs-lookup"><span data-stu-id="9629d-119">The <xref:System.Reflection.Assembly.GetExportedTypes%2A> method lists the types that are visible to callers outside the assembly.</span></span> <span data-ttu-id="9629d-120"><xref:System.Reflection.Assembly.GetType%2A>方法可以用來搜尋特定型別的組件中。</span><span class="sxs-lookup"><span data-stu-id="9629d-120">The <xref:System.Reflection.Assembly.GetType%2A> method can be used to search for a particular type in the assembly.</span></span> <span data-ttu-id="9629d-121"><xref:System.Reflection.Assembly.CreateInstance%2A>方法可以用來搜尋及組件中建立型別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="9629d-121">The <xref:System.Reflection.Assembly.CreateInstance%2A> method can be used to search for and create instances of types in the assembly.</span></span>  
  
 <span data-ttu-id="9629d-122">如需有關組件的詳細資訊，請參閱 < 應用程式定義域和組件 > 一節[應用程式定義域](~/docs/framework/app-domains/application-domains.md)主題。</span><span class="sxs-lookup"><span data-stu-id="9629d-122">For more information on assemblies, see the "Application Domains and Assemblies" section in the [Application Domains](~/docs/framework/app-domains/application-domains.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-123">下列程式碼範例示範如何取得目前執行的組件、 建立該組件，內含類型的執行個體和叫用其中一種類型的方法具有晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="9629d-123">The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</span></span> <span data-ttu-id="9629d-124">基於此目的，在程式碼範例定義名為類別`Example`，與名為方法`SampleMethod`。</span><span class="sxs-lookup"><span data-stu-id="9629d-124">For this purpose, the code example defines a class named `Example`, with a method named `SampleMethod`.</span></span> <span data-ttu-id="9629d-125">類別的建構函式會接受一個整數，用來計算該方法的傳回值。</span><span class="sxs-lookup"><span data-stu-id="9629d-125">The constructor of the class accepts an integer, which is used to compute the return value of the method.</span></span>  
  
 <span data-ttu-id="9629d-126">在程式碼範例也示範如何使用<xref:System.Reflection.Assembly.GetName%2A>方法，以取得<xref:System.Reflection.AssemblyName>可以用來剖析組件的完整名稱的物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-126">The code example also demonstrates the use of the <xref:System.Reflection.Assembly.GetName%2A> method to obtain an <xref:System.Reflection.AssemblyName> object that can be used to parse the full name of the assembly.</span></span> <span data-ttu-id="9629d-127">此範例會顯示組件的版本號碼<xref:System.Reflection.Assembly.CodeBase%2A>屬性，而<xref:System.Reflection.Assembly.EntryPoint%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-127">The example displays the version number of the assembly, the <xref:System.Reflection.Assembly.CodeBase%2A> property, and the <xref:System.Reflection.Assembly.EntryPoint%2A> property.</span></span>  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="9629d-128">針對繼承者完全信任。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9629d-128">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="9629d-129">這個類別無法繼承由部分信任的程式碼。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9629d-129">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="9629d-130">此型別具備執行緒安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9629d-130">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-131">初始化 <see cref="T:System.Reflection.Assembly" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-131">Initializes a new instance of the <see cref="T:System.Reflection.Assembly" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-132">這個建構函式會由衍生類別叫用的建構期間<xref:System.Reflection.Assembly>物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-132">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Assembly> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-133">取得組件位置，例如原先在 <see cref="T:System.Reflection.AssemblyName" /> 物件中指定的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-133">Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-134">原先指定的組件位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-134">The location of the assembly as specified originally.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-135">若要取得載入的資訊清單包含檔案的絕對路徑，請使用<xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType>屬性改為。</span><span class="sxs-lookup"><span data-stu-id="9629d-135">To get the absolute path to the loaded manifest-containing file, use the <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="9629d-136">做為位元組陣列載入組件時，使用的多載<xref:System.Reflection.Assembly.Load%2A>採用位元組陣列的方法，這個屬性會傳回呼叫端的方法，而不是載入的組件的位置的位置。</span><span class="sxs-lookup"><span data-stu-id="9629d-136">If the assembly was loaded as a byte array, using an overload of the <xref:System.Reflection.Assembly.Load%2A> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-137">下列範例會使用<xref:System.Reflection.Assembly.CodeBase%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-137">The following example uses the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-138">存取路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-138">for access to the path.</span>
          </span>
          <span data-ttu-id="9629d-139">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-139">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-140">從這個組件找出類型，並使用系統啟動項 (Activator) 建立它的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-140">Locates a type from this assembly and creates an instance of it using the system activator.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="9629d-141">要尋找的 <see cref="P:System.Type.FullName" /> 類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-141">The <see cref="P:System.Type.FullName" /> of the type to locate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-142">從這個組件找出指定類型，並使用系統啟動項，利用區分大小寫的搜尋，建立它的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-142">Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-143">透過預設建構函式建立之指定類型的執行個體，如果找不到 <see langword="null" /> 則為 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-143">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="9629d-144">該類型在 <see cref="T:System.Reflection.BindingFlags" /> 設定為 <see langword="Public" /> 或 <see langword="Instance" /> 時，於未指定文化特性或啟動屬性的情況下，使用預設繫結器進行解析。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-144">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-145">如果找不到執行階段`typeName`中<xref:System.Reflection.Assembly>執行個體，它會傳回`null`而非擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9629d-145">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="9629d-146">這可能是因為：</span><span class="sxs-lookup"><span data-stu-id="9629d-146">This might happen because:</span></span>  
  
-   <span data-ttu-id="9629d-147">您還沒有指定之型別的完整的名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-147">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="9629d-148">您已指定完整限定的類型名稱，但其不符合類型之大小寫<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-148">You've specified the fully qualified type name, but its case doesn’t match the case of the type's <xref:System.Type.FullName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="9629d-149">如需不區分大小寫的比較`typeName`型別的完整名稱，然後呼叫<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>多載，並指定`true`如`ignoreCase`引數。</span><span class="sxs-lookup"><span data-stu-id="9629d-149">For a case-insensitive comparison of `typeName` with the type's full name, call the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specify `true` for the `ignoreCase` argument.</span></span>  
  
-   <span data-ttu-id="9629d-150">型別不存在於目前<xref:System.Reflection.Assembly>執行個體。</span><span class="sxs-lookup"><span data-stu-id="9629d-150">The type doesn’t exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-151">下列範例會定義`Person`類別並呼叫<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>它具現化的方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-151">The following example defines a `Person` class and calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-152">
            <paramref name="typeName" /> 為空字串 ("") 或以 null 字元開頭的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-152">
              <paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span>
          </span>
          <span data-ttu-id="9629d-153">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-153">-or-</span>
          </span>
          <span data-ttu-id="9629d-154">目前的組件已載入到僅限反映的內容中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-154">The current assembly was loaded into the reflection-only context.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-155">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-155">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="9629d-156">找不到相符的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-156">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-157">找不到 <paramref name="typeName" /> 所需的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-157">
              <paramref name="typeName" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-158">找到 <paramref name="typeName" /> 所需的相依組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-158">
              <paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-159">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-159">-or-</span>
          </span>
          <span data-ttu-id="9629d-160">目前的組件已載入僅限反映的內容中，而且 <paramref name="typeName" /> 需要未預先載入的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-160">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-161">
            <paramref name="typeName" /> 需要相依組件，但這個檔案不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-161">
              <paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-162">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-162">-or-</span>
          </span>
          <span data-ttu-id="9629d-163">
            <paramref name="typeName" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-163">
              <paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-164">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-164">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-165">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-165">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="9629d-166">要尋找的 <see cref="P:System.Type.FullName" /> 類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-166">The <see cref="P:System.Type.FullName" /> of the type to locate.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="9629d-167">若要忽略類型名稱的大小寫，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-167">
              <see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-168">從這個組件找出指定類型，並使用系統啟動項，利用選擇性區分大小寫的搜尋，建立它的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-168">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-169">透過預設建構函式建立之指定類型的執行個體，如果找不到 <see langword="null" /> 則為 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-169">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="9629d-170">該類型在 <see cref="T:System.Reflection.BindingFlags" /> 設定為 <see langword="Public" /> 或 <see langword="Instance" /> 時，於未指定文化特性或啟動屬性的情況下，使用預設繫結器進行解析。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-170">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-171">如果找不到執行階段`typeName`中<xref:System.Reflection.Assembly>執行個體，它會傳回`null`而非擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9629d-171">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="9629d-172">這可能是因為：</span><span class="sxs-lookup"><span data-stu-id="9629d-172">This might happen because:</span></span>  
  
-   <span data-ttu-id="9629d-173">您還沒有指定之型別的完整的名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-173">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="9629d-174">型別不存在於目前<xref:System.Reflection.Assembly>執行個體。</span><span class="sxs-lookup"><span data-stu-id="9629d-174">The type doesn’t exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-175">下列範例會定義`Person`類別。</span><span class="sxs-lookup"><span data-stu-id="9629d-175">The following example defines a `Person` class.</span></span> <span data-ttu-id="9629d-176">然後它會呼叫<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>方法具現化，但因為機殼`typeName`引數不符合的型別<xref:System.Type.FullName%2A>屬性，此方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="9629d-176">It then calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it, but because the casing of the `typeName` argument doesn’t match that of the type's <xref:System.Type.FullName%2A> property, the method returns `null`.</span></span> <span data-ttu-id="9629d-177">當範例會傳遞至相同的字串<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>多載，並指定比較是否應區分大小寫，`Person`找到類別，和`Person`成功具現化物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-177">When the example passes the same string to the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specifies that the comparison should be case-insensitive, the `Person` class is found, and a `Person` object is successfully instantiated.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-178">
            <paramref name="typeName" /> 為空字串 ("") 或以 null 字元開頭的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-178">
              <paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span>
          </span>
          <span data-ttu-id="9629d-179">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-179">-or-</span>
          </span>
          <span data-ttu-id="9629d-180">目前的組件已載入到僅限反映的內容中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-180">The current assembly was loaded into the reflection-only context.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="9629d-181">找不到相符的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-181">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-182">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-182">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-183">找不到 <paramref name="typeName" /> 所需的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-183">
              <paramref name="typeName" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-184">找到 <paramref name="typeName" /> 所需的相依組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-184">
              <paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-185">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-185">-or-</span>
          </span>
          <span data-ttu-id="9629d-186">目前的組件已載入僅限反映的內容中，而且 <paramref name="typeName" /> 需要未預先載入的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-186">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-187">
            <paramref name="typeName" /> 需要相依組件，但這個檔案不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-187">
              <paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-188">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-188">-or-</span>
          </span>
          <span data-ttu-id="9629d-189">
            <paramref name="typeName" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-189">
              <paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-190">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-190">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-191">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-191">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="9629d-192">要尋找的 <see cref="P:System.Type.FullName" /> 類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-192">The <see cref="P:System.Type.FullName" /> of the type to locate.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="9629d-193">若要忽略類型名稱的大小寫，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-193">
              <see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="9629d-194">位元遮罩，會影響搜尋的進行方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-194">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="9629d-195">該值是來自 <see cref="T:System.Reflection.BindingFlags" /> 的位元旗標之組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-195">The value is a combination of bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="9629d-196">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see langword="MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-196">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="9629d-197">如果 <c>Binder</c> 為 <see langword="null" />，則會使用預設 Binder。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-197">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="9629d-198">包含要傳遞至建構函式之引數的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-198">An array that contains the arguments to be passed to the constructor.</span>
          </span>
          <span data-ttu-id="9629d-199">這個引數陣列必須在數目、順序和類型上符合要叫用的建構函式的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-199">This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</span>
          </span>
          <span data-ttu-id="9629d-200">如果需要預設的建構函式，則 <c>args</c> 必須是空陣列或 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-200">If the default constructor is desired, <c>args</c> must be an empty array or <see langword="null" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="9629d-201">
            <see langword="CultureInfo" /> 的執行個體，用於管理類型的強制型轉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-201">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="9629d-202">如果這是 <see langword="null" />，會使用目前執行緒的 <see langword="CultureInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-202">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="9629d-203">(例如，要將代表 1000 的 <see langword="String" /> 轉換成 <see langword="Double" /> 值時，這是必要的，因為 1000 的表示方式會因不同文化特性而有所不同)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-203">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <param name="activationAttributes">
          <span data-ttu-id="9629d-204">一或多個屬性的陣列，此屬性可參與啟動過程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-204">An array of one or more attributes that can participate in activation.</span>
          </span>
          <span data-ttu-id="9629d-205">陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-205">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span>
          </span>
          <span data-ttu-id="9629d-206">此參數與啟動了用戶端的物件相關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-206">This parameter is related to client-activated objects.</span>
          </span>
          <span data-ttu-id="9629d-207">用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-207">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span>
          </span>
          <span data-ttu-id="9629d-208">分散式應用程式應該改用 Windows Communication Foundation。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-208">Distributed applications should instead use Windows Communication Foundation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-209">從這個組件找出指定類型，並使用系統啟動項，利用選擇性區分大小寫的搜尋，以及取得指定文化特性 (Culture)、引數和繫結和啟動屬性，建立它的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-209">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-210">指定之類型的執行個體，如果找不到 <see langword="null" /> 則為 <paramref name="typeName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-210">An instance of the specified type, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span>
          </span>
          <span data-ttu-id="9629d-211">所提供的引數會用來解析類型，以及繫結建立執行個體所用的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-211">The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-212">
            <paramref name="typeName" /> 為空字串 ("") 或以 null 字元開頭的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-212">
              <paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span>
          </span>
          <span data-ttu-id="9629d-213">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-213">-or-</span>
          </span>
          <span data-ttu-id="9629d-214">目前的組件已載入到僅限反映的內容中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-214">The current assembly was loaded into the reflection-only context.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-215">
            <paramref name="typeName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-215">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="9629d-216">找不到相符的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-216">No matching constructor was found.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9629d-217">將非空白的啟用屬性陣列傳遞給不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-217">A non-empty activation attributes array is passed to a type that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-218">找不到 <paramref name="typeName" /> 所需的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-218">
              <paramref name="typeName" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-219">找到 <paramref name="typeName" /> 所需的相依組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-219">
              <paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-220">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-220">-or-</span>
          </span>
          <span data-ttu-id="9629d-221">目前的組件已載入僅限反映的內容中，而且 <paramref name="typeName" /> 需要未預先載入的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-221">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-222">
            <paramref name="typeName" /> 需要相依組件，但這個檔案不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-222">
              <paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-223">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-223">-or-</span>
          </span>
          <span data-ttu-id="9629d-224">
            <paramref name="typeName" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-224">
              <paramref name="typeName" /> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-225">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-225">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-226">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-226">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-227">若要建立委派的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-227">to create an instance of a delegate.</span>
          </span>
          <span data-ttu-id="9629d-228">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-228">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <span data-ttu-id="9629d-229">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-229">The display name of an assembly.</span>
          </span>
        </param>
        <param name="typeName">
          <span data-ttu-id="9629d-230">類型的完整名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-230">The full name of a type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-231">建立類型名稱，由其組件的顯示名稱所限定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-231">Creates the name of a type qualified by the display name of its assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-232">類型的完整名稱是由組件的顯示名稱所限定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-232">The full name of the type qualified by the display name of the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-233">傳回字串的格式為：</span><span class="sxs-lookup"><span data-stu-id="9629d-233">The format of the returned string is:</span></span>  
  
 <span data-ttu-id="9629d-234">\<FullTypeName >， \<AssemblyDisplayName ></span><span class="sxs-lookup"><span data-stu-id="9629d-234">\<FullTypeName>, \<AssemblyDisplayName></span></span>  
  
 <span data-ttu-id="9629d-235">請參閱<xref:System.Reflection.AssemblyName>的組件的顯示名稱格式的說明。</span><span class="sxs-lookup"><span data-stu-id="9629d-235">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
 <span data-ttu-id="9629d-236">為了符合 common language runtime 的版本中的變更，請使用這個方法，而不是自行建構的限定的名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-236">To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</span></span>  <span data-ttu-id="9629d-237">如需完整的組件名稱的資訊，請參閱<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-237">For information about qualified assembly names, see <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-238">取得包含此組件之自訂屬性的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-238">Gets a collection that contains this assembly's custom attributes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-239">包含此組件之自訂屬性的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-239">A collection that contains this assembly's custom attributes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-240">取得這個組件中定義之類型的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-240">Gets a collection of the types defined in this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-241">這個組件中定義的類型集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-241">A collection of the types defined in this assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-242"><xref:System.Reflection.Assembly.DefinedTypes%2A>屬性相當於<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法，不同之處在於<xref:System.Reflection.Assembly.DefinedTypes%2A>屬性傳回的集合<xref:System.Reflection.TypeInfo>物件，而<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法傳回的陣列<xref:System.Type>物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-242">The <xref:System.Reflection.Assembly.DefinedTypes%2A> property is comparable to the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method, except that the <xref:System.Reflection.Assembly.DefinedTypes%2A> property returns a collection of <xref:System.Reflection.TypeInfo> objects, and the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method returns an array of <xref:System.Type> objects.</span></span>  
  
 <span data-ttu-id="9629d-243">傳回的陣列會包含巢狀型別。</span><span class="sxs-lookup"><span data-stu-id="9629d-243">The returned array includes nested types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-244">取得這個組件的進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-244">Gets the entry point of this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-245">物件，表示這個組件的進入點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-245">An object that represents the entry point of this assembly.</span>
          </span>
          <span data-ttu-id="9629d-246">如果找不到進入點 (例如，組件是 DLL)，則傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-246">If no entry point is found (for example, the assembly is a DLL), <see langword="null" /> is returned.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="9629d-247">與這個執行個體相互比較的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-247">The object to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-248">判斷這個組件和指定的物件是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-248">Determines whether this assembly and the specified object are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-249">如果 <paramref name="o" /> 等於這個執行個體則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-249">
              <see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-250"><xref:System.Reflection.Assembly.Equals%2A>方法會執行參考相等來判斷測試是否目前的執行個體和`o`相等。</span><span class="sxs-lookup"><span data-stu-id="9629d-250">The <xref:System.Reflection.Assembly.Equals%2A> method performs a test for reference equality to determine whether the current instance and `o` are equal.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-251">取得代表基礎碼的 URI，包括逸出字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-251">Gets the URI, including escape characters, that represents the codebase.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-252">具有逸出字元的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-252">A URI with escape characters.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-253">存取路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-253">for access to the path.</span>
          </span>
          <span data-ttu-id="9629d-254">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-254">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-255">取得這個組件的辨識碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-255">Gets the evidence for this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-256">這個組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-256">The evidence for this assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-257">所謂的辨識項是一組資訊，由輸入的安全性原則決策所構成，例如要將那些權限授與給程式碼。</span><span class="sxs-lookup"><span data-stu-id="9629d-257">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-258">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-258">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-259">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-259">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-260">取得在這個組件中定義的公用類型集合，而這些類型在組件外部是可見的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-260">Gets a collection of the public types defined in this assembly that are visible outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-261">在這個組件中定義的公用類型，而這些類型在組件外部是可見的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-261">A collection of the public types defined in this assembly that are visible outside the assembly.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-262">取得組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-262">Gets the display name of the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-263">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-263">The display name of the assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-264">請參閱<xref:System.Reflection.AssemblyName>的組件的顯示名稱格式的說明。</span><span class="sxs-lookup"><span data-stu-id="9629d-264">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-265">建議您不要撰寫自己的程式碼剖析顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-265">Writing your own code to parse display names is not recommended.</span></span> <span data-ttu-id="9629d-266">相反地，顯示將名稱傳遞給<xref:System.Reflection.AssemblyName.%23ctor%2A>建構函式加以剖析，並於其中填入新的適當欄位<xref:System.Reflection.AssemblyName>。</span><span class="sxs-lookup"><span data-stu-id="9629d-266">Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.</span></span>  
  
 <span data-ttu-id="9629d-267">在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="9629d-267">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="9629d-268">不過，它不包含在所傳回的字串<xref:System.Reflection.Assembly.FullName%2A>屬性，因為相容性。</span><span class="sxs-lookup"><span data-stu-id="9629d-268">However, it is not included in the string returned by the <xref:System.Reflection.Assembly.FullName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="9629d-269">請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-269">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-270">下列範例會擷取目前正在執行的組件的顯示名稱和包含的組件的顯示名稱<xref:System.Int32>型別 (`int`在 C# 中， `Integer` Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="9629d-270">The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <xref:System.Int32> type (`int` in C#, `Integer` in Visual Basic).</span></span>  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="9629d-271">物件，代表會傳回的組件類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-271">An object representing a type in the assembly that will be returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-272">取得目前載入的組件，其中定義指定類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-272">Gets the currently loaded assembly in which the specified type is defined.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-273">組件，其中定義指定類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-273">The assembly in which the specified type is defined.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-274">呼叫這個方法就相當於擷取的值<xref:System.Type.Assembly?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-274">Calling this method is equivalent to retrieving the value of the  <xref:System.Type.Assembly?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="9629d-275">不過，<xref:System.Type.Assembly?displayProperty=nameWithType>屬性通常會提供更優異的效能。</span><span class="sxs-lookup"><span data-stu-id="9629d-275">However, the <xref:System.Type.Assembly?displayProperty=nameWithType> property typically offers superior performance.</span></span>  
  
 <span data-ttu-id="9629d-276">若要呼叫這個方法，您必須擁有<xref:System.Type>物件，這表示在其中定義該類別的組件必須已經載入。</span><span class="sxs-lookup"><span data-stu-id="9629d-276">In order to call this method, you must have a <xref:System.Type> object, which means that the assembly in which the class is defined must already be loaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-277">下列範例會擷取包含的組件<xref:System.Int32>輸入，並顯示其名稱和檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="9629d-277">The following example retrieves the assembly that contains the <xref:System.Int32> type and displays its name and file location.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-278">
            <paramref name="type" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-278">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-279">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-279">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-280">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-280">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-281">傳回方法的 <see cref="T:System.Reflection.Assembly" />，其叫用目前執行的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-281">Returns the <see cref="T:System.Reflection.Assembly" /> of the method that invoked the currently executing method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-282">方法的 <see langword="Assembly" /> 物件，其叫用目前執行的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-282">The <see langword="Assembly" /> object of the method that invoked the currently executing method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-283">如果此方法，會呼叫<xref:System.Reflection.Assembly.GetCallingAssembly%2A>方法是由在 just-in-time (JIT) 編譯器內嵌展開，或是如果內嵌方式展開其呼叫端，組件所傳回<xref:System.Reflection.Assembly.GetCallingAssembly%2A>意外可能不同。</span><span class="sxs-lookup"><span data-stu-id="9629d-283">If the method that calls the <xref:System.Reflection.Assembly.GetCallingAssembly%2A> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <xref:System.Reflection.Assembly.GetCallingAssembly%2A> may differ unexpectedly.</span></span> <span data-ttu-id="9629d-284">例如，請考慮下列方法和組件：</span><span class="sxs-lookup"><span data-stu-id="9629d-284">For example, consider the following methods and assemblies:</span></span>  
  
-   <span data-ttu-id="9629d-285">方法`M1`組件中`A1`呼叫<xref:System.Reflection.Assembly.GetCallingAssembly%2A>。</span><span class="sxs-lookup"><span data-stu-id="9629d-285">Method `M1` in assembly `A1` calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
-   <span data-ttu-id="9629d-286">方法`M2`組件中`A2`呼叫`M1`。</span><span class="sxs-lookup"><span data-stu-id="9629d-286">Method `M2` in assembly `A2` calls `M1`.</span></span>  
  
-   <span data-ttu-id="9629d-287">方法`M3`組件中`A3`呼叫`M2`。</span><span class="sxs-lookup"><span data-stu-id="9629d-287">Method `M3` in assembly `A3` calls `M2`.</span></span>  
  
 <span data-ttu-id="9629d-288">當`M1`不是內嵌<xref:System.Reflection.Assembly.GetCallingAssembly%2A>傳回`A2`。</span><span class="sxs-lookup"><span data-stu-id="9629d-288">When `M1` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="9629d-289">當`M1`是內嵌<xref:System.Reflection.Assembly.GetCallingAssembly%2A>傳回`A3`。</span><span class="sxs-lookup"><span data-stu-id="9629d-289">When `M1` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span> <span data-ttu-id="9629d-290">同樣地，當`M2`不是內嵌<xref:System.Reflection.Assembly.GetCallingAssembly%2A>傳回`A2`。</span><span class="sxs-lookup"><span data-stu-id="9629d-290">Similarly, when `M2` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="9629d-291">當`M2`是內嵌<xref:System.Reflection.Assembly.GetCallingAssembly%2A>傳回`A3`。</span><span class="sxs-lookup"><span data-stu-id="9629d-291">When `M2` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span>  
  
 <span data-ttu-id="9629d-292">也會發生這種效果時`M1`為結尾的呼叫，從執行`M2`，或當`M2`為結尾的呼叫，從執行`M3`。</span><span class="sxs-lookup"><span data-stu-id="9629d-292">This effect also occurs when `M1` executes as a tail call from `M2`, or when `M2` executes as a tail call from `M3`.</span></span> <span data-ttu-id="9629d-293">您可以防止 JIT 編譯器內嵌呼叫的方法<xref:System.Reflection.Assembly.GetCallingAssembly%2A>，藉由套用<xref:System.Runtime.CompilerServices.MethodImplAttribute>屬性搭配<xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType>旗標，但沒有任何類似的機制，可防止 tail 呼叫。</span><span class="sxs-lookup"><span data-stu-id="9629d-293">You can prevent the JIT compiler from inlining the method that calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, by applying the <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribute with the <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, but there is no similar mechanism for preventing tail calls.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-294">下列範例會取得目前的方法呼叫的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-294">The following example gets the calling assembly of the current method.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-295">取得這個組件的自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-295">Gets the custom attributes for this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="9629d-296">
            <see cref="T:System.Reflection.Assembly" /> 類型的物件會忽略這個引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-296">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-297">取得這個組件的所有自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-297">Gets all the custom attributes for this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-298">包含此組件之自訂屬性的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-298">An array that contains the custom attributes for this assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-299">這個方法會實作對應<xref:System.Reflection.ICustomAttributeProvider>介面方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-299">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="9629d-300">因此，`inherit`必須指定參數，即使它會被忽略。</span><span class="sxs-lookup"><span data-stu-id="9629d-300">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="9629d-301">虛擬的屬性會指出時有這個屬性時，必須設定核心中繼資料的位元。</span><span class="sxs-lookup"><span data-stu-id="9629d-301">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="9629d-302">與擴充類型的中繼資料，並儲存以及類型的自訂屬性，不同的是虛擬屬性修改類型的中繼資料，則會捨棄。</span><span class="sxs-lookup"><span data-stu-id="9629d-302">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="9629d-303">某些產生的位元不能使用現有的反映 Api 來存取。</span><span class="sxs-lookup"><span data-stu-id="9629d-303">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="9629d-304">下表摘要說明不同的虛擬屬性和可反映中的位元的存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-304">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="9629d-305">虛擬屬性</span><span class="sxs-lookup"><span data-stu-id="9629d-305">Pseudo-Attribute</span></span>|<span data-ttu-id="9629d-306">中繼資料位元</span><span class="sxs-lookup"><span data-stu-id="9629d-306">Metadata Bits</span></span>|<span data-ttu-id="9629d-307">反映存取子</span><span class="sxs-lookup"><span data-stu-id="9629d-307">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="9629d-308">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-308">DllImportAttribute</span></span>|<span data-ttu-id="9629d-309">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="9629d-309">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="9629d-310">DLL 名稱</span><span class="sxs-lookup"><span data-stu-id="9629d-310">DLL name</span></span>|<span data-ttu-id="9629d-311">沒有存取子 PInvokeMap 一般方法/全域方法屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-311">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="9629d-312">DLL 名稱沒有存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-312">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="9629d-313">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-313">GuidAttribute</span></span>|<span data-ttu-id="9629d-314">儲存為真正的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-314">Stored as a real custom attribute.</span></span>|<span data-ttu-id="9629d-315">存取為真正的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-315">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="9629d-316">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-316">ComImportAttribute</span></span>|<span data-ttu-id="9629d-317">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="9629d-317">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="9629d-318">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="9629d-318">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="9629d-319">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-319">SerializableAttribute</span></span>|<span data-ttu-id="9629d-320">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="9629d-320">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="9629d-321">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="9629d-321">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="9629d-322">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-322">NonSerializedAttribute</span></span>|<span data-ttu-id="9629d-323">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="9629d-323">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="9629d-324">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="9629d-324">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="9629d-325">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-325">MethodImplAttribute</span></span>|<span data-ttu-id="9629d-326">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="9629d-326">CorMethodImpl</span></span>|<span data-ttu-id="9629d-327">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="9629d-327">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="9629d-328">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="9629d-328">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="9629d-329">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-329">MarshalAsAttribute</span></span>|<span data-ttu-id="9629d-330">各種不同的位元。</span><span class="sxs-lookup"><span data-stu-id="9629d-330">Various bits.</span></span>|<span data-ttu-id="9629d-331">沒有存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-331">No accessor.</span></span>|  
|<span data-ttu-id="9629d-332">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-332">PreserveSigAttribute</span></span>|<span data-ttu-id="9629d-333">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="9629d-333">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="9629d-334">MethodInfo.GetMethodImplementationFlags()。OLE</span><span class="sxs-lookup"><span data-stu-id="9629d-334">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="9629d-335">ConstructorInfo.GetMethodImplementationFlags()。OLE</span><span class="sxs-lookup"><span data-stu-id="9629d-335">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="9629d-336">InAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-336">InAttribute</span></span>|<span data-ttu-id="9629d-337">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="9629d-337">CorParamAttr.pdIn</span></span>|<span data-ttu-id="9629d-338">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="9629d-338">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="9629d-339">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-339">OutAttribute</span></span>|<span data-ttu-id="9629d-340">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="9629d-340">CorParamAttr.pdOut</span></span>|<span data-ttu-id="9629d-341">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="9629d-341">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="9629d-342">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-342">StructLayoutAttribute</span></span>|<span data-ttu-id="9629d-343">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="9629d-343">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="9629d-344">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="9629d-344">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="9629d-345">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="9629d-345">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="9629d-346">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="9629d-346">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="9629d-347">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="9629d-347">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="9629d-348">類別封裝。</span><span class="sxs-lookup"><span data-stu-id="9629d-348">Class packing.</span></span>|<span data-ttu-id="9629d-349">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="9629d-349">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="9629d-350">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="9629d-350">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="9629d-351">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="9629d-351">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="9629d-352">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="9629d-352">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="9629d-353">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="9629d-353">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="9629d-354">沒有存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-354">No accessor.</span></span>|  
|<span data-ttu-id="9629d-355">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-355">FieldOffsetAttribute</span></span>|<span data-ttu-id="9629d-356">欄位的位移。</span><span class="sxs-lookup"><span data-stu-id="9629d-356">Field offset.</span></span>|<span data-ttu-id="9629d-357">沒有存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-357">No accessor.</span></span>|  
|<span data-ttu-id="9629d-358">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-358">AssemblyLoadAttribute</span></span>|<span data-ttu-id="9629d-359">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="9629d-359">CorAssemblyFlags</span></span>|<span data-ttu-id="9629d-360">沒有存取子或列舉值。</span><span class="sxs-lookup"><span data-stu-id="9629d-360">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-361">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-361">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-362">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-362">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="9629d-363">要為其傳回自訂屬性的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-363">The type for which the custom attributes are to be returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="9629d-364">
            <see cref="T:System.Reflection.Assembly" /> 類型的物件會忽略這個引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-364">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-365">取得這個組件由類型所指定的自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-365">Gets the custom attributes for this assembly as specified by type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-366">包含這個組件之自訂屬性的陣列，這些自訂屬性是由 <paramref name="attributeType" /> 所指定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-366">An array that contains the custom attributes for this assembly as specified by <paramref name="attributeType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-367">這個方法會實作對應<xref:System.Reflection.ICustomAttributeProvider>介面方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-367">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="9629d-368">因此，`inherit`必須指定參數，即使它會被忽略。</span><span class="sxs-lookup"><span data-stu-id="9629d-368">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="9629d-369">虛擬的屬性會指出時有這個屬性時，必須設定核心中繼資料的位元。</span><span class="sxs-lookup"><span data-stu-id="9629d-369">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="9629d-370">與擴充類型的中繼資料，並儲存以及類型的自訂屬性，不同的是虛擬屬性修改類型的中繼資料，則會捨棄。</span><span class="sxs-lookup"><span data-stu-id="9629d-370">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="9629d-371">某些產生的位元不能使用現有的反映 Api 來存取。</span><span class="sxs-lookup"><span data-stu-id="9629d-371">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="9629d-372">下表摘要說明不同的虛擬屬性和可反映中的位元的存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-372">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="9629d-373">虛擬屬性</span><span class="sxs-lookup"><span data-stu-id="9629d-373">Pseudo-Attribute</span></span>|<span data-ttu-id="9629d-374">中繼資料位元</span><span class="sxs-lookup"><span data-stu-id="9629d-374">Metadata Bits</span></span>|<span data-ttu-id="9629d-375">反映存取子</span><span class="sxs-lookup"><span data-stu-id="9629d-375">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="9629d-376">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-376">DllImportAttribute</span></span>|<span data-ttu-id="9629d-377">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="9629d-377">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="9629d-378">DLL 名稱</span><span class="sxs-lookup"><span data-stu-id="9629d-378">DLL name</span></span>|<span data-ttu-id="9629d-379">沒有存取子 PInvokeMap 一般方法/全域方法屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-379">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="9629d-380">DLL 名稱沒有存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-380">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="9629d-381">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-381">GuidAttribute</span></span>|<span data-ttu-id="9629d-382">儲存為真正的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-382">Stored as a real custom attribute.</span></span>|<span data-ttu-id="9629d-383">存取為真正的自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-383">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="9629d-384">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-384">ComImportAttribute</span></span>|<span data-ttu-id="9629d-385">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="9629d-385">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="9629d-386">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="9629d-386">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="9629d-387">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-387">SerializableAttribute</span></span>|<span data-ttu-id="9629d-388">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="9629d-388">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="9629d-389">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="9629d-389">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="9629d-390">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-390">NonSerializedAttribute</span></span>|<span data-ttu-id="9629d-391">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="9629d-391">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="9629d-392">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="9629d-392">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="9629d-393">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-393">MethodImplAttribute</span></span>|<span data-ttu-id="9629d-394">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="9629d-394">CorMethodImpl</span></span>|<span data-ttu-id="9629d-395">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="9629d-395">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="9629d-396">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="9629d-396">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="9629d-397">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-397">MarshalAsAttribute</span></span>|<span data-ttu-id="9629d-398">各種不同的位元。</span><span class="sxs-lookup"><span data-stu-id="9629d-398">Various bits.</span></span>|<span data-ttu-id="9629d-399">沒有存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-399">No accessor.</span></span>|  
|<span data-ttu-id="9629d-400">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-400">PreserveSigAttribute</span></span>|<span data-ttu-id="9629d-401">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="9629d-401">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="9629d-402">MethodInfo.GetMethodImplementationFlags()。OLE</span><span class="sxs-lookup"><span data-stu-id="9629d-402">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="9629d-403">ConstructorInfo.GetMethodImplementationFlags()。OLE</span><span class="sxs-lookup"><span data-stu-id="9629d-403">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="9629d-404">InAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-404">InAttribute</span></span>|<span data-ttu-id="9629d-405">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="9629d-405">CorParamAttr.pdIn</span></span>|<span data-ttu-id="9629d-406">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="9629d-406">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="9629d-407">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-407">OutAttribute</span></span>|<span data-ttu-id="9629d-408">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="9629d-408">CorParamAttr.pdOut</span></span>|<span data-ttu-id="9629d-409">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="9629d-409">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="9629d-410">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-410">StructLayoutAttribute</span></span>|<span data-ttu-id="9629d-411">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="9629d-411">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="9629d-412">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="9629d-412">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="9629d-413">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="9629d-413">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="9629d-414">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="9629d-414">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="9629d-415">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="9629d-415">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="9629d-416">類別封裝。</span><span class="sxs-lookup"><span data-stu-id="9629d-416">Class packing.</span></span>|<span data-ttu-id="9629d-417">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="9629d-417">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="9629d-418">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="9629d-418">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="9629d-419">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="9629d-419">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="9629d-420">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="9629d-420">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="9629d-421">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="9629d-421">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="9629d-422">沒有存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-422">No accessor.</span></span>|  
|<span data-ttu-id="9629d-423">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-423">FieldOffsetAttribute</span></span>|<span data-ttu-id="9629d-424">欄位的位移。</span><span class="sxs-lookup"><span data-stu-id="9629d-424">Field offset.</span></span>|<span data-ttu-id="9629d-425">沒有存取子。</span><span class="sxs-lookup"><span data-stu-id="9629d-425">No accessor.</span></span>|  
|<span data-ttu-id="9629d-426">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="9629d-426">AssemblyLoadAttribute</span></span>|<span data-ttu-id="9629d-427">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="9629d-427">CorAssemblyFlags</span></span>|<span data-ttu-id="9629d-428">沒有存取子或列舉值。</span><span class="sxs-lookup"><span data-stu-id="9629d-428">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-429">
            <paramref name="attributeType" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-429">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-430">
            <paramref name="attributeType" /> 不是執行階段型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-430">
              <paramref name="attributeType" /> is not a runtime type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-431">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-431">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-432">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-432">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-433">傳回已套用至目前 <see cref="T:System.Reflection.Assembly" /> 之屬性的相關資訊，表示為 <see cref="T:System.Reflection.CustomAttributeData" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-433">Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Assembly" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-434">
            <see cref="T:System.Reflection.CustomAttributeData" /> 物件的泛型清單，表示已套用至目前組件之屬性的資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-434">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-435">若要檢查的自訂屬性中僅限反映的內容，在其中已載入至僅限反映內容的程式碼中定義的自訂屬性本身的情況下的程式碼中使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-435">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="9629d-436">等方法<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>和<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>不能在這種情況下，因為它們會產生屬性的執行個體。</span><span class="sxs-lookup"><span data-stu-id="9629d-436">Methods like <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="9629d-437">無法執行僅限反映內容中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="9629d-437">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="9629d-438">如需詳細資訊和例如程式碼，請參閱<xref:System.Reflection.CustomAttributeData>類別。</span><span class="sxs-lookup"><span data-stu-id="9629d-438">For more information and for example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-439">取得預設應用程式定義域中的處理序可執行檔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-439">Gets the process executable in the default application domain.</span>
          </span>
          <span data-ttu-id="9629d-440">在其他應用程式定義域中，這是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 執行的第一個可執行檔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-440">In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-441">組件，該組件是預設應用程式定義域中的處理序可執行檔，或是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 執行的第一個可執行檔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-441">The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span>
          </span>
          <span data-ttu-id="9629d-442">從 Unmanaged 程式碼呼叫時，可能會傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-442">Can return <see langword="null" /> when called from unmanaged code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-443"><xref:System.Reflection.Assembly.GetEntryAssembly%2A>方法可以傳回`null`當 managed 組件已載入來自未受管理的應用程式。</span><span class="sxs-lookup"><span data-stu-id="9629d-443">The <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method can return `null` when a managed assembly has been loaded from an unmanaged application.</span></span> <span data-ttu-id="9629d-444">例如，如果未受管理的應用程式會建立以 C# 撰寫，呼叫 COM 元件的執行個體<xref:System.Reflection.Assembly.GetEntryAssembly%2A>C# 元件的方法會傳回 null，因為在程序的進入點是 unmanaged 程式碼，而不是 managed 組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-444">For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-445">取得組件，其中含有目前正在執行的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-445">Gets the assembly that contains the code that is currently executing.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-446">包含目前正在執行之程式碼的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-446">The assembly that contains the code that is currently executing.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-447">基於效能考量，您應該在您不知道在執行階段目前正在執行哪一個組件時，才呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-447">For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</span></span> <span data-ttu-id="9629d-448">建議用來擷取<xref:System.Reflection.Assembly>物件，表示目前的組件是使用<xref:System.Type.Assembly%2A?displayProperty=nameWithType>類型的屬性找到的組件，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="9629d-448">The recommended way to retrieve an <xref:System.Reflection.Assembly> object that represents the current assembly is to use the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property of a type found in the assembly, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 <span data-ttu-id="9629d-449">若要取得組件，其中包含呼叫目前執行的程式碼的方法，使用<xref:System.Reflection.Assembly.GetCallingAssembly%2A>。</span><span class="sxs-lookup"><span data-stu-id="9629d-449">To get the assembly that contains the method that called the currently executing code, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-450">下列範例會使用<xref:System.Type.Assembly%2A?displayProperty=nameWithType>取得目前執行的組件的屬性，根據該組件中所包含的型別。</span><span class="sxs-lookup"><span data-stu-id="9629d-450">The following example uses the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property to get the currently executing assembly based on a type contained in that assembly.</span></span> <span data-ttu-id="9629d-451">它也會呼叫<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>方法，以顯示，它會傳回<xref:System.Reflection.Assembly>物件，代表相同的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-451">It also calls the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method to show that it returns an <xref:System.Reflection.Assembly> object that represents the same assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-452">取得在這個組件中定義的公用類型，而這些類型在組件外部是可見的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-452">Gets the public types defined in this assembly that are visible outside the assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-453">陣列，表示在這個組件中定義的類型，而這些類型會在組件外部顯示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-453">An array that represents the types defined in this assembly that are visible outside the assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-454">組件外部可見的類型才是公用類型和其他公用型別內的巢狀的公用型別。</span><span class="sxs-lookup"><span data-stu-id="9629d-454">The only types visible outside an assembly are public types and public types nested within other public types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-455">下列程式碼範例會定義數個類別使用各種存取層級，與呼叫<xref:System.Reflection.Assembly.GetExportedTypes%2A>來顯示組件外部可見的項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-455">The following code sample defines a number of classes with various access levels, and calls <xref:System.Reflection.Assembly.GetExportedTypes%2A> to display the ones that are visible from outside the assembly.</span></span>  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9629d-456">該組件是動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-456">The assembly is a dynamic assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-457">無法載入相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-457">Unable to load a dependent assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9629d-458">指定檔案的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-458">The name of the specified file.</span>
          </span>
          <span data-ttu-id="9629d-459">切勿包括該檔案的路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-459">Do not include the path to the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-460">取得指定之檔案的 <see cref="T:System.IO.FileStream" />，這個指定之檔案位於這個組件的資訊清單檔案表中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-460">Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-461">包含指定之檔案的資料流，如果找不到檔案則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-461">A stream that contains the specified file, or <see langword="null" /> if the file is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-462">此方法適用於這兩個公用和私用資源檔案。</span><span class="sxs-lookup"><span data-stu-id="9629d-462">This method works on both public and private resource files.</span></span>  
  
 <span data-ttu-id="9629d-463">`name`不應該包含檔案的路徑。</span><span class="sxs-lookup"><span data-stu-id="9629d-463">The `name` should not include the path to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-464">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-464">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-465">
            <paramref name="name" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-465">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-466">
            <paramref name="name" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-466">The <paramref name="name" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-467">找不到 <paramref name="name" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-467">
              <paramref name="name" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-468">
            <paramref name="name" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-468">
              <paramref name="name" /> is not a valid assembly.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-469">為存取路徑，並讀取指定的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-469">for access to the path and for reading the specified file.</span>
          </span>
          <span data-ttu-id="9629d-470">相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-470">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-471">取得組件資訊清單檔案表中的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-471">Gets the files in the file table of an assembly manifest.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-472">取得組件資訊清單檔案表中的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-472">Gets the files in the file table of an assembly manifest.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-473">包含檔案之資料流的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-473">An array of streams that contain the files.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-474">此方法適用於公用和私用的資源檔。</span><span class="sxs-lookup"><span data-stu-id="9629d-474">This method works on public and private resource files.</span></span>  
  
 <span data-ttu-id="9629d-475">這個多載就相當於呼叫<xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29>多載，並指定`false`。</span><span class="sxs-lookup"><span data-stu-id="9629d-475">This overload is equivalent to calling the <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload and specifying `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-476">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-476">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-477">找不到檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-477">A file was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-478">檔案不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-478">A file was not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <span data-ttu-id="9629d-479">若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-479">
              <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-480">取得組件資訊清單檔案表中的檔案，指定是否要包含資源模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-480">Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-481">包含檔案之資料流的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-481">An array of streams that contain the files.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-482">此方法適用於公用和私用的資源檔。</span><span class="sxs-lookup"><span data-stu-id="9629d-482">This method works on public and private resource files.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-483">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-483">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-484">找不到檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-484">A file was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-485">檔案不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-485">A file was not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-486">傳回這個執行個體的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-486">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-487">32 位元帶正負號的整數雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-487">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-488">取得做為這個組件部分的所有載入模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-488">Gets all the loaded modules that are part of this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-489">取得做為這個組件部分的所有載入模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-489">Gets all the loaded modules that are part of this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-490">模組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-490">An array of modules.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <span data-ttu-id="9629d-491">若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-491">
              <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-492">取得做為這個組件部分的所有載入模組，指定是否要包含資源模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-492">Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-493">模組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-493">An array of modules.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">
          <span data-ttu-id="9629d-494">區分大小寫的資源名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-494">The case-sensitive name of the resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-495">傳回指定資源已保存方式的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-495">Returns information about how the given resource has been persisted.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-496">物件，其中會填入有關資源拓撲的資訊，如果找不到資源，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-496">An object that is populated with information about the resource's topology, or <see langword="null" /> if the resource is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-497">只有當資源會顯示呼叫者，或呼叫端時，才會傳回資源資訊<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="9629d-497">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-498">
            <paramref name="resourceName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-498">
              <paramref name="resourceName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-499">
            <paramref name="resourceName" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-499">The <paramref name="resourceName" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-500">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-500">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-501">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-501">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-502">傳回這個組件中的所有資源名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-502">Returns the names of all the resources in this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-503">陣列，包含所有資源的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-503">An array that contains the names of all the resources.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-504">您可以使用每個資源名稱，如下所示，這個方法所傳回陣列中：</span><span class="sxs-lookup"><span data-stu-id="9629d-504">You can use each resource name in the array returned by this method as follows:</span></span>  
  
-   <span data-ttu-id="9629d-505">您可以傳遞要的資源名稱<xref:System.Reflection.Assembly.GetManifestResourceInfo%2A>方法來取得資源的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="9629d-505">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> method to get additional information about the resource.</span></span>  
  
-   <span data-ttu-id="9629d-506">如果名稱識別的二進位.resources 檔案，您可以移除其.resources 檔的副檔名，並將它傳遞給<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType>建構函式來具現化資源管理員。</span><span class="sxs-lookup"><span data-stu-id="9629d-506">If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructor to instantiate the resource manager.</span></span>  
  
-   <span data-ttu-id="9629d-507">您可以傳遞要的資源名稱<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>方法來擷取<xref:System.IO.Stream>物件，您可以傳遞至<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="9629d-507">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="9629d-508">您可以傳遞要的資源名稱<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>方法來擷取<xref:System.IO.Stream>物件，您可以傳遞至<xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="9629d-508">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
 <span data-ttu-id="9629d-509">只有當資源會顯示呼叫者，或呼叫端時，才會傳回資源資訊<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="9629d-509">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-510">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-510">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-511">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-511">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-512">載入來自這個組件的指定資訊清單資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-512">Loads the specified manifest resource from this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9629d-513">所要求的資訊清單資源的區分大小寫名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-513">The case-sensitive name of the manifest resource being requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-514">載入來自這個組件的指定資訊清單資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-514">Loads the specified manifest resource from this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-515">資訊清單資源，而如果編譯期間未指定資源或是呼叫者看不到該資源，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-515">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-516">資訊清單資源是在編譯時期的組件中內嵌的資源 （例如影像檔）。</span><span class="sxs-lookup"><span data-stu-id="9629d-516">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="9629d-517">如需有關資訊清單資源的詳細資訊，請參閱[Microsoft.NET Framework 資源的基本概念](http://go.microsoft.com/fwlink/?LinkId=204554)MSDN Library 中。</span><span class="sxs-lookup"><span data-stu-id="9629d-517">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](http://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="9629d-518">只有當資源會顯示呼叫者，或呼叫端時，才會傳回資源資訊<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="9629d-518">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-519">這個方法會傳回`null`如果存取私用的資源，另一個組件，而且呼叫端沒有<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="9629d-519">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="9629d-520">如果組件資訊清單列出的資源檔<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>傳回<xref:System.IO.Stream>物件即使資源檔在找不在磁碟上的時間。</span><span class="sxs-lookup"><span data-stu-id="9629d-520">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="9629d-521">如果找不到資源檔，並傳遞產生<xref:System.IO.Stream>物件至<xref:System.Resources.ResourceReader>建構函式會導致<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-521">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-522">
            <paramref name="name" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-522">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-523">
            <paramref name="name" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-523">The <paramref name="name" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-524">
            <block subset="none" type="note">
              <para>在[適用於 Microsoft Store 應用程式的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)中或[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為捕捉基底類別例外狀況 <see cref="T:System.IO.IOException" />。</para>
            </block>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-524">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  </para>
              </block>
            </span>
          </span>
          <span data-ttu-id="9629d-525">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-525">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-526">找不到 <paramref name="name" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-526">
              <paramref name="name" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-527">
            <paramref name="name" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-527">
              <paramref name="name" /> is not a valid assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="9629d-528">資源長度大於 <see cref="F:System.Int64.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-528">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-529">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-529">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-530">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-530">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="9629d-531">類型，其命名空間是用來限定資訊清單資源名稱的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-531">The type whose namespace is used to scope the manifest resource name.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="9629d-532">所要求的資訊清單資源的區分大小寫名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-532">The case-sensitive name of the manifest resource being requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-533">從這個組件載入指定資訊清單資源，由指定類型的命名空間限定範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-533">Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-534">資訊清單資源，而如果編譯期間未指定資源或是呼叫者看不到該資源，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-534">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-535">比方說，如果完整名稱指定給`type`是 「 MyNameSpace.MyClasses"和`name`是"Net"，這個方法多載搜尋名為"MyNameSpace.Net 」 的資源。</span><span class="sxs-lookup"><span data-stu-id="9629d-535">For example, if the full name specified for `type` is "MyNameSpace.MyClasses" and `name` is "Net", this method overload searches for a resource named "MyNameSpace.Net".</span></span>  
  
 <span data-ttu-id="9629d-536">資訊清單資源是在編譯時期的組件中內嵌的資源 （例如影像檔）。</span><span class="sxs-lookup"><span data-stu-id="9629d-536">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="9629d-537">如需有關資訊清單資源的詳細資訊，請參閱[Microsoft.NET Framework 資源的基本概念](http://go.microsoft.com/fwlink/?LinkId=204554)MSDN Library 中。</span><span class="sxs-lookup"><span data-stu-id="9629d-537">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](http://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="9629d-538">只有當資源會顯示呼叫者，或呼叫端時，才會傳回資源資訊<xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="9629d-538">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-539">這個方法會傳回`null`如果存取私用的資源，另一個組件，而且呼叫端沒有<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="9629d-539">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="9629d-540">如果組件資訊清單列出的資源檔<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>傳回<xref:System.IO.Stream>物件即使資源檔在找不在磁碟上的時間。</span><span class="sxs-lookup"><span data-stu-id="9629d-540">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="9629d-541">如果找不到資源檔，並傳遞產生<xref:System.IO.Stream>物件至<xref:System.Resources.ResourceReader>建構函式會導致<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-541">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-542">
            <paramref name="name" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-542">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-543">
            <paramref name="name" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-543">The <paramref name="name" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-544">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-544">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-545">找不到 <paramref name="name" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-545">
              <paramref name="name" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-546">
            <paramref name="name" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-546">
              <paramref name="name" /> is not a valid assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="9629d-547">資源長度大於 <see cref="F:System.Int64.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-547">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="9629d-548">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-548">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="9629d-549">相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-549">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9629d-550">所要求的模組名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-550">The name of the module being requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-551">取得這個組件中的指定模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-551">Gets the specified module in this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-552">正在接受要求的模組，如果找不到模組，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-552">The module being requested, or <see langword="null" /> if the module is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-553">此方法適用於檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-553">This method works on file names.</span></span>  
  
 <span data-ttu-id="9629d-554">中的類別`Reflection.Emit`命名空間發出動態模組的範圍名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-554">Classes in the `Reflection.Emit` namespace emit the scope name for a dynamic module.</span></span> <span data-ttu-id="9629d-555">領域名稱可以由<xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-555">The scope name can be determined by the <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="9629d-556">傳遞您想要的模組類型`Assembly.GetModule`。</span><span class="sxs-lookup"><span data-stu-id="9629d-556">Pass the kind of module you want to `Assembly.GetModule`.</span></span> <span data-ttu-id="9629d-557">比方說，如果您想包含組件資訊清單的模組時，傳遞到模組的範圍名稱`GetModule`。</span><span class="sxs-lookup"><span data-stu-id="9629d-557">For example, if you want the module that contains the assembly manifest, pass the scope name of the module to `GetModule`.</span></span> <span data-ttu-id="9629d-558">否則，請傳遞模組的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-558">Otherwise, pass the file name of the module.</span></span> <span data-ttu-id="9629d-559">載入組件，這是由其中一個`Load`具有 byte [] 參數的方法只有一個的模組，這是資訊清單模組。</span><span class="sxs-lookup"><span data-stu-id="9629d-559">Assemblies loaded by one of the `Load` methods that have a byte[] parameter have only one module, and that is the manifest module.</span></span> <span data-ttu-id="9629d-560">一律搜尋這些使用範圍名稱的模組。</span><span class="sxs-lookup"><span data-stu-id="9629d-560">Always seek these modules using the scope name.</span></span>  
  
 <span data-ttu-id="9629d-561">型別可以擷取從特定模組使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-561">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9629d-562">呼叫`Module.GetType`模組包含資訊清單不會起始一整個組件的搜尋。</span><span class="sxs-lookup"><span data-stu-id="9629d-562">Calling `Module.GetType` on the module containing the manifest will not initiate a search of the entire assembly.</span></span> <span data-ttu-id="9629d-563">若要擷取類型從組件，不論哪一個模組是在中，您必須呼叫<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-563">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-564">
            <paramref name="name" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-564">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-565">
            <paramref name="name" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-565">The <paramref name="name" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-566">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-566">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-567">找不到 <paramref name="name" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-567">
              <paramref name="name" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-568">
            <paramref name="name" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-568">
              <paramref name="name" /> is not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-569">取得所有屬於這個組件的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-569">Gets all the modules that are part of this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-570">取得所有屬於這個組件的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-570">Gets all the modules that are part of this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-571">模組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-571">An array of modules.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-572">此方法適用於公用和私用的資源檔。</span><span class="sxs-lookup"><span data-stu-id="9629d-572">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-573">模組必須發出具有副檔名的檔案。</span><span class="sxs-lookup"><span data-stu-id="9629d-573">Modules must be emitted with file name extensions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-574">下列範例會傳回的陣列，其中包含組件資訊清單中顯示模組的名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-574">The following example displays the name of the module in the returned array that contains the assembly manifest.</span></span>  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-575">要載入的模組未指定副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-575">The module to be loaded does not specify a file name extension.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <span data-ttu-id="9629d-576">若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-576">
              <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-577">取得所有屬於這個組件的模組，指定是否要包含資源模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-577">Gets all the modules that are part of this assembly, specifying whether to include resource modules.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-578">模組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-578">An array of modules.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-579">此方法適用於公用和私用的資源檔。</span><span class="sxs-lookup"><span data-stu-id="9629d-579">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-580">模組必須發出具有副檔名的檔案。</span><span class="sxs-lookup"><span data-stu-id="9629d-580">Modules must be emitted with file name extensions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-581">取得這個組件的 <see cref="T:System.Reflection.AssemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-581">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-582">取得這個組件的 <see cref="T:System.Reflection.AssemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-582">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-583">物件，包含這個組件的完整剖析顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-583">An object that contains the fully parsed display name for this assembly.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-584">用於存取組件的路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-584">for access to the path of the assembly.</span>
          </span>
          <span data-ttu-id="9629d-585">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-585">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <span data-ttu-id="9629d-586">若要將 <see langword="true" /> 設定為組件陰影複製以後的位置，則為 <see cref="P:System.Reflection.Assembly.CodeBase" />；若要將 <see langword="false" /> 設定為原始位置，則為 <see cref="P:System.Reflection.Assembly.CodeBase" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-586">
              <see langword="true" /> to set the <see cref="P:System.Reflection.Assembly.CodeBase" /> to the location of the assembly after it was shadow copied; <see langword="false" /> to set <see cref="P:System.Reflection.Assembly.CodeBase" /> to the original location.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-587">取得這個組件的 <see cref="T:System.Reflection.AssemblyName" />，設定按照 <paramref name="copiedName" /> 指定的基礎碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-587">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly, setting the codebase as specified by <paramref name="copiedName" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-588">物件，包含這個組件的完整剖析顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-588">An object that contains the fully parsed display name for this assembly.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-589">用於存取組件的路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-589">for access to the path of the assembly.</span>
          </span>
          <span data-ttu-id="9629d-590">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-590">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="9629d-591">要被填入 (Populate) 序列化資訊的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-591">The object to be populated with serialization information.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="9629d-592">序列化的目的端內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-592">The destination context of the serialization.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-593">使用要重新執行個體化這個組件所需的所有資料，取得序列化 (Serialization) 資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-593">Gets serialization information with all of the data needed to reinstantiate this assembly.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-594">
            <paramref name="info" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-594">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9629d-595">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-595">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9629d-596">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-596">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-597">取得這個組件參考之所有組件的 <see cref="T:System.Reflection.AssemblyName" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-597">Gets the <see cref="T:System.Reflection.AssemblyName" /> objects for all the assemblies referenced by this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-598">陣列，包含這個組件參考之所有組件的完整剖析顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-598">An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="9629d-599">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>屬性<xref:System.Reflection.AssemblyName>這個方法所傳回的物件是<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType>沒有雜湊演算法所參考的組件，則不是參考的組件的雜湊演算法由識別<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="9629d-599">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property of an <xref:System.Reflection.AssemblyName> object that is returned by this method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="9629d-600">在舊版的.NET Framework 中，<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>屬性傳回<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType>在此情況下。</span><span class="sxs-lookup"><span data-stu-id="9629d-600">In previous versions of the .NET Framework, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in this situation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-601">下列程式碼範例示範如何呼叫<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-601">The following code example demonstrates calling the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> method.</span></span> <span data-ttu-id="9629d-602">此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Assembly>類別。</span><span class="sxs-lookup"><span data-stu-id="9629d-602">This code example is part of a larger example provided for the <xref:System.Reflection.Assembly> class.</span></span>  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-603">取得附屬組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-603">Gets the satellite assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">
          <span data-ttu-id="9629d-604">指定的文化特性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-604">The specified culture.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-605">取得指定文化特性的附屬組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-605">Gets the satellite assembly for the specified culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-606">指定的附屬組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-606">The specified satellite assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-607">附屬組件包含不同主要應用程式組件，其中包含不可當地語系化的可執行程式碼和做為預設或中性文化特性之單一文化特性資源的當地語系化的資源。</span><span class="sxs-lookup"><span data-stu-id="9629d-607">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="9629d-608">呼叫這個方法，以使用您目前的組件版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-608">Call this method to use your current assembly version.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-609">
            <paramref name="culture" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-609">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-610">找不到組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-610">The assembly cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-611">找到具有相符檔名的附屬組件，但 <see langword="CultureInfo" /> 與所指定者不符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-611">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> did not match the one specified.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-612">此附屬組件不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-612">The satellite assembly is not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">
          <span data-ttu-id="9629d-613">指定的文化特性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-613">The specified culture.</span>
          </span>
        </param>
        <param name="version">
          <span data-ttu-id="9629d-614">附屬組件的版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-614">The version of the satellite assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-615">取得指定文化特性的附屬組件指定版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-615">Gets the specified version of the satellite assembly for the specified culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-616">指定的附屬組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-616">The specified satellite assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-617">附屬組件包含不同主要應用程式組件，其中包含不可當地語系化的可執行程式碼和做為預設或中性文化特性之單一文化特性資源的當地語系化的資源。</span><span class="sxs-lookup"><span data-stu-id="9629d-617">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="9629d-618">呼叫<xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29>多載，以使用您目前的組件版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-618">Call the <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload to use your current assembly version.</span></span>  
  
 <span data-ttu-id="9629d-619">如果`version`是`null`，如果將 資源 與 主要組件已簽署，系統會使用目前的組件版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-619">If `version` is `null`, the current assembly version is used if both the resource and main assemblies are signed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-620">
            <paramref name="culture" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-620">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-621">找到具有相符檔名的附屬組件，但 <see langword="CultureInfo" /> 或版本與所指定者不符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-621">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> or the version did not match the one specified.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-622">找不到組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-622">The assembly cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-623">此附屬組件不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-623">The satellite assembly is not a valid assembly.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-624">取得代表指定類型的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-624">Gets the <see cref="T:System.Type" /> object that represents the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9629d-625">類型的完整名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-625">The full name of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-626">取得具有組件執行個體中指定名稱的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-626">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-627">物件，表示指定的類別，如果找不到類別，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-627">An object that represents the specified class, or <see langword="null" /> if the class is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-628">這個方法只會搜尋目前組件執行個體。</span><span class="sxs-lookup"><span data-stu-id="9629d-628">This method only searches the current assembly instance.</span></span> <span data-ttu-id="9629d-629">`name`參數包含命名空間，但不是含組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-629">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="9629d-630">若要搜尋型別的其他組件，請使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法多載，可以選擇性地包含組件顯示名稱的型別名稱的一部分。</span><span class="sxs-lookup"><span data-stu-id="9629d-630">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-631">如果類型已轉送至另一個組件，它仍會傳回這個方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-631">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="9629d-632">類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-632">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-633">下列範例會定義抽象`MeansOfTransportation`類別中`Transportation`命名空間。</span><span class="sxs-lookup"><span data-stu-id="9629d-633">The following example defines an abstract `MeansOfTransportation` class in the `Transportation` namespace.</span></span> <span data-ttu-id="9629d-634">它會呼叫<xref:System.Reflection.Assembly.GetType%28System.String%29>方法來擷取其<xref:System.Type>物件時，會呼叫<xref:System.Type.GetProperties%2A?displayProperty=nameWithType>方法來取得各種<xref:System.Reflection.PropertyInfo>代表類型的屬性，然後在類型上顯示資訊的物件抽象屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-634">It calls the <xref:System.Reflection.Assembly.GetType%28System.String%29> method to retrieve its <xref:System.Type> object, calls the <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> method to get an array of <xref:System.Reflection.PropertyInfo> objects that represent the type's properties, and then displays information on the type's abstract properties.</span></span> <span data-ttu-id="9629d-635">請注意，呼叫<xref:System.Reflection.Assembly.GetType%28System.String%29>方法會使用型別的完整格式的名稱 （亦即，其型別名稱以及其命名空間）。</span><span class="sxs-lookup"><span data-stu-id="9629d-635">Note that the call to the <xref:System.Reflection.Assembly.GetType%28System.String%29> method uses the type's fully qualified name (that is, its namespace along with its type name).</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-636">
            <paramref name="name" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-636">
              <paramref name="name" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-637">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-637">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-638">找不到 <paramref name="name" /> 所需的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-638">
              <paramref name="name" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-639">
            <block subset="none" type="note">
              <para>在[適用於 Windows Store 應用程式的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。找到 </para>
            </block>
            <paramref name="name" /> 所需的相依組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-639">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  </para>
              </block>
              <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-640">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-640">-or-</span>
          </span>
          <span data-ttu-id="9629d-641">目前的組件已載入僅限反映的內容中，而且 <paramref name="name" /> 需要未預先載入的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-641">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-642">
            <paramref name="name" /> 需要相依組件，但這個檔案不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-642">
              <paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-643">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-643">-or-</span>
          </span>
          <span data-ttu-id="9629d-644">
            <paramref name="name" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-644">
              <paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9629d-645">類型的完整名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-645">The full name of the type.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="9629d-646">
            <see langword="true" /> 表示找不到該類型時擲回例外狀況，<see langword="false" /> 則表示傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-646">
              <see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-647">取得具有組件執行個體中指定之名稱的 <see cref="T:System.Type" /> 物件，並在找不到類型時選擇性地擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-647">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-648">表示指定之類別的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-648">An object that represents the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-649">這個方法只會搜尋目前組件執行個體。</span><span class="sxs-lookup"><span data-stu-id="9629d-649">This method only searches the current assembly instance.</span></span> <span data-ttu-id="9629d-650">`name`參數包含命名空間，但不是含組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-650">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="9629d-651">若要搜尋型別的其他組件，請使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法多載，可以選擇性地包含組件顯示名稱的型別名稱的一部分。</span><span class="sxs-lookup"><span data-stu-id="9629d-651">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-652">如果類型已轉送至另一個組件，它仍會傳回這個方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-652">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="9629d-653">類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-653">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="9629d-654">`throwOnError`參數只會影響找不到類型時，會發生什麼事。</span><span class="sxs-lookup"><span data-stu-id="9629d-654">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="9629d-655">它不會影響其他可能會擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9629d-655">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="9629d-656">特別是，如果找到的型別，但無法載入，<xref:System.TypeLoadException>可能會擲回即使`throwOnError`是`false`。</span><span class="sxs-lookup"><span data-stu-id="9629d-656">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-657">
            <paramref name="name" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-657">
              <paramref name="name" /> is invalid.</span>
          </span>
          <span data-ttu-id="9629d-658">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-658">-or-</span>
          </span>
          <span data-ttu-id="9629d-659">
            <paramref name="name" /> 的長度超過 1024 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-659">The length of <paramref name="name" /> exceeds 1024 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-660">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-660">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="9629d-661">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-661">
              <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-662">找不到 <paramref name="name" /> 所需的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-662">
              <paramref name="name" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-663">找到 <paramref name="name" /> 所需的相依組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-663">
              <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-664">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-664">-or-</span>
          </span>
          <span data-ttu-id="9629d-665">目前的組件已載入僅限反映的內容中，而且 <paramref name="name" /> 需要未預先載入的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-665">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-666">
            <paramref name="name" /> 需要相依組件，但這個檔案不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-666">
              <paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-667">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-667">-or-</span>
          </span>
          <span data-ttu-id="9629d-668">
            <paramref name="name" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-668">
              <paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9629d-669">類型的完整名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-669">The full name of the type.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="9629d-670">
            <see langword="true" /> 表示找不到該類型時擲回例外狀況，<see langword="false" /> 則表示傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-670">
              <see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="9629d-671">若要忽略類型名稱的大小寫，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-671">
              <see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-672">使用忽略大小寫和找不到類型時擲回例外狀況的選項，取得具有組件執行個體中指定之名稱的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-672">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-673">表示指定之類別的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-673">An object that represents the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-674">這個方法只會搜尋目前組件執行個體。</span><span class="sxs-lookup"><span data-stu-id="9629d-674">This method only searches the current assembly instance.</span></span> <span data-ttu-id="9629d-675">`name`參數包含命名空間，但不是含組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-675">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="9629d-676">若要搜尋型別的其他組件，請使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法多載，可以選擇性地包含組件顯示名稱的型別名稱的一部分。</span><span class="sxs-lookup"><span data-stu-id="9629d-676">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-677">如果類型已轉送至另一個組件，它仍會傳回這個方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-677">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="9629d-678">類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-678">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="9629d-679">`throwOnError`參數只會影響找不到類型時，會發生什麼事。</span><span class="sxs-lookup"><span data-stu-id="9629d-679">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="9629d-680">它不會影響其他可能會擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9629d-680">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="9629d-681">特別是，如果找到的型別，但無法載入，<xref:System.TypeLoadException>可能會擲回即使`throwOnError`是`false`。</span><span class="sxs-lookup"><span data-stu-id="9629d-681">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-682">
            <paramref name="name" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-682">
              <paramref name="name" /> is invalid.</span>
          </span>
          <span data-ttu-id="9629d-683">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-683">-or-</span>
          </span>
          <span data-ttu-id="9629d-684">
            <paramref name="name" /> 的長度超過 1024 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-684">The length of <paramref name="name" /> exceeds 1024 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-685">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-685">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="9629d-686">
            <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-686">
              <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-687">找不到 <paramref name="name" /> 所需的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-687">
              <paramref name="name" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-688">找到 <paramref name="name" /> 所需的相依組件，但無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-688">
              <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-689">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-689">-or-</span>
          </span>
          <span data-ttu-id="9629d-690">目前的組件已載入僅限反映的內容中，而且 <paramref name="name" /> 需要未預先載入的相依組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-690">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-691">
            <paramref name="name" /> 需要相依組件，但這個檔案不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-691">
              <paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-692">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-692">-or-</span>
          </span>
          <span data-ttu-id="9629d-693">
            <paramref name="name" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-693">
              <paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-694">取得定義於這個組件中的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-694">Gets the types defined in this assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-695">陣列，包含在這個組件中定義的所有類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-695">An array that contains all the types that are defined in this assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-696">傳回的陣列會包含巢狀型別。</span><span class="sxs-lookup"><span data-stu-id="9629d-696">The returned array includes nested types.</span></span>  
  
 <span data-ttu-id="9629d-697">如果<xref:System.Reflection.Assembly.GetTypes%2A>組件和型別上呼叫方法，因為組件相依於尚未載入 （例如，如果其衍生自第二個組件中的型別），組件中的型別<xref:System.Reflection.ReflectionTypeLoadException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="9629d-697">If the <xref:System.Reflection.Assembly.GetTypes%2A> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <xref:System.Reflection.ReflectionTypeLoadException> is thrown.</span></span> <span data-ttu-id="9629d-698">比方說，就可能發生此第一個組件已載入具有<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>或<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>未載入方法和第二個組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-698">For example, this can happen if the first assembly was loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods, and the second assembly was not loaded.</span></span> <span data-ttu-id="9629d-699">就可能也會使用載入的組件<xref:System.Reflection.Assembly.Load%2A>並<xref:System.Reflection.Assembly.LoadFile%2A>方法，如果第二個組件無法找到時<xref:System.Reflection.Assembly.GetTypes%2A>呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-699">It can also happen with assemblies loaded using the <xref:System.Reflection.Assembly.Load%2A> and <xref:System.Reflection.Assembly.LoadFile%2A> methods if the second assembly cannot be located when the <xref:System.Reflection.Assembly.GetTypes%2A> method is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-700">如果類型已轉送至另一個組件，它不包含傳回陣列中。</span><span class="sxs-lookup"><span data-stu-id="9629d-700">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="9629d-701">類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-701">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="9629d-702">若要擷取的集合<xref:System.Reflection.TypeInfo>而非陣列的物件<xref:System.Type>物件，使用<xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-702">To retrieve a collection of <xref:System.Reflection.TypeInfo> objects instead of an array of <xref:System.Type> objects, use the <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-703">下列範例會顯示在指定的組件中的型別上的其中一種方法的參數。</span><span class="sxs-lookup"><span data-stu-id="9629d-703">The following example displays parameters of one method on a type in the specified assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="9629d-704">此組件包含一或多個無法載入的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-704">The assembly contains one or more types that cannot be loaded.</span>
          </span>
          <span data-ttu-id="9629d-705">這個例外狀況的 <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> 屬性所傳回的陣列包含載入每個類型的 <see cref="T:System.Type" /> 物件和無法載入的每個類型的 <see langword="null" />，而 <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> 屬性包含無法載入之每個類型的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-705">The array returned by the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> property of this exception contains a <see cref="T:System.Type" /> object for each type that was loaded and <see langword="null" /> for each type that could not be loaded, while the <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> property contains an exception for each type that could not be loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-706">取得值，指出組件是否從全域組件快取載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-706">Gets a value indicating whether the assembly was loaded from the global assembly cache.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-707">如果組件是從全域組件快取載入，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-707">
              <see langword="true" /> if the assembly was loaded from the global assembly cache; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-708">取得用來載入組件的主應用程式內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-708">Gets the host context with which the assembly was loaded.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-709">
            <see cref="T:System.Int64" /> 值，表示用來載入組件的主應用程式內容 (如果有)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-709">An <see cref="T:System.Int64" /> value that indicates the host context with which the assembly was loaded, if any.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-710">取得字串，表示儲存在含有資訊清單之檔案中的 Common Language Runtime (CLR) 版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-710">Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-711">CLR 版本資料夾名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-711">The CLR version folder name.</span>
          </span>
          <span data-ttu-id="9629d-712">這不是完整的路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-712">This is not a full path.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-713">例如，.NET Framework 1.1 版的值會是 v1.1.4322。</span><span class="sxs-lookup"><span data-stu-id="9629d-713">For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</span></span> <span data-ttu-id="9629d-714">該版本的二進位檔案會位於路徑 %windir%\microsoft.net\framework\v1.1.4322。</span><span class="sxs-lookup"><span data-stu-id="9629d-714">The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</span></span>  
  
 <span data-ttu-id="9629d-715">根據預設，<xref:System.Reflection.Assembly.ImageRuntimeVersion%2A>設為用來建置組件的 clr 版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-715">By default, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> is set to the version of the CLR used to build the assembly.</span></span> <span data-ttu-id="9629d-716">不過，它可能會有已設定為另一個值在編譯時期。</span><span class="sxs-lookup"><span data-stu-id="9629d-716">However, it might have been set to another value at compile time.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="9629d-717">這個組件中要加以檢查的屬性類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-717">The type of the attribute to be checked for this assembly.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="9629d-718">這個類型的物件會忽略這個引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-718">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-719">指出是否已將指定的屬性套用至組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-719">Indicates whether or not a specified attribute has been applied to the assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-720">如果已將屬性套用至組件，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-720">
              <see langword="true" /> if the attribute has been applied to the assembly; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9629d-721">下列程式碼範例適用於<xref:System.Reflection.AssemblyTitleAttribute>屬性，以組件，然後再使用<xref:System.Reflection.Assembly.IsDefined%2A>表示是否已套用。</span><span class="sxs-lookup"><span data-stu-id="9629d-721">The following code example applies the <xref:System.Reflection.AssemblyTitleAttribute> attribute to an assembly and then uses <xref:System.Reflection.Assembly.IsDefined%2A> to indicate whether it was applied.</span></span> <span data-ttu-id="9629d-722">它也會測試未套用的屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-722">It also tests an attribute that was not applied.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-723">
            <paramref name="attributeType" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-723">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-724">
            <paramref name="attributeType" /> 使用無效的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-724">
              <paramref name="attributeType" /> uses an invalid type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-725">取得值，這個值表示目前組件是否使用反映發出在目前處理序中動態產生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-725">Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-726">如果目前組件是在目前處理序中動態產生，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-726">
              <see langword="true" /> if the current assembly was generated dynamically in the current process; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-727">動態組件由衍生類別<xref:System.Reflection.Emit.AssemblyBuilder>。</span><span class="sxs-lookup"><span data-stu-id="9629d-727">Dynamic assemblies are represented by the derived class <xref:System.Reflection.Emit.AssemblyBuilder>.</span></span>  
  
 <span data-ttu-id="9629d-728">動態組件儲存到磁碟，儲存的組件時不是動態的。</span><span class="sxs-lookup"><span data-stu-id="9629d-728">When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</span></span> <span data-ttu-id="9629d-729">如果已儲存的組件會載入至另一個應用程式定義域或處理程序，<xref:System.Reflection.Assembly.IsDynamic%2A>屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="9629d-729">If the saved assembly is loaded into another application domain or process, the <xref:System.Reflection.Assembly.IsDynamic%2A> property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-730">取得值，這個值表示目前組件是否以完全信任來載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-730">Gets a value that indicates whether the current assembly is loaded with full trust.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-731">如果目前組件是以完全信任來載入，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-731">
              <see langword="true" /> if the current assembly is loaded with full trust; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-732">載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-732">Loads an assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="9629d-733">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-733">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-734">載入具有通用物件檔案格式 (Common Object File Format，COFF) 之映像的組件 (包含發出的組件)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-734">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</span>
          </span>
          <span data-ttu-id="9629d-735">組件會載入至呼叫端的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-735">The assembly is loaded into the application domain of the caller.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-736">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-736">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-737">使用這個方法載入的組件的信任層級是與呼叫組件的信任層級相同。</span><span class="sxs-lookup"><span data-stu-id="9629d-737">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="9629d-738">若要從應用程式定義域的信任層級的位元組陣列載入組件，請使用<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="9629d-738">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="9629d-739">如需使用辨識項使用的多載<xref:System.Reflection.Assembly.Load%2A>方法採用位元組陣列，請參閱<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="9629d-739">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="9629d-740">反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-740">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="9629d-741">這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。</span><span class="sxs-lookup"><span data-stu-id="9629d-741">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="9629d-742">若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。</span><span class="sxs-lookup"><span data-stu-id="9629d-742">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="9629d-743">請注意，這個方法多載一定會建立新<xref:System.Reflection.Assembly>具有它自己的對應物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-743">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-744">
            <paramref name="rawAssembly" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-744">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-745">
            <paramref name="rawAssembly" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-745">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-746">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-746">-or-</span>
          </span>
          <span data-ttu-id="9629d-747">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="rawAssembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-747">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">
          <span data-ttu-id="9629d-748">描述要載入之組件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-748">The object that describes the assembly to be loaded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-749">載入組件，指定其 <see cref="T:System.Reflection.AssemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-749">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-750">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-750">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-751"><xref:System.IO.FileLoadException> 如果擲回`assemblyRef`指定完整的組件名稱和第一個符合的簡單名稱的組件有不同的版本、 文化特性或公開金鑰語彙基元。</span><span class="sxs-lookup"><span data-stu-id="9629d-751"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="9629d-752">載入器不會繼續探查比對的簡單名稱的其他組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-752">The loader does not continue probing for other assemblies that match the simple name.</span></span> <span data-ttu-id="9629d-753">因為遠端組件中的程式碼的執行已停用預設的情況下，.NET Framework 4 中，從開始<xref:System.IO.FileLoadException>如果也會擲回`assemblyRef`指定遠端組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-753">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="9629d-754">若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-754">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>     
  
> [!NOTE]
>  <span data-ttu-id="9629d-755">請勿使用<xref:System.Reflection.AssemblyName>只有<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性集。</span><span class="sxs-lookup"><span data-stu-id="9629d-755">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="9629d-756"><xref:System.Reflection.AssemblyName.CodeBase%2A>不提供任何項目 （例如名稱或版本） 的組件身分識別，因此載入不會根據負載所識別的規則，如您所預期<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-756">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="9629d-757">相反地，會載入組件，使用載入來源的規則。</span><span class="sxs-lookup"><span data-stu-id="9629d-757">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="9629d-758">使用載入來源內容的缺點的相關資訊，請參閱<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法多載或[組件載入的最佳作法](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-758">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="9629d-759">是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="9629d-759">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="9629d-760">組件和安全性辨識項合併的規則如下所示：</span><span class="sxs-lookup"><span data-stu-id="9629d-760">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="9629d-761">當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-761">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="9629d-762">當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="9629d-762">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="9629d-763">做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="9629d-763">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="9629d-764">當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入的通用物件檔案格式 (COFF) 映像，辨識項的參數繼承自呼叫組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-764">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="9629d-765">這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-765">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9629d-766">在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。</span><span class="sxs-lookup"><span data-stu-id="9629d-766">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="9629d-767">`Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-767">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="9629d-768">當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。</span><span class="sxs-lookup"><span data-stu-id="9629d-768">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="9629d-769">呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。</span><span class="sxs-lookup"><span data-stu-id="9629d-769">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="9629d-770">反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-770">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="9629d-771">這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。</span><span class="sxs-lookup"><span data-stu-id="9629d-771">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="9629d-772">若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。</span><span class="sxs-lookup"><span data-stu-id="9629d-772">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-773">如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>屬性所設定，第一次嘗試載入組件會使用顯示名稱 (包括版本、 文化特性，並依此類推，所傳回<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性)。</span><span class="sxs-lookup"><span data-stu-id="9629d-773">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="9629d-774">如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>用來搜尋該組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-774">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="9629d-775">如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，顯示名稱比對組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-775">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="9629d-776">如果比對失敗，<xref:System.IO.FileLoadException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="9629d-776">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-777">下列範例會具現化<xref:System.Reflection.AssemblyName>物件，並使用它來載入`sysglobal.dll`組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-777">The following example instantiates an <xref:System.Reflection.AssemblyName> object and uses it to load the `sysglobal.dll` assembly.</span></span> <span data-ttu-id="9629d-778">範例接著會顯示組件的公用類型的完整名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-778">The example then displays the full name of the assembly's public types.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-779">
            <paramref name="assemblyRef" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-779">
              <paramref name="assemblyRef" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-780">找不到 <paramref name="assemblyRef" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-780">
              <paramref name="assemblyRef" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-781">
            <block subset="none" type="note">
              <para>在[適用於 Microsoft Store 應用程式的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912)中或[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為捕捉基底類別例外狀況 <see cref="T:System.IO.IOException" />。</para>
            </block>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-781">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  </para>
              </block>
            </span>
          </span>
          <span data-ttu-id="9629d-782">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-782">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-783">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-783">-or-</span>
          </span>
          <span data-ttu-id="9629d-784">
            <paramref name="assemblyRef" /> 指定遠端組件，但停用在遠端組件中執行程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-784">
              <paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="9629d-785">請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-785">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-786">
            <paramref name="assemblyRef" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-786">
              <paramref name="assemblyRef" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-787">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-787">-or-</span>
          </span>
          <span data-ttu-id="9629d-788">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyRef" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-788">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-789">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-789">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="9629d-790">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-790">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="9629d-791">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-791">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-792">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-792">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-793">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-793">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <span data-ttu-id="9629d-794">組件名稱的完整格式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-794">The long form of the assembly name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-795">載入組件，其名稱指定為完整格式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-795">Loads an assembly given the long form of its name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-796">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-796">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-797">組件名稱的完整格式是由其簡單名稱 （例如 「 系統 」 System.dll 組件） 以及其版本、 文化特性、 公開金鑰語彙基元和 （選擇性） 其處理器架構所組成。</span><span class="sxs-lookup"><span data-stu-id="9629d-797">The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</span></span> <span data-ttu-id="9629d-798">它會對應至組件的<xref:System.Reflection.Assembly.FullName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-798">It corresponds to the assembly's <xref:System.Reflection.Assembly.FullName%2A> property.</span></span> <span data-ttu-id="9629d-799">下列範例說明如何使用載入的.NET Framework 4 System.dll 組件的完整名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-799">The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <span data-ttu-id="9629d-800"><xref:System.IO.FileLoadException> 如果擲回`assemblyString`指定完整的組件名稱，而第一個符合的簡單名稱的組件有不同的版本、 文化特性或公開金鑰語彙基元。</span><span class="sxs-lookup"><span data-stu-id="9629d-800"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="9629d-801">載入器不會繼續探查比對的簡單名稱的其他組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-801">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="9629d-802">是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="9629d-802">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="9629d-803">組件和安全性辨識項合併的規則如下所示：</span><span class="sxs-lookup"><span data-stu-id="9629d-803">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="9629d-804">當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-804">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="9629d-805">當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="9629d-805">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="9629d-806">做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="9629d-806">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="9629d-807">當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入的通用物件檔案格式 (COFF) 映像，辨識項的參數繼承自呼叫組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-807">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="9629d-808">這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-808">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9629d-809">在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。</span><span class="sxs-lookup"><span data-stu-id="9629d-809">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="9629d-810">`Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-810">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="9629d-811">當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。</span><span class="sxs-lookup"><span data-stu-id="9629d-811">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="9629d-812">呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。</span><span class="sxs-lookup"><span data-stu-id="9629d-812">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="9629d-813">反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-813">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="9629d-814">這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。</span><span class="sxs-lookup"><span data-stu-id="9629d-814">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="9629d-815">若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。</span><span class="sxs-lookup"><span data-stu-id="9629d-815">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="9629d-816">在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="9629d-816">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="9629d-817">例如，"ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="9629d-817">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="9629d-818">不過，若要指定組件名稱的建議的方式是建立<xref:System.Reflection.AssemblyName>物件，並將它傳遞給適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-818">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="9629d-819">請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-819">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-820">下列範例會載入組件，指定其完整的名稱，並列出包含指定的組件中的所有型別。</span><span class="sxs-lookup"><span data-stu-id="9629d-820">The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</span></span> <span data-ttu-id="9629d-821">若要執行此程式碼範例，您必須提供完整的組件名稱。</span><span class="sxs-lookup"><span data-stu-id="9629d-821">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="9629d-822">如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-822">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-823">
            <paramref name="assemblyString" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-823">
              <paramref name="assemblyString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-824">
            <paramref name="assemblyString" /> 是零長度字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-824">
              <paramref name="assemblyString" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-825">找不到 <paramref name="assemblyString" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-825">
              <paramref name="assemblyString" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-826">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-826">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-827">
            <paramref name="assemblyString" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-827">
              <paramref name="assemblyString" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-828">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-828">-or-</span>
          </span>
          <span data-ttu-id="9629d-829">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyString" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-829">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-830">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-830">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-831">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-831">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="9629d-832">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-832">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="9629d-833">位元組陣列，包含表示組件符號的未經處理位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-833">A byte array that contains the raw bytes representing the symbols for the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-834">使用通用物件檔案格式 (COFF) 映像載入組件，其中包含已發出的組件，並可選擇性地包含組件的符號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-834">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</span>
          </span>
          <span data-ttu-id="9629d-835">組件會載入至呼叫端的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-835">The assembly is loaded into the application domain of the caller.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-836">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-836">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-837">使用這個方法載入的組件的信任層級是與呼叫組件的信任層級相同。</span><span class="sxs-lookup"><span data-stu-id="9629d-837">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="9629d-838">若要從應用程式定義域的信任層級的位元組陣列載入組件，請使用<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="9629d-838">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="9629d-839">如需使用辨識項使用的多載<xref:System.Reflection.Assembly.Load%2A>方法採用位元組陣列，請參閱<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="9629d-839">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="9629d-840">反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-840">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="9629d-841">這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。</span><span class="sxs-lookup"><span data-stu-id="9629d-841">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="9629d-842">若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。</span><span class="sxs-lookup"><span data-stu-id="9629d-842">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="9629d-843">請注意，這個方法多載一定會建立新<xref:System.Reflection.Assembly>具有它自己的對應物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-843">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-844">
            <paramref name="rawAssembly" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-844">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-845">
            <paramref name="rawAssembly" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-845">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-846">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-846">-or-</span>
          </span>
          <span data-ttu-id="9629d-847">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="rawAssembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-847">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">
          <span data-ttu-id="9629d-848">描述要載入之組件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-848">The object that describes the assembly to be loaded.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="9629d-849">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-849">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-850">載入組件，指定其 <see cref="T:System.Reflection.AssemblyName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-850">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span>
          </span>
          <span data-ttu-id="9629d-851">使用所提供的辨識項，將組件載入至呼叫端的定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-851">The assembly is loaded into the domain of the caller using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-852">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-852">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-853"><xref:System.IO.FileLoadException> 如果擲回`assemblyRef`指定完整的組件名稱，而第一個符合的簡單名稱的組件有不同的版本、 文化特性或公開金鑰語彙基元。</span><span class="sxs-lookup"><span data-stu-id="9629d-853"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="9629d-854">載入器不會繼續探查比對的簡單名稱的其他組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-854">The loader does not continue probing for other assemblies that match the simple name.</span></span>  <span data-ttu-id="9629d-855">因為遠端組件中的程式碼的執行已停用預設的情況下，.NET Framework 4 中，從開始<xref:System.IO.FileLoadException>如果也會擲回`assemblyRef`指定遠端組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-855">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="9629d-856">若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-856">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>   
  
> [!NOTE]
>  <span data-ttu-id="9629d-857">請勿使用<xref:System.Reflection.AssemblyName>只有<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性集。</span><span class="sxs-lookup"><span data-stu-id="9629d-857">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="9629d-858"><xref:System.Reflection.AssemblyName.CodeBase%2A>不提供任何項目 （例如名稱或版本） 的組件身分識別，因此載入不會根據負載所識別的規則，如您所預期<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-858">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="9629d-859">相反地，會載入組件，使用載入來源的規則。</span><span class="sxs-lookup"><span data-stu-id="9629d-859">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="9629d-860">使用載入來源內容的缺點的相關資訊，請參閱<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法多載或[組件載入的最佳作法](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-860">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="9629d-861">是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="9629d-861">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="9629d-862">組件和安全性辨識項合併的規則如下所示：</span><span class="sxs-lookup"><span data-stu-id="9629d-862">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="9629d-863">當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-863">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="9629d-864">當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="9629d-864">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="9629d-865">做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="9629d-865">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="9629d-866">當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入的通用物件檔案格式 (COFF) 映像，辨識項的參數繼承自呼叫組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-866">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="9629d-867">這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-867">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9629d-868">在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。</span><span class="sxs-lookup"><span data-stu-id="9629d-868">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="9629d-869">`Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-869">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="9629d-870">當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。</span><span class="sxs-lookup"><span data-stu-id="9629d-870">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="9629d-871">呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。</span><span class="sxs-lookup"><span data-stu-id="9629d-871">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="9629d-872">反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-872">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="9629d-873">這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。</span><span class="sxs-lookup"><span data-stu-id="9629d-873">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="9629d-874">若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。</span><span class="sxs-lookup"><span data-stu-id="9629d-874">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-875">如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>屬性所設定，第一次嘗試載入組件會使用顯示名稱 (包括版本、 文化特性，並依此類推，所傳回<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性)。</span><span class="sxs-lookup"><span data-stu-id="9629d-875">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="9629d-876">如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>用來搜尋該組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-876">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="9629d-877">如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，顯示名稱比對組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-877">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="9629d-878">如果比對失敗，<xref:System.IO.FileLoadException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="9629d-878">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="9629d-879">如果您呼叫<xref:System.Reflection.Assembly.Load%2A>方法超過一次在相同的組件，但以指定不同的辨識項，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為不能是不同的辨識項規格的完整性與等號比較決定。</span><span class="sxs-lookup"><span data-stu-id="9629d-879">If you call the <xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="9629d-880">第一個成功的辨識項是所使用的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-880">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-881">
            <paramref name="assemblyRef" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-881">
              <paramref name="assemblyRef" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-882">找不到 <paramref name="assemblyRef" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-882">
              <paramref name="assemblyRef" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-883">
            <paramref name="assemblyRef" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-883">
              <paramref name="assemblyRef" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-884">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-884">-or-</span>
          </span>
          <span data-ttu-id="9629d-885">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyRef" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-885">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-886">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-886">An assembly or module was loaded twice with two different evidences.</span>
          </span>
          <span data-ttu-id="9629d-887">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-887">-or-</span>
          </span>
          <span data-ttu-id="9629d-888">
            <paramref name="assemblyRef" /> 指定遠端組件，但已停用在遠端組件中執行程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-888">
              <paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="9629d-889">請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-889">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-890">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-890">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="9629d-891">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-891">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="9629d-892">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-892">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-893">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-893">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-894">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-894">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <span data-ttu-id="9629d-895">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-895">The display name of the assembly.</span>
          </span>
        </param>
        <param name="assemblySecurity">
          <span data-ttu-id="9629d-896">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-896">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-897">載入提供其顯示名稱的組件，使用提供的辨識項將組件載入至呼叫端的定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-897">Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-898">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-898">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-899"><xref:System.IO.FileLoadException> 如果擲回`assemblyString`指定完整的組件名稱，而第一個符合的簡單名稱的組件有不同的版本、 文化特性或公開金鑰語彙基元。</span><span class="sxs-lookup"><span data-stu-id="9629d-899"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="9629d-900">載入器不會繼續探查比對的簡單名稱的其他組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-900">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="9629d-901">是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="9629d-901">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="9629d-902">組件和安全性辨識項合併的規則如下所示：</span><span class="sxs-lookup"><span data-stu-id="9629d-902">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="9629d-903">當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-903">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="9629d-904">當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="9629d-904">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="9629d-905">做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="9629d-905">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="9629d-906">當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入的通用物件檔案格式 (COFF) 映像，辨識項的參數繼承自呼叫組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-906">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="9629d-907">這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-907">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9629d-908">在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。</span><span class="sxs-lookup"><span data-stu-id="9629d-908">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="9629d-909">`Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-909">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="9629d-910">當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。</span><span class="sxs-lookup"><span data-stu-id="9629d-910">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="9629d-911">呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。</span><span class="sxs-lookup"><span data-stu-id="9629d-911">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="9629d-912">反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-912">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="9629d-913">這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。</span><span class="sxs-lookup"><span data-stu-id="9629d-913">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="9629d-914">若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。</span><span class="sxs-lookup"><span data-stu-id="9629d-914">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="9629d-915">如果您呼叫這個方法一次以上相同的組件，但使用不同的辨識項，指定，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為無法判斷是否相等和不同的辨識項規格的完整性。</span><span class="sxs-lookup"><span data-stu-id="9629d-915">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="9629d-916">第一個成功的辨識項是所使用的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-916">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="9629d-917">在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。</span><span class="sxs-lookup"><span data-stu-id="9629d-917">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="9629d-918">例如，"ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="9629d-918">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="9629d-919">不過，若要指定組件名稱的建議的方式是建立<xref:System.Reflection.AssemblyName>物件，並將它傳遞給適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-919">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="9629d-920">請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-920">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-921">
            <paramref name="assemblyString" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-921">
              <paramref name="assemblyString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-922">找不到 <paramref name="assemblyString" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-922">
              <paramref name="assemblyString" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-923">
            <paramref name="assemblyString" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-923">
              <paramref name="assemblyString" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-924">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-924">-or-</span>
          </span>
          <span data-ttu-id="9629d-925">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyString" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-925">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-926">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-926">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-927">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-927">-or-</span>
          </span>
          <span data-ttu-id="9629d-928">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-928">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-929">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-929">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-930">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-930">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="9629d-931">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-931">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="9629d-932">位元組陣列，包含表示組件符號的未經處理位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-932">A byte array that contains the raw bytes representing the symbols for the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="9629d-933">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-933">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-934">使用通用物件檔案格式 (COFF) 映像載入組件，其中包含已發出的組件，並可選擇性地包含組件的符號和辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-934">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</span>
          </span>
          <span data-ttu-id="9629d-935">組件會載入至呼叫端的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-935">The assembly is loaded into the application domain of the caller.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-936">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-936">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-937">使用所提供的辨識項，將組件載入至呼叫端的定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-937">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span> <span data-ttu-id="9629d-938">表示組件符號的未經處理位元組也載入。</span><span class="sxs-lookup"><span data-stu-id="9629d-938">The raw bytes representing the symbols for the assembly are also loaded.</span></span>  
  
 <span data-ttu-id="9629d-939">是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="9629d-939">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="9629d-940">組件和安全性辨識項合併的規則如下所示：</span><span class="sxs-lookup"><span data-stu-id="9629d-940">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="9629d-941">當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-941">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="9629d-942">當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="9629d-942">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="9629d-943">做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="9629d-943">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="9629d-944">當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入 （coff） 映像，辨識項的參數繼承自呼叫組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-944">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="9629d-945">這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。</span><span class="sxs-lookup"><span data-stu-id="9629d-945">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="9629d-946">在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。</span><span class="sxs-lookup"><span data-stu-id="9629d-946">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="9629d-947">`Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-947">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="9629d-948">當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。</span><span class="sxs-lookup"><span data-stu-id="9629d-948">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="9629d-949">會忽略呼叫組件的辨識項和辨識項 （coff） 映像。</span><span class="sxs-lookup"><span data-stu-id="9629d-949">Evidence of the calling assembly and evidence of the COFF image are ignored.</span></span>  
  
 <span data-ttu-id="9629d-950">反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-950">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="9629d-951">這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。</span><span class="sxs-lookup"><span data-stu-id="9629d-951">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="9629d-952">若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。</span><span class="sxs-lookup"><span data-stu-id="9629d-952">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="9629d-953">如果您呼叫 [\]，位元組\<xref:System.Reflection.Assembly.Load%2A > 方法超過一次在相同的組件，但以指定不同的辨識項，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為無法判斷相等和不同的辨識項規格的完整性。</span><span class="sxs-lookup"><span data-stu-id="9629d-953">If you call the [\], Byte\<xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="9629d-954">第一個成功的辨識項是所使用的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-954">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="9629d-955">請注意，這個方法多載一定會建立新<xref:System.Reflection.Assembly>具有它自己的對應物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-955">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-956">
            <paramref name="rawAssembly" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-956">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-957">
            <paramref name="rawAssembly" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-957">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-958">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-958">-or-</span>
          </span>
          <span data-ttu-id="9629d-959">目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="rawAssembly" /> 的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-959">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-960">使用兩個不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-960">An assembly or module was loaded twice with two different evidences.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9629d-961">
            <paramref name="securityEvidence" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-961">
              <paramref name="securityEvidence" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9629d-962">根據預設，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中並未啟用舊版的 CAS 原則；如果未啟用該原則，<paramref name="securityEvidence" /> 必須是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-962">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-963">提供提供辨識項的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-963">for the ability to supply evidence.</span>
          </span>
          <span data-ttu-id="9629d-964">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-964">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span>
          </span>
          <span data-ttu-id="9629d-965">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-965">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="9629d-966">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-966">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="9629d-967">位元組陣列，包含表示組件符號的未經處理位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-967">A byte array that contains the raw bytes representing the symbols for the assembly.</span>
          </span>
        </param>
        <param name="securityContextSource">
          <span data-ttu-id="9629d-968">安全性內容的來源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-968">The source of the security context.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-969">使用通用物件檔案格式 (COFF) 映像載入組件，其中包含已發出的組件，並可選擇性地包含組件的符號，以及指定安全性內容的來源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-969">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</span>
          </span>
          <span data-ttu-id="9629d-970">組件會載入至呼叫端的應用程式定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-970">The assembly is loaded into the application domain of the caller.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-971">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-971">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-972">組件會載入應用程式定義域的呼叫端安全性內容中使用指定的來源。</span><span class="sxs-lookup"><span data-stu-id="9629d-972">The assembly is loaded into the application domain of the caller using the specified source for the security context.</span></span> <span data-ttu-id="9629d-973">如果`rawSymbolStore`已指定，也會載入組件表示符號的未經處理位元組。</span><span class="sxs-lookup"><span data-stu-id="9629d-973">If `rawSymbolStore` was specified, the raw bytes that represent the symbols for the assembly are also loaded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-974">
            <paramref name="rawAssembly" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-974">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-975">
            <paramref name="rawAssembly" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-975">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-976">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-976">-or-</span>
          </span>
          <span data-ttu-id="9629d-977">用以編譯 <paramref name="rawAssembly" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-977">
              <paramref name="rawAssembly" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9629d-978">
            <paramref name="securityContextSource" /> 的值不是其中一個列舉值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-978">The value of <paramref name="securityContextSource" /> is not one of the enumeration values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-979">載入組件檔案的內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-979">Loads the contents of an assembly file.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="9629d-980">要載入的完整檔案路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-980">The fully qualified path of the file to load.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-981">載入指定路徑上組件檔案的內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-981">Loads the contents of an assembly file on the specified path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-982">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-982">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-983">使用<xref:System.Reflection.Assembly.LoadFile%2A>方法來載入和檢查組件具有相同的識別，但位於不同的路徑。</span><span class="sxs-lookup"><span data-stu-id="9629d-983">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="9629d-984"><xref:System.Reflection.Assembly.LoadFile%2A> 不會將檔案載入到載入來源內容，並無法解決相依性載入路徑中，使用做為<xref:System.Reflection.Assembly.LoadFrom%2A>方法會執行。</span><span class="sxs-lookup"><span data-stu-id="9629d-984"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="9629d-985"><xref:System.Reflection.Assembly.LoadFile%2A> 在此限案例中有用因為<xref:System.Reflection.Assembly.LoadFrom%2A>不能用來載入組件具有相同的身分識別但不同的路徑，它會載入的第一個這類組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-985"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="9629d-986">從.NET Framework 4 中，如果`path`在遠端位置中指定的組件、 組件載入已停用預設的情況下，而`LoadFile`方法會擲回<xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-986">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="9629d-987">若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-987">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-988">
            <paramref name="path" /> 引數不是絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-988">The <paramref name="path" /> argument is not an absolute path.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-989">
            <paramref name="path" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-989">The <paramref name="path" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-990">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-990">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-991">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-991">-or-</span>
          </span>
          <span data-ttu-id="9629d-992">已停用在遠端組件中執行程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-992">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="9629d-993">請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-993">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-994">
            <paramref name="path" /> 參數是空字串 ("") 或不存在。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-994">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-995">
            <paramref name="path" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-995">
              <paramref name="path" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-996">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-996">-or-</span>
          </span>
          <span data-ttu-id="9629d-997">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="path" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-997">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-998">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-998">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="9629d-999">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-999">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-1000">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1000">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-1001">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1001">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="9629d-1002">組件檔的完整路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1002">The fully qualified path of the assembly file.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="9629d-1003">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1003">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1004">載入既定路徑的組件，並使用提供的辨識項將組件載入至呼叫端的定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1004">Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1005">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1005">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1006">使用<xref:System.Reflection.Assembly.LoadFile%2A>方法來載入和檢查組件具有相同的識別，但位於不同的路徑。</span><span class="sxs-lookup"><span data-stu-id="9629d-1006">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="9629d-1007"><xref:System.Reflection.Assembly.LoadFile%2A> 無法將檔案載入<xref:System.Reflection.Assembly.LoadFrom%2A>內容，並無法解決相依性載入路徑中，使用做為<xref:System.Reflection.Assembly.LoadFrom%2A>方法會執行。</span><span class="sxs-lookup"><span data-stu-id="9629d-1007"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the <xref:System.Reflection.Assembly.LoadFrom%2A> context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="9629d-1008"><xref:System.Reflection.Assembly.LoadFile%2A> 在此限案例中有用因為<xref:System.Reflection.Assembly.LoadFrom%2A>不能用來載入組件具有相同的身分識別但不同的路徑，它會載入的第一個這類組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1008"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="9629d-1009">從.NET Framework 4 中，如果`path`在遠端位置中指定的組件、 組件載入已停用預設的情況下，而`LoadFile`方法會擲回<xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1009">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="9629d-1010">若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1010">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1011">
            <paramref name="path" /> 引數不是絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1011">The <paramref name="path" /> argument is not an absolute path.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1012">
            <paramref name="path" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1012">The <paramref name="path" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-1013">
            <paramref name="path" /> 參數是空字串 ("") 或不存在。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1013">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1014">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1014">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-1015">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1015">-or-</span>
          </span>
          <span data-ttu-id="9629d-1016">已停用在遠端組件中執行程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1016">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="9629d-1017">請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1017">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1018">
            <paramref name="path" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1018">
              <paramref name="path" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-1019">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1019">-or-</span>
          </span>
          <span data-ttu-id="9629d-1020">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="path" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1020">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9629d-1021">
            <paramref name="securityEvidence" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1021">
              <paramref name="securityEvidence" /> is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9629d-1022">根據預設，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中並未啟用舊版的 CAS 原則；如果未啟用該原則，<paramref name="securityEvidence" /> 必須是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1022">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-1023">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1023">for access to read from a file or directory, and for access to the information in the path itself.</span>
          </span>
          <span data-ttu-id="9629d-1024">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1024">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-1025">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1025">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-1026">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1026">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1027">載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1027">Loads an assembly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

<span data-ttu-id="9629d-1028">從.NET Framework 4 開始，能夠從遠端位置載入的組件中執行程式碼會停用預設值，而且呼叫`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1028">Starting with .NET Framework 4, the ability to execute code in assemblies loaded from remote locations is disabled by default, and the call to the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="9629d-1029">若要載入的組件，並執行其程式碼，您必須使用下列其中一個：</span><span class="sxs-lookup"><span data-stu-id="9629d-1029">To load the assembly and execute its code, you must either:</span></span>

- <span data-ttu-id="9629d-1030">組件中明確建立沙箱。</span><span class="sxs-lookup"><span data-stu-id="9629d-1030">Explicitly create a sandbox for the assembly.</span></span> <span data-ttu-id="9629d-1031">(請參閱[如何： 在沙箱中執行部分信任程式碼](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)。)</span><span class="sxs-lookup"><span data-stu-id="9629d-1031">(See [How to: Run Partially Trusted Code in a Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span></span>

- <span data-ttu-id="9629d-1032">以完全信任執行組件的程式碼，藉由設定`enabled`的屬性[`<loadFromRemoteSources>`組態項目](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)到`true`。</span><span class="sxs-lookup"><span data-stu-id="9629d-1032">Run the assembly's code in full trust by setting the `enabled` attribute of the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) to `true`.</span></span> <span data-ttu-id="9629d-1033">如需詳細資訊，請參閱 < [ `<loadFromRemoteSources>`組態項目](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)文章。</span><span class="sxs-lookup"><span data-stu-id="9629d-1033">For more information, see the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="9629d-1034">檔案的名稱或路徑，包含組件的資訊清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1034">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1035">載入組件，指定其檔案名稱或路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1035">Loads an assembly given its file name or path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1036">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1036">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1037">`assemblyFile`參數必須參考到不含逸出字元的 URI。</span><span class="sxs-lookup"><span data-stu-id="9629d-1037">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="9629d-1038">這個方法會提供所有 URI 中的無效字元的逸出字元。</span><span class="sxs-lookup"><span data-stu-id="9629d-1038">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-1039">不支援檔案傳輸通訊協定 (FTP)。</span><span class="sxs-lookup"><span data-stu-id="9629d-1039">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="9629d-1040">如果 URI 提供給`assemblyFile`是 FTP 位址，未載入的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1040">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="9629d-1041">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="9629d-1041">No exception is thrown.</span></span>  
  
 <span data-ttu-id="9629d-1042">`assemblyFile` 可以是絕對或相對到目前的目錄，而且組件會載入至呼叫端的定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1042">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="9629d-1043">組件可以載入三個內容之一，或可以載入沒有內容：</span><span class="sxs-lookup"><span data-stu-id="9629d-1043">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="9629d-1044">載入內容包含探查所找到的組件： 在 GAC 中，主應用程式組件中儲存如果裝載執行階段，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1044">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="9629d-1045"><xref:System.Reflection.Assembly.Load%2A> 方法的大部分多載都會將組件載入此內容中。</span><span class="sxs-lookup"><span data-stu-id="9629d-1045">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="9629d-1046">載入來源內容包含使用者提供不包含在搜尋所探查的目錄路徑的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1046">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="9629d-1047"><xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 是依路徑載入之方法的範例。</span><span class="sxs-lookup"><span data-stu-id="9629d-1047"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span> 

    <span data-ttu-id="9629d-1048">如果.NET Framework 4 中，從開始的 URI`assemblyFile`指定遠端位置，組件載入已停用預設的情況下，而`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1048">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="9629d-1049">若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1049">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="9629d-1050">僅限反映的內容包含使用載入的組件<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 在這些程式碼無法執行內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1050">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="9629d-1051">如果使用者產生，或找到此組件，它不在任何內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1051">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="9629d-1052">這會套用至組件載入多載<xref:System.Reflection.Assembly.Load%2A>指定位元組陣列，包含組件，並建立使用反映的暫時性動態組件發出，並不會儲存至磁碟的方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-1052">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="9629d-1053">載入來源內容可讓從不會納入探查路徑載入的組件，而且找到並載入，因為路徑資訊由內容維護該路徑可允許相依性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1053">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="9629d-1054"><xref:System.Reflection.Assembly.LoadFrom%2A>方法有下列缺點。</span><span class="sxs-lookup"><span data-stu-id="9629d-1054">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="9629d-1055">請考慮改用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1055">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="9629d-1056">如果已載入具有相同身分識別的組件，<xref:System.Reflection.Assembly.LoadFrom%2A> 會傳回載入的組件，即使指定不同的路徑也是一樣。</span><span class="sxs-lookup"><span data-stu-id="9629d-1056">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="9629d-1057">如果使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 載入組件，之後載入內容中的組件卻試圖根據顯示名稱載入相同組件，則載入嘗試會失敗。</span><span class="sxs-lookup"><span data-stu-id="9629d-1057">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="9629d-1058">當組件還原序列化時，可能發生這項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1058">This can occur when an assembly is de-serialized.</span></span>  
  
-   <span data-ttu-id="9629d-1059">如果組件是以載入<xref:System.Reflection.Assembly.LoadFrom%2A>，探查路徑中包含的組件具有相同的身分識別但不同的位置，並<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，或其他非預期的行為可能會發生。</span><span class="sxs-lookup"><span data-stu-id="9629d-1059">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="9629d-1060"><xref:System.Reflection.Assembly.LoadFrom%2A> 要求所指定路徑上的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1060"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="9629d-1061">如果原生映像存在`assemblyFile`，不會使用它。</span><span class="sxs-lookup"><span data-stu-id="9629d-1061">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="9629d-1062">無法以定義域中性方式載入組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1062">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="9629d-1063">在.NET Framework 1.0 和 1.1 版中，不會套用原則。</span><span class="sxs-lookup"><span data-stu-id="9629d-1063">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-1064">下列範例會載入組件，指定其檔案名稱或路徑。</span><span class="sxs-lookup"><span data-stu-id="9629d-1064">The following example loads an assembly given its file name or path.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1065">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1065">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-1066">
            <paramref name="assemblyFile" /> 找不到，或者您要載入的模組未指定副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1066">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1067">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1067">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-1068">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1068">-or-</span>
          </span>
          <span data-ttu-id="9629d-1069">已停用在遠端組件中執行程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1069">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="9629d-1070">請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1070">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1071">
            <paramref name="assemblyFile" /> 不是有效的組件，例如 64 位元處理序中的 32 位元組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1071">
              <paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span>
          </span>
          <span data-ttu-id="9629d-1072">如需詳細資訊，請參閱例外狀況主題。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1072">See the exception topic for more information.</span>
          </span>
          <span data-ttu-id="9629d-1073">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1073">-or-</span>
          </span>
          <span data-ttu-id="9629d-1074">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1074">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="9629d-1075">指定了不是以 "file://" 開頭的基礎碼，而且沒有必要的 <see cref="T:System.Net.WebPermission" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1075">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1076">
            <paramref name="assemblyFile" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1076">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="9629d-1077">組件名稱超過系統定義的長度上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1077">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-1078">用於讀取以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1078">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="9629d-1079">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1079">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="9629d-1080">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1080">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="9629d-1081">檔案的名稱或路徑，包含組件的資訊清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1081">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="9629d-1082">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1082">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1083">載入組件，指定其檔案名稱或路徑，並提供安全性辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1083">Loads an assembly given its file name or path and supplying security evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1084">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1084">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1085">`assemblyFile`參數必須參考到不含逸出字元的 URI。</span><span class="sxs-lookup"><span data-stu-id="9629d-1085">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="9629d-1086">這個方法會提供所有 URI 中的無效字元的逸出字元。</span><span class="sxs-lookup"><span data-stu-id="9629d-1086">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-1087">不支援檔案傳輸通訊協定 (FTP)。</span><span class="sxs-lookup"><span data-stu-id="9629d-1087">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="9629d-1088">如果 URI 提供給`assemblyFile`是 FTP 位址，未載入的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1088">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="9629d-1089">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="9629d-1089">No exception is thrown.</span></span>  
  
 <span data-ttu-id="9629d-1090">`assemblyFile` 可以是絕對或相對到目前的目錄，而且組件會載入至呼叫端的定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1090">`assemblyFile` may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="9629d-1091">組件可以載入三個內容之一，或可以載入沒有內容：</span><span class="sxs-lookup"><span data-stu-id="9629d-1091">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="9629d-1092">載入內容包含探查所找到的組件： 在 GAC 中，主應用程式組件中儲存如果裝載執行階段，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1092">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="9629d-1093"><xref:System.Reflection.Assembly.Load%2A> 方法的大部分多載都會將組件載入此內容中。</span><span class="sxs-lookup"><span data-stu-id="9629d-1093">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="9629d-1094">載入來源內容包含使用者提供不包含在搜尋所探查的目錄路徑的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1094">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="9629d-1095"><xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 是依路徑載入之方法的範例。</span><span class="sxs-lookup"><span data-stu-id="9629d-1095"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>

    <span data-ttu-id="9629d-1096">如果.NET Framework 4 中，從開始的 URI`assemblyFile`指定遠端位置，組件載入已停用預設的情況下，而`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1096">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="9629d-1097">若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1097">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="9629d-1098">僅限反映的內容包含使用載入的組件<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 在這些程式碼無法執行內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1098">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="9629d-1099">如果使用者產生，或找到此組件，它不在任何內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1099">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="9629d-1100">這會套用至組件載入多載<xref:System.Reflection.Assembly.Load%2A>指定位元組陣列，包含組件，並建立使用反映的暫時性動態組件發出，並不會儲存至磁碟的方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-1100">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="9629d-1101">載入來源內容可讓從不會納入探查路徑載入的組件，而且找到並載入，因為路徑資訊由內容維護該路徑可允許相依性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1101">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="9629d-1102"><xref:System.Reflection.Assembly.LoadFrom%2A>方法有下列缺點。</span><span class="sxs-lookup"><span data-stu-id="9629d-1102">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="9629d-1103">請考慮改用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1103">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="9629d-1104">如果已載入具有相同身分識別的組件，<xref:System.Reflection.Assembly.LoadFrom%2A> 會傳回載入的組件，即使指定不同的路徑也是一樣。</span><span class="sxs-lookup"><span data-stu-id="9629d-1104">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="9629d-1105">如果使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 載入組件，之後載入內容中的組件卻試圖根據顯示名稱載入相同組件，則載入嘗試會失敗。</span><span class="sxs-lookup"><span data-stu-id="9629d-1105">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="9629d-1106">還原序列化組件時，也可能發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="9629d-1106">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="9629d-1107">如果組件是以載入<xref:System.Reflection.Assembly.LoadFrom%2A>，探查路徑中包含的組件具有相同的身分識別但不同的位置，並<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，或其他非預期的行為可能會發生。</span><span class="sxs-lookup"><span data-stu-id="9629d-1107">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="9629d-1108"><xref:System.Reflection.Assembly.LoadFrom%2A> 要求所指定路徑上的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1108"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="9629d-1109">如果原生映像存在`assemblyFile`，不會使用它。</span><span class="sxs-lookup"><span data-stu-id="9629d-1109">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="9629d-1110">無法以定義域中性方式載入組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1110">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="9629d-1111">在.NET Framework 1.0 和 1.1 版中，不會套用原則。</span><span class="sxs-lookup"><span data-stu-id="9629d-1111">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="9629d-1112">是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="9629d-1112">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="9629d-1113">組件和安全性辨識項合併的規則如下所示：</span><span class="sxs-lookup"><span data-stu-id="9629d-1113">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="9629d-1114">當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-1114">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="9629d-1115">當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="9629d-1115">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="9629d-1116">做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.LoadFrom%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="9629d-1116">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="9629d-1117">如果您呼叫這個方法一次以上相同的組件，但使用不同的辨識項，指定，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為無法判斷是否相等和不同的辨識項規格的完整性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1117">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="9629d-1118">第一個成功的辨識項是所使用的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-1118">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="9629d-1119">當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法使用`Byte[]`結合載入的通用物件檔案格式 (COFF) 映像，辨識項的參數。</span><span class="sxs-lookup"><span data-stu-id="9629d-1119">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="9629d-1120">`Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1120">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="9629d-1121">當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。</span><span class="sxs-lookup"><span data-stu-id="9629d-1121">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="9629d-1122">呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。</span><span class="sxs-lookup"><span data-stu-id="9629d-1122">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1123">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1123">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-1124">
            <paramref name="assemblyFile" /> 找不到，或者您要載入的模組未指定副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1124">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1125">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1125">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-1126">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1126">-or-</span>
          </span>
          <span data-ttu-id="9629d-1127">
            <paramref name="securityEvidence" /> 並未模稜兩可，而且已判定為無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1127">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span>
          </span>
          <span data-ttu-id="9629d-1128">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1128">-or-</span>
          </span>
          <span data-ttu-id="9629d-1129">已停用在遠端組件中執行程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1129">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="9629d-1130">請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1130">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1131">
            <paramref name="assemblyFile" /> 不是有效的組件，例如 64 位元處理序中的 32 位元組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1131">
              <paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span>
          </span>
          <span data-ttu-id="9629d-1132">如需詳細資訊，請參閱例外狀況主題。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1132">See the exception topic for more information.</span>
          </span>
          <span data-ttu-id="9629d-1133">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1133">-or-</span>
          </span>
          <span data-ttu-id="9629d-1134">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1134">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="9629d-1135">指定了不是以 "file://" 開頭的基礎碼，而且沒有必要的 <see cref="T:System.Net.WebPermission" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1135">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1136">
            <paramref name="assemblyFile" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1136">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="9629d-1137">組件名稱超過系統定義的長度上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1137">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-1138">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1138">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-1139">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1139">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-1140">用於讀取以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1140">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="9629d-1141">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1141">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="9629d-1142">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1142">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="9629d-1143">檔案的名稱或路徑，包含組件的資訊清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1143">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <param name="hashValue">
          <span data-ttu-id="9629d-1144">計算的雜湊碼值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1144">The value of the computed hash code.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="9629d-1145">雜湊演算法，用於雜湊檔案和用來產生強式名稱 (Strong Name)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1145">The hash algorithm used for hashing files and for generating the strong name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1146">指定組件的檔案名稱或路徑，雜湊值和雜湊演算法，來載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1146">Loads an assembly given its file name or path, hash value, and hash algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1147">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1147">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1148">`assemblyFile`參數必須參考到不含逸出字元的 URI。</span><span class="sxs-lookup"><span data-stu-id="9629d-1148">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="9629d-1149">這個方法會提供所有 URI 中的無效字元的逸出字元。</span><span class="sxs-lookup"><span data-stu-id="9629d-1149">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-1150">不支援檔案傳輸通訊協定 (FTP)。</span><span class="sxs-lookup"><span data-stu-id="9629d-1150">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="9629d-1151">如果 URI 提供給`assemblyFile`是 FTP 位址，未載入的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1151">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="9629d-1152">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="9629d-1152">No exception is thrown.</span></span>  
  
 <span data-ttu-id="9629d-1153">`assemblyFile` 可以是絕對或相對到目前的目錄，而且組件會載入至呼叫端的定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1153">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="9629d-1154">組件可以載入三個內容之一，或可以載入沒有內容：</span><span class="sxs-lookup"><span data-stu-id="9629d-1154">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="9629d-1155">載入內容包含探查所找到的組件： 全域組件快取中，主應用程式組件中儲存如果裝載執行階段，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1155">The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="9629d-1156"><xref:System.Reflection.Assembly.Load%2A> 方法的大部分多載都會將組件載入此內容中。</span><span class="sxs-lookup"><span data-stu-id="9629d-1156">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="9629d-1157">載入來源內容包含使用者提供的目標不會納入探查路徑的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1157">The load-from context contains assemblies for which the user provided a path that is not included in probing.</span></span> <span data-ttu-id="9629d-1158"><xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 是依路徑載入之方法的範例。</span><span class="sxs-lookup"><span data-stu-id="9629d-1158"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="9629d-1159">如果.NET Framework 4 中，從開始的 URI`assemblyFile`指定遠端位置，組件載入已停用預設的情況下，而`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1159">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="9629d-1160">若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1160">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="9629d-1161">僅限反映的內容包含使用載入的組件<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 在這些程式碼無法執行內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1161">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="9629d-1162">如果使用者產生，或找到此組件，它不在任何內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1162">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="9629d-1163">這會套用至組件載入多載<xref:System.Reflection.Assembly.Load%2A>指定位元組陣列，包含組件，並建立使用反映的暫時性動態組件發出，並不會儲存至磁碟的方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-1163">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="9629d-1164">載入來源內容可讓從不會納入探查路徑載入的組件，而且找到並載入，因為路徑資訊由內容維護該路徑可允許相依性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1164">The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="9629d-1165"><xref:System.Reflection.Assembly.LoadFrom%2A>方法有下列缺點。</span><span class="sxs-lookup"><span data-stu-id="9629d-1165">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="9629d-1166">請考慮改用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1166">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="9629d-1167">如果已載入具有相同身分識別的組件，<xref:System.Reflection.Assembly.LoadFrom%2A> 會傳回載入的組件，即使指定不同的路徑也是一樣。</span><span class="sxs-lookup"><span data-stu-id="9629d-1167">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="9629d-1168">如果使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 載入組件，之後載入內容中的組件卻試圖根據顯示名稱載入相同組件，則載入嘗試會失敗。</span><span class="sxs-lookup"><span data-stu-id="9629d-1168">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="9629d-1169">還原序列化組件時，也可能發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="9629d-1169">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="9629d-1170">如果組件是以載入<xref:System.Reflection.Assembly.LoadFrom%2A>，探查路徑中包含的組件具有相同的身分識別但不同的位置，並<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，或其他非預期的行為可能會發生。</span><span class="sxs-lookup"><span data-stu-id="9629d-1170">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="9629d-1171"><xref:System.Reflection.Assembly.LoadFrom%2A> 要求所指定路徑上的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1171"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="9629d-1172">如果原生映像存在`assemblyFile`，不會使用它。</span><span class="sxs-lookup"><span data-stu-id="9629d-1172">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="9629d-1173">組件無法以定義域中性方式載入。</span><span class="sxs-lookup"><span data-stu-id="9629d-1173">The assembly cannot be loaded as domain-neutral.</span></span>  
  
 <span data-ttu-id="9629d-1174">組件是以載入器所提供的辨識項載入。</span><span class="sxs-lookup"><span data-stu-id="9629d-1174">The assembly is loaded with the evidence that the loader supplies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1175">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1175">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-1176">找不到 <paramref name="assemblyFile" />，或您想載入的模組並未指定檔案的副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1176">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1177">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1177">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-1178">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1178">-or-</span>
          </span>
          <span data-ttu-id="9629d-1179">已停用在遠端組件中執行程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1179">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="9629d-1180">請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1180">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1181">
            <paramref name="assemblyFile" /> 不是有效的組件，例如 64 位元處理序中的 32 位元組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1181">
              <paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span>
          </span>
          <span data-ttu-id="9629d-1182">如需詳細資訊，請參閱例外狀況主題。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1182">See the exception topic for more information.</span>
          </span>
          <span data-ttu-id="9629d-1183">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1183">-or-</span>
          </span>
          <span data-ttu-id="9629d-1184">用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1184">
              <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="9629d-1185">指定了不是以 "file://" 開頭的基礎碼，而且沒有必要的 <see cref="T:System.Net.WebPermission" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1185">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1186">
            <paramref name="assemblyFile" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1186">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="9629d-1187">組件名稱超過系統定義的長度上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1187">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-1188">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1188">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-1189">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1189">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-1190">用於讀取以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1190">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="9629d-1191">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1191">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="9629d-1192">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1192">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="9629d-1193">檔案的名稱或路徑，包含組件的資訊清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1193">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="9629d-1194">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1194">Evidence for loading the assembly.</span>
          </span>
        </param>
        <param name="hashValue">
          <span data-ttu-id="9629d-1195">計算的雜湊碼值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1195">The value of the computed hash code.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="9629d-1196">雜湊演算法，用於雜湊檔案和用來產生強式名稱 (Strong Name)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1196">The hash algorithm used for hashing files and for generating the strong name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1197">指定組件的檔案名稱或路徑、安全性辨識項、雜湊值和雜湊演算法，來載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1197">Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1198">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1198">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1199">`assemblyFile`參數必須參考到不含逸出字元的 URI。</span><span class="sxs-lookup"><span data-stu-id="9629d-1199">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="9629d-1200">這個方法會提供所有 URI 中的無效字元的逸出字元。</span><span class="sxs-lookup"><span data-stu-id="9629d-1200">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-1201">不支援檔案傳輸通訊協定 (FTP)。</span><span class="sxs-lookup"><span data-stu-id="9629d-1201">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="9629d-1202">如果 URI 提供給`assemblyFile`是 FTP 位址，未載入的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1202">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="9629d-1203">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="9629d-1203">No exception is thrown.</span></span>  
  
 <span data-ttu-id="9629d-1204">`assemblyFile` 可以是絕對或相對到目前的目錄，而且組件會載入至呼叫端的定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1204">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="9629d-1205">組件可以載入三個內容之一，或可以載入沒有內容：</span><span class="sxs-lookup"><span data-stu-id="9629d-1205">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="9629d-1206">載入內容包含探查所找到的組件： 在 GAC 中，主應用程式組件中儲存如果裝載執行階段，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1206">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="9629d-1207"><xref:System.Reflection.Assembly.Load%2A> 方法的大部分多載都會將組件載入此內容中。</span><span class="sxs-lookup"><span data-stu-id="9629d-1207">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="9629d-1208">載入來源內容包含使用者提供不包含在搜尋所探查的目錄路徑的組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1208">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="9629d-1209"><xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 是依路徑載入之方法的範例。</span><span class="sxs-lookup"><span data-stu-id="9629d-1209"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="9629d-1210">如果.NET Framework 4 中，從開始的 URI`assemblyFile`指定遠端位置，組件載入已停用預設的情況下，而`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1210">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="9629d-1211">若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1211">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="9629d-1212">僅限反映的內容包含使用載入的組件<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 在這些程式碼無法執行內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1212">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="9629d-1213">如果使用者產生，或找到此組件，它不在任何內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1213">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="9629d-1214">這會套用至組件載入多載<xref:System.Reflection.Assembly.Load%2A>指定位元組陣列，包含組件，並建立使用反映的暫時性動態組件發出，並不會儲存至磁碟的方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-1214">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="9629d-1215">載入來源內容可讓從不會納入探查路徑載入的組件，而且找到並載入，因為路徑資訊由內容維護該路徑可允許相依性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1215">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="9629d-1216"><xref:System.Reflection.Assembly.LoadFrom%2A>方法有下列缺點。</span><span class="sxs-lookup"><span data-stu-id="9629d-1216">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="9629d-1217">請考慮改用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1217">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="9629d-1218">如果已載入具有相同身分識別的組件，<xref:System.Reflection.Assembly.LoadFrom%2A> 會傳回載入的組件，即使指定不同的路徑也是一樣。</span><span class="sxs-lookup"><span data-stu-id="9629d-1218">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="9629d-1219">如果使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 載入組件，之後載入內容中的組件卻試圖根據顯示名稱載入相同組件，則載入嘗試會失敗。</span><span class="sxs-lookup"><span data-stu-id="9629d-1219">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="9629d-1220">還原序列化組件時，也可能發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="9629d-1220">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="9629d-1221">如果組件是以載入<xref:System.Reflection.Assembly.LoadFrom%2A>，探查路徑中包含的組件具有相同的身分識別但不同的位置，並<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，或其他非預期的行為可能會發生。</span><span class="sxs-lookup"><span data-stu-id="9629d-1221">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="9629d-1222"><xref:System.Reflection.Assembly.LoadFrom%2A> 要求所指定路徑上的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1222"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="9629d-1223">如果原生映像存在`assemblyFile`，不會使用它。</span><span class="sxs-lookup"><span data-stu-id="9629d-1223">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="9629d-1224">無法以定義域中性方式載入組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1224">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="9629d-1225">在.NET Framework 1.0 和 1.1 版中，不會套用原則。</span><span class="sxs-lookup"><span data-stu-id="9629d-1225">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="9629d-1226">是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="9629d-1226">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="9629d-1227">組件和安全性辨識項合併的規則如下所示：</span><span class="sxs-lookup"><span data-stu-id="9629d-1227">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="9629d-1228">當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-1228">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="9629d-1229">當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。</span><span class="sxs-lookup"><span data-stu-id="9629d-1229">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="9629d-1230">做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.LoadFrom%2A>方法取代的辨識項載入器所提供的片段。</span><span class="sxs-lookup"><span data-stu-id="9629d-1230">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="9629d-1231">如果您呼叫這個方法一次以上相同的組件，但使用不同的辨識項，指定，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為無法判斷是否相等和不同的辨識項規格的完整性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1231">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="9629d-1232">第一個成功的辨識項是所使用的辨識項。</span><span class="sxs-lookup"><span data-stu-id="9629d-1232">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="9629d-1233">當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法使用`Byte[]`結合載入的通用物件檔案格式 (COFF) 映像，辨識項的參數。</span><span class="sxs-lookup"><span data-stu-id="9629d-1233">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="9629d-1234">`Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1234">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="9629d-1235">當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。</span><span class="sxs-lookup"><span data-stu-id="9629d-1235">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="9629d-1236">呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。</span><span class="sxs-lookup"><span data-stu-id="9629d-1236">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1237">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1237">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-1238">
            <paramref name="assemblyFile" /> 找不到，或者您要載入的模組未指定副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1238">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1239">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1239">A file that was found could not be loaded.</span>
          </span>
          <span data-ttu-id="9629d-1240">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1240">-or-</span>
          </span>
          <span data-ttu-id="9629d-1241">
            <paramref name="securityEvidence" /> 並未模稜兩可，而且已判定為無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1241">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span>
          </span>
          <span data-ttu-id="9629d-1242">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1242">-or-</span>
          </span>
          <span data-ttu-id="9629d-1243">已停用在遠端組件中執行程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1243">The ability to execute code in remote assemblies is disabled.</span>
          </span>
          <span data-ttu-id="9629d-1244">請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1244">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1245">
            <paramref name="assemblyFile" /> 不是有效的組件，例如 64 位元處理序中的 32 位元組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1245">
              <paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span>
          </span>
          <span data-ttu-id="9629d-1246">如需詳細資訊，請參閱例外狀況主題。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1246">See the exception topic for more information.</span>
          </span>
          <span data-ttu-id="9629d-1247">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1247">-or-</span>
          </span>
          <span data-ttu-id="9629d-1248">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1248">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="9629d-1249">指定了不是以 "file://" 開頭的基礎碼，而且沒有必要的 <see cref="T:System.Net.WebPermission" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1249">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1250">
            <paramref name="assemblyFile" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1250">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="9629d-1251">組件名稱超過系統定義的長度上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1251">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-1252">與辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1252">to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-1253">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1253">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-1254">用於讀取以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1254">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="9629d-1255">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1255">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="9629d-1256">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1256">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1257">載入這個組件內部的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1257">Loads the module internal to this assembly.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">
          <span data-ttu-id="9629d-1258">模組的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1258">The name of the module.</span>
          </span>
          <span data-ttu-id="9629d-1259">這個字串必須對應於這個組件的資訊清單中的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1259">This string must correspond to a file name in this assembly's manifest.</span>
          </span>
        </param>
        <param name="rawModule">
          <span data-ttu-id="9629d-1260">位元組陣列，是以 COFF 為基礎而含有發出模組的映像，或是資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1260">A byte array that is a COFF-based image containing an emitted module, or a resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1261">使用通用物件檔案格式 (COFF) 為基礎的映像 (包含發出的模組) 或是資源檔，載入組件的內部模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1261">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1262">載入的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1262">The loaded module.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1263">
            <paramref name="moduleName" /> 或 <paramref name="rawModule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1263">
              <paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1264">
            <paramref name="moduleName" /> 與這個組件的資訊清單中的檔案項目不符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1264">
              <paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1265">
            <paramref name="rawModule" /> 不是有效的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1265">
              <paramref name="rawModule" /> is not a valid module.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1266">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1266">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-1267">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1267">to provide evidence.</span>
          </span>
          <span data-ttu-id="9629d-1268">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1268">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">
          <span data-ttu-id="9629d-1269">模組的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1269">The name of the module.</span>
          </span>
          <span data-ttu-id="9629d-1270">這個字串必須對應於這個組件的資訊清單中的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1270">This string must correspond to a file name in this assembly's manifest.</span>
          </span>
        </param>
        <param name="rawModule">
          <span data-ttu-id="9629d-1271">位元組陣列，是以 COFF 為基礎而含有發出模組的映像，或是資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1271">A byte array that is a COFF-based image containing an emitted module, or a resource.</span>
          </span>
        </param>
        <param name="rawSymbolStore">
          <span data-ttu-id="9629d-1272">位元組陣列，包含表示模組符號的未經處理位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1272">A byte array containing the raw bytes representing the symbols for the module.</span>
          </span>
          <span data-ttu-id="9629d-1273">如果這是資源檔，則必須是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1273">Must be <see langword="null" /> if this is a resource file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1274">使用通用物件檔案格式 (COFF) 為基礎的映像 (包含發出的模組) 或是資源檔，載入組件的內部模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1274">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span>
          </span>
          <span data-ttu-id="9629d-1275">表示模組符號的未經處理位元組也載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1275">The raw bytes representing the symbols for the module are also loaded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1276">載入的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1276">The loaded module.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1277">
            <paramref name="moduleName" /> 或 <paramref name="rawModule" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1277">
              <paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1278">
            <paramref name="moduleName" /> 與這個組件的資訊清單中的檔案項目不符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1278">
              <paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1279">
            <paramref name="rawModule" /> 不是有效的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1279">
              <paramref name="rawModule" /> is not a valid module.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1280">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1280">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-1281">若要提供辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1281">to provide evidence.</span>
          </span>
          <span data-ttu-id="9629d-1282">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1282">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1283">使用部分的名稱，從應用程式目錄或從全域組件快取載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1283">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="9629d-1284">多載<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>方法已經過時，而且為了與舊版相容而保留。</span><span class="sxs-lookup"><span data-stu-id="9629d-1284">The overloads of the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method are obsolete and have been retained for backward compatibility.</span></span> <span data-ttu-id="9629d-1285">非過時的替代方式是 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1285">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">
          <span data-ttu-id="9629d-1286">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1286">The display name of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1287">使用部分的名稱，從應用程式目錄或從全域組件快取載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1287">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1288">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1288">The loaded assembly.</span>
          </span>
          <span data-ttu-id="9629d-1289">如果找不到 <paramref name="partialName" />，這個方法會傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1289">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="9629d-1290"><xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29>方法已經過時，已保留回溯相容性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1290">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="9629d-1291">非過時的替代方式是 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1291">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9629d-1292">使用這個方法載入組件的應用程式將會受到這些組件升級。</span><span class="sxs-lookup"><span data-stu-id="9629d-1292">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="9629d-1293">因此，不會使用這個方法。重新設計應用程式使用<xref:System.Reflection.Assembly.Load%28System.String%29>方法多載或<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="9629d-1293">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%28System.String%29> method overload or the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 <span data-ttu-id="9629d-1294">這個方法會先呼叫<xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1294">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="9629d-1295">如果找不到組件，則這個方法會傳回組件從全域組件快取具有相同簡單名稱和最高的版本號碼。</span><span class="sxs-lookup"><span data-stu-id="9629d-1295">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1296">
            <paramref name="partialName" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1296">The <paramref name="partialName" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1297">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1297">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-1298">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1298">-or-</span>
          </span>
          <span data-ttu-id="9629d-1299">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="partialName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1299">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">
          <span data-ttu-id="9629d-1300">組件的顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1300">The display name of the assembly.</span>
          </span>
        </param>
        <param name="securityEvidence">
          <span data-ttu-id="9629d-1301">用於載入組件的辨識項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1301">Evidence for loading the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1302">使用部分的名稱，從應用程式目錄或從全域組件快取載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1302">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span>
          </span>
          <span data-ttu-id="9629d-1303">使用所提供的辨識項，將組件載入至呼叫端的定義域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1303">The assembly is loaded into the domain of the caller using the supplied evidence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1304">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1304">The loaded assembly.</span>
          </span>
          <span data-ttu-id="9629d-1305">如果找不到 <paramref name="partialName" />，這個方法會傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1305">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="9629d-1306"><xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29>方法已經過時，已保留回溯相容性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1306">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="9629d-1307">非過時的替代方式是 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1307">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9629d-1308">所謂的辨識項是一組資訊，由輸入的安全性原則決策所構成，例如要將那些權限授與給程式碼。</span><span class="sxs-lookup"><span data-stu-id="9629d-1308">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 <span data-ttu-id="9629d-1309">使用這個方法載入組件的應用程式將會受到這些組件升級。</span><span class="sxs-lookup"><span data-stu-id="9629d-1309">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="9629d-1310">因此，不會使用這個方法。重新設計應用程式使用<xref:System.Reflection.Assembly.Load%2A>方法或<xref:System.Reflection.Assembly.LoadFrom%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-1310">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%2A> method or the <xref:System.Reflection.Assembly.LoadFrom%2A> method.</span></span>  
  
 <span data-ttu-id="9629d-1311">這個方法會先呼叫<xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1311">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="9629d-1312">如果找不到組件，則這個方法會傳回組件從全域組件快取具有相同簡單名稱和最高的版本號碼。</span><span class="sxs-lookup"><span data-stu-id="9629d-1312">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1313">已使用兩組不同的辨識項載入組件或模組兩次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1313">An assembly or module was loaded twice with two different sets of evidence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1314">
            <paramref name="partialName" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1314">The <paramref name="partialName" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1315">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1315">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-1316">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1316">-or-</span>
          </span>
          <span data-ttu-id="9629d-1317">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="partialName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1317">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9629d-1318">呼叫 unmanaged 程式碼，並使用辨識項載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1318">for calling unmanaged code and to load an assembly with evidence.</span>
          </span>
          <span data-ttu-id="9629d-1319">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1319">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1320">取得包含資訊清單之載入檔的完整路徑或 UNC 位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1320">Gets the full path or UNC location of the loaded file that contains the manifest.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-1321">包含資訊清單之載入檔的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1321">The location of the loaded file that contains the manifest.</span>
          </span>
          <span data-ttu-id="9629d-1322">如果載入檔已經過陰影複製，則該位置就是陰影複製後的檔案位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1322">If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</span>
          </span>
          <span data-ttu-id="9629d-1323">如果組件是從位元組陣列載入 (例如，使用 <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> 方法多載時)，則傳回值就是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1323">If the assembly is loaded from a byte array, such as when using the <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> method overload, the value returned is an empty string ("").</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1324">若要取得位置，該檔案已陰影複製之前，請使用<xref:System.Reflection.Assembly.CodeBase%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1324">To get the location before the file has been shadow-copied, use the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9629d-1325">下列範例會顯示包含資訊清單之載入檔的位置。</span><span class="sxs-lookup"><span data-stu-id="9629d-1325">The following example displays the location of the loaded file that contains the manifest.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9629d-1326">目前的組件是以 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 物件表示的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1326">The current assembly is a dynamic assembly, represented by an <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-1327">存取路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1327">for access to the path.</span>
          </span>
          <span data-ttu-id="9629d-1328">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1328">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1329">取得包含目前組件之資訊清單的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1329">Gets the module that contains the manifest for the current assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-1330">包含組件之資訊清單的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1330">The module that contains the manifest for the assembly.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1331">發生於 Common Language Runtime 類別載入器無法經由一般方法解析對組件內部模組的參考時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1331">Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1332">這個事件提供回呼地尋找並載入模組本身並傳回它的機率。</span><span class="sxs-lookup"><span data-stu-id="9629d-1332">This event gives the callback a chance to find and load the module itself and return it.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9629d-1333">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1333">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9629d-1334">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1334">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1335">取得包含這個組件中模組的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1335">Gets a collection that contains the modules in this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-1336">包含此組件中之模組的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1336">A collection that contains the modules in this assembly.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="9629d-1337">與「右」<c></c>比較的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1337">The assembly to compare to <c>right</c>.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="9629d-1338">與「左」<c></c>比較的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1338">The assembly to compare to <c>left</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1339">表示兩個 <see cref="T:System.Reflection.Assembly" /> 物件是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1339">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1340">如果 <see langword="true" /> 等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1340">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="9629d-1341">與「右」<c></c>比較的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1341">The assembly to compare to <c>right</c>.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="9629d-1342">與「左」<c></c>比較的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1342">The assembly to compare to <c>left</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1343">表示兩個 <see cref="T:System.Reflection.Assembly" /> 物件是否不相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1343">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1344">如果 <see langword="true" /> 不等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1344">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1345">取得目前組件的授權集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1345">Gets the grant set of the current assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-1346">目前組件的授權集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1346">The grant set of the current assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1347"><xref:System.Security.PermissionSet> 物件可以包含機密資訊，例如路徑。</span><span class="sxs-lookup"><span data-stu-id="9629d-1347"><xref:System.Security.PermissionSet> objects can contain sensitive information such as paths.</span></span> <span data-ttu-id="9629d-1348">因此，完全信任，才能存取這些物件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1348">Therefore, full trust is required to access these objects.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9629d-1349">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1349">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9629d-1350">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1350">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1351">取得 <see cref="T:System.Boolean" /> 值，指出這個組件是否已載入僅限反映的內容中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1351">Gets a <see cref="T:System.Boolean" /> value indicating whether this assembly was loaded into the reflection-only context.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-1352">如果這個組件已載入僅限反映的內容 (而非執行內容) 中，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1352">
              <see langword="true" /> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1353">如果組件已載入僅限反映的內容，使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>方法中，您無法執行程式碼組件中。</span><span class="sxs-lookup"><span data-stu-id="9629d-1353">If an assembly has been loaded into the reflection-only context, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, you cannot execute code in the assembly.</span></span> <span data-ttu-id="9629d-1354">若要執行程式碼，組件必須載入的執行內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1354">To execute code, the assembly must be loaded into the execution context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1355">將組件載入僅限反映的內容中，以便在其中檢查組件但不執行組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1355">Loads an assembly into the reflection-only context, where it can be examined but not executed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">
          <span data-ttu-id="9629d-1356">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1356">A byte array that is a COFF-based image containing an emitted assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1357">從以通用物件檔案格式 (COFF) 為基礎的映像 (包含發出的組件) 載入組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1357">Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</span>
          </span>
          <span data-ttu-id="9629d-1358">這個組件會載入呼叫端應用程式定義域之僅限反映的內容中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1358">The assembly is loaded into the reflection-only context of the caller's application domain.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1359">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1359">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1360">您無法從組件載入僅限反映內容中執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="9629d-1360">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="9629d-1361">若要執行的程式碼，組件必須載入執行內容，使用<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-1361">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="9629d-1362">僅限反映的內容並無不同於其他的內容項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1362">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="9629d-1363">載入至內容的組件可以卸載只能透過卸載應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1363">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1364">
            <paramref name="rawAssembly" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1364">
              <paramref name="rawAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1365">
            <paramref name="rawAssembly" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1365">
              <paramref name="rawAssembly" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-1366">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1366">-or-</span>
          </span>
          <span data-ttu-id="9629d-1367">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="rawAssembly" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1367">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1368">
            <paramref name="rawAssembly" /> 無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1368">
              <paramref name="rawAssembly" /> cannot be loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <span data-ttu-id="9629d-1369">組件的顯示名稱，如同 <see cref="P:System.Reflection.AssemblyName.FullName" /> 屬性所傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1369">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1370">將組件載入僅限反映的內容中，並指定其顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1370">Loads an assembly into the reflection-only context, given its display name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1371">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1371">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1372">相依性不會自動載入至僅限反映的內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1372">Dependencies are not automatically loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="9629d-1373">您無法從組件載入僅限反映內容中執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="9629d-1373">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="9629d-1374">若要執行的程式碼，組件必須載入執行內容，使用<xref:System.Reflection.Assembly.Load%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-1374">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="9629d-1375">是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="9629d-1375">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="9629d-1376">組件和安全性辨識項合併的規則如下所示：</span><span class="sxs-lookup"><span data-stu-id="9629d-1376">The rules for assembly and security evidence merging are as follows:</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9629d-1377">反映在編譯 c + + 中的可執行檔上可能會擲回<xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="9629d-1377">Reflecting on executable files compiled in C++ might throw a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="9629d-1378">這很可能被因 c + + 編譯器移除定位位置或.reloc 區段，您可執行檔。</span><span class="sxs-lookup"><span data-stu-id="9629d-1378">This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</span></span> <span data-ttu-id="9629d-1379">若要保留.reloc 位址，請指定`/fixed:no`當您要連結。</span><span class="sxs-lookup"><span data-stu-id="9629d-1379">To preserve the .reloc address, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="9629d-1380">僅限反映的內容並無不同於其他的內容項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1380">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="9629d-1381">載入至內容的組件可以卸載只能透過卸載應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1381">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1382">
            <paramref name="assemblyString" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1382">
              <paramref name="assemblyString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1383">
            <paramref name="assemblyString" /> 為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1383">
              <paramref name="assemblyString" /> is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-1384">找不到 <paramref name="assemblyString" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1384">
              <paramref name="assemblyString" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1385">已找到 <paramref name="assemblyString" /> 但是無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1385">
              <paramref name="assemblyString" /> is found, but cannot be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1386">
            <paramref name="assemblyString" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1386">
              <paramref name="assemblyString" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-1387">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1387">-or-</span>
          </span>
          <span data-ttu-id="9629d-1388">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyString" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1388">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="9629d-1389">檔案的路徑，該檔案包含組件的資訊清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1389">The path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1390">將組件載入僅限反映的內容中，並指定其路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1390">Loads an assembly into the reflection-only context, given its path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1391">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1391">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1392">相依性不會自動載入至僅限反映的內容。</span><span class="sxs-lookup"><span data-stu-id="9629d-1392">Dependencies are not automatically loaded into the reflection-only context.</span></span> <span data-ttu-id="9629d-1393">若要自動載入相依性，請處理<xref:System.AppDomain.ReflectionOnlyAssemblyResolve>事件和負載事件處理常式中的相依性。</span><span class="sxs-lookup"><span data-stu-id="9629d-1393">To automatically load dependencies, handle the <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> event and load the dependency in the event handler.</span></span>  
  
 <span data-ttu-id="9629d-1394">您無法從組件載入僅限反映內容中執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="9629d-1394">You cannot execute code from an assembly that has been loaded into the reflection-only context.</span></span> <span data-ttu-id="9629d-1395">若要執行的程式碼，載入組件<xref:System.Reflection.Assembly.LoadFile%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9629d-1395">To execute the code, load the assembly with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="9629d-1396">`assemblyFile`參數必須參考到不含逸出字元的 URI。</span><span class="sxs-lookup"><span data-stu-id="9629d-1396">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="9629d-1397">這個方法會提供所有 URI 中的無效字元的逸出字元。</span><span class="sxs-lookup"><span data-stu-id="9629d-1397">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
 <span data-ttu-id="9629d-1398">針對指定的路徑`assemblyFile`相對於目前的目錄。</span><span class="sxs-lookup"><span data-stu-id="9629d-1398">The path specified for `assemblyFile` is relative to the current directory.</span></span> <span data-ttu-id="9629d-1399">組件會載入至呼叫端的定義域項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1399">The assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="9629d-1400">僅限反映的內容並無不同於其他的內容項目。</span><span class="sxs-lookup"><span data-stu-id="9629d-1400">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="9629d-1401">載入至內容的組件可以卸載只能透過卸載應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1401">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1402">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1402">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-1403">找不到 <paramref name="assemblyFile" />，或您想載入的模組並未指定檔案的副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1403">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1404">已找到 <paramref name="assemblyFile" /> 但是無法載入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1404">
              <paramref name="assemblyFile" /> is found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1405">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1405">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-1406">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1406">-or-</span>
          </span>
          <span data-ttu-id="9629d-1407">目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyFile" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1407">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="9629d-1408">指定了不是以 "file://" 開頭的基礎碼，而且沒有必要的 <see cref="T:System.Net.WebPermission" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1408">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="9629d-1409">組件名稱超過系統定義的長度上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1409">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1410">
            <paramref name="assemblyFile" /> 為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1410">
              <paramref name="assemblyFile" /> is an empty string ("").</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="9629d-1411">用於讀取以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1411">for reading a URI that begins with "file://".</span>
          </span>
          <span data-ttu-id="9629d-1412">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1412">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
        <permission cref="T:System.Net.WebPermission">
          <span data-ttu-id="9629d-1413">用於讀取不是以"file:// 開頭的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1413">for reading a URI that does not begin with "file://".</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1414">取得值，這個值指出應針對此組件強制執行的 Common Language Runtime (CLR) 安全性規則組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1414">Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9629d-1415">CLR 對這個組件強制執行的安全性規則組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1415">The security rule set that the CLR enforces for this assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1416">根據預設，您使用編譯的組件[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]有透明度，不過您可以明確成為改為。</span><span class="sxs-lookup"><span data-stu-id="9629d-1416">By default, assemblies that you compile with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] have  transparency, although you can explicitly make them  instead.</span></span> <span data-ttu-id="9629d-1417">舊版.NET Framework 進行編譯的組件具有層級 1 透明度。</span><span class="sxs-lookup"><span data-stu-id="9629d-1417">Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</span></span>  
  
 <span data-ttu-id="9629d-1418">請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="9629d-1418">See [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1419">傳回目前執行個體的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1419">Returns the type of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1420">代表 <see cref="T:System.Reflection.Assembly" /> 類型的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1420">An object that represents the <see cref="T:System.Reflection.Assembly" /> type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9629d-1421">傳回組件的完整名稱，也稱為顯示名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1421">Returns the full name of the assembly, also known as the display name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1422">組件的完整名稱或類別名稱 (如果無法判斷組件的完整名稱)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1422">The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">
          <span data-ttu-id="9629d-1423">檔案的名稱或路徑，包含組件的資訊清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1423">The name or path of the file that contains the manifest of the assembly.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9629d-1424">將組件載入到載入內容中，並略過部分安全性檢查。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1424">Loads an assembly into the load-from context, bypassing some security checks.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9629d-1425">載入的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1425">The loaded assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9629d-1426">使用這個方法載入作業系統標示為已從 Web （例如，暫存檔案從網際網路或內部網路下載） 載入的本機組件。</span><span class="sxs-lookup"><span data-stu-id="9629d-1426">Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</span></span> <span data-ttu-id="9629d-1427">之前[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，這類組件已自動載入沙箱應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9629d-1427">Before the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], such assemblies were automatically loaded into a sandboxed application domain.</span></span> <span data-ttu-id="9629d-1428">從開始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，它們是以完全信任來載入。</span><span class="sxs-lookup"><span data-stu-id="9629d-1428">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], they are loaded with full trust.</span></span>  
  
 <span data-ttu-id="9629d-1429">您可以使用此方法的替代方案，以套用[ &lt;NetFx40_LegacySecurityPolicy&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)應用程式組態檔中。</span><span class="sxs-lookup"><span data-stu-id="9629d-1429">As an alternative to using this method, you can apply the [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) in your application configuration file.</span></span> <span data-ttu-id="9629d-1430">這會導致 common language runtime，若要還原的安全性原則[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="9629d-1430">This causes the common language runtime to revert to the security policy of the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9629d-1431">如果您使用這些解決方案，您必須先確認它是安全載入`assemblyFile`以完全信任。</span><span class="sxs-lookup"><span data-stu-id="9629d-1431">If you use either of these solutions, you must be certain that it is safe to load `assemblyFile` with full trust.</span></span>  
  
 <span data-ttu-id="9629d-1432">討論的載入內容，包括為載入來源內容，請參閱<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="9629d-1432">For a discussion of load contexts, including the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9629d-1433">
            <paramref name="assemblyFile" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1433">
              <paramref name="assemblyFile" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9629d-1434">
            <paramref name="assemblyFile" /> 找不到，或者您要載入的模組未指定副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1434">
              <paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="9629d-1435">無法載入找到的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1435">A file that was found could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="9629d-1436">
            <paramref name="assemblyFile" /> 不是有效的組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1436">
              <paramref name="assemblyFile" /> is not a valid assembly.</span>
          </span>
          <span data-ttu-id="9629d-1437">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1437">-or-</span>
          </span>
          <span data-ttu-id="9629d-1438">用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1438">
              <paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="9629d-1439">指定了不是以 "file://" 開頭的基礎碼，而且沒有必要的 <see cref="T:System.Net.WebPermission" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1439">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9629d-1440">
            <paramref name="assemblyFile" /> 參數是空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1440">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="9629d-1441">組件名稱超過系統定義的長度上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1441">The assembly name exceeds the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9629d-1442">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1442">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9629d-1443">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9629d-1443">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>