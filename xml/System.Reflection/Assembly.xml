<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ca1d35134ce1c37e8332bb5562a19a9db5b2b1fa" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51926976" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示組件 (Assembly)，此組件是可重複使用、可控制版本和自我描述的 Common Language Runtime 應用程式建置區塊。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Reflection.Assembly>類別來載入組件，來瀏覽組件，來探索組件中包含的型別，以及建立這些類型的執行個體的中繼資料和組成組件。  
  
 若要取得的陣列<xref:System.Reflection.Assembly>物件代表目前的組件載入應用程式定義域 （比方說的預設應用程式定義域的簡單專案），使用<xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType>方法。  
  
 以動態方式載入組件<xref:System.Reflection.Assembly>類別提供下列靜態方法 (`Shared`方法在 Visual Basic 中的)。 組件會載入應用程式定義域載入作業發生的位置。  
  
-   載入組件的建議的方式是使用<xref:System.AppDomain.Load%2A>方法，用來識別要由其顯示名稱所載入的組件 (比方說，"System.Windows.Forms，version=2.0.0.0，Culture = neutral，publickeytoken=b77a5c561934e089")。 組件的搜尋會遵循規則中所述[執行階段如何找出組件](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)。  
  
-   <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法可讓您載入組件反映，但不是執行。 比方說，64 位元平台為目標的組件由 32 位元平台執行的程式碼進行檢查。  
  
-   <xref:System.Reflection.Assembly.LoadFile%2A>和<xref:System.Reflection.Assembly.LoadFrom%2A>方法提供極少數的情況下必須路徑所識別的組件中。  
  
 若要取得<xref:System.Reflection.Assembly>物件的目前執行的組件，用來使用<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>方法。  
  
 許多成員的<xref:System.Reflection.Assembly>類別提供組件的相關資訊。 例如:   
  
-   <xref:System.Reflection.Assembly.GetName%2A>方法會傳回<xref:System.Reflection.AssemblyName>提供存取組件的顯示名稱的組件的物件。  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A>方法會列出套用至組件的屬性。  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A>方法可以存取組件資訊清單中的檔案。  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A>方法提供的組件資訊清單中的資源名稱。  
  
 <xref:System.Reflection.Assembly.GetTypes%2A>方法列出組件中的所有型別。 <xref:System.Reflection.Assembly.GetExportedTypes%2A>方法列出呼叫端組件外部可見的類型。 <xref:System.Reflection.Assembly.GetType%2A>方法可以用來搜尋特定型別的組件中。 <xref:System.Reflection.Assembly.CreateInstance%2A>方法可以用來搜尋及組件中建立型別的執行個體。  
  
 如需有關組件的詳細資訊，請參閱 < 應用程式定義域和組件 > 一節[應用程式定義域](~/docs/framework/app-domains/application-domains.md)主題。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得目前執行的組件、 建立該組件，內含類型的執行個體和叫用其中一種類型的方法具有晚期繫結。 基於此目的，在程式碼範例定義名為類別`Example`，與名為方法`SampleMethod`。 類別的建構函式會接受一個整數，用來計算該方法的傳回值。  
  
 在程式碼範例也示範如何使用<xref:System.Reflection.Assembly.GetName%2A>方法，以取得<xref:System.Reflection.AssemblyName>可以用來剖析組件的完整名稱的物件。 此範例會顯示組件的版本號碼<xref:System.Reflection.Assembly.CodeBase%2A>屬性，而<xref:System.Reflection.Assembly.EntryPoint%2A>屬性。  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">針對繼承者完全信任。 這個類別無法繼承由部分信任的程式碼。</permission>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">應用程式定義域</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Reflection.Assembly" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會由衍生類別叫用的建構期間<xref:System.Reflection.Assembly>物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得組件位置，例如原先在 <see cref="T:System.Reflection.AssemblyName" /> 物件中指定的。</summary>
        <value>原先指定的組件位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得載入的資訊清單包含檔案的絕對路徑，請使用<xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType>屬性改為。  
  
 做為位元組陣列載入組件時，使用的多載<xref:System.Reflection.Assembly.Load%2A>採用位元組陣列的方法，這個屬性會傳回呼叫端的方法，而不是載入的組件的位置的位置。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Reflection.Assembly.CodeBase%2A>屬性。  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從這個組件找出類型，並使用系統啟動項 (Activator) 建立它的執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要尋找的 <see cref="P:System.Type.FullName" /> 類型。</param>
        <summary>從這個組件找出指定類型，並使用系統啟動項，利用區分大小寫的搜尋，建立它的執行個體。</summary>
        <returns>透過預設建構函式建立之指定類型的執行個體，如果找不到 <see langword="null" /> 則為 <paramref name="typeName" />。 該類型在 <see cref="T:System.Reflection.BindingFlags" /> 設定為 <see langword="Public" /> 或 <see langword="Instance" /> 時，於未指定文化特性或啟動屬性的情況下，使用預設繫結器進行解析。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果找不到執行階段`typeName`中<xref:System.Reflection.Assembly>執行個體，它會傳回`null`而非擲回例外狀況。 這可能是因為：  
  
-   您還沒有指定之型別的完整的名稱。  
  
-   您已指定完整限定的類型名稱，但其不符合類型之大小寫<xref:System.Type.FullName%2A?displayProperty=nameWithType>屬性。 如需不區分大小寫的比較`typeName`型別的完整名稱，然後呼叫<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>多載，並指定`true`如`ignoreCase`引數。  
  
-   型別不存在於目前<xref:System.Reflection.Assembly>執行個體。  
  
   
  
## Examples  
 下列範例會定義`Person`類別並呼叫<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>它具現化的方法。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 為空字串 ("") 或以 null 字元開頭的字串。  
  
-或- 
目前的組件已載入到僅限反映的內容中。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="typeName" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="typeName" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="typeName" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="typeName" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要尋找的 <see cref="P:System.Type.FullName" /> 類型。</param>
        <param name="ignoreCase">若要忽略類型名稱的大小寫，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>從這個組件找出指定類型，並使用系統啟動項，利用選擇性區分大小寫的搜尋，建立它的執行個體。</summary>
        <returns>透過預設建構函式建立之指定類型的執行個體，如果找不到 <see langword="null" /> 則為 <paramref name="typeName" />。 該類型在 <see cref="T:System.Reflection.BindingFlags" /> 設定為 <see langword="Public" /> 或 <see langword="Instance" /> 時，於未指定文化特性或啟動屬性的情況下，使用預設繫結器進行解析。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果找不到執行階段`typeName`中<xref:System.Reflection.Assembly>執行個體，它會傳回`null`而非擲回例外狀況。 這可能是因為：  
  
-   您還沒有指定之型別的完整的名稱。  
  
-   型別不存在於目前<xref:System.Reflection.Assembly>執行個體。  
  
   
  
## Examples  
 下列範例會定義`Person`類別。 然後它會呼叫<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>方法具現化，但因為機殼`typeName`引數不符合的型別<xref:System.Type.FullName%2A>屬性，此方法會傳回`null`。 當範例會傳遞至相同的字串<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>多載，並指定比較是否應區分大小寫，`Person`找到類別，和`Person`成功具現化物件。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 為空字串 ("") 或以 null 字元開頭的字串。  
  
-或- 
目前的組件已載入到僅限反映的內容中。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="typeName" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="typeName" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="typeName" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="typeName" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">要尋找的 <see cref="P:System.Type.FullName" /> 類型。</param>
        <param name="ignoreCase">若要忽略類型名稱的大小寫，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <param name="bindingAttr">位元遮罩，會影響搜尋的進行方式。 該值是來自 <see cref="T:System.Reflection.BindingFlags" /> 的位元旗標之組合。</param>
        <param name="binder">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see langword="MemberInfo" /> 物件的物件。 如果 <c>Binder</c> 為 <see langword="null" />，則會使用預設 Binder。</param>
        <param name="args">包含要傳遞至建構函式之引數的陣列。 這個引數陣列必須在數目、順序和類型上符合要叫用的建構函式的參數。 如果需要預設的建構函式，則 <c>args</c> 必須是空陣列或 <see langword="null" />。</param>
        <param name="culture">
          <see langword="CultureInfo" /> 的執行個體，用於管理類型的強制型轉。 如果這是 <see langword="null" />，會使用目前執行緒的 <see langword="CultureInfo" />。 (例如，要將代表 1000 的 <see langword="String" /> 轉換成 <see langword="Double" /> 值時，這是必要的，因為 1000 的表示方式會因不同文化特性而有所不同)。</param>
        <param name="activationAttributes">一或多個屬性的陣列，此屬性可參與啟動過程。 陣列通常只會包含一個 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 物件來指定用以啟動遠端物件的 URL。  此參數與啟動了用戶端的物件相關。 用戶端啟動是一項舊的技術，保留目的在提供回溯相容性，不建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。</param>
        <summary>從這個組件找出指定類型，並使用系統啟動項，利用選擇性區分大小寫的搜尋，以及取得指定文化特性 (Culture)、引數和繫結和啟動屬性，建立它的執行個體。</summary>
        <returns>指定之類型的執行個體，如果找不到 <see langword="null" /> 則為 <paramref name="typeName" />。 所提供的引數會用來解析類型，以及繫結建立執行個體所用的建構函式。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 為空字串 ("") 或以 null 字元開頭的字串。  
  
-或- 
目前的組件已載入到僅限反映的內容中。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">找不到相符的建構函式。</exception>
        <exception cref="T:System.NotSupportedException">將非空白的啟用屬性陣列傳遞給不是繼承自 <see cref="T:System.MarshalByRefObject" /> 的類型。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="typeName" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="typeName" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="typeName" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="typeName" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要建立委派的執行個體。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">組件的顯示名稱。</param>
        <param name="typeName">類型的完整名稱。</param>
        <summary>建立類型名稱，由其組件的顯示名稱所限定。</summary>
        <returns>類型的完整名稱是由組件的顯示名稱所限定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回字串的格式為：  
  
 \<FullTypeName >， \<AssemblyDisplayName >  
  
 請參閱<xref:System.Reflection.AssemblyName>的組件的顯示名稱格式的說明。  
  
 為了符合 common language runtime 的版本中的變更，請使用這個方法，而不是自行建構的限定的名稱。  如需完整的組件名稱的資訊，請參閱<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含此組件之自訂屬性的集合。</summary>
        <value>包含此組件之自訂屬性的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個組件中定義之類型的集合。</summary>
        <value>這個組件中定義的類型集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A>屬性相當於<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法，不同之處在於<xref:System.Reflection.Assembly.DefinedTypes%2A>屬性傳回的集合<xref:System.Reflection.TypeInfo>物件，而<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法傳回的陣列<xref:System.Type>物件。  
  
 傳回的陣列會包含巢狀型別。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個組件的進入點。</summary>
        <value>物件，表示這個組件的進入點。 如果找不到進入點 (例如，組件是 DLL)，則傳回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">與這個執行個體相互比較的物件。</param>
        <summary>判斷這個組件和指定的物件是否相等。</summary>
        <returns>如果 <see langword="true" /> 等於這個執行個體則為 <paramref name="o" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A>方法會執行參考相等來判斷測試是否目前的執行個體和`o`相等。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得代表基礎碼的 URI，包括逸出字元。</summary>
        <value>具有逸出字元的 URI。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個組件的辨識碼。</summary>
        <value>這個組件的辨識項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所謂的辨識項是一組資訊，由輸入的安全性原則決策所構成，例如要將那些權限授與給程式碼。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在這個組件中定義的公用類型集合，而這些類型在組件外部是可見的。</summary>
        <value>在這個組件中定義的公用類型，而這些類型在組件外部是可見的。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得組件的顯示名稱。</summary>
        <value>組件的顯示名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱<xref:System.Reflection.AssemblyName>的組件的顯示名稱格式的說明。  
  
> [!NOTE]
>  建議您不要撰寫自己的程式碼剖析顯示名稱。 相反地，顯示將名稱傳遞給<xref:System.Reflection.AssemblyName.%23ctor%2A>建構函式加以剖析，並於其中填入新的適當欄位<xref:System.Reflection.AssemblyName>。  
  
 在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。 不過，它不包含在所傳回的字串<xref:System.Reflection.Assembly.FullName%2A>屬性，因為相容性。 請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會擷取目前正在執行的組件的顯示名稱和包含的組件的顯示名稱<xref:System.Int32>型別 (`int`在 C# 中， `Integer` Visual Basic 中)。  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完整的類型名稱</related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">物件，代表會傳回的組件類型。</param>
        <summary>取得目前載入的組件，其中定義指定類型。</summary>
        <returns>組件，其中定義指定類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法就相當於擷取的值<xref:System.Type.Assembly?displayProperty=nameWithType>屬性。 不過，<xref:System.Type.Assembly?displayProperty=nameWithType>屬性通常會提供更優異的效能。  
  
 若要呼叫這個方法，您必須擁有<xref:System.Type>物件，這表示在其中定義該類別的組件必須已經載入。  
  
   
  
## Examples  
 下列範例會擷取包含的組件<xref:System.Int32>輸入，並顯示其名稱和檔案的位置。  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回方法的 <see cref="T:System.Reflection.Assembly" />，其叫用目前執行的方法。</summary>
        <returns>方法的 <see langword="Assembly" /> 物件，其叫用目前執行的方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法，會呼叫<xref:System.Reflection.Assembly.GetCallingAssembly%2A>方法是由在 just-in-time (JIT) 編譯器內嵌展開，或是如果內嵌方式展開其呼叫端，組件所傳回<xref:System.Reflection.Assembly.GetCallingAssembly%2A>意外可能不同。 例如，請考慮下列方法和組件：  
  
-   方法`M1`組件中`A1`呼叫<xref:System.Reflection.Assembly.GetCallingAssembly%2A>。  
  
-   方法`M2`組件中`A2`呼叫`M1`。  
  
-   方法`M3`組件中`A3`呼叫`M2`。  
  
 當`M1`不是內嵌<xref:System.Reflection.Assembly.GetCallingAssembly%2A>傳回`A2`。 當`M1`是內嵌<xref:System.Reflection.Assembly.GetCallingAssembly%2A>傳回`A3`。 同樣地，當`M2`不是內嵌<xref:System.Reflection.Assembly.GetCallingAssembly%2A>傳回`A2`。 當`M2`是內嵌<xref:System.Reflection.Assembly.GetCallingAssembly%2A>傳回`A3`。  
  
 也會發生這種效果時`M1`為結尾的呼叫，從執行`M2`，或當`M2`為結尾的呼叫，從執行`M3`。 您可以防止 JIT 編譯器內嵌呼叫的方法<xref:System.Reflection.Assembly.GetCallingAssembly%2A>，藉由套用<xref:System.Runtime.CompilerServices.MethodImplAttribute>屬性搭配<xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType>旗標，但沒有任何類似的機制，可防止 tail 呼叫。  
  
   
  
## Examples  
 下列範例會取得目前的方法呼叫的組件。  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得這個組件的自訂屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see cref="T:System.Reflection.Assembly" /> 類型的物件會忽略這個引數。</param>
        <summary>取得這個組件的所有自訂屬性。</summary>
        <returns>包含此組件之自訂屬性的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作對應<xref:System.Reflection.ICustomAttributeProvider>介面方法。 因此，`inherit`必須指定參數，即使它會被忽略。  
  
 虛擬的屬性會指出時有這個屬性時，必須設定核心中繼資料的位元。 與擴充類型的中繼資料，並儲存以及類型的自訂屬性，不同的是虛擬屬性修改類型的中繼資料，則會捨棄。 某些產生的位元不能使用現有的反映 Api 來存取。  
  
 下表摘要說明不同的虛擬屬性和可反映中的位元的存取子。  
  
|虛擬屬性|中繼資料位元|反映存取子|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 名稱|沒有存取子 PInvokeMap 一般方法/全域方法屬性。<br /><br /> DLL 名稱沒有存取子。|  
|GuidAttribute|儲存為真正的自訂屬性。|存取為真正的自訂屬性。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|各種不同的位元。|沒有存取子。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags()。OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags()。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 類別封裝。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 沒有存取子。|  
|FieldOffsetAttribute|欄位的位移。|沒有存取子。|  
|AssemblyLoadAttribute|CorAssemblyFlags|沒有存取子或列舉值。|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">要為其傳回自訂屬性的類型。</param>
        <param name="inherit">
          <see cref="T:System.Reflection.Assembly" /> 類型的物件會忽略這個引數。</param>
        <summary>取得這個組件由類型所指定的自訂屬性。</summary>
        <returns>包含這個組件之自訂屬性的陣列，這些自訂屬性是由 <paramref name="attributeType" /> 所指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作對應<xref:System.Reflection.ICustomAttributeProvider>介面方法。 因此，`inherit`必須指定參數，即使它會被忽略。  
  
 虛擬的屬性會指出時有這個屬性時，必須設定核心中繼資料的位元。 與擴充類型的中繼資料，並儲存以及類型的自訂屬性，不同的是虛擬屬性修改類型的中繼資料，則會捨棄。 某些產生的位元不能使用現有的反映 Api 來存取。  
  
 下表摘要說明不同的虛擬屬性和可反映中的位元的存取子。  
  
|虛擬屬性|中繼資料位元|反映存取子|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 名稱|沒有存取子 PInvokeMap 一般方法/全域方法屬性。<br /><br /> DLL 名稱沒有存取子。|  
|GuidAttribute|儲存為真正的自訂屬性。|存取為真正的自訂屬性。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|各種不同的位元。|沒有存取子。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags()。OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags()。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 類別封裝。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 沒有存取子。|  
|FieldOffsetAttribute|欄位的位移。|沒有存取子。|  
|AssemblyLoadAttribute|CorAssemblyFlags|沒有存取子或列舉值。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> 不是執行階段類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回已套用至目前 <see cref="T:System.Reflection.Assembly" /> 之屬性的相關資訊，表示為 <see cref="T:System.Reflection.CustomAttributeData" /> 物件。</summary>
        <returns>
          <see cref="T:System.Reflection.CustomAttributeData" /> 物件的泛型清單，表示已套用至目前組件之屬性的資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要檢查的自訂屬性中僅限反映的內容，在其中已載入至僅限反映內容的程式碼中定義的自訂屬性本身的情況下的程式碼中使用這個方法。 等方法<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>和<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>不能在這種情況下，因為它們會產生屬性的執行個體。 無法執行僅限反映內容中的程式碼。 如需詳細資訊和例如程式碼，請參閱<xref:System.Reflection.CustomAttributeData>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得預設應用程式定義域中的處理序可執行檔。 在其他應用程式定義域中，這是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 執行的第一個可執行檔。</summary>
        <returns>組件，該組件是預設應用程式定義域中的處理序可執行檔，或是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 執行的第一個可執行檔。 從 Unmanaged 程式碼呼叫時，可能會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.GetEntryAssembly%2A>方法可以傳回`null`當 managed 組件已載入來自未受管理的應用程式。 例如，如果未受管理的應用程式會建立以 C# 撰寫，呼叫 COM 元件的執行個體<xref:System.Reflection.Assembly.GetEntryAssembly%2A>C# 元件的方法會傳回 null，因為在程序的進入點是 unmanaged 程式碼，而不是 managed 組件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得組件，其中含有目前正在執行的程式碼。</summary>
        <returns>包含目前正在執行之程式碼的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基於效能考量，您應該在您不知道在執行階段目前正在執行哪一個組件時，才呼叫這個方法。 建議用來擷取<xref:System.Reflection.Assembly>物件，表示目前的組件是使用<xref:System.Type.Assembly%2A?displayProperty=nameWithType>類型的屬性找到的組件，如下列範例所示。  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 若要取得組件，其中包含呼叫目前執行的程式碼的方法，使用<xref:System.Reflection.Assembly.GetCallingAssembly%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Type.Assembly%2A?displayProperty=nameWithType>取得目前執行的組件的屬性，根據該組件中所包含的型別。 它也會呼叫<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>方法，以顯示，它會傳回<xref:System.Reflection.Assembly>物件，代表相同的組件。  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得在這個組件中定義的公用類型，而這些類型在組件外部是可見的。</summary>
        <returns>陣列，表示在這個組件中定義的類型，而這些類型會在組件外部顯示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件外部可見的類型才是公用類型和其他公用型別內的巢狀的公用型別。  
  
   
  
## Examples  
 下列程式碼範例會定義數個類別使用各種存取層級，與呼叫<xref:System.Reflection.Assembly.GetExportedTypes%2A>來顯示組件外部可見的項目。  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">該組件是動態組件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法載入相依組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">指定檔案的名稱。 切勿包括該檔案的路徑。</param>
        <summary>取得指定之檔案的 <see cref="T:System.IO.FileStream" />，這個指定之檔案位於這個組件的資訊清單檔案表中。</summary>
        <returns>包含指定之檔案的資料流，如果找不到檔案則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法適用於這兩個公用和私用資源檔案。  
  
 `name`不應該包含檔案的路徑。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 不是有效的組件。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">為存取路徑，並讀取指定的檔案。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得組件資訊清單檔案表中的檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得組件資訊清單檔案表中的檔案。</summary>
        <returns>包含檔案之資料流的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法適用於公用和私用的資源檔。  
  
 這個多載就相當於呼叫<xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29>多載，並指定`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案。</exception>
        <exception cref="T:System.BadImageFormatException">檔案不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>取得組件資訊清單檔案表中的檔案，指定是否要包含資源模組。</summary>
        <returns>包含檔案之資料流的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法適用於公用和私用的資源檔。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案。</exception>
        <exception cref="T:System.BadImageFormatException">檔案不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個執行個體的雜湊碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得做為這個組件部分的所有載入模組。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得做為這個組件部分的所有載入模組。</summary>
        <returns>模組陣列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>取得做為這個組件部分的所有載入模組，指定是否要包含資源模組。</summary>
        <returns>模組陣列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">區分大小寫的資源名稱。</param>
        <summary>傳回指定資源已保存方式的資訊。</summary>
        <returns>物件，其中會填入有關資源拓撲的資訊，如果找不到資源，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有當資源會顯示呼叫者，或呼叫端時，才會傳回資源資訊<xref:System.Security.Permissions.ReflectionPermission>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> 參數是空字串 ("")。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個組件中的所有資源名稱。</summary>
        <returns>陣列，包含所有資源的名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用每個資源名稱，如下所示，這個方法所傳回陣列中：  
  
-   您可以傳遞要的資源名稱<xref:System.Reflection.Assembly.GetManifestResourceInfo%2A>方法來取得資源的其他資訊。  
  
-   如果名稱識別的二進位.resources 檔案，您可以移除其.resources 檔的副檔名，並將它傳遞給<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType>建構函式來具現化資源管理員。  
  
-   您可以傳遞要的資源名稱<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>方法來擷取<xref:System.IO.Stream>物件，您可以傳遞至<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>建構函式。  
  
-   您可以傳遞要的資源名稱<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>方法來擷取<xref:System.IO.Stream>物件，您可以傳遞至<xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>建構函式。  
  
 只有當資源會顯示呼叫者，或呼叫端時，才會傳回資源資訊<xref:System.Security.Permissions.ReflectionPermission>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>載入來自這個組件的指定資訊清單資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">所要求的資訊清單資源的區分大小寫名稱。</param>
        <summary>載入來自這個組件的指定資訊清單資源。</summary>
        <returns>資訊清單資源，而如果編譯期間未指定資源或是呼叫者看不到該資源，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資訊清單資源是在編譯時期的組件中內嵌的資源 （例如影像檔）。 如需有關資訊清單資源的詳細資訊，請參閱[Microsoft.NET Framework 資源的基本概念](https://go.microsoft.com/fwlink/?LinkId=204554)MSDN Library 中。  
  
 只有當資源會顯示呼叫者，或呼叫端時，才會傳回資源資訊<xref:System.Security.Permissions.ReflectionPermission>。  
  
> [!NOTE]
>  這個方法會傳回`null`如果存取私用的資源，另一個組件，而且呼叫端沒有<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標。  
  
 如果組件資訊清單列出的資源檔<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>傳回<xref:System.IO.Stream>物件即使資源檔在找不在磁碟上的時間。 如果找不到資源檔，並傳遞產生<xref:System.IO.Stream>物件至<xref:System.Resources.ResourceReader>建構函式會導致<xref:System.ArgumentException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 無法載入找到的檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 不是有效的組件。</exception>
        <exception cref="T:System.NotImplementedException">資源長度大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">組件資訊清單</related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">類型，其命名空間是用來限定資訊清單資源名稱的範圍。</param>
        <param name="name">所要求的資訊清單資源的區分大小寫名稱。</param>
        <summary>從這個組件載入指定資訊清單資源，由指定類型的命名空間限定範圍。</summary>
        <returns>資訊清單資源，而如果編譯期間未指定資源或是呼叫者看不到該資源，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比方說，如果完整名稱指定給`type`是 「 MyNameSpace.MyClasses"和`name`是"Net"，這個方法多載搜尋名為"MyNameSpace.Net 」 的資源。  
  
 資訊清單資源是在編譯時期的組件中內嵌的資源 （例如影像檔）。 如需有關資訊清單資源的詳細資訊，請參閱[Microsoft.NET Framework 資源的基本概念](https://go.microsoft.com/fwlink/?LinkId=204554)MSDN Library 中。  
  
 只有當資源會顯示呼叫者，或呼叫端時，才會傳回資源資訊<xref:System.Security.Permissions.ReflectionPermission>。  
  
> [!NOTE]
>  這個方法會傳回`null`如果存取私用的資源，另一個組件，而且呼叫端沒有<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標。  
  
 如果組件資訊清單列出的資源檔<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>傳回<xref:System.IO.Stream>物件即使資源檔在找不在磁碟上的時間。 如果找不到資源檔，並傳遞產生<xref:System.IO.Stream>物件至<xref:System.Resources.ResourceReader>建構函式會導致<xref:System.ArgumentException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 不是有效的組件。</exception>
        <exception cref="T:System.NotImplementedException">資源長度大於 <see cref="F:System.Int64.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">當叫用晚期繫結機制透過例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">組件資訊清單</related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">所要求的模組名稱。</param>
        <summary>取得這個組件中的指定模組。</summary>
        <returns>正在接受要求的模組，如果找不到模組，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法適用於檔案名稱。  
  
 中的類別`Reflection.Emit`命名空間發出動態模組的範圍名稱。 領域名稱可以由<xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType>屬性。 傳遞您想要的模組類型`Assembly.GetModule`。 比方說，如果您想包含組件資訊清單的模組時，傳遞到模組的範圍名稱`GetModule`。 否則，請傳遞模組的檔案名稱。 載入組件，這是由其中一個`Load`具有 byte [] 參數的方法只有一個的模組，這是資訊清單模組。 一律搜尋這些使用範圍名稱的模組。  
  
 型別可以擷取從特定模組使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>。 呼叫`Module.GetType`模組包含資訊清單不會起始一整個組件的搜尋。 若要擷取類型從組件，不論哪一個模組是在中，您必須呼叫<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 不是有效的組件。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得所有屬於這個組件的模組。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得所有屬於這個組件的模組。</summary>
        <returns>模組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法適用於公用和私用的資源檔。  
  
> [!NOTE]
>  模組必須發出具有副檔名的檔案。  
  
   
  
## Examples  
 下列範例會傳回的陣列，其中包含組件資訊清單中顯示模組的名稱。  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">要載入的模組未指定副檔名。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">若要包含資源模組，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>取得所有屬於這個組件的模組，指定是否要包含資源模組。</summary>
        <returns>模組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法適用於公用和私用的資源檔。  
  
> [!NOTE]
>  模組必須發出具有副檔名的檔案。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得這個組件的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得這個組件的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
        <returns>物件，包含這個組件的完整剖析顯示名稱。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取組件的路徑。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">若要將 <see langword="true" /> 設定為組件陰影複製以後的位置，則為 <see cref="P:System.Reflection.Assembly.CodeBase" />；若要將 <see langword="false" /> 設定為原始位置，則為 <see cref="P:System.Reflection.Assembly.CodeBase" />。</param>
        <summary>取得這個組件的 <see cref="T:System.Reflection.AssemblyName" />，設定按照 <paramref name="copiedName" /> 指定的基礎碼。</summary>
        <returns>物件，包含這個組件的完整剖析顯示名稱。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取組件的路徑。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">要被填入 (Populate) 序列化資訊的物件。</param>
        <param name="context">序列化的目的端內容。</param>
        <summary>使用要重新執行個體化這個組件所需的所有資料，取得序列化 (Serialization) 資訊。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得這個組件參考之所有組件的 <see cref="T:System.Reflection.AssemblyName" /> 物件。</summary>
        <returns>陣列，包含這個組件參考之所有組件的完整剖析顯示名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，則<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>屬性<xref:System.Reflection.AssemblyName>這個方法所傳回的物件是<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType>沒有雜湊演算法所參考的組件，則不是參考的組件的雜湊演算法由識別<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>列舉型別。 在舊版的.NET Framework 中，<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>屬性傳回<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType>在此情況下。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A>方法。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Assembly>類別。  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得附屬組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">指定的文化特性。</param>
        <summary>取得指定文化特性的附屬組件。</summary>
        <returns>指定的附屬組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附屬組件包含不同主要應用程式組件，其中包含不可當地語系化的可執行程式碼和做為預設或中性文化特性之單一文化特性資源的當地語系化的資源。  
  
 呼叫這個方法，以使用您目前的組件版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找不到具有相符檔案名稱的附屬組件，但 <see langword="CultureInfo" /> 不符合所指定者。</exception>
        <exception cref="T:System.BadImageFormatException">此附屬組件不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">指定的文化特性。</param>
        <param name="version">附屬組件的版本。</param>
        <summary>取得指定文化特性的附屬組件指定版本。</summary>
        <returns>指定的附屬組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附屬組件包含不同主要應用程式組件，其中包含不可當地語系化的可執行程式碼和做為預設或中性文化特性之單一文化特性資源的當地語系化的資源。  
  
 呼叫<xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29>多載，以使用您目前的組件版本。  
  
 如果`version`是`null`，如果將 資源 與 主要組件已簽署，系統會使用目前的組件版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到檔案名稱相符的附屬組件，但 <see langword="CultureInfo" /> 或版本不符合所指定者。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到組件。</exception>
        <exception cref="T:System.BadImageFormatException">此附屬組件不是有效的組件。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得代表指定類型的 <see cref="T:System.Type" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">類型的完整名稱。</param>
        <summary>取得具有組件執行個體中指定名稱的 <see cref="T:System.Type" /> 物件。</summary>
        <returns>物件，表示指定的類別，如果找不到類別，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會搜尋目前組件執行個體。 `name`參數包含命名空間，但不是含組件。 若要搜尋型別的其他組件，請使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法多載，可以選擇性地包含組件顯示名稱的型別名稱的一部分。  
  
> [!NOTE]
>  如果類型已轉送至另一個組件，它仍會傳回這個方法。 類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
   
  
## Examples  
 下列範例會定義抽象`MeansOfTransportation`類別中`Transportation`命名空間。 它會呼叫<xref:System.Reflection.Assembly.GetType%28System.String%29>方法來擷取其<xref:System.Type>物件時，會呼叫<xref:System.Type.GetProperties%2A?displayProperty=nameWithType>方法來取得各種<xref:System.Reflection.PropertyInfo>代表類型的屬性，然後在類型上顯示資訊的物件抽象屬性。 請注意，呼叫<xref:System.Reflection.Assembly.GetType%28System.String%29>方法會使用型別的完整格式的名稱 （亦即，其型別名稱以及其命名空間）。  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 無效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="name" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>找到 
          <paramref name="name" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="name" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="name" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">類型的完整名稱。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，<see langword="false" /> 則表示傳回 <see langword="null" />。</param>
        <summary>取得具有組件執行個體中指定之名稱的 <see cref="T:System.Type" /> 物件，並在找不到類型時選擇性地擲回例外狀況。</summary>
        <returns>表示指定之類別的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會搜尋目前組件執行個體。 `name`參數包含命名空間，但不是含組件。 若要搜尋型別的其他組件，請使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法多載，可以選擇性地包含組件顯示名稱的型別名稱的一部分。  
  
> [!NOTE]
>  如果類型已轉送至另一個組件，它仍會傳回這個方法。 類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 `throwOnError`參數只會影響找不到類型時，會發生什麼事。 它不會影響其他可能會擲回的例外狀況。 特別是，如果找到的型別，但無法載入，<xref:System.TypeLoadException>可能會擲回即使`throwOnError`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 無效。  
  
-或- 
<paramref name="name" /> 的長度超過 1024 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="name" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="name" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="name" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="name" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">類型的完整名稱。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示找不到該類型時擲回例外狀況，<see langword="false" /> 則表示傳回 <see langword="null" />。</param>
        <param name="ignoreCase">若要忽略類型名稱的大小寫，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>使用忽略大小寫和找不到類型時擲回例外狀況的選項，取得具有組件執行個體中指定之名稱的 <see cref="T:System.Type" /> 物件。</summary>
        <returns>表示指定之類別的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只會搜尋目前組件執行個體。 `name`參數包含命名空間，但不是含組件。 若要搜尋型別的其他組件，請使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法多載，可以選擇性地包含組件顯示名稱的型別名稱的一部分。  
  
> [!NOTE]
>  如果類型已轉送至另一個組件，它仍會傳回這個方法。 類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 `throwOnError`參數只會影響找不到類型時，會發生什麼事。 它不會影響其他可能會擲回的例外狀況。 特別是，如果找到的型別，但無法載入，<xref:System.TypeLoadException>可能會擲回即使`throwOnError`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 無效。  
  
-或- 
<paramref name="name" /> 的長度超過 1024 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 為 <see langword="true" />，而且找不到類型。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="name" /> 所需的相依組件。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="name" /> 所需的相依組件，但無法載入。  
  
-或- 
目前的組件已載入僅限反映的內容中，而且 <paramref name="name" /> 需要未預先載入的相依組件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 需要相依組件，但這個檔案不是有效的組件。  
  
-或- 
 <paramref name="name" /> 所需的相依組件是針對比目前載入之版本還新的執行階段版本所編譯。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得定義於這個組件中的類型。</summary>
        <returns>陣列，包含在這個組件中定義的所有類型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的陣列會包含巢狀型別。  
  
 如果<xref:System.Reflection.Assembly.GetTypes%2A>組件和型別上呼叫方法，因為組件相依於尚未載入 （例如，如果其衍生自第二個組件中的型別），組件中的型別<xref:System.Reflection.ReflectionTypeLoadException>就會擲回。 比方說，就可能發生此第一個組件已載入具有<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>或<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>未載入方法和第二個組件。 就可能也會使用載入的組件<xref:System.Reflection.Assembly.Load%2A>並<xref:System.Reflection.Assembly.LoadFile%2A>方法，如果第二個組件無法找到時<xref:System.Reflection.Assembly.GetTypes%2A>呼叫方法。  
  
> [!NOTE]
>  如果類型已轉送至另一個組件，它不包含傳回陣列中。 類型轉送上的資訊，請參閱[Common Language Runtime 中的型別轉送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 若要擷取的集合<xref:System.Reflection.TypeInfo>而非陣列的物件<xref:System.Type>物件，使用<xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType>屬性。  
  
   
  
## Examples  
 下列範例會顯示在指定的組件中的型別上的其中一種方法的參數。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">此組件包含一或多個無法載入的類型。 這個例外狀況的 <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> 屬性所傳回的陣列包含載入每個類型的 <see cref="T:System.Type" /> 物件和無法載入的每個類型的 <see langword="null" />，而 <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> 屬性包含無法載入之每個類型的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出組件是否從全域組件快取載入。</summary>
        <value>如果組件是從全域組件快取載入，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來載入組件的主應用程式內容。</summary>
        <value>
          <see cref="T:System.Int64" /> 值，表示用來載入組件的主應用程式內容 (如果有)。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得字串，表示儲存在含有資訊清單之檔案中的 Common Language Runtime (CLR) 版本。</summary>
        <value>CLR 版本資料夾名稱。 這不是完整的路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，.NET Framework 1.1 版的值會是 v1.1.4322。 該版本的二進位檔案會位於路徑 %windir%\microsoft.net\framework\v1.1.4322。  
  
 根據預設，<xref:System.Reflection.Assembly.ImageRuntimeVersion%2A>設為用來建置組件的 clr 版本。 不過，它可能會有已設定為另一個值在編譯時期。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">這個組件中要加以檢查的屬性類型。</param>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>指出是否已將指定的屬性套用至組件。</summary>
        <returns>如果已將屬性套用至組件，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例適用於<xref:System.Reflection.AssemblyTitleAttribute>屬性，以組件，然後再使用<xref:System.Reflection.Assembly.IsDefined%2A>表示是否已套用。 它也會測試未套用的屬性。  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> 使用無效的類型。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前組件是否使用反映發出在目前處理序中動態產生。</summary>
        <value>如果目前組件是在目前處理序中動態產生，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態組件由衍生類別<xref:System.Reflection.Emit.AssemblyBuilder>。  
  
 動態組件儲存到磁碟，儲存的組件時不是動態的。 如果已儲存的組件會載入至另一個應用程式定義域或處理程序，<xref:System.Reflection.Assembly.IsDynamic%2A>屬性會傳回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前組件是否以完全信任來載入。</summary>
        <value>如果目前組件是以完全信任來載入，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>載入組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</param>
        <summary>載入具有通用物件檔案格式 (Common Object File Format，COFF) 之映像的組件 (包含發出的組件)。 組件會載入至呼叫端的應用程式定義域。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法載入的組件的信任層級是與呼叫組件的信任層級相同。 若要從應用程式定義域的信任層級的位元組陣列載入組件，請使用<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>方法多載。 如需使用辨識項使用的多載<xref:System.Reflection.Assembly.Load%2A>方法採用位元組陣列，請參閱<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>方法多載。  
  
 反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。 這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。 若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。  
  
 請注意，這個方法多載一定會建立新<xref:System.Reflection.Assembly>具有它自己的對應物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
-或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="rawAssembly" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">描述要載入之組件的物件。</param>
        <summary>載入組件，指定其 <see cref="T:System.Reflection.AssemblyName" />。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 如果擲回`assemblyRef`指定完整的組件名稱和第一個符合的簡單名稱的組件有不同的版本、 文化特性或公開金鑰語彙基元。 載入器不會繼續探查比對的簡單名稱的其他組件。 因為遠端組件中的程式碼的執行已停用預設的情況下，.NET Framework 4 中，從開始<xref:System.IO.FileLoadException>如果也會擲回`assemblyRef`指定遠端組件。 若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。     
  
> [!NOTE]
>  請勿使用<xref:System.Reflection.AssemblyName>只有<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性集。 <xref:System.Reflection.AssemblyName.CodeBase%2A>不提供任何項目 （例如名稱或版本） 的組件身分識別，因此載入不會根據負載所識別的規則，如您所預期<xref:System.Reflection.Assembly.Load%2A>方法。 相反地，會載入組件，使用載入來源的規則。 使用載入來源內容的缺點的相關資訊，請參閱<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法多載或[組件載入的最佳作法](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。  
  
 是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。 組件和安全性辨識項合併的規則如下所示：  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入的通用物件檔案格式 (COFF) 映像，辨識項的參數繼承自呼叫組件。 這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。 `Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。 呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。  
  
 反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。 這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。 若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。  
  
> [!NOTE]
>  如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>屬性所設定，第一次嘗試載入組件會使用顯示名稱 (包括版本、 文化特性，並依此類推，所傳回<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性)。 如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>用來搜尋該組件。 如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，顯示名稱比對組件。 如果比對失敗，<xref:System.IO.FileLoadException>就會擲回。  
  
   
  
## Examples  
 下列範例會具現化<xref:System.Reflection.AssemblyName>物件，並使用它來載入`sysglobal.dll`組件。 範例接著會顯示組件的公用類型的完整名稱。  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyRef" />。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 無法載入找到的檔案。

-或-

<paramref name="assemblyRef" /> 指定遠端組件，但已停用在遠端組件中執行程式碼的能力。 請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的組件。 -或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyRef" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">執行階段如何找出組件</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">組件名稱的完整格式。</param>
        <summary>載入組件，其名稱指定為完整格式。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件名稱的完整格式是由其簡單名稱 （例如 「 系統 」 System.dll 組件） 以及其版本、 文化特性、 公開金鑰語彙基元和 （選擇性） 其處理器架構所組成。 它會對應至組件的<xref:System.Reflection.Assembly.FullName%2A>屬性。 下列範例說明如何使用載入的.NET Framework 4 System.dll 組件的完整名稱。  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> 如果擲回`assemblyString`指定完整的組件名稱，而第一個符合的簡單名稱的組件有不同的版本、 文化特性或公開金鑰語彙基元。 載入器不會繼續探查比對的簡單名稱的其他組件。  
  
 是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。 組件和安全性辨識項合併的規則如下所示：  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入的通用物件檔案格式 (COFF) 映像，辨識項的參數繼承自呼叫組件。 這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。 `Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。 呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。  
  
 反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。 這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。 若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。  
  
 在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，若要指定組件名稱的建議的方式是建立<xref:System.Reflection.AssemblyName>物件，並將它傳遞給適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。 請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會載入組件，指定其完整的名稱，並列出包含指定的組件中的所有型別。 若要執行此程式碼範例，您必須提供完整的組件名稱。 如需如何取得完整組件名稱的資訊，請參閱[組件名稱](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> 是零長度字串</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyString" />。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的組件。  
  
-或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyString" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">執行階段如何找出組件</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</param>
        <param name="rawSymbolStore">位元組陣列，包含表示組件符號的未經處理位元組。</param>
        <summary>使用通用物件檔案格式 (COFF) 映像載入組件，其中包含已發出的組件，並可選擇性地包含組件的符號。 組件會載入至呼叫端的應用程式定義域。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法載入的組件的信任層級是與呼叫組件的信任層級相同。 若要從應用程式定義域的信任層級的位元組陣列載入組件，請使用<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>方法多載。 如需使用辨識項使用的多載<xref:System.Reflection.Assembly.Load%2A>方法採用位元組陣列，請參閱<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>方法多載。  
  
 反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。 這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。 若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。  
  
 請注意，這個方法多載一定會建立新<xref:System.Reflection.Assembly>具有它自己的對應物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
-或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="rawAssembly" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">描述要載入之組件的物件。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>載入組件，指定其 <see cref="T:System.Reflection.AssemblyName" />。 使用所提供的辨識項，將組件載入至呼叫端的定義域。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 如果擲回`assemblyRef`指定完整的組件名稱，而第一個符合的簡單名稱的組件有不同的版本、 文化特性或公開金鑰語彙基元。 載入器不會繼續探查比對的簡單名稱的其他組件。  因為遠端組件中的程式碼的執行已停用預設的情況下，.NET Framework 4 中，從開始<xref:System.IO.FileLoadException>如果也會擲回`assemblyRef`指定遠端組件。 若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。   
  
> [!NOTE]
>  請勿使用<xref:System.Reflection.AssemblyName>只有<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性集。 <xref:System.Reflection.AssemblyName.CodeBase%2A>不提供任何項目 （例如名稱或版本） 的組件身分識別，因此載入不會根據負載所識別的規則，如您所預期<xref:System.Reflection.Assembly.Load%2A>方法。 相反地，會載入組件，使用載入來源的規則。 使用載入來源內容的缺點的相關資訊，請參閱<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法多載或[組件載入的最佳作法](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。  
  
 是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。 組件和安全性辨識項合併的規則如下所示：  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入的通用物件檔案格式 (COFF) 映像，辨識項的參數繼承自呼叫組件。 這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。 `Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。 呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。  
  
 反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。 這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。 若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。  
  
> [!NOTE]
>  如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>屬性所設定，第一次嘗試載入組件會使用顯示名稱 (包括版本、 文化特性，並依此類推，所傳回<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>屬性)。 如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>用來搜尋該組件。 如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，顯示名稱比對組件。 如果比對失敗，<xref:System.IO.FileLoadException>就會擲回。  
  
 如果您呼叫<xref:System.Reflection.Assembly.Load%2A>方法超過一次在相同的組件，但以指定不同的辨識項，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為不能是不同的辨識項規格的完整性與等號比較決定。 第一個成功的辨識項是所使用的辨識項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyRef" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyRef" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。

-或-

<paramref name="assemblyRef" /> 指定遠端組件，但已停用在遠端組件中執行程式碼的能力。 請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">執行階段如何找出組件</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">組件的顯示名稱。</param>
        <param name="assemblySecurity">用於載入組件的辨識項。</param>
        <summary>載入提供其顯示名稱的組件，使用提供的辨識項將組件載入至呼叫端的定義域。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 如果擲回`assemblyString`指定完整的組件名稱，而第一個符合的簡單名稱的組件有不同的版本、 文化特性或公開金鑰語彙基元。 載入器不會繼續探查比對的簡單名稱的其他組件。  
  
 是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。 組件和安全性辨識項合併的規則如下所示：  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入的通用物件檔案格式 (COFF) 映像，辨識項的參數繼承自呼叫組件。 這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。 `Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。 呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。  
  
 反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。 這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。 若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。  
  
 如果您呼叫這個方法一次以上相同的組件，但使用不同的辨識項，指定，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為無法判斷是否相等和不同的辨識項規格的完整性。 第一個成功的辨識項是所使用的辨識項。  
  
 在.NET Framework 2.0 版中，處理器架構會新增至組件識別，而且可以指定為組件名稱字串的一部分。 例如，"ProcessorArchitecture = msil"。 不過，若要指定組件名稱的建議的方式是建立<xref:System.Reflection.AssemblyName>物件，並將它傳遞給適當的多載<xref:System.Reflection.Assembly.Load%2A>方法。 請參閱 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyString" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyString" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。  
  
-或- 
使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">執行階段如何找出組件</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</param>
        <param name="rawSymbolStore">位元組陣列，包含表示組件符號的未經處理位元組。</param>
        <param name="securityEvidence">用於載入組件的辨識項。</param>
        <summary>使用通用物件檔案格式 (COFF) 映像載入組件，其中包含已發出的組件，並可選擇性地包含組件的符號和辨識項。 組件會載入至呼叫端的應用程式定義域。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用所提供的辨識項，將組件載入至呼叫端的定義域。 表示組件符號的未經處理位元組也載入。  
  
 是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。 組件和安全性辨識項合併的規則如下所示：  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.Load%2A>方法取代的辨識項載入器所提供的片段。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`載入 （coff） 映像，辨識項的參數繼承自呼叫組件。 這適用於.NET Framework 1.1 版 Service Pack 1 (SP1) 和後續版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，並在未安裝 SP1，當您使用的版本 1.1<xref:System.Reflection.Assembly.Load%2A>方法多載`Byte[]`結合載入 （coff） 映像，辨識項的參數。 `Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。  
  
-   當您使用<xref:System.Reflection.Assembly.Load%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。 會忽略呼叫組件的辨識項和辨識項 （coff） 映像。  
  
 反映 c + + 可執行檔可能會擲回<xref:System.BadImageFormatException>。 這可能是因為 c + + 編譯器移除重新配置位址或`.reloc`從可執行檔的區段。 若要保留`.reloc`解決您的 c + + 可執行檔，請指定`/fixed:no`當您要連結。  
  
 如果您呼叫 [\]，位元組\<xref:System.Reflection.Assembly.Load%2A > 方法超過一次在相同的組件，但以指定不同的辨識項，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為無法判斷相等和不同的辨識項規格的完整性。 第一個成功的辨識項是所使用的辨識項。  
  
 請注意，這個方法多載一定會建立新<xref:System.Reflection.Assembly>具有它自己的對應物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="rawAssembly" /> 的版本還要更新。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> 不是 <see langword="null" />。  根據預設，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中並未啟用舊版的 CAS 原則；如果未啟用該原則，<paramref name="securityEvidence" /> 必須是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供提供辨識項的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</param>
        <param name="rawSymbolStore">位元組陣列，包含表示組件符號的未經處理位元組。</param>
        <param name="securityContextSource">安全性內容的來源。</param>
        <summary>使用通用物件檔案格式 (COFF) 映像載入組件，其中包含已發出的組件，並可選擇性地包含組件的符號，以及指定安全性內容的來源。 組件會載入至呼叫端的應用程式定義域。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 組件會載入應用程式定義域的呼叫端安全性內容中使用指定的來源。 如果`rawSymbolStore`已指定，也會載入組件表示符號的未經處理位元組。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
-或- 
 <paramref name="rawAssembly" /> 是以比目前載入的 Common Language Runtime 版本更新的版本所編譯。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> 的值不是其中一個列舉值。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>載入組件檔案的內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要載入的完整檔案路徑。</param>
        <summary>載入指定路徑上組件檔案的內容。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Reflection.Assembly.LoadFile%2A>方法來載入和檢查組件具有相同的識別，但位於不同的路徑。 <xref:System.Reflection.Assembly.LoadFile%2A> 不會將檔案載入到載入來源內容，並無法解決相依性載入路徑中，使用做為<xref:System.Reflection.Assembly.LoadFrom%2A>方法會執行。 <xref:System.Reflection.Assembly.LoadFile%2A> 在此限案例中有用因為<xref:System.Reflection.Assembly.LoadFrom%2A>不能用來載入組件具有相同的身分識別但不同的路徑，它會載入的第一個這類組件。  

從.NET Framework 4 中，如果`path`在遠端位置中指定的組件、 組件載入已停用預設的情況下，而`LoadFile`方法會擲回<xref:System.IO.FileLoadException>。 若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 引數不是絕對路徑。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。

-或-

已停用在遠端組件中執行程式碼的能力。 請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 參數為空字串 ("") 或不存在。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> 不是有效的組件。  
  
-或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="path" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">組件檔的完整路徑。</param>
        <param name="securityEvidence">用於載入組件的辨識項。</param>
        <summary>載入既定路徑的組件，並使用提供的辨識項將組件載入至呼叫端的定義域。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Reflection.Assembly.LoadFile%2A>方法來載入和檢查組件具有相同的識別，但位於不同的路徑。 <xref:System.Reflection.Assembly.LoadFile%2A> 無法將檔案載入<xref:System.Reflection.Assembly.LoadFrom%2A>內容，並無法解決相依性載入路徑中，使用做為<xref:System.Reflection.Assembly.LoadFrom%2A>方法會執行。 <xref:System.Reflection.Assembly.LoadFile%2A> 在此限案例中有用因為<xref:System.Reflection.Assembly.LoadFrom%2A>不能用來載入組件具有相同的身分識別但不同的路徑，它會載入的第一個這類組件。  

從.NET Framework 4 中，如果`path`在遠端位置中指定的組件、 組件載入已停用預設的情況下，而`LoadFile`方法會擲回<xref:System.IO.FileLoadException>。 若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 引數不是絕對路徑。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 參數為空字串 ("") 或不存在。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。

-或-

已停用在遠端組件中執行程式碼的能力。 請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="path" /> 的版本還要更新。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> 不是 <see langword="null" />。 根據預設，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中並未啟用舊版的 CAS 原則；如果未啟用該原則，<paramref name="securityEvidence" /> 必須是 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄，以及在本身的路徑資訊的存取權的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>載入組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

從.NET Framework 4 開始，能夠從遠端位置載入的組件中執行程式碼會停用預設值，而且呼叫`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。 若要載入的組件，並執行其程式碼，您必須使用下列其中一個：

- 組件中明確建立沙箱。 (請參閱[如何： 在沙箱中執行部分信任程式碼](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)。)

- 以完全信任執行組件的程式碼，藉由設定`enabled`的屬性[`<loadFromRemoteSources>`組態項目](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)到`true`。 如需詳細資訊，請參閱 < [ `<loadFromRemoteSources>`組態項目](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)文章。

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱或路徑，包含組件的資訊清單。</param>
        <summary>載入組件，指定其檔案名稱或路徑。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`參數必須參考到不含逸出字元的 URI。 這個方法會提供所有 URI 中的無效字元的逸出字元。  
  
> [!NOTE]
>  不支援檔案傳輸通訊協定 (FTP)。 如果 URI 提供給`assemblyFile`是 FTP 位址，未載入的組件。 不會有例外狀況擲回。  
  
 `assemblyFile` 可以是絕對或相對到目前的目錄，而且組件會載入至呼叫端的定義域。  
  
 組件可以載入三個內容之一，或可以載入沒有內容：  
  
-   載入內容包含探查所找到的組件： 在 GAC 中，主應用程式組件中儲存如果裝載執行階段，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>應用程式定義域。 <xref:System.Reflection.Assembly.Load%2A> 方法的大部分多載都會將組件載入此內容中。  
  
-   載入來源內容包含使用者提供不包含在搜尋所探查的目錄路徑的組件。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 是依路徑載入之方法的範例。 

    如果.NET Framework 4 中，從開始的 URI`assemblyFile`指定遠端位置，組件載入已停用預設的情況下，而`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。 若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。    
  
-   僅限反映的內容包含使用載入的組件<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 在這些程式碼無法執行內容。  
  
-   如果使用者產生，或找到此組件，它不在任何內容。 這會套用至組件載入多載<xref:System.Reflection.Assembly.Load%2A>指定位元組陣列，包含組件，並建立使用反映的暫時性動態組件發出，並不會儲存至磁碟的方法。  
  
 載入來源內容可讓從不會納入探查路徑載入的組件，而且找到並載入，因為路徑資訊由內容維護該路徑可允許相依性。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>方法有下列缺點。 請考慮改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已載入具有相同身分識別的組件，<xref:System.Reflection.Assembly.LoadFrom%2A> 會傳回載入的組件，即使指定不同的路徑也是一樣。  
  
-   如果使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 載入組件，之後載入內容中的組件卻試圖根據顯示名稱載入相同組件，則載入嘗試會失敗。 當組件還原序列化時，可能發生這項目。  
  
-   如果組件是以載入<xref:System.Reflection.Assembly.LoadFrom%2A>，探查路徑中包含的組件具有相同的身分識別但不同的位置，並<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，或其他非預期的行為可能會發生。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 要求所指定路徑上的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果原生映像存在`assemblyFile`，不會使用它。 無法以定義域中性方式載入組件。  
  
-   在.NET Framework 1.0 和 1.1 版中，不會套用原則。  
  
   
  
## Examples  
 下列範例會載入組件，指定其檔案名稱或路徑。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />，或您想載入的模組並未指定檔案的副檔名。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。

-或-

已停用在遠端組件中執行程式碼的能力。 請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件，例如 64 位元處理序中的 32 位元組件。 如需詳細資訊，請參閱例外狀況主題。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.Security.SecurityException">指定了並非以 "file://" 開頭的程式碼基底，且沒有必要的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">組件名稱超過系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取以"file:// 開頭的 URI。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱或路徑，包含組件的資訊清單。</param>
        <param name="securityEvidence">用於載入組件的辨識項。</param>
        <summary>載入組件，指定其檔案名稱或路徑，並提供安全性辨識項。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`參數必須參考到不含逸出字元的 URI。 這個方法會提供所有 URI 中的無效字元的逸出字元。  
  
> [!NOTE]
>  不支援檔案傳輸通訊協定 (FTP)。 如果 URI 提供給`assemblyFile`是 FTP 位址，未載入的組件。 不會有例外狀況擲回。  
  
 `assemblyFile` 可以是絕對或相對到目前的目錄，而且組件會載入至呼叫端的定義域。  
  
 組件可以載入三個內容之一，或可以載入沒有內容：  
  
-   載入內容包含探查所找到的組件： 在 GAC 中，主應用程式組件中儲存如果裝載執行階段，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>應用程式定義域。 <xref:System.Reflection.Assembly.Load%2A> 方法的大部分多載都會將組件載入此內容中。  
  
-   載入來源內容包含使用者提供不包含在搜尋所探查的目錄路徑的組件。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 是依路徑載入之方法的範例。

    如果.NET Framework 4 中，從開始的 URI`assemblyFile`指定遠端位置，組件載入已停用預設的情況下，而`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。 若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。    
  
-   僅限反映的內容包含使用載入的組件<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 在這些程式碼無法執行內容。  
  
-   如果使用者產生，或找到此組件，它不在任何內容。 這會套用至組件載入多載<xref:System.Reflection.Assembly.Load%2A>指定位元組陣列，包含組件，並建立使用反映的暫時性動態組件發出，並不會儲存至磁碟的方法。  
  
 載入來源內容可讓從不會納入探查路徑載入的組件，而且找到並載入，因為路徑資訊由內容維護該路徑可允許相依性。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>方法有下列缺點。 請考慮改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已載入具有相同身分識別的組件，<xref:System.Reflection.Assembly.LoadFrom%2A> 會傳回載入的組件，即使指定不同的路徑也是一樣。  
  
-   如果使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 載入組件，之後載入內容中的組件卻試圖根據顯示名稱載入相同組件，則載入嘗試會失敗。 還原序列化組件時，也可能發生這種情況。  
  
-   如果組件是以載入<xref:System.Reflection.Assembly.LoadFrom%2A>，探查路徑中包含的組件具有相同的身分識別但不同的位置，並<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，或其他非預期的行為可能會發生。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 要求所指定路徑上的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果原生映像存在`assemblyFile`，不會使用它。 無法以定義域中性方式載入組件。  
  
-   在.NET Framework 1.0 和 1.1 版中，不會套用原則。  
  
 是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。 組件和安全性辨識項合併的規則如下所示：  
  
-   當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.LoadFrom%2A>方法取代的辨識項載入器所提供的片段。  
  
-   如果您呼叫這個方法一次以上相同的組件，但使用不同的辨識項，指定，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為無法判斷是否相等和不同的辨識項規格的完整性。 第一個成功的辨識項是所使用的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法使用`Byte[]`結合載入的通用物件檔案格式 (COFF) 映像，辨識項的參數。 `Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。  
  
-   當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。 呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />，或您想載入的模組並未指定檔案的副檔名。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。  
  
-或- 
<paramref name="securityEvidence" /> 並非模稜兩可，而且已判定為無效。

-或-

已停用在遠端組件中執行程式碼的能力。 請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件，例如 64 位元處理序中的 32 位元組件。 如需詳細資訊，請參閱例外狀況主題。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.Security.SecurityException">指定了並非以 "file://" 開頭的程式碼基底，且沒有必要的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">組件名稱超過系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取以"file:// 開頭的 URI。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱或路徑，包含組件的資訊清單。</param>
        <param name="hashValue">計算的雜湊碼值。</param>
        <param name="hashAlgorithm">雜湊演算法，用於雜湊檔案和用來產生強式名稱 (Strong Name)。</param>
        <summary>指定組件的檔案名稱或路徑，雜湊值和雜湊演算法，來載入組件。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`參數必須參考到不含逸出字元的 URI。 這個方法會提供所有 URI 中的無效字元的逸出字元。  
  
> [!NOTE]
>  不支援檔案傳輸通訊協定 (FTP)。 如果 URI 提供給`assemblyFile`是 FTP 位址，未載入的組件。 不會有例外狀況擲回。  
  
 `assemblyFile` 可以是絕對或相對到目前的目錄，而且組件會載入至呼叫端的定義域。  
  
 組件可以載入三個內容之一，或可以載入沒有內容：  
  
-   載入內容包含探查所找到的組件： 全域組件快取中，主應用程式組件中儲存如果裝載執行階段，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>應用程式定義域。 <xref:System.Reflection.Assembly.Load%2A> 方法的大部分多載都會將組件載入此內容中。  
  
-   載入來源內容包含使用者提供的目標不會納入探查路徑的組件。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 是依路徑載入之方法的範例。  

    如果.NET Framework 4 中，從開始的 URI`assemblyFile`指定遠端位置，組件載入已停用預設的情況下，而`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。 若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。    
  
-   僅限反映的內容包含使用載入的組件<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 在這些程式碼無法執行內容。  
  
-   如果使用者產生，或找到此組件，它不在任何內容。 這會套用至組件載入多載<xref:System.Reflection.Assembly.Load%2A>指定位元組陣列，包含組件，並建立使用反映的暫時性動態組件發出，並不會儲存至磁碟的方法。  
  
 載入來源內容可讓從不會納入探查路徑載入的組件，而且找到並載入，因為路徑資訊由內容維護該路徑可允許相依性。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>方法有下列缺點。 請考慮改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已載入具有相同身分識別的組件，<xref:System.Reflection.Assembly.LoadFrom%2A> 會傳回載入的組件，即使指定不同的路徑也是一樣。  
  
-   如果使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 載入組件，之後載入內容中的組件卻試圖根據顯示名稱載入相同組件，則載入嘗試會失敗。 還原序列化組件時，也可能發生這種情況。  
  
-   如果組件是以載入<xref:System.Reflection.Assembly.LoadFrom%2A>，探查路徑中包含的組件具有相同的身分識別但不同的位置，並<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，或其他非預期的行為可能會發生。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 要求所指定路徑上的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果原生映像存在`assemblyFile`，不會使用它。 組件無法以定義域中性方式載入。  
  
 組件是以載入器所提供的辨識項載入。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />，或您想載入的模組並未指定檔案的副檔名。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。

-或-

已停用在遠端組件中執行程式碼的能力。 請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件，例如 64 位元處理序中的 32 位元組件。 如需詳細資訊，請參閱例外狀況主題。  
  
-或- 
 用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.Security.SecurityException">指定了並非以 "file://" 開頭的程式碼基底，且沒有必要的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">組件名稱超過系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取以"file:// 開頭的 URI。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱或路徑，包含組件的資訊清單。</param>
        <param name="securityEvidence">用於載入組件的辨識項。</param>
        <param name="hashValue">計算的雜湊碼值。</param>
        <param name="hashAlgorithm">雜湊演算法，用於雜湊檔案和用來產生強式名稱 (Strong Name)。</param>
        <summary>指定組件的檔案名稱或路徑、安全性辨識項、雜湊值和雜湊演算法，來載入組件。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`參數必須參考到不含逸出字元的 URI。 這個方法會提供所有 URI 中的無效字元的逸出字元。  
  
> [!NOTE]
>  不支援檔案傳輸通訊協定 (FTP)。 如果 URI 提供給`assemblyFile`是 FTP 位址，未載入的組件。 不會有例外狀況擲回。  
  
 `assemblyFile` 可以是絕對或相對到目前的目錄，而且組件會載入至呼叫端的定義域。  
  
 組件可以載入三個內容之一，或可以載入沒有內容：  
  
-   載入內容包含探查所找到的組件： 在 GAC 中，主應用程式組件中儲存如果裝載執行階段，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>應用程式定義域。 <xref:System.Reflection.Assembly.Load%2A> 方法的大部分多載都會將組件載入此內容中。  
  
-   載入來源內容包含使用者提供不包含在搜尋所探查的目錄路徑的組件。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 是依路徑載入之方法的範例。  

    如果.NET Framework 4 中，從開始的 URI`assemblyFile`指定遠端位置，組件載入已停用預設的情況下，而`LoadFrom`方法會擲回<xref:System.IO.FileLoadException>。 若要啟用從遠端位置載入的程式碼的執行，您可以使用[ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)組態項目。    
  
-   僅限反映的內容包含使用載入的組件<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 在這些程式碼無法執行內容。  
  
-   如果使用者產生，或找到此組件，它不在任何內容。 這會套用至組件載入多載<xref:System.Reflection.Assembly.Load%2A>指定位元組陣列，包含組件，並建立使用反映的暫時性動態組件發出，並不會儲存至磁碟的方法。  
  
 載入來源內容可讓從不會納入探查路徑載入的組件，而且找到並載入，因為路徑資訊由內容維護該路徑可允許相依性。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>方法有下列缺點。 請考慮改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已載入具有相同身分識別的組件，<xref:System.Reflection.Assembly.LoadFrom%2A> 會傳回載入的組件，即使指定不同的路徑也是一樣。  
  
-   如果使用 <xref:System.Reflection.Assembly.LoadFrom%2A> 載入組件，之後載入內容中的組件卻試圖根據顯示名稱載入相同組件，則載入嘗試會失敗。 還原序列化組件時，也可能發生這種情況。  
  
-   如果組件是以載入<xref:System.Reflection.Assembly.LoadFrom%2A>，探查路徑中包含的組件具有相同的身分識別但不同的位置，並<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，或其他非預期的行為可能會發生。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 要求所指定路徑上的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果原生映像存在`assemblyFile`，不會使用它。 無法以定義域中性方式載入組件。  
  
-   在.NET Framework 1.0 和 1.1 版中，不會套用原則。  
  
 是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。 組件和安全性辨識項合併的規則如下所示：  
  
-   當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法沒有<xref:System.Security.Policy.Evidence>參數，已載入組件使用載入器所提供的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法使用<xref:System.Security.Policy.Evidence>參數部分會合併。 做為引數提供的辨識項的片段<xref:System.Reflection.Assembly.LoadFrom%2A>方法取代的辨識項載入器所提供的片段。  
  
-   如果您呼叫這個方法一次以上相同的組件，但使用不同的辨識項，指定，common language runtime 不會擲回<xref:System.IO.FileLoadException>因為無法判斷是否相等和不同的辨識項規格的完整性。 第一個成功的辨識項是所使用的辨識項。  
  
-   當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法使用`Byte[]`結合載入的通用物件檔案格式 (COFF) 映像，辨識項的參數。 `Zone``Url`並`Site`繼承自呼叫的組件，並`Hash`和`StrongName`取自 COFF 組件。  
  
-   當您使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法`Byte[]`參數和<xref:System.Security.Policy.Evidence>載入 （coff） 映像，只提供的辨識項會使用。 呼叫組件的辨識項和 （coff） 映像的辨識項會被忽略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />，或您想載入的模組並未指定檔案的副檔名。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。  
  
-或- 
<paramref name="securityEvidence" /> 並非模稜兩可，而且已判定為無效。

-或-

已停用在遠端組件中執行程式碼的能力。 請參閱 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件，例如 64 位元處理序中的 32 位元組件。 如需詳細資訊，請參閱例外狀況主題。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.Security.SecurityException">指定了並非以 "file://" 開頭的程式碼基底，且沒有必要的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">組件名稱超過系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">與辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取以"file:// 開頭的 URI。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>載入這個組件內部的模組。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">模組的名稱。 這個字串必須對應於這個組件的資訊清單中的檔案名稱。</param>
        <param name="rawModule">位元組陣列，是以 COFF 為基礎而含有發出模組的映像，或是資源。</param>
        <summary>使用通用物件檔案格式 (COFF) 為基礎的映像 (包含發出的模組) 或是資源檔，載入組件的內部模組。</summary>
        <returns>載入的模組。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> 或 <paramref name="rawModule" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> 不符合這個組件的資訊清單中某個檔案項目。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> 不是有效的模組。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">模組的名稱。 這個字串必須對應於這個組件的資訊清單中的檔案名稱。</param>
        <param name="rawModule">位元組陣列，是以 COFF 為基礎而含有發出模組的映像，或是資源。</param>
        <param name="rawSymbolStore">位元組陣列，包含表示模組符號的未經處理位元組。 如果這是資源檔，則必須是 <see langword="null" />。</param>
        <summary>使用通用物件檔案格式 (COFF) 為基礎的映像 (包含發出的模組) 或是資源檔，載入組件的內部模組。 表示模組符號的未經處理位元組也載入。</summary>
        <returns>載入的模組。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> 或 <paramref name="rawModule" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> 不符合這個組件的資訊清單中某個檔案項目。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> 不是有效的模組。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供辨識項。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用部分的名稱，從應用程式目錄或從全域組件快取載入組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  多載<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>方法已經過時，而且為了與舊版相容而保留。 非過時的替代方式是 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">組件的顯示名稱。</param>
        <summary>使用部分的名稱，從應用程式目錄或從全域組件快取載入組件。</summary>
        <returns>載入的組件。 如果找不到 <paramref name="partialName" />，這個方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29>方法已經過時，已保留回溯相容性。 非過時的替代方式是 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 使用這個方法載入組件的應用程式將會受到這些組件升級。 因此，不會使用這個方法。重新設計應用程式使用<xref:System.Reflection.Assembly.Load%28System.String%29>方法多載或<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>方法多載。  
  
 這個方法會先呼叫<xref:System.Reflection.Assembly.Load%2A>。 如果找不到組件，則這個方法會傳回組件從全域組件快取具有相同簡單名稱和最高的版本號碼。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="partialName" />。</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">組件的顯示名稱。</param>
        <param name="securityEvidence">用於載入組件的辨識項。</param>
        <summary>使用部分的名稱，從應用程式目錄或從全域組件快取載入組件。 使用所提供的辨識項，將組件載入至呼叫端的定義域。</summary>
        <returns>載入的組件。 如果找不到 <paramref name="partialName" />，這個方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29>方法已經過時，已保留回溯相容性。 非過時的替代方式是 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 所謂的辨識項是一組資訊，由輸入的安全性原則決策所構成，例如要將那些權限授與給程式碼。  
  
 使用這個方法載入組件的應用程式將會受到這些組件升級。 因此，不會使用這個方法。重新設計應用程式使用<xref:System.Reflection.Assembly.Load%2A>方法或<xref:System.Reflection.Assembly.LoadFrom%2A>方法。  
  
 這個方法會先呼叫<xref:System.Reflection.Assembly.Load%2A>。 如果找不到組件，則這個方法會傳回組件從全域組件快取具有相同簡單名稱和最高的版本號碼。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">已使用兩組不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="partialName" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼，並使用辨識項載入組件。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含資訊清單之載入檔的完整路徑或 UNC 位置。</summary>
        <value>包含資訊清單之載入檔的位置。 如果載入檔已經過陰影複製，則該位置就是陰影複製後的檔案位置。 如果組件是從位元組陣列載入 (例如，使用 <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> 方法多載時)，則傳回值就是空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得位置，該檔案已陰影複製之前，請使用<xref:System.Reflection.Assembly.CodeBase%2A>屬性。  
  
   
  
## Examples  
 下列範例會顯示包含資訊清單之載入檔的位置。  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">目前的組件是以 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 物件表示的動態組件。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">陰影複製組件</related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含目前組件之資訊清單的模組。</summary>
        <value>包含組件之資訊清單的模組。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 Common Language Runtime 類別載入器無法經由一般方法解析對組件內部模組的參考時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個事件提供回呼地尋找並載入模組本身並傳回它的機率。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含這個組件中模組的集合。</summary>
        <value>包含此組件中之模組的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">與「右」<c></c>比較的組件。</param>
        <param name="right">與「左」<c></c>比較的組件。</param>
        <summary>表示兩個 <see cref="T:System.Reflection.Assembly" /> 物件是否相等。</summary>
        <returns>如果 <see langword="true" /> 等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">與「右」<c></c>比較的組件。</param>
        <param name="right">與「左」<c></c>比較的組件。</param>
        <summary>表示兩個 <see cref="T:System.Reflection.Assembly" /> 物件是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前組件的授權集。</summary>
        <value>目前組件的授權集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 物件可以包含機密資訊，例如路徑。 因此，完全信任，才能存取這些物件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Boolean" /> 值，指出這個組件是否已載入僅限反射內容中。</summary>
        <value>如果這個組件已載入僅限反映的內容 (而非執行內容) 中，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果組件已載入僅限反映的內容，使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>方法中，您無法執行程式碼組件中。 若要執行程式碼，組件必須載入的執行內容。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將組件載入僅限反映的內容中，以便在其中檢查組件但不執行組件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">位元組陣列，該陣列是以 COFF 為基礎的影像，其中包含發出的組件。</param>
        <summary>從以通用物件檔案格式 (COFF) 為基礎的映像 (包含發出的組件) 載入組件。 這個組件會載入呼叫端應用程式定義域之僅限反映的內容中。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法從組件載入僅限反映內容中執行程式碼。 若要執行的程式碼，組件必須載入執行內容，使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
 僅限反映的內容並無不同於其他的內容項目。 載入至內容的組件可以卸載只能透過卸載應用程式定義域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的組件。  
  
-或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="rawAssembly" />。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入 <paramref name="rawAssembly" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">組件的顯示名稱，如同 <see cref="P:System.Reflection.AssemblyName.FullName" /> 屬性所傳回。</param>
        <summary>將組件載入僅限反映的內容中，並指定其顯示名稱。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相依性不會自動載入至僅限反映的內容。  
  
 您無法從組件載入僅限反映內容中執行程式碼。 若要執行的程式碼，組件必須載入執行內容，使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
 是否將某些使用權限授予組件則以辨識項 (Evidence) 為基礎。 組件和安全性辨識項合併的規則如下所示：  
  
> [!NOTE]
>  反映在編譯 c + + 中的可執行檔上可能會擲回<xref:System.IO.FileLoadException>。 這很可能被因 c + + 編譯器移除定位位置或.reloc 區段，您可執行檔。 若要保留.reloc 位址，請指定`/fixed:no`當您要連結。  
  
 僅限反映的內容並無不同於其他的內容項目。 載入至內容的組件可以卸載只能透過卸載應用程式定義域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> 為空字串 ("")。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyString" />。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="assemblyString" />，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的組件。  
  
-或- 
目前載入的是通用語言執行平台 2.0 版或更新版本，且已使用更新的版本來編譯 <paramref name="assemblyString" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的路徑，該檔案包含組件的資訊清單。</param>
        <summary>將組件載入僅限反映的內容中，並指定其路徑。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相依性不會自動載入至僅限反映的內容。 若要自動載入相依性，請處理<xref:System.AppDomain.ReflectionOnlyAssemblyResolve>事件和負載事件處理常式中的相依性。  
  
 您無法從組件載入僅限反映內容中執行程式碼。 若要執行的程式碼，載入組件<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 `assemblyFile`參數必須參考到不含逸出字元的 URI。 這個方法會提供所有 URI 中的無效字元的逸出字元。  
  
 針對指定的路徑`assemblyFile`相對於目前的目錄。 組件會載入至呼叫端的定義域項目。  
  
 僅限反映的內容並無不同於其他的內容項目。 載入至內容的組件可以卸載只能透過卸載應用程式定義域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />，或您想載入的模組並未指定檔案的副檔名。</exception>
        <exception cref="T:System.IO.FileLoadException">找到 <paramref name="assemblyFile" />，但無法載入。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
目前載入的是 Common Language Runtime 2.0 版或更新版本，編譯 <paramref name="assemblyFile" /> 的版本還要更新。</exception>
        <exception cref="T:System.Security.SecurityException">指定了並非以 "file://" 開頭的程式碼基底，且沒有必要的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">組件名稱超過系統定義的長度上限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 為空字串 ("")。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取以"file:// 開頭的 URI。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用於讀取不是以"file:// 開頭的 URI。</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值指出應針對此組件強制執行的 Common Language Runtime (CLR) 安全性規則組合。</summary>
        <value>CLR 對這個組件強制執行的安全性規則組合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，您使用編譯的組件[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]有透明度，不過您可以明確成為改為。 舊版.NET Framework 進行編譯的組件具有層級 1 透明度。  
  
 請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">安全性透明的程式碼</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4 中的安全性變更</related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前執行個體的類型。</summary>
        <returns>代表 <see cref="T:System.Reflection.Assembly" /> 類型的物件。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回組件的完整名稱，也稱為顯示名稱。</summary>
        <returns>組件的完整名稱或類別名稱 (如果無法判斷組件的完整名稱)。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">檔案的名稱或路徑，包含組件的資訊清單。</param>
        <summary>將組件載入到載入內容中，並略過部分安全性檢查。</summary>
        <returns>載入的組件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法載入作業系統標示為已從 Web （例如，暫存檔案從網際網路或內部網路下載） 載入的本機組件。 之前[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，這類組件已自動載入沙箱應用程式定義域。 從開始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，它們是以完全信任來載入。  
  
 您可以使用此方法的替代方案，以套用[ &lt;NetFx40_LegacySecurityPolicy&gt;項目](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)應用程式組態檔中。 這會導致 common language runtime，若要還原的安全性原則[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
> [!CAUTION]
>  如果您使用這些解決方案，您必須先確認它是安全載入`assemblyFile`以完全信任。  
  
 討論的載入內容，包括為載入來源內容，請參閱<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="assemblyFile" />，或您想載入的模組並未指定檔案的副檔名。</exception>
        <exception cref="T:System.IO.FileLoadException">無法載入找到的檔案。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的組件。  
  
-或- 
 用以編譯 <paramref name="assemblyFile" /> 的通用語言執行平台，其版本比目前所載入的版本還要更新。</exception>
        <exception cref="T:System.Security.SecurityException">指定了並非以 "file://" 開頭的程式碼基底，且沒有必要的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 參數是空字串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">組件名稱超過系統定義的長度上限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
  </Members>
</Type>