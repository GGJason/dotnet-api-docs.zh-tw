<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d4ba5-101">提供方法和建構函式的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-101">Provides information about methods and constructors.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-102">`MethodBase` 是基底類別<xref:System.Reflection.MethodInfo>和<xref:System.Reflection.ConstructorInfo>。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="d4ba5-103">針對繼承者完全信任。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-103">for full trust for inheritors.</span></span> <span data-ttu-id="d4ba5-104">這個類別無法被繼承，部分信任程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-104">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="d4ba5-105">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-105">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides">
      <para><span data-ttu-id="d4ba5-106">當您繼承自<see langword="MethodBase" />，您必須覆寫下列成員： <see cref="M:System.Reflection.MethodBase.GetParameters" />， <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />， <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />， <see cref="P:System.Reflection.MethodBase.MethodHandle" />， <see cref="P:System.Reflection.MethodBase.Attributes" />， <see cref="P:System.Reflection.MemberInfo.Name" />， <see cref="P:System.Reflection.MemberInfo.DeclaringType" />， <see cref="P:System.Reflection.MemberInfo.MemberType" />， <see cref="P:System.Reflection.MemberInfo.ReflectedType" />， <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /><see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />，和<see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-106">When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span></span></para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d4ba5-107">初始化 <see cref="T:System.Reflection.MethodBase" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-108">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="d4ba5-109">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-110">取得與這個方法相關的屬性 (Attribute)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-110">Gets the attributes associated with this method.</span></span></summary>
        <value><span data-ttu-id="d4ba5-111">其中一個 <see cref="T:System.Reflection.MethodAttributes" /> 值。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-112">所有成員都有一組屬性，定義相對於特定類型的成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="d4ba5-113">若要取得<xref:System.Reflection.MethodAttributes>，第一次取得型別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="d4ba5-114">從型別，get 方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-114">From the type, get the method.</span></span> <span data-ttu-id="d4ba5-115">從方法，取得<xref:System.Reflection.MethodAttributes>。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-116">下列程式碼範例會顯示使用者定義方法 Mymethod 的屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="d4ba5-117">此程式碼會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="d4ba5-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="d4ba5-118">Reflection.MethodBase.Attributes 範例</span><span class="sxs-lookup"><span data-stu-id="d4ba5-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="d4ba5-119">Mymethodbase = Void Mymethod (Int32、 System.String ByRef System.String ByRef)</span><span class="sxs-lookup"><span data-stu-id="d4ba5-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="d4ba5-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="d4ba5-120">PrivateScope</span></span>  
  
 <span data-ttu-id="d4ba5-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="d4ba5-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="d4ba5-122">家族</span><span class="sxs-lookup"><span data-stu-id="d4ba5-122">Family</span></span>  
  
 <span data-ttu-id="d4ba5-123">Public</span><span class="sxs-lookup"><span data-stu-id="d4ba5-123">Public</span></span>  
  
 <span data-ttu-id="d4ba5-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="d4ba5-124">HideBySig</span></span>  
  
 <span data-ttu-id="d4ba5-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="d4ba5-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="d4ba5-126">使用<see cref="P:System.Reflection.MethodBase.Attributes" />屬性來決定方法是否為<see langword="public" />， <see langword="private" />， <see langword="final" />， <see langword="virtual" />，依此類推。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-126">Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</span></span></para>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-127">取得值，指出這個方法的呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-127">Gets a value indicating the calling conventions for this method.</span></span></summary>
        <value><span data-ttu-id="d4ba5-128">這個方法的 <see cref="T:System.Reflection.CallingConventions" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-129">取得值，指出泛型方法是否包含未指派的泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-130">如果目前的 <see cref="T:System.Reflection.MethodBase" /> 物件表示包含未指派泛型型別參數的泛型方法，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-130"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-131">只有當沒有任何泛型類型定義 」 或 「 開放式建構的類型所有封入類型或方法本身的類型引數中，可以叫用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="d4ba5-132">型別可以很複雜，因為並不容易進行這種遞迴判定。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="d4ba5-133">為了方便起見，並減少錯誤的機會<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性提供的標準方式來區別封閉式的建構方法，可以叫用，並開啟建構無法的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="d4ba5-134">如果<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性會傳回`true`，無法叫用此方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="d4ba5-135"><xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>以遞迴方式型別參數的屬性搜尋。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="d4ba5-136">例如，它會傳回`true`開啟型別中的任何方法`A<T>`(`A(Of T)`在 Visual Basic 中)，即使不是泛型方法本身。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="d4ba5-137">這和行為的<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性，它會傳回`false`這類方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="d4ba5-138">同樣地， <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property 參數會傳回`true`開啟型別中任何建構函式，即使建構函式不能有自己的型別參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="d4ba5-139">非變異條件的詞彙與泛型方法的特定清單，請參閱<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="d4ba5-140">如需其他用在反映中泛型的詞彙的非變異條件的清單，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="d4ba5-141">與這個執行個體相比較的物件，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-141">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d4ba5-142">傳回值，這個值指出此執行個體是否與指定的物件相等。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-142">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns>
          <span data-ttu-id="d4ba5-143">如果 <see langword="true" /> 和這個執行個體具有相同的類型和值，則為 <paramref name="obj" />否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-143"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d4ba5-144">傳回代表目前執行方法的 <see langword="MethodBase" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span></span></summary>
        <returns>
          <span data-ttu-id="d4ba5-145"><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> 是從執行方法中呼叫的靜態方法，並傳回關於該執行方法的資訊。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-145"><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span></span>  
  
 <span data-ttu-id="d4ba5-146">代表目前執行方法的 <see langword="MethodBase" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-146">A <see langword="MethodBase" /> object representing the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-147">如果目前執行的方法上泛型類型，定義<xref:System.Reflection.MethodInfo>所傳回<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>取自泛型類型定義 (也就是<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>傳回`true`)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="d4ba5-148">因此，它並不會反映時呼叫該方法所使用的型別引數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="d4ba5-149">比方說，如果方法`M()`泛型類型上定義`C<T>`(`C(Of T)`在 Visual Basic 中)，和<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>從呼叫`C<string>.M()`，然後<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>傳回`C<T>.M()`(`C(Of T).M()`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="d4ba5-150">如果目前執行的方法是泛型的方法，<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>傳回泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="d4ba5-151">如果泛型的方法上泛型類型，定義<xref:System.Reflection.MethodInfo>取自泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-152">下列範例會定義兩種類型。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-152">The following example defines two types.</span></span> <span data-ttu-id="d4ba5-153">第一個是非泛型類別， `TestClass`，包括建構函式，名為的方法`GetValue`，和名為讀寫屬性`GetValue`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="d4ba5-154">第二個是泛型類別，名為`TestClass<T>`包含建構函式，`GetValue`方法，而且泛型的方法， `ConvertValue<Y>`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="d4ba5-155">每個建構函式、 方法和屬性存取子包含呼叫<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="d4ba5-156">這個成員曾被晚期繫結機制叫用過。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-156">This member was invoked with a late-binding mechanism.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-157">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="d4ba5-158">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d4ba5-159">傳回 <see cref="T:System.Type" /> 物件的陣列，這些物件代表泛型方法的類型引數，或泛型方法定義的類型參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-160"><see cref="T:System.Type" /> 物件的陣列，這些物件代表泛型方法的類型引數，或泛型方法定義的類型參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span> <span data-ttu-id="d4ba5-161">如果目前的方法不是泛型方法，則會傳回空白陣列。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-161">Returns an empty array if the current method is not a generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-162">傳回陣列中的項目會以其出現在清單中的泛型方法的型別參數的順序。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="d4ba5-163">如果目前的方法為封閉式的建構的方法 (也就是<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性會傳回`false`)，所傳回的陣列<xref:System.Reflection.MethodBase.GetGenericArguments%2A>方法包含已指派給之泛型方法的泛型類型參數的型別定義。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="d4ba5-164">如果目前的方法是泛型方法定義，陣列會包含型別參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="d4ba5-165">如果目前的方法是開啟的建構的方法 (也就是<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性會傳回`true`) 中的特定類型已指派給某些型別參數和型別封入泛型類型參數已指派給其他類型參數，此陣列包含型別和型別參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="d4ba5-166">使用<xref:System.Type.IsGenericParameter%2A>屬性來區分它們。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="d4ba5-167">如需示範此案例中，請參閱提供的程式碼範例<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="d4ba5-168">.NET Framework 2.0 不支援泛型建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d4ba5-169">這個屬性會擲回<xref:System.NotSupportedException>如果未在衍生類別中覆寫，因此例外狀況會擲回目前的執行個體屬於類型<xref:System.Reflection.ConstructorInfo>。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="d4ba5-170">非變異條件的詞彙與泛型方法的特定清單，請參閱<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="d4ba5-171">如需其他用在反映中泛型的詞彙的非變異條件的清單，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d4ba5-172">目前物件為 <see cref="T:System.Reflection.ConstructorInfo" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span></span> <span data-ttu-id="d4ba5-173">.NET Framework 2.0 不支援泛型建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-173">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d4ba5-174">如果未在衍生類別中覆寫這個方法，則這個例外狀況就是預設行為。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-174">This exception is the default behavior if this method is not overridden in a derived class.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d4ba5-175">傳回這個執行個體的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-175">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-176">32 位元帶正負號的整數雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-176">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d4ba5-177">在衍生類別中覆寫時，取得 <see cref="T:System.Reflection.MethodBody" /> 物件，其提供對目前方法之 MSIL 資料流、區域變數和例外狀況的存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-178"><see cref="T:System.Reflection.MethodBody" /> 物件，其提供對目前方法之 MSIL 資料流、區域變數和例外狀況的存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-179">您沒有覆寫<xref:System.Reflection.MethodBase.GetMethodBody%2A>才能使用它。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="d4ba5-180">您可以呼叫<xref:System.Reflection.MethodBase.GetMethodBody%2A>方法<xref:System.Reflection.MethodInfo>和<xref:System.Reflection.ConstructorInfo>物件，因為在執行階段版本，這些類別中覆寫此方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="d4ba5-181">例如，執行階段版本<xref:System.Reflection.MethodInfo>類別衍生自<xref:System.Reflection.MethodInfo>類別，又衍生自<xref:System.Reflection.MethodBase>類別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-182">下列程式碼範例會定義名為的測試方法`MethodBodyExample`，並顯示其本機變數的資訊和例外狀況處理子句。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="d4ba5-183"><xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType>方法用來取得<xref:System.Reflection.MethodBody>測試方法的物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="d4ba5-184"><xref:System.Reflection.MethodBody.LocalVariables%2A>屬性用來取得一份<xref:System.Reflection.LocalVariableInfo>物件和顯示它們的型別以及索引順序。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="d4ba5-185"><xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A>屬性用來取得例外狀況處理子句的清單。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-186">並非所有電腦的語言可以都產生<xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType>子句。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="d4ba5-187">Visual Basic 範例會顯示篩選子句中，使用 Visual Basic`When`運算式，其他語言的範例中會省略。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d4ba5-188">除非在衍生類別中覆寫這個方法，否則該方法無效。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-188">This method is invalid unless overridden in a derived class.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-189">用於存取中繼資料的成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-189">for the access to metadata for members.</span></span> <span data-ttu-id="d4ba5-190">權限的值： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="d4ba5-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d4ba5-191">使用指定的控制代碼取得方法資訊。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-191">Gets method information using the specified handle.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="d4ba5-192">方法的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-192">The method's handle.</span></span></param>
        <summary><span data-ttu-id="d4ba5-193">利用方法的內部中繼資料表示 (控制代碼) 取得方法資訊。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-193">Gets method information by using the method's internal metadata representation (handle).</span></span></summary>
        <returns><span data-ttu-id="d4ba5-194"><see langword="MethodBase" />，包含方法的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-194">A <see langword="MethodBase" /> containing information about the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-195">只有在所取得的應用程式定義域控制代碼是有效的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4ba5-196"><paramref name="handle" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-196"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-197">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="d4ba5-198">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="d4ba5-199">建構函式或方法之內部中繼資料表示的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-199">A handle to the internal metadata representation of a constructor or method.</span></span></param>
        <param name="declaringType"><span data-ttu-id="d4ba5-200">定義建構函式或方法之泛型型別的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-200">A handle to the generic type that defines the constructor or method.</span></span></param>
        <summary><span data-ttu-id="d4ba5-201">針對指定的泛型型別，取得指定的控制代碼所表示之建構函式或方法的 <see cref="T:System.Reflection.MethodBase" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-202"><see cref="T:System.Reflection.MethodBase" /> 物件，在 <paramref name="handle" /> 所指定的泛型型別中，表示 <paramref name="declaringType" /> 指定的方法或建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-203">只有在所取得的應用程式定義域控制代碼是有效的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="d4ba5-204">A<xref:System.RuntimeMethodHandle>結構建構函式或方法的泛型類型可以表示不同<xref:System.Reflection.MethodBase>物件，根據指定的泛型類型的型別參數的型別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="d4ba5-205">比方說，如果`class G<T>`(`class G(Of T)`在 Visual Basic 中`generic <T> ref class G`c + + 中) 的方法會傳回型別`T`、<xref:System.Reflection.MethodBase>這類物件建構的類別中的該方法`G<int>`不同<xref:System.Reflection.MethodBase>泛型類型定義中的該方法的物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4ba5-206"><paramref name="handle" /> 無效。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-206"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-207">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="d4ba5-208">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d4ba5-209">在衍生類別中覆寫時，傳回 <see cref="T:System.Reflection.MethodImplAttributes" /> 旗標。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-210"><see langword="MethodImplAttributes" /> 旗標。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-210">The <see langword="MethodImplAttributes" /> flags.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d4ba5-211">下列範例定義動態組件中的建構函式，然後再使用<xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A>方法，以顯示依預設會設定的方法實作旗標。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-212">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="d4ba5-213">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d4ba5-214">在衍生類別中覆寫時，取得指定方法或建構函式的參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-215"><see langword="ParameterInfo" /> 型別的陣列，含有與這個 <see langword="MethodBase" /> 執行個體反映的方法 (或建構函式) 簽章相符的資訊。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d4ba5-216">下列範例會使用<xref:System.Reflection.MethodBase.GetParameters%2A>方法來擷取參數的`Invoke`委派的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="d4ba5-217">此範例會定義名為委派`MyDelegate`和名為事件`ev`型別的`MyDelegate`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="d4ba5-218">中的程式碼`Main`方法會藉由取得事件的委派類型，探索事件簽章取得`Invoke`方法的委派類型，然後擷取並顯示參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-219">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="d4ba5-220">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d4ba5-221">叫用 (Invoke) 這個 <see langword="MethodInfo" /> 執行個體所反映的方法或建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="d4ba5-222">要叫用方法或建構函式的物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-222">The object on which to invoke the method or constructor.</span></span> <span data-ttu-id="d4ba5-223">如果方法是靜態的則會忽略這個引數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-223">If a method is static, this argument is ignored.</span></span> <span data-ttu-id="d4ba5-224">如果建構函式是靜態的，此引數必須為 <see langword="null" />，或者為定義建構函式的類別執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span></span></param>
        <param name="parameters"><span data-ttu-id="d4ba5-225">叫用方法或建構函式的引數清單。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-225">An argument list for the invoked method or constructor.</span></span> <span data-ttu-id="d4ba5-226">這是物件陣列，其數目、順序和型別與要叫用的方法或建構函式的參數相同。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span></span> <span data-ttu-id="d4ba5-227">如果沒有任何參數，「參數」<c></c> 該是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-227">If there are no parameters, <c>parameters</c> should be <see langword="null" />.</span></span>  
  
 <span data-ttu-id="d4ba5-228">如果此執行個體所代表的方法或建構函式採用 <see langword="ref" /> 參數 (Visual Basic 中的 <see langword="ByRef" />)，則針對該參數不需要特別的屬性以使用此函式叫用方法或建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span></span> <span data-ttu-id="d4ba5-229">此陣列中任何未明確使用值初始化的物件，都會包含該物件類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span></span> <span data-ttu-id="d4ba5-230">對於參考型別項目，這個值為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-230">For reference-type elements, this value is <see langword="null" />.</span></span> <span data-ttu-id="d4ba5-231">對於實值型別項目，這個值為 0、0.0 或 <see langword="false" />，由特定的項目類型決定。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span></span></param>
        <summary><span data-ttu-id="d4ba5-232">使用指定的參數叫用由目前執行個體代表的方法或建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-233">包含叫用方法之傳回值的物件，或者 <see langword="null" /> (在建構函式的情況下)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-234">這是便利的方法呼叫<xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29>方法多載，傳遞<xref:System.Reflection.BindingFlags.Default>如`invokeAttr`和`null`如`binder`和`culture`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="d4ba5-235">如果叫用的方法擲回例外狀況，<xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType>方法傳回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="d4ba5-236">要叫用靜態方法，使用其<xref:System.Reflection.MethodInfo>物件，傳遞`null`如`obj`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-237">如果這個方法多載用來叫用的執行個體建構函式，該物件提供給`obj`重新初始化; 也就是執行所有執行個體的初始設定式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="d4ba5-238">傳回值為 `null`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-238">The return value is `null`.</span></span> <span data-ttu-id="d4ba5-239">如果類別建構函式會叫用，則會重新初始化類別;也就是說，所有的類別初始設定式會執行。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="d4ba5-240">傳回值為 `null`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-241">從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="d4ba5-242">(請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="d4ba5-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="d4ba5-243">若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="d4ba5-244">如果目前方法的參數是實值類型，且對應的引數中`parameters`是`null`，執行階段會傳遞實值類型的零初始化執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-245">下列程式碼範例示範如何使用反映來動態方法查閱。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="d4ba5-246">請注意，您不能使用<xref:System.Reflection.MethodInfo>叫用在衍生類別中覆寫的方法，因為晚期繫結無法解析的覆寫基底類別的物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="d4ba5-247">在[適用於 Windows 市集應用程式的 .NET - 支援的應用程式開發介面](http://go.microsoft.com/fwlink/?LinkID=247912) 或是[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為攔截 <see cref="T:System.Exception" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-247">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d4ba5-248"><paramref name="obj" /> 參數為 <see langword="null" />，且方法不是靜態的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-248">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span></span>  
  
 <span data-ttu-id="d4ba5-249">-或-</span><span class="sxs-lookup"><span data-stu-id="d4ba5-249">-or-</span></span>  
  
 <span data-ttu-id="d4ba5-250">方法並未由 <paramref name="obj" /> 類別宣告或繼承。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-250">The method is not declared or inherited by the class of <paramref name="obj" />.</span></span>  
  
 <span data-ttu-id="d4ba5-251">-或-</span><span class="sxs-lookup"><span data-stu-id="d4ba5-251">-or-</span></span>  
  
 <span data-ttu-id="d4ba5-252">已叫用靜態建構函式，且 <paramref name="obj" /> 不是 <see langword="null" /> 或者宣告建構函式之類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-252">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d4ba5-253"><paramref name="parameters" /> 陣列項目不符合此執行個體所反映之方法或建構函式的簽章。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-253">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d4ba5-254">叫用的方法或建構函式會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-254">The invoked method or constructor throws an exception.</span></span>  
  
 <span data-ttu-id="d4ba5-255">-或-</span><span class="sxs-lookup"><span data-stu-id="d4ba5-255">-or-</span></span>  
  
 <span data-ttu-id="d4ba5-256">目前的執行個體是包含無法驗證的程式碼的 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-256">The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span></span> <span data-ttu-id="d4ba5-257">如需了解 <see cref="T:System.Reflection.Emit.DynamicMethod" />，請參閱＜備註＞中的＜驗證＞一節。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-257">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="d4ba5-258"><paramref name="parameters" /> 陣列沒有正確的引數數目。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-258">The <paramref name="parameters" /> array does not have the correct number of arguments.</span></span></exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="d4ba5-259">在[適用於 Windows 市集應用程式的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或是[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改為攔截基底類別例外狀況 <see cref="T:System.MemberAccessException" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-259">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d4ba5-260">呼叫端並沒有執行由目前執行個體所代表之方法或建構函式的權限。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-260">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d4ba5-261">宣告方法的型別是開放式泛型型別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-261">The type that declares the method is an open generic type.</span></span> <span data-ttu-id="d4ba5-262">也就是，<see cref="P:System.Type.ContainsGenericParameters" /> 屬性會針對宣告型別傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-262">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d4ba5-263">目前的執行個體是 <see cref="T:System.Reflection.Emit.MethodBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-263">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-264">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-264">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="d4ba5-265">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-265">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="d4ba5-266">要叫用方法或建構函式的物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-266">The object on which to invoke the method or constructor.</span></span> <span data-ttu-id="d4ba5-267">如果方法是靜態的則會忽略這個引數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-267">If a method is static, this argument is ignored.</span></span> <span data-ttu-id="d4ba5-268">如果建構函式是靜態的，此引數必須為 <see langword="null" />，或者為定義建構函式的類別執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-268">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="d4ba5-269">由零或來自 <see cref="T:System.Reflection.BindingFlags" /> 的多個位元旗標組成的位元遮罩。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-269">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span> <span data-ttu-id="d4ba5-270">如果「繫結器」<c></c>為<see langword="null" />，則指派給這個參數的值為 <see cref="F:System.Reflection.BindingFlags.Default" />因此，不論您傳入什麼都會忽略。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-270">If <c>binder</c> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span></span></param>
        <param name="binder"><span data-ttu-id="d4ba5-271">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see langword="MemberInfo" /> 物件的物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-271">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="d4ba5-272">如果 <c>Binder</c> 為 <see langword="null" />，則會使用預設 Binder。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-272">If <c>binder</c> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="parameters"><span data-ttu-id="d4ba5-273">叫用方法或建構函式的引數清單。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-273">An argument list for the invoked method or constructor.</span></span> <span data-ttu-id="d4ba5-274">這是物件陣列，其數目、順序和型別與要叫用的方法或建構函式的參數相同。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-274">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span></span> <span data-ttu-id="d4ba5-275">如果沒有參數，這應該是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-275">If there are no parameters, this should be <see langword="null" />.</span></span>  
  
 <span data-ttu-id="d4ba5-276">如果這個執行個體表示的方法或建構函式採用 ByRef 參數，該參數就不需要有特殊屬性，就能夠以這個函式叫用方法或建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-276">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span></span> <span data-ttu-id="d4ba5-277">此陣列中任何未明確使用值初始化的物件，都會包含該物件類型的預設值。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-277">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span></span> <span data-ttu-id="d4ba5-278">對於參考型別項目，這個值為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-278">For reference-type elements, this value is <see langword="null" />.</span></span> <span data-ttu-id="d4ba5-279">對於實值型別項目，這個值為 0、0.0 或 <see langword="false" />，由特定的項目類型決定。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-279">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span></span></param>
        <param name="culture"><span data-ttu-id="d4ba5-280"><see langword="CultureInfo" /> 的執行個體，用於管理類型的強制型轉。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-280">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="d4ba5-281">如果這是 <see langword="null" />，會使用目前執行緒的 <see langword="CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-281">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="d4ba5-282">(例如，要將代表 1000 的 <see langword="String" /> 轉換成 <see langword="Double" /> 值時，這是必要的，因為 1000 的表示方式會因不同文化特性而有所不同)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-282">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <summary><span data-ttu-id="d4ba5-283">在衍生類別中覆寫時，需使用指定的參數叫用反映的方法或建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-283">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-284"><see langword="Object" />，包含叫用方法的傳回值，但如果是建構函式，則為 <see langword="null" />，如果方法的傳回型別為 <see langword="null" />，則為 <see langword="void" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-284">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span></span> <span data-ttu-id="d4ba5-285">呼叫方法或建構函式之前，<see langword="Invoke" /> 會檢查使用者是否有存取權限，並驗證參數是否有效。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-285">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-286">動態叫用這個執行個體所反映的方法`obj`，並且傳遞指定的參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-286">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="d4ba5-287">如果這個方法是靜態，`obj`參數已忽略。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-287">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="d4ba5-288">對於非靜態方法，`obj`應該類別繼承，或是宣告方法，必須是相同的類型與這個類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-288">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="d4ba5-289">如果方法沒有參數，值`parameters`應該`null`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-289">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="d4ba5-290">否則數字、 類型和順序中的項目`parameters`應該數目、 類型與這個執行個體所反映的方法參數順序相同。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-290">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="d4ba5-291">您不可以省略選擇性參數呼叫`Invoke`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-291">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="d4ba5-292">若要叫用方法，並省略選擇性參數，您應該呼叫`Type.InvokeMember`改為。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-292">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-293">如果這個方法多載用來叫用的執行個體建構函式，該物件提供給`obj`重新初始化; 也就是執行所有執行個體的初始設定式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-293">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="d4ba5-294">傳回值為 `null`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-294">The return value is `null`.</span></span> <span data-ttu-id="d4ba5-295">如果類別建構函式會叫用，則會重新初始化類別;也就是說，所有的類別初始設定式會執行。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-295">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="d4ba5-296">傳回值為 `null`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-296">The return value is `null`.</span></span>  
  
 <span data-ttu-id="d4ba5-297">傳值方式傳遞基本參數，執行一般擴展 (Int16]-> [Int32，例如)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-297">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="d4ba5-298">傳值方式傳遞參考參數，一般參考擴展允許 （至基底類別和介面類型的基底類別衍生的類別）。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-298">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="d4ba5-299">不過，若為傳址方式傳遞基本參數，類型必須完全符合。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-299">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="d4ba5-300">傳址方式傳遞參考參數的一般擴展仍然適用。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-300">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="d4ba5-301">例如，如果該方法所反映這個執行個體宣告為`public boolean Compare(String a, String b)`，然後`parameters`應該是陣列的`Objects`長度為 2， `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-301">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="d4ba5-302">如果目前方法的參數是實值類型，且對應的引數中`parameters`是`null`，執行階段會傳遞實值類型的零初始化執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-302">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="d4ba5-303">反映叫用虛擬方法時，會使用動態方法查閱。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-303">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="d4ba5-304">例如，假設類別 B 繼承自類別 A，而且兩者實作虛擬方法，名為 M。現在，假設您有`MethodInfo`物件，代表 M 上類別 a。如果您使用`Invoke`M 類型 B 的物件上叫用，則反映將使用指定的類別 b 的實作方法即使 B 類型的物件會轉換成 A，要使用類別 B 所指定的實作 （請參閱以下程式碼範例）。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-304">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="d4ba5-305">相反地，如果非虛擬方法，則反映會採用的實作類型，指定要從中`MethodInfo`已取得，不論類型為何傳遞做為目標的物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-305">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="d4ba5-306">完全信任程式碼會忽略存取限制。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-306">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="d4ba5-307">也就是私用建構函式、 方法、 欄位和屬性可以存取和每當程式碼受到完全信任時，透過反映來叫用。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-307">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="d4ba5-308">如果叫用的方法擲回例外狀況，`TargetInvocationException.GetException`傳回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-308">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="d4ba5-309">此實作會擲回`NotSupportedException`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-309">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-310">從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法可以用來存取非公用成員，如果呼叫端被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標，如果非公用成員的授權集僅限於呼叫者的授與集或子集合類別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-310">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="d4ba5-311">(請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="d4ba5-311">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="d4ba5-312">若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-312">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-313">下列範例示範的所有成員<xref:System.Reflection.Binder?displayProperty=nameWithType>類別使用的多載<xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-313">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d4ba5-314">私用方法`CanConvertFrom`尋找相容的類型指定型別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-314">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="d4ba5-315">叫用成員的自訂繫結案例中的另一個範例，請參閱[動態載入和使用型別](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-315">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="d4ba5-316"><paramref name="obj" /> 參數為 <see langword="null" />，且方法不是靜態的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-316">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span></span>  
  
 <span data-ttu-id="d4ba5-317">-或-</span><span class="sxs-lookup"><span data-stu-id="d4ba5-317">-or-</span></span>  
  
 <span data-ttu-id="d4ba5-318">方法並未由 <paramref name="obj" /> 類別宣告或繼承。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-318">The method is not declared or inherited by the class of <paramref name="obj" />.</span></span>  
  
 <span data-ttu-id="d4ba5-319">-或-</span><span class="sxs-lookup"><span data-stu-id="d4ba5-319">-or-</span></span>  
  
 <span data-ttu-id="d4ba5-320">已叫用靜態建構函式，且 <paramref name="obj" /> 不是 <see langword="null" /> 或者宣告建構函式之類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-320">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d4ba5-321"><paramref name="parameters" /> 參數的型別與這個執行個體反映的方法或建構函式的簽章不相符。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-321">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="d4ba5-322"><paramref name="parameters" /> 陣列沒有正確的引數數目。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-322">The <paramref name="parameters" /> array does not have the correct number of arguments.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="d4ba5-323">叫用的方法或建構函式會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-323">The invoked method or constructor throws an exception.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="d4ba5-324">呼叫端並沒有執行由目前執行個體所代表之方法或建構函式的權限。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-324">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d4ba5-325">宣告方法的型別是開放式泛型型別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-325">The type that declares the method is an open generic type.</span></span> <span data-ttu-id="d4ba5-326">也就是，<see cref="P:System.Type.ContainsGenericParameters" /> 屬性會針對宣告型別傳回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-326">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="d4ba5-327">叫用時晚期繫結透過機制例如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-327">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="d4ba5-328">關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-328">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-329">取得值，指出方法是否為抽象。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-329">Gets a value indicating whether the method is abstract.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-330">如果方法是抽象，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-330"><see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-331">基底類別上宣告抽象成員，因此不提供實作。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-331">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="d4ba5-332">若要取得<xref:System.Reflection.MethodBase>，第一次取得型別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-332">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="d4ba5-333">從型別，get 方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-333">From the type, get the method.</span></span> <span data-ttu-id="d4ba5-334">從方法，取得`MethodBase`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-334">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="d4ba5-335">如果`MethodBase`或建構函式不是公用，則受到保護，並無法輕易地存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-335">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="d4ba5-336">若要存取非公用方法，設定<xref:System.Reflection.BindingFlags>遮罩至`NonPublic`中`GetMethod`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-336">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-337">下列範例會判斷是否將指定的方法是抽象的並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-337">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-338">取得值，指出 <see cref="F:System.Reflection.MethodAttributes.Assembly" /> 是否描述此方法或建構函式 (Constructor) 的潛在可視性；亦即，最多只有相同組件 (Assembly) 中的其他型別可以看見該方法或建構函式，組件外部的衍生型別 (Derived Type) 則看不見它們。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-338">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-339">如果 <see cref="F:System.Reflection.MethodAttributes.Assembly" /> 已精確描述這個方法或建構函式的可視性則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-339"><see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-340">其類型的可見性受限於實際的可見性的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-340">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="d4ba5-341"><xref:System.Reflection.MethodBase.IsAssembly%2A>屬性可能是`true`方法，但如果它是私用巢狀型別的方法的方法不包含型別外部可見的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-341">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="d4ba5-342">完全所描述的方法或建構函式可見性<xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType>只有可視性修飾詞是否`internal`(`Friend`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-342">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="d4ba5-343">這個屬性是`false`的方法`protected internal`C# 中 (`Protected Friend`在 Visual Basic 中`protected public`c + + 中); 使用<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>屬性來識別這類方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-343">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-344">下列程式碼範例會定義具有不同層級的可見性的方法，並顯示的值及其<xref:System.Reflection.MethodBase.IsAssembly%2A>， <xref:System.Reflection.MethodBase.IsFamily%2A>， <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>，和<xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-344">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-345">Visual Basic 和 C# 語言無法定義具有方法<xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType>可見性，則為，存取層級只會出現在 c + + 範例。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-345">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-346">取得值，指出方法是否為建構函示。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-346">Gets a value indicating whether the method is a constructor.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-347">如果這個方法是由 <see cref="T:System.Reflection.ConstructorInfo" /> 物件所表示的建構函式 (請參閱＜註解＞中有關 <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> 物件的備註)，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-347"><see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-348"><xref:System.Reflection.MethodBase.IsConstructor%2A>屬性會傳回`false`如<xref:System.Reflection.Emit.ConstructorBuilder>物件存放至動態類型，除非<xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType>旗標包含在`attributes`參數定義建構函式時。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-348">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="d4ba5-349">省略<xref:System.Reflection.MethodAttributes.RTSpecialName>旗標不會影響發出的建構函式的正確性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-349">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-350">取得值，指出 <see cref="F:System.Reflection.MethodAttributes.Family" /> 是否描述此方法或建構函式的可視性；亦即，您只能在其類別和衍生類別內看見該方法或建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-350">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-351">如果 <see cref="F:System.Reflection.MethodAttributes.Family" /> 有精確描述這個方法或建構函式 (Constructor) 的存取權限則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-351"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-352">完全所描述的方法或建構函式可見性<xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType>只有可視性修飾詞是否`protected`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-352">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="d4ba5-353">這個屬性是`false`的方法`protected internal`C# 中 (`Protected Friend`在 Visual Basic 中`protected public`c + + 中); 使用<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>屬性來識別這類方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-353">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-354">下列程式碼範例會定義具有不同層級的可見性的方法，並顯示的值及其<xref:System.Reflection.MethodBase.IsAssembly%2A>， <xref:System.Reflection.MethodBase.IsFamily%2A>， <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>，和<xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-354">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-355">Visual Basic 和 C# 語言無法定義具有方法<xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType>可見性，則為，存取層級只會出現在 c + + 範例。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-355">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-356">取得值，指出 <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /> 是否描述此方法或建構函式的可視性；亦即，只有當該方法或建構函式位於相同的組件時，衍生類別才能呼叫它們。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-356">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-357">如果 <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /> 有精確描述這個方法或建構函式 (Constructor) 的存取權限則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-357"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-358">完全所描述的方法或建構函式可見性<xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType>可視性修飾詞是否`protected private`c + + 中。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-358">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="d4ba5-359">無法在 Visual Basic 或 C# 定義具有這個可見性的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-359">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-360">下列程式碼範例會定義具有不同層級的可見性的方法，並顯示的值及其<xref:System.Reflection.MethodBase.IsAssembly%2A>， <xref:System.Reflection.MethodBase.IsFamily%2A>， <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>，和<xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-360">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-361">Visual Basic 和 C# 語言無法定義具有方法<xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType>可見性，則為，存取層級只會出現在 c + + 範例。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-361">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-362">取得值，指出 <see cref="F:System.Reflection.MethodAttributes.FamORAssem" /> 是否描述此方法或建構函式的潛在可視性；亦即，無論該方法或建構函式位於何處，衍生類別以及相同組件中的類別都可以呼叫它們。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-362">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-363">如果 <see cref="F:System.Reflection.MethodAttributes.FamORAssem" /> 有精確描述這個方法或建構函式 (Constructor) 的存取權限則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-363"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-364">如果型別成員具有<xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType>可見性，您可以呼叫從衍生類別中的任何成員或相同的組件中的任何成員，而不是從任何其他型別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-364">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="d4ba5-365">其類型的可見性受限於實際的可見性的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-365">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="d4ba5-366"><xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>屬性可能是`true`方法，但如果它是私用巢狀型別的方法的方法不包含型別外部可見的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-366">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="d4ba5-367">完全所描述的方法或建構函式可見性<xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType>可視性修飾詞是否`protected internal`C# 中 (`Protected Friend`在 Visual Basic 中`protected public`c + + 中)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-367">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-368">下列程式碼範例會定義具有不同層級的可見性的方法，並顯示的值及其<xref:System.Reflection.MethodBase.IsAssembly%2A>， <xref:System.Reflection.MethodBase.IsFamily%2A>， <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>，和<xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-368">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-369">Visual Basic 和 C# 語言無法定義具有方法<xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType>可見性，則為，存取層級只會出現在 c + + 範例。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-369">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-370">取得值，指出這個方法是否為 <see langword="final" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-370">Gets a value indicating whether this method is <see langword="final" />.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-371">如果這個方法為 <see langword="final" /> 則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-371"><see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-372">若要判斷是否可覆寫方法，不檢查是否足夠<xref:System.Reflection.MethodBase.IsVirtual%2A>是`true`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-372">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="d4ba5-373">將可覆寫，方法如`IsVirtual`必須`true`和`IsFinal`必須`false`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-373">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="d4ba5-374">例如，方法可能會非虛擬的但它會實作介面方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-374">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="d4ba5-375">Common language runtime 需要實作介面成員的所有方法都必須都標示為`virtual`; 因此，編譯器會將方法標示`virtual final`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-375">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="d4ba5-376">讓某些情況下，其中的方法標示為`virtual`但仍不可覆寫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-376">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="d4ba5-377">若要確定是否可覆寫方法，使用如下的程式碼：</span><span class="sxs-lookup"><span data-stu-id="d4ba5-377">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="d4ba5-378">如果`IsVirtual`是`false`或`IsFinal`是`true`，則無法覆寫此方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-378">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-379">下列範例會顯示`false`如`IsFinal`，這可能會導致您認為 MyMethod 是可覆寫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-379">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="d4ba5-380">程式碼會列印`false`即使未標記為 MyMethod`virtual`因此不能覆寫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-380">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-381">取得值，指出方法是否為泛型。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-381">Gets a value indicating whether the method is generic.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-382">如果目前的 <see cref="T:System.Reflection.MethodBase" /> 表示泛型方法，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-382"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-383">使用<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性來判斷是否目前<xref:System.Reflection.MethodBase>物件代表泛型方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-383">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="d4ba5-384">使用<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A>屬性來判斷是否目前<xref:System.Reflection.MethodBase>物件都代表開放式建構的方法或封閉式的建構的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-384">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-385">根據預設，不支援泛型這個屬性會傳回`false`如果未在衍生類別中覆寫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-385">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="d4ba5-386">泛型建構函式不支援在.NET Framework 2.0 版中，因此這個屬性會傳回`false`如果目前的執行個體屬於類型<xref:System.Reflection.ConstructorInfo>。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-386">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="d4ba5-387">下表摘要說明非變異詞彙與泛型方法的特定條件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-387">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="d4ba5-388">用來在反映中泛型，例如其他條款*泛型型別參數*和*泛型型別*，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-388">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="d4ba5-389">詞彙</span><span class="sxs-lookup"><span data-stu-id="d4ba5-389">Term</span></span>|<span data-ttu-id="d4ba5-390">非變異條件</span><span class="sxs-lookup"><span data-stu-id="d4ba5-390">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="d4ba5-391">泛型方法定義</span><span class="sxs-lookup"><span data-stu-id="d4ba5-391">generic method definition</span></span>| <span data-ttu-id="d4ba5-392"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-392">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="d4ba5-393">定義泛型方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-393">Defines a generic method.</span></span> <span data-ttu-id="d4ba5-394">建構的方法由呼叫<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.MethodInfo>物件，代表泛型方法定義，並指定型別引數的陣列。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-394">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="d4ba5-395"><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>泛型方法定義上只可以呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-395">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="d4ba5-396">任何泛型方法定義為泛型方法，但反之不然。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-396">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="d4ba5-397">Generic Method - 泛型方法</span><span class="sxs-lookup"><span data-stu-id="d4ba5-397">generic method</span></span>|<span data-ttu-id="d4ba5-398">`IsGenericMethod` 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-398">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="d4ba5-399">可以是泛型方法定義中，開啟建構的方法或封閉式的建構的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-399">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="d4ba5-400">開放式建構的方法</span><span class="sxs-lookup"><span data-stu-id="d4ba5-400">open constructed method</span></span>|<span data-ttu-id="d4ba5-401"><xref:System.Reflection.MethodBase.ContainsGenericParameters> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-401">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="d4ba5-402">您不可能叫用開啟的建構的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-402">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="d4ba5-403">封閉式的建構的方法</span><span class="sxs-lookup"><span data-stu-id="d4ba5-403">closed constructed method</span></span>|<span data-ttu-id="d4ba5-404"><xref:System.Reflection.MethodBase.ContainsGenericParameters> 屬性為 `false`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-404">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="d4ba5-405">當遞迴檢查，此方法沒有任何未指派的泛型參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-405">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="d4ba5-406">包含型別沒有泛型型別參數，且型別引數都沒有泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-406">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="d4ba5-407">可以叫用此方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-407">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-408">取得值，指出方法是否為泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-408">Gets a value indicating whether the method is a generic method definition.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-409">如果目前的 <see cref="T:System.Reflection.MethodBase" /> 物件代表泛型方法的定義，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-409"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-410">如果目前<xref:System.Reflection.MethodBase>代表泛型方法定義，然後：</span><span class="sxs-lookup"><span data-stu-id="d4ba5-410">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="d4ba5-411"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-411">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="d4ba5-412">每個<xref:System.Type>所傳回陣列中的物件<xref:System.Reflection.MethodBase.GetGenericArguments%2A>方法：</span><span class="sxs-lookup"><span data-stu-id="d4ba5-412">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="d4ba5-413"><xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> 屬性為 `true`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-413">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="d4ba5-414"><xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType>屬性會傳回目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-414">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="d4ba5-415"><xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType>屬性是相同的位置<xref:System.Type>陣列中的物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-415">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4ba5-416">根據預設，不支援泛型這個屬性會傳回`false`如果未在衍生類別中覆寫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-416">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="d4ba5-417">泛型建構函式不支援在.NET Framework 2.0 版中，因此這個屬性會傳回`false`如果目前的執行個體屬於類型<xref:System.Reflection.ConstructorInfo>。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-417">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="d4ba5-418">非變異條件的詞彙與泛型方法的特定清單，請參閱<xref:System.Reflection.MethodBase.IsGenericMethod%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-418">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="d4ba5-419">如需其他用在反映中泛型的詞彙的非變異條件的清單，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-419">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-420">取得值，指出是否只有簽章完全一樣的同類成員隱藏於衍生類別中。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-420">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-421">如果成員是根據簽章而隱藏，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-421"><see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-422">當在衍生類別中的成員宣告與 C#`new`修飾詞或 Visual Basic`Shadows`修飾詞，它可以隱藏基底類別中相同名稱的成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-422">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="d4ba5-423">C# 簽章隱藏基底類別成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-423">C# hides base class members by signature.</span></span> <span data-ttu-id="d4ba5-424">也就是說，如果基底類別成員具有多個多載，隱藏只有一個是具有相同的簽章的一個。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-424">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="d4ba5-425">相反地，Visual Basic 會隱藏所有基底類別多載。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-425">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="d4ba5-426">因此，<xref:System.Reflection.MethodBase.IsHideBySig%2A>傳回`false`與 Visual Basic 中宣告的成員上`Shadows`修飾詞，以及`true`使用 C# 中宣告的成員上`new`修飾詞。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-426">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="d4ba5-427">這個屬性不會判斷方法是否<xref:System.Reflection.MethodAttributes.NewSlot>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-427">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="d4ba5-428">宣告其中一種方法`new`或`Shadows`修飾詞必須<xref:System.Reflection.MethodAttributes.NewSlot>屬性，但只使用宣告的方法`new`（亦即只有 C# 方法） 將會有<xref:System.Reflection.MethodBase.IsHideBySig%2A>屬性設定為`true`.</span><span class="sxs-lookup"><span data-stu-id="d4ba5-428">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="d4ba5-429">若要判斷方法是否<xref:System.Reflection.MethodAttributes.NewSlot>屬性，請使用類似下列的程式碼：`if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`在 C# 或`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-429">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="d4ba5-430">不過請注意，，雖然所有的方法宣告與`new`或`Shadows`有<xref:System.Reflection.MethodAttributes.NewSlot>屬性，並非所有的方法具有<xref:System.Reflection.MethodAttributes.NewSlot>屬性宣告使用`new`或`Shadows`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-430">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-431">下列程式碼範例包含具有多載的方法，基底類別和衍生的類別會隱藏其中一個多載。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-431">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="d4ba5-432">在 Visual Basic 版本的程式碼範例中，<xref:System.Reflection.MethodBase.IsHideBySig%2A>屬性會傳回`false`衍生類別中的成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-432">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="d4ba5-433">在 C# 版本的程式碼範例中，該屬性傳回`true`衍生類別中的成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-433">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-434">取得值，指出這個成員是否為私用的 (Private)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-434">Gets a value indicating whether this member is private.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-435">如果對這個方法的存取限於類別本身的其他成員，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-435"><see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-436">如果型別成員具有`Private`層級的可見性，它可以從呼叫相同類別中沒有其他任何成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-436">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-437">取得值，指出這是否為公用的方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-437">Gets a value indicating whether this is a public method.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-438">如果這個方法是公用的，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-438"><see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-439">若要取得<xref:System.Reflection.MethodBase>，第一次取得型別。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-439">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="d4ba5-440">從型別，get 方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-440">From the type, get the method.</span></span> <span data-ttu-id="d4ba5-441">從方法，取得`MethodBase`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-441">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="d4ba5-442">如果`MethodBase`或建構函式不是公用，則受到保護，並無法輕易地存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-442">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="d4ba5-443">若要存取非公用方法，設定<xref:System.Reflection.BindingFlags>遮罩至`NonPublic`中`GetMethod`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-443">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-444">下列範例會使用<xref:System.Reflection.MethodBase.IsPublic%2A>屬性來顯示一個訊息，指出指定的方法是否為公用。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-444">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-445">取得值，這個值表示目前方法或建構函式在目前信任層級上是否為安全性關鍵或安全性安全關鍵，因而可以執行重要的作業。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-445">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-446">如果目前方法或建構函式在目前信任層級上為安全性關鍵或安全性安全關鍵，則為 <see langword="true" />，如果它是透明，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-446"><see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-447"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>， <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.MethodBase.IsSecurityTransparent%2A>屬性報表的方法或建構函式在其目前信任層級，common language runtime (CLR) 所決定的透明度。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-447">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="d4ba5-448">這些屬性的組合是下表所示：</span><span class="sxs-lookup"><span data-stu-id="d4ba5-448">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="d4ba5-449">安全性層級</span><span class="sxs-lookup"><span data-stu-id="d4ba5-449">Security level</span></span>|<span data-ttu-id="d4ba5-450">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="d4ba5-450">IsSecurityCritical</span></span>|<span data-ttu-id="d4ba5-451">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="d4ba5-451">IsSecuritySafeCritical</span></span>|<span data-ttu-id="d4ba5-452">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="d4ba5-452">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="d4ba5-453">Critical</span><span class="sxs-lookup"><span data-stu-id="d4ba5-453">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="d4ba5-454">安全關鍵</span><span class="sxs-lookup"><span data-stu-id="d4ba5-454">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="d4ba5-455">透明</span><span class="sxs-lookup"><span data-stu-id="d4ba5-455">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="d4ba5-456">使用這些屬性會比檢查組件和型別和成員的安全性註釋、 檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-456">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d4ba5-457">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-457">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="d4ba5-458">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段就會忽略組件的安全性註釋。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-458">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="d4ba5-459">組件和其所有類型都視為透明的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-459">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="d4ba5-460">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-460">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="d4ba5-461">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-461">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="d4ba5-462">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-462">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="d4ba5-463">如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-463">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="d4ba5-464">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-464">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-465">取得值，這個值表示目前方法或建構函式在目前信任層級上是否為安全性安全關鍵，也就是說，它是否可以執行重要作業並且可供透明程式碼存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-465">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-466">如果方法或建構函式在目前信任層級上為安全性安全關鍵，則為 <see langword="true" />，如果它是安全性關鍵或透明，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-466"><see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-467"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>， <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.MethodBase.IsSecurityTransparent%2A>屬性報表的方法或建構函式在其目前信任層級，common language runtime (CLR) 所決定的透明度。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-467">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="d4ba5-468">這些屬性的組合是下表所示：</span><span class="sxs-lookup"><span data-stu-id="d4ba5-468">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="d4ba5-469">安全性層級</span><span class="sxs-lookup"><span data-stu-id="d4ba5-469">Security level</span></span>|<span data-ttu-id="d4ba5-470">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="d4ba5-470">IsSecurityCritical</span></span>|<span data-ttu-id="d4ba5-471">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="d4ba5-471">IsSecuritySafeCritical</span></span>|<span data-ttu-id="d4ba5-472">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="d4ba5-472">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="d4ba5-473">Critical</span><span class="sxs-lookup"><span data-stu-id="d4ba5-473">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="d4ba5-474">安全關鍵</span><span class="sxs-lookup"><span data-stu-id="d4ba5-474">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="d4ba5-475">透明</span><span class="sxs-lookup"><span data-stu-id="d4ba5-475">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="d4ba5-476">使用這些屬性會比檢查組件和型別和成員的安全性註釋、 檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-476">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d4ba5-477">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-477">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="d4ba5-478">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段就會忽略組件的安全性註釋。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-478">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="d4ba5-479">組件和其所有類型都視為透明的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-479">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="d4ba5-480">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-480">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="d4ba5-481">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-481">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="d4ba5-482">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-482">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="d4ba5-483">如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-483">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="d4ba5-484">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-484">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-485">取得值，這個值表示目前方法或建構函式在目前信任層級上是否為透明，因此不得執行重要作業。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-485">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-486">如果方法或建構函式在目前信任層級上為安全性透明，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-486"><see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-487">如果這個屬性會傳回`true`、<xref:System.Reflection.MethodBase.IsSecurityCritical%2A>和<xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>屬性傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-487">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="d4ba5-488"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>， <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.MethodBase.IsSecurityTransparent%2A>屬性報表的方法或建構函式在其目前信任層級，common language runtime (CLR) 所決定的透明度。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-488">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="d4ba5-489">使用這些屬性會比檢查組件和型別和成員的安全性註釋、 檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-489">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d4ba5-490">對於部分信任組件，這個屬性的值會取決於目前的信任層級的組件中。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-490">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="d4ba5-491">如果組件會載入至部分信任的應用程式網域 （例如，插入的沙箱化應用程式定義域），執行階段就會忽略組件的安全性註釋。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-491">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="d4ba5-492">組件和其所有類型都視為透明的。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-492">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="d4ba5-493">執行階段以部分信任組件的安全性註釋只修改時小心，該組件會載入至完全信任的應用程式網域 （例如，插入的桌面應用程式的預設應用程式網域）。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-493">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="d4ba5-494">相反地，受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 會一律載入以完全信任，不論應用程式定義域的信任層級因此其目前的信任層級永遠都是完全受信任。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-494">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="d4ba5-495">您可以使用，以判斷目前的信任層級的組件和應用程式定義域<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-495">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="d4ba5-496">如需有關反映和透明度的詳細資訊，請參閱[反映的安全性考量](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-496">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="d4ba5-497">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-497">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-498">取得值，指出這個方法是否有特別的名稱。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-498">Gets a value indicating whether this method has a special name.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-499">如果這個方法有特別的名稱，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-499"><see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-500"><xref:System.Reflection.MethodAttributes.SpecialName>位元會設為旗標以特殊方式處理由某些編譯器 （例如屬性存取子和運算子多載方法） 的成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-500">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-501">這個範例會示範搭配<xref:System.Reflection.MethodBase.IsSpecialName%2A>篩選內部或從清單的私用成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-501">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-502">取得值指出方法是否為 <see langword="static" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-502">Gets a value indicating whether the method is <see langword="static" />.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-503">如果這個方法為 <see langword="static" /> 則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-503"><see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-504">靜態成員不能以隱含方式參考類別中的執行個體資料。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-504">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-505">取得值指出方法是否為 <see langword="virtual" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-505">Gets a value indicating whether the method is <see langword="virtual" />.</span></span></summary>
        <value>
          <span data-ttu-id="d4ba5-506">如果這個方法為 <see langword="virtual" /> 則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-506"><see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-507">虛擬成員可能會參考類別中的執行個體資料，而且必須透過類別的執行個體參考。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-507">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="d4ba5-508">若要判斷是否可覆寫方法，不檢查是否足夠`IsVirtual`是`true`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-508">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="d4ba5-509">將可覆寫，方法如`IsVirtual`必須`true`和<xref:System.Reflection.MethodBase.IsFinal%2A>必須`false`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-509">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="d4ba5-510">例如，方法可能會非虛擬的但它會實作介面方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-510">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="d4ba5-511">Common language runtime 需要實作介面成員的所有方法都必須都標示為`virtual`; 因此，編譯器會將方法標示`virtual final`。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-511">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="d4ba5-512">讓某些情況下，其中的方法標示為`virtual`但仍不可覆寫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-512">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="d4ba5-513">若要確定是否可覆寫方法，使用如下的程式碼：</span><span class="sxs-lookup"><span data-stu-id="d4ba5-513">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="d4ba5-514">如果`IsVirtual`是`false`或`IsFinal`是`true`，則無法覆寫此方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-514">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="d4ba5-515">您可以判斷是否目前的方法覆寫基底類別中的方法藉由呼叫<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-515">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d4ba5-516">下列範例會實作`IsOverride`此方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-516">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="d4ba5-517">下列範例會顯示`false`如`IsFinal`，這可能會導致您認為`MyMethod`是可覆寫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-517">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="d4ba5-518">程式碼會列印`false`即使`MyMethod`未標記為`virtual`因此不能覆寫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-518">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-519">取得方法內部中繼資料 (Metadata) 表示的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-519">Gets a handle to the internal metadata representation of a method.</span></span></summary>
        <value><span data-ttu-id="d4ba5-520"><see cref="T:System.RuntimeMethodHandle" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-520">A <see cref="T:System.RuntimeMethodHandle" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-521">控制代碼是有效的只有在所取得的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-521">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-522">取得 <see cref="T:System.Reflection.MethodImplAttributes" /> 旗標，這些旗標會指定方法實作的屬性。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-522">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span></span></summary>
        <value><span data-ttu-id="d4ba5-523">方法實作旗標。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-523">The method implementation flags.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-524">如需詳細資訊，請參閱 <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-524">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="d4ba5-525">要比較的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-525">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="d4ba5-526">要比較的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-526">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="d4ba5-527">表示兩個 <see cref="T:System.Reflection.MethodBase" /> 物件是否相等。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-527">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="d4ba5-528">如果 <see langword="true" /> 等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-528"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="d4ba5-529">要比較的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-529">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="d4ba5-530">要比較的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-530">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="d4ba5-531">表示兩個 <see cref="T:System.Reflection.MethodBase" /> 物件是否不相等。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-531">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="d4ba5-532">如果 <see langword="true" /> 不等於 <paramref name="left" />，則為 <paramref name="right" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-532"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="d4ba5-533">保留供未來使用。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-533">Reserved for future use.</span></span> <span data-ttu-id="d4ba5-534">必須是 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-534">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="d4ba5-535">要對應之傳入的名稱陣列。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-535">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="d4ba5-536">要對應的名稱計數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-536">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="d4ba5-537">用於解譯名稱的地區設定內容。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-537">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="d4ba5-538">呼叫端配置的陣列，用於接收對應於名稱的 ID。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-538">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="d4ba5-539">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-539">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-540">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-540">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="d4ba5-541">如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-541">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="d4ba5-542">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-542">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d4ba5-543">如需這個成員的說明，請參閱 <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-543">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span></span></summary>
        <returns><span data-ttu-id="d4ba5-544">如需這個成員的說明，請參閱 <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-544">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-545">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-545">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-546">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-546">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="d4ba5-547">要傳回的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-547">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="d4ba5-548">類型資訊的地區設定識別項。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-548">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="d4ba5-549">接收要求的類型資訊物件的指標。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-549">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="d4ba5-550">擷取物件的類型資訊，可以用來取得介面的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-550">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-551">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-551">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="d4ba5-552">如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-552">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="d4ba5-553">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-553">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="d4ba5-554">指向接收物件提供的類型資訊介面數目的位置。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-554">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="d4ba5-555">擷取物件提供的類型資訊介面數目 (0 或 1)。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-555">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-556">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-556">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="d4ba5-557">如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-557">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="d4ba5-558">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-558">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="d4ba5-559">辨識成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-559">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="d4ba5-560">保留供未來使用。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-560">Reserved for future use.</span></span> <span data-ttu-id="d4ba5-561">必須是 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-561">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="d4ba5-562">地區設定內容，用於解譯引數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-562">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="d4ba5-563">描述呼叫之內容的旗標。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-563">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="d4ba5-564">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-564">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="d4ba5-565">指向用於儲存結果之位置的指標。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-565">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="d4ba5-566">包含例外狀況資訊的結構指標。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-566">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="d4ba5-567">第一個有錯誤的引數索引。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-567">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="d4ba5-568">提供物件所公開的屬性和方法的存取權。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-568">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-569">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="d4ba5-570">如需有關`IDispatch::Invoke`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-570">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="d4ba5-571">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-572">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-572">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-573">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-573">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-574">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-574">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-575">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-575">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-576">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-576">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-577">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-577">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-578">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-578">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-579">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-579">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-580">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-580">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-581">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-581">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-582">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-582">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-583">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-583">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-584">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-584">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-585">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-585">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-586">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-586">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-587">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-587">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-588">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-588">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-589">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-589">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-590">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-590">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-591">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-591">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-592">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-592">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-593">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-593">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-594">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-594">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-595">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-595">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-596">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-596">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-597">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-597">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-598">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-598">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-599">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-599">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-600">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-600">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-601">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-601">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-602">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-602">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-603">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-603">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-604">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-604">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-605">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-605">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-606">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-606">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-607">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-607">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-608">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-608">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-609">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-609">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-610">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-610">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-611">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-611">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-612">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-612">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-613">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-613">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-614">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-614">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-615">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-615">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-616">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-616">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-617">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-617">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-618">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-618">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-619">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-619">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d4ba5-620">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-620">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span></span></summary>
        <value><span data-ttu-id="d4ba5-621">如需這個成員的說明，請參閱 <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-621">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4ba5-622">這個成員是明確介面成員實作，</span><span class="sxs-lookup"><span data-stu-id="d4ba5-622">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="d4ba5-623">只有在 <xref:System.Reflection.MethodBase> 執行個體轉換成 <xref:System.Runtime.InteropServices._MethodBase> 介面時，才能使用這個成員。</span><span class="sxs-lookup"><span data-stu-id="d4ba5-623">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>