<Type Name="SessionAuthenticationModule" FullName="System.IdentityModel.Services.SessionAuthenticationModule">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1289b28bb0b4bf053a1698a1a9adae95172abf08" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39753171" /></Metadata><TypeSignature Language="C#" Value="public class SessionAuthenticationModule : System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionAuthenticationModule extends System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.SessionAuthenticationModule" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionAuthenticationModule&#xA;Inherits HttpModuleBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionAuthenticationModule : System::IdentityModel::Services::HttpModuleBase" />
  <TypeSignature Language="F#" Value="type SessionAuthenticationModule = class&#xA;    inherit HttpModuleBase" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Services.HttpModuleBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>實作 ASP.NET 模組，它會處理在 WS-Federation 案例中的工作階段 cookie。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 ASP.NET 管線中，存在時<xref:System.IdentityModel.Services.SessionAuthenticationModule>(SAM) 會處理在 Ws-federation 案例中的工作階段 cookie。 它會使用指定的 cookie 處理常式<xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A>屬性未經處理的工作階段 cookie 讀取的 HTTP 要求，並寫入至 HTTP 回應。 它會使用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>設定應用程式還原序列化至未經處理的工作階段 cookie<xref:System.IdentityModel.Tokens.SessionSecurityToken>物件。 工作階段安全性權杖包含宣告 (<xref:System.Security.Claims.Claim>) 和主體 (<xref:System.Security.Claims.ClaimsPrincipal>) 正在服務此要求的實體與相關聯。  
  
 SAM 加入其<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>事件處理常式來<xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType>ASP.NET 管線中的事件。 這個處理常式會攔截登入要求，如果沒有工作階段 cookie，將它還原序列化工作階段權杖，並設定<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>和<xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType>屬性，以包含在工作階段權杖的宣告主體。 它會叫用數個在此程序期間公開 sam 的其他方法。  
  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>可以叫用方法，以將使用者登出工作階段 （例如，在 SignOut.aspx.cs 程式碼後置檔案）。  
  
 SAM 會公開數個事件，提供存取至其處理管線。 <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>和<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated>事件可讓您修改讀取 cookie 或在處理期間建立的工作階段權杖。 一般而言，這是要新增、 移除或轉換權杖中的宣告，或調整其到期時間。 <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut>， <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut>，和<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError>事件提供攔截到登出要求的處理。 對於許多案例中，只要加入這些事件處理常式通常 global.asax.cs 檔案的內容，會足夠。  
  
 更複雜的情況下，您可以從衍生<xref:System.IdentityModel.Services.SessionAuthenticationModule>來實作自訂的 SAM。 為了這個目的，期間叫用方法的許多<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>和<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>公開，讓您能夠提供自訂行為的工作階段處理生命週期的特定階段。  
  
 您也可以將它新增至 HTTP 模組，在組態檔中的 ASP.NET 管線新增 SAM`<system.webServer>`項目適用於 IIS 7 及更新版本的版本，或在`<system.web>`IIS 7 之前的版本中的項目。 SAM 所使用的 cookie 處理常式可以設有[ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md)項目。  
  
   
  
## Examples  
 [!code-csharp[WifSAM#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#1)]  
  
 下列 XML 會示範如何在 ASP.NET 管線中設定 SAM。 為求簡單明瞭這裡省略許多其他會出現在一般組態中的項目。  
  
```xml  
<configuration>  
  <system.webServer>  
    <modules>  
      <!--WIF 4.5 modules -->  
      <add name="SessionAuthenticationModule" type="System.IdentityModel.Services.SessionAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
      <add name="WsFederationAuthenticationModule" type="System.IdentityModel.Services.WSFederationAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
  </system.webServer>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionAuthenticationModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionAuthenticationModule();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.IdentityModel.Services.SessionAuthenticationModule" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A>屬性設定為`false`並<xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A>屬性會初始化為預設執行個體<xref:System.IdentityModel.Services.CookieHandlerElement.ChunkedCookieHandler%2A>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateSessionSecurityToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateSessionSecurityToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken(System.IdentityModel.Tokens.SessionSecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateSessionSecurityToken (sessionToken As SessionSecurityToken, writeCookie As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateSessionSecurityToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken, bool writeCookie);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken * bool -&gt; unit&#xA;override this.AuthenticateSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken * bool -&gt; unit" Usage="sessionAuthenticationModule.AuthenticateSessionSecurityToken (sessionToken, writeCookie)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="writeCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sessionToken">要用來驗證連入 HTTP 要求的工作階段安全性權杖。</param>
        <param name="writeCookie"><see langword="true" /> 表示要寫入工作階段 cookie，否則為 <see langword="false" />。</param>
        <summary>藉由驗證連入工作階段權杖來驗證連入要求。 驗證成功時，它會使用 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 更新目前 HTTP 內容和執行緒主體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A>方法從呼叫<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>方法。 它會呼叫<xref:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken%2A>方法來驗證連入權杖，並且更新<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>而<xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType>屬性。 如果`writeCookie`參數是`true`，則<xref:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie%2A>方法會叫用來寫入 cookie 的工作階段權杖。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSessionTokenCookie">
      <MemberSignature Language="C#" Value="public bool ContainsSessionTokenCookie (System.Web.HttpCookieCollection httpCookieCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsSessionTokenCookie(class System.Web.HttpCookieCollection httpCookieCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ContainsSessionTokenCookie(System.Web.HttpCookieCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsSessionTokenCookie(System::Web::HttpCookieCollection ^ httpCookieCollection);" />
      <MemberSignature Language="F#" Value="member this.ContainsSessionTokenCookie : System.Web.HttpCookieCollection -&gt; bool" Usage="sessionAuthenticationModule.ContainsSessionTokenCookie httpCookieCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpCookieCollection" Type="System.Web.HttpCookieCollection" />
      </Parameters>
      <Docs>
        <param name="httpCookieCollection">要在其中進行搜尋的 Cookie 集合。</param>
        <summary>判斷工作階段 Cookie 是否在指定的 Cookie 集合中。</summary>
        <returns>如果找到工作階段 Cookie，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="httpCookieCollection" /> 為 null</exception>
      </Docs>
    </Member>
    <Member MemberName="ContextSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContextSessionSecurityToken As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IdentityModel::Tokens::SessionSecurityToken ^ ContextSessionSecurityToken { System::IdentityModel::Tokens::SessionSecurityToken ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken" Usage="System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 的作用中 <see cref="T:System.Web.HttpContext" />。</summary>
        <value>使用中工作階段安全性權杖。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieHandler">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Services.CookieHandler CookieHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Services.CookieHandler CookieHandler" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieHandler As CookieHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Services::CookieHandler ^ CookieHandler { System::IdentityModel::Services::CookieHandler ^ get(); void set(System::IdentityModel::Services::CookieHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieHandler : System.IdentityModel.Services.CookieHandler with get, set" Usage="System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Services.CookieHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來讀取、寫入和刪除工作階段 cookie 的 cookie 處理常式。</summary>
        <value>Cookie 處理常式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A>屬性由初始化<xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration%2A>方法。 這個方法會初始化根據指定的 cookie 處理常式的屬性<xref:System.IdentityModel.Services.Configuration.FederationConfiguration>物件上設定<xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType>屬性。 您可以透過組態檔中設定的 cookie 處理常式[ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md)項目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, valuetype System.DateTime validFrom, valuetype System.DateTime validTo, bool isPersistent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.DateTime,System.DateTime,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, validFrom As DateTime, validTo As DateTime, isPersistent As Boolean) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="F#" Value="member this.CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * DateTime * DateTime * bool -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionAuthenticationModule.CreateSessionSecurityToken (principal, context, validFrom, validTo, isPersistent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
        <Parameter Name="isPersistent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="principal">要在權杖中擷取的主體。</param>
        <param name="context">應用程式定義的內容字串。</param>
        <param name="validFrom">這個語彙基元有效的第一個執行個體。</param>
        <param name="validTo">這個語彙基元有效的最後一個執行個體。</param>
        <param name="isPersistent">如果使用者代理程式應該保存此值，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>使用已設定的工作階段權杖處理常式，從指定的參數建立 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</summary>
        <returns>工作階段權杖。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">不是有效的已設定工作階段權杖處理常式。 (<see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 屬性中沒有設定 <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteSessionTokenCookie">
      <MemberSignature Language="C#" Value="public void DeleteSessionTokenCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSessionTokenCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSessionTokenCookie ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSessionTokenCookie();" />
      <MemberSignature Language="F#" Value="member this.DeleteSessionTokenCookie : unit -&gt; unit" Usage="sessionAuthenticationModule.DeleteSessionTokenCookie " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刪除工作階段 Cookie，並從快取中將其移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用指定的 cookie 處理常式會刪除工作階段 cookie<xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A>屬性。 會呼叫這個方法期間由登出<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeModule">
      <MemberSignature Language="C#" Value="protected override void InitializeModule (System.Web.HttpApplication context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializeModule(class System.Web.HttpApplication context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule(System.Web.HttpApplication)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InitializeModule (context As HttpApplication)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InitializeModule(System::Web::HttpApplication ^ context);" />
      <MemberSignature Language="F#" Value="override this.InitializeModule : System.Web.HttpApplication -&gt; unit" Usage="sessionAuthenticationModule.InitializeModule context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpApplication" />
      </Parameters>
      <Docs>
        <param name="context">包含這個模組的 HTTP 應用程式物件。</param>
        <summary>初始化模組，並做準備以處理來自模組之 [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] 應用程式物件的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新增<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>和<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A>處理常式<xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType>並<xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType>所指定的應用程式物件的事件`context`參數。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializePropertiesFromConfiguration">
      <MemberSignature Language="C#" Value="protected override void InitializePropertiesFromConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializePropertiesFromConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InitializePropertiesFromConfiguration ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InitializePropertiesFromConfiguration();" />
      <MemberSignature Language="F#" Value="override this.InitializePropertiesFromConfiguration : unit -&gt; unit" Usage="sessionAuthenticationModule.InitializePropertiesFromConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>根據組態檔中的定義，初始化模組屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 初始化<xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A>屬性從指定的組態中的處理常式<xref:System.IdentityModel.Services.Configuration.FederationConfiguration?displayProperty=nameWithType>物件上設定<xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType>屬性。 您可以透過組態檔中指定的 cookie 處理常式[ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md)項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceMode">
      <MemberSignature Language="C#" Value="public bool IsReferenceMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReferenceMode" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReferenceMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReferenceMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReferenceMode : bool with get, set" Usage="System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定是否應該將工作階段資訊 (宣告值等) 儲存在工作階段 Cookie 中，或者是否應該將工作階段內容儲存在伺服器端 (使用 Cookie 只儲存參考)。</summary>
        <value>如果已發行的 Cookie 處於參考模式，則為 <see langword="true" />，否則為<see langword="false" />。 預設是<see langword="false" />，指定所簽發的 cookie 未進入參考模式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在參考模式中，<xref:System.IdentityModel.Tokens.SessionSecurityToken>會儲存在伺服器端快取 (衍生自物件<xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>)。 已發行的 cookie 只會包含用來擷取權杖，從快取為內容識別碼。  
  
> [!IMPORTANT]
>  在參考模式中操作 Microsoft 建議您提供的處理常式<xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated?displayProperty=nameWithType>事件中的 global.asax.cs 檔案及設定<xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>傳入的權杖上<xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType>屬性。 這可確保工作階段權杖會以每個要求的參考模式運作，且優先只要設定<xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A?displayProperty=nameWithType>工作階段驗證模組上的屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthenticateRequest (object sender, EventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthenticateRequest(object sender, class System.EventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthenticateRequest(System::Object ^ sender, EventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthenticateRequest : obj * EventArgs -&gt; unit&#xA;override this.OnAuthenticateRequest : obj * EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnAuthenticateRequest (sender, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">事件的來源。 這個將會是 <see cref="T:System.Web.HttpApplication" /> 物件。</param>
        <param name="eventArgs">事件的資料。</param>
        <summary>處理來自 [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] 管線的 <see cref="E:System.Web.HttpApplication.AuthenticateRequest" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行下列動作：  
  
1.  叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie%2A>方法，以讀取<xref:System.IdentityModel.Tokens.SessionSecurityToken>從工作階段 cookie 中，如果有的話。  
  
2.  如果工作階段安全性權杖不可為讀取 （最有可能因為工作階段尚未建立），就會傳回。  
  
3.  叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived%2A>方法以引發<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>事件。 這便有機會從要修改的 cookie 讀取的語彙基元或取消要求。 處理常式也可以指定的權杖應該重新發出，藉由設定<xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType>屬性。  
  
4.  如果語彙基元重新發出，會從快取中移除，並叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated%2A>方法以引發<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated>事件。 這會提供要一次修改的語彙基元的機會。 請重新發出行為也可以藉由設定修改<xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType>事件處理常式中的屬性。  
  
5.  叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A>方法來驗證使用者。 如果成功，這已設定的作用<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性中包含的主體<xref:System.IdentityModel.Tokens.SessionSecurityToken.ClaimsPrincipal%2A?displayProperty=nameWithType>的連入權杖的屬性。  
  
6.  如果工作階段已過期，會叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>方法。  
  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>方法會加入至的處理常式<xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType>中的事件<xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">不是有效的已設定工作階段權杖處理常式。 (<see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 屬性中沒有設定 <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPostAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnPostAuthenticateRequest (object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPostAuthenticateRequest(object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPostAuthenticateRequest (sender As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPostAuthenticateRequest(System::Object ^ sender, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPostAuthenticateRequest : obj * EventArgs -&gt; unit&#xA;override this.OnPostAuthenticateRequest : obj * EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnPostAuthenticateRequest (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">事件的來源。 這個將會是 <see cref="T:System.Web.HttpApplication" /> 物件。</param>
        <param name="e">事件的資料。</param>
        <summary>處理來自 [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] 管線的 <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作是空的。  
  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A>處理常式加入的處理常式<xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType>中的事件<xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenCreated (System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenCreated(class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated(System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionSecurityTokenCreated (args As SessionSecurityTokenCreatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionSecurityTokenCreated(System::IdentityModel::Services::SessionSecurityTokenCreatedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionSecurityTokenCreated : System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs -&gt; unit&#xA;override this.OnSessionSecurityTokenCreated : System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSessionSecurityTokenCreated args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">事件的資料。</param>
        <summary>引發 <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從呼叫<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenReceived (System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenReceived(class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived(System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionSecurityTokenReceived (args As SessionSecurityTokenReceivedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionSecurityTokenReceived(System::IdentityModel::Services::SessionSecurityTokenReceivedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionSecurityTokenReceived : System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs -&gt; unit&#xA;override this.OnSessionSecurityTokenReceived : System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSessionSecurityTokenReceived args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">事件的資料。</param>
        <summary>引發 <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從呼叫<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignedOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSignedOut (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignedOut(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSignedOut (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSignedOut(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSignedOut : EventArgs -&gt; unit&#xA;override this.OnSignedOut : EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSignedOut e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>引發 <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會叫用從<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>方法之後登出已執行和已刪除的工作階段 cookie。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSigningOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSigningOut (System.IdentityModel.Services.SigningOutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSigningOut(class System.IdentityModel.Services.SigningOutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut(System.IdentityModel.Services.SigningOutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSigningOut (e As SigningOutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSigningOut(System::IdentityModel::Services::SigningOutEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSigningOut : System.IdentityModel.Services.SigningOutEventArgs -&gt; unit&#xA;override this.OnSigningOut : System.IdentityModel.Services.SigningOutEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSigningOut e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.SigningOutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>引發 <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會叫用從<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>方法，以執行登出。它會叫用才能刪除工作階段 cookie。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignOutError">
      <MemberSignature Language="C#" Value="protected virtual void OnSignOutError (System.IdentityModel.Services.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignOutError(class System.IdentityModel.Services.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError(System.IdentityModel.Services.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSignOutError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSignOutError(System::IdentityModel::Services::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSignOutError : System.IdentityModel.Services.ErrorEventArgs -&gt; unit&#xA;override this.OnSignOutError : System.IdentityModel.Services.ErrorEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSignOutError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的資料。</param>
        <summary>引發 <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會叫用從<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>登出期間發生錯誤時的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie (byte[] sessionCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie(unsigned int8[] sessionCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSessionTokenFromCookie (sessionCookie As Byte()) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SessionSecurityToken ^ ReadSessionTokenFromCookie(cli::array &lt;System::Byte&gt; ^ sessionCookie);" />
      <MemberSignature Language="F#" Value="member this.ReadSessionTokenFromCookie : byte[] -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionAuthenticationModule.ReadSessionTokenFromCookie sessionCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionCookie" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="sessionCookie">在 cookie 中未經處理的格式，包含工作階段權杖。</param>
        <summary>從指定的工作階段 Cookie 讀取 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />。</summary>
        <returns>已從 cookie 讀取的工作階段權杖。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">不是有效的已設定工作階段權杖處理常式。 (<see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 屬性中沒有設定 <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />
      <MemberSignature Language="VB.NET" Value="Public Event SessionSecurityTokenCreated As EventHandler(Of SessionSecurityTokenCreatedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SessionSecurityTokenCreatedEventArgs ^&gt; ^ SessionSecurityTokenCreated;" />
      <MemberSignature Language="F#" Value="member this.SessionSecurityTokenCreated : EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; " Usage="member this.SessionSecurityTokenCreated : System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>已經建立工作階段安全性權杖時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要修改的工作階段安全性權杖寫入至 cookie 之前，您可以使用此事件。  
  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated>就會引發事件，從<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>方法之後的工作階段權杖 (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) 已建立。 發生這種情況，例如，如果事件處理常式<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>事件修改權杖。  
  
 若要修改的工作階段權杖的屬性，再進一步沿著管線傳遞並用來驗證要求 （使用者） 的實體，您可以使用此事件。  
  
 在事件處理常式中，您可以存取透過語彙基元<xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType>屬性。 在修改後的權杖，您可以確保，它會寫回至 cookie 藉由設定<xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType>屬性設`true`。 不同的是，<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated>事件，<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated>不是可取消的事件。  
  
   
  
## Examples  
 下列程式碼顯示的處理常式<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated>global.asax.cs 檔案在 ASP.NET web 應用程式中實作的事件。 您也必須新增事件處理常式。 更完整的範例所示<xref:System.IdentityModel.Services.SessionAuthenticationModule>概觀主題。  
  
 [!code-csharp[WifSAM#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />
      <MemberSignature Language="VB.NET" Value="Public Event SessionSecurityTokenReceived As EventHandler(Of SessionSecurityTokenReceivedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SessionSecurityTokenReceivedEventArgs ^&gt; ^ SessionSecurityTokenReceived;" />
      <MemberSignature Language="F#" Value="member this.SessionSecurityTokenReceived : EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; " Usage="member this.SessionSecurityTokenReceived : System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>已經從 cookie 讀取工作階段安全性權杖時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>就會引發事件，從<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A>方法之後的工作階段權杖 (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) 已成功從工作階段 cookie 讀取。  
  
 若要修改的工作階段權杖的屬性，再進一步沿著管線傳遞並用來驗證要求 （使用者） 的實體，您可以使用此事件。 其中一個最常見案例涉及修改的工作階段到期時間 (可透過存取<xref:System.IdentityModel.Tokens.SessionSecurityToken.ValidTo%2A?displayProperty=nameWithType>屬性) 來覆寫透過設定中設定的工作階段到期時間`lifetime`屬性[ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md)項目。 藉由修改每個要求上的這個屬性，您可以實作滑動的工作階段中。也就是工作階段存留期會延伸每次使用者存取站台。  
  
 在事件處理常式中，您可以存取透過語彙基元<xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.SessionToken%2A?displayProperty=nameWithType>屬性。 在修改後的權杖，您可以確保，它會寫回至 cookie 藉由設定<xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType>至`true`。 最後，<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>事件是否可取消的事件，而您可以設定<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs>中止進一步處理的要求。  
  
   
  
## Examples  
 下列程式碼顯示的處理常式<xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived>global.asax.cs 檔案在 ASP.NET web 應用程式中實作的事件。 您也必須新增事件處理常式。 更完整的範例所示<xref:System.IdentityModel.Services.SessionAuthenticationModule>概觀主題。  
  
 [!code-csharp[WifSAM#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalFromSessionToken">
      <MemberSignature Language="C#" Value="protected virtual void SetPrincipalFromSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetPrincipalFromSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetPrincipalFromSessionToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionSecurityToken);" />
      <MemberSignature Language="F#" Value="abstract member SetPrincipalFromSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit&#xA;override this.SetPrincipalFromSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionAuthenticationModule.SetPrincipalFromSessionToken sessionSecurityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">要從中設定主體的工作階段權杖。</param>
        <summary>將 <see cref="T:System.Web.HttpContext" /> 和 <see cref="T:System.Threading.Thread" /> 的主體設為指定工作階段權杖中包含的主體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken%2A>方法，並將<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性並<xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType>上的屬性<xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>使用會傳回身分識別。  
  
 這個方法會從呼叫<xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignedOut">
      <MemberSignature Language="C#" Value="public event EventHandler SignedOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SignedOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />
      <MemberSignature Language="VB.NET" Value="Public Event SignedOut As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SignedOut;" />
      <MemberSignature Language="F#" Value="member this.SignedOut : EventHandler " Usage="member this.SignedOut : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用者已登出之後發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從引發<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>方法之後<xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A>叫用方法。  
  
 此事件不保證會針對每個工作階段呼叫。 例如，cookie 可能會遭到刪除用戶端中，在此情況下，引發這個事件會永遠不會因為刪除工作階段的任何伺服器端事件。  
  
   
  
## Examples  
 下列程式碼顯示的處理常式<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut>global.asax.cs 檔案在 ASP.NET web 應用程式中實作的事件。 您也必須新增事件處理常式。 更完整的範例所示<xref:System.IdentityModel.Services.SessionAuthenticationModule>概觀主題。  
  
 [!code-csharp[WifSAM#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SigningOut">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />
      <MemberSignature Language="VB.NET" Value="Public Event SigningOut As EventHandler(Of SigningOutEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SigningOutEventArgs ^&gt; ^ SigningOut;" />
      <MemberSignature Language="F#" Value="member this.SigningOut : EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; " Usage="member this.SigningOut : System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>刪除登入工作階段之前發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從引發<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>方法之前<xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A>叫用方法。  
  
 此事件不保證會針對每個工作階段呼叫。 例如，cookie 可能會遭到刪除用戶端中，在此情況下，引發這個事件會永遠不會因為刪除工作階段的任何伺服器端事件。  
  
   
  
## Examples  
 下列程式碼顯示的處理常式<xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut>global.asax.cs 檔案在 ASP.NET web 應用程式中實作的事件。 您也必須新增事件處理常式。 更完整的範例所示<xref:System.IdentityModel.Services.SessionAuthenticationModule>概觀主題。  
  
 [!code-csharp[WifSAM#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOut">
      <MemberSignature Language="C#" Value="public virtual void SignOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SignOut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SignOut" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SignOut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SignOut();" />
      <MemberSignature Language="F#" Value="abstract member SignOut : unit -&gt; unit&#xA;override this.SignOut : unit -&gt; unit" Usage="sessionAuthenticationModule.SignOut " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前使用者登出並引發適當的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut%2A>， <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A>，和<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut%2A>; 方法來執行登出。如果發生例外狀況<xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError%2A>方法會叫用來引發<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError>事件。 您可以設定<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>屬性<xref:System.IdentityModel.Services.ErrorEventArgs>物件傳遞至這個事件，以取消登出，並防止用戶端傳播的例外狀況的事件處理常式。  
  
 您可以覆寫這個方法，以新增應用程式特有的行為。  
  
   
  
## Examples  
 下列程式碼顯示程式碼叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>從 SignOut.aspx 網頁 (SignOut.aspx.cs) 中的 ASP.NET web 應用程式的方法。 更完整的範例所示<xref:System.IdentityModel.Services.SessionAuthenticationModule>概觀主題。  
  
 [!code-csharp[WifSAM#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOutError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />
      <MemberSignature Language="VB.NET" Value="Public Event SignOutError As EventHandler(Of ErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::ErrorEventArgs ^&gt; ^ SignOutError;" />
      <MemberSignature Language="F#" Value="member this.SignOutError : EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; " Usage="member this.SignOutError : System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當登出期間發生錯誤時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從引發<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A>登出期間發生錯誤時的方法。  
  
 在 事件處理常式中，您可以取得所引發的事件中產生的例外狀況<xref:System.IdentityModel.Services.ErrorEventArgs.Exception%2A?displayProperty=nameWithType>屬性。 您可以取消進一步處理的例外狀況，其結果不藉由設定傳播至用戶端，例外狀況<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>的屬性<xref:System.IdentityModel.Services.ErrorEventArgs>至`true`。  
  
 此事件不保證會針對每個工作階段呼叫。 例如，cookie 可能會遭到刪除用戶端中，在此情況下，引發這個事件會永遠不會因為刪除工作階段的任何伺服器端事件。  
  
   
  
## Examples  
 下列程式碼顯示的處理常式<xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError>global.asax.cs 檔案在 ASP.NET web 應用程式中實作的事件。 您也必須新增事件處理常式。 更完整的範例所示<xref:System.IdentityModel.Services.SessionAuthenticationModule>概觀主題。  
  
 [!code-csharp[WifSAM#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public bool TryReadSessionTokenFromCookie (out System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadSessionTokenFromCookie([out] class System.IdentityModel.Tokens.SessionSecurityToken&amp; sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadSessionTokenFromCookie (ByRef sessionToken As SessionSecurityToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReadSessionTokenFromCookie([Runtime::InteropServices::Out] System::IdentityModel::Tokens::SessionSecurityToken ^ % sessionToken);" />
      <MemberSignature Language="F#" Value="member this.TryReadSessionTokenFromCookie :  -&gt; bool" Usage="sessionAuthenticationModule.TryReadSessionTokenFromCookie sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" RefType="out" />
      </Parameters>
      <Docs>
        <param name="sessionToken">這個方法回傳時，會包含從工作階段 Cookie 讀取的工作階段安全性權杖。</param>
        <summary>嘗試從工作階段 Cookie 讀取 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />，並傳回表示是否已成功地讀取工作階段 Cookie 的值。</summary>
        <returns>如果已順利從要求中讀取工作階段 Cookie，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用中設定的 cookie 處理常式中讀取的 cookie<xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A>屬性然後再叫用<xref:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie%2A>從 cookie 讀取語彙基元的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSessionToken">
      <MemberSignature Language="C#" Value="protected System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateSessionToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionSecurityToken);" />
      <MemberSignature Language="F#" Value="member this.ValidateSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionAuthenticationModule.ValidateSessionToken sessionSecurityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">要驗證的權杖。</param>
        <summary>驗證指定的<see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> ，並傳回其識別。</summary>
        <returns>包含在權杖中的識別集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從呼叫<xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A>方法。 它會叫用<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A?displayProperty=nameWithType>的驗證權杖並擷取其身分識別設定的工作階段權杖處理常式的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Services.FederatedSessionExpiredException">權杖已過期。</exception>
        <exception cref="T:System.IdentityModel.Services.FederationException">權杖的開始時間尚未生效。</exception>
        <exception cref="T:System.InvalidOperationException">不是有效的已設定工作階段權杖處理常式。 (<see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 屬性中沒有設定 <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSessionTokenToCookie">
      <MemberSignature Language="C#" Value="public void WriteSessionTokenToCookie (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSessionTokenToCookie(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSessionTokenToCookie (sessionToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSessionTokenToCookie(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberSignature Language="F#" Value="member this.WriteSessionTokenToCookie : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionAuthenticationModule.WriteSessionTokenToCookie sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">要寫入的工作階段安全性權杖。</param>
        <summary>將指定的 <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> 寫入至工作階段 Cookie。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用中設定的 cookie 處理常式寫入 cookie<xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sessionToken" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">不是有效的已設定工作階段權杖處理常式。 (<see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> 屬性中沒有設定 <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />)。</exception>
      </Docs>
    </Member>
  </Members>
</Type>