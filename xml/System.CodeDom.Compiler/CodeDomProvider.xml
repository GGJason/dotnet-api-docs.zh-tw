<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6b363c079585f8a6b7ddeaeb04c81ee9d77dae6d" />
    <Meta Name="ms.sourcegitcommit" Value="69952c4c5555f8f4bed66798cdd71228d3a9eb98" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/18/2018" />
    <Meta Name="ms.locfileid" Value="39104843" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供基底類別 (Base Class) 給 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作。 這個類別是抽象的。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.CodeDom.Compiler.CodeDomProvider>可用來建立和擷取的程式碼產生器和程式碼編譯器的執行個體。 程式碼產生器可以用來產生特定語言的程式碼，且程式碼編譯器可將程式碼編譯為組件。  
  
> [!NOTE]
>  在  [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]、 方法可在程式碼產生器和程式碼編譯器都可以直接從程式碼提供者。 您不需要呼叫<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>或<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>來存取這些方法與這些方法會標記為過時。 這適用於預先存在的以及新的程式碼提供者實作。  
  
 A<xref:System.CodeDom.Compiler.CodeDomProvider>實作通常會提供程式碼產生和/或程式碼編譯介面，以產生程式碼和管理單一程式設計語言的編譯。 有幾種語言都受到<xref:System.CodeDom.Compiler.CodeDomProvider>隨附的實作[!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]。 這些語言包括 C#、 Visual Basic、 c + + 和 JScript。 開發人員或編譯器廠商可以實作<xref:System.CodeDom.Compiler.ICodeGenerator>並<xref:System.CodeDom.Compiler.ICodeCompiler>介面，並提供<xref:System.CodeDom.Compiler.CodeDomProvider>延伸到其他程式設計語言支援 CodeDOM。  
  
 [ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)機器組態檔 (Machine.config) 提供一個機制，讓開發人員和編譯器廠商新增組態設定的其他<xref:System.CodeDom.Compiler.CodeDomProvider>實作。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider>類別提供靜態方法來探索及列舉<xref:System.CodeDom.Compiler.CodeDomProvider>的電腦上的實作。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法會傳回所有的設定<xref:System.CodeDom.Compiler.CodeDomProvider>的電腦上的實作。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法會傳回特定的設定<xref:System.CodeDom.Compiler.CodeDomProvider>實作中，以程式設計的語言名稱。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法傳回的執行個體<xref:System.CodeDom.Compiler.CodeDomProvider>特定語言的實作。  
  
 如需組態檔中的語言提供者設定的詳細資訊，請參閱 <<c0> [ 編譯器和語言提供者設定結構描述](http://msdn.microsoft.com/library/c020b139-8699-4f0d-9ac9-70d0c5b2a8c8)。  
  
> [!NOTE]
>  此類別可讓連結要求和繼承要求在類別層級。 A<xref:System.Security.SecurityException>立即呼叫端或衍生的類別不具有完全信任權限時，就會擲回。 如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)並[繼承要求](http://msdn.microsoft.com/library/28b9adbb-8f08-4f10-b856-dbf59eb932d9)。  
  
   
  
## Examples  
 下列範例程式可以產生和編譯的程式會列印"Hello World"使用 CodeDOM 模型為基礎的原始碼<xref:System.Console>類別。 提供 Windows Form 使用者介面。 使用者可以選取目標程式從幾個選項的語言： C#、 Visual Basic 和 JScript。  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個類別不能由部分信任的程式碼。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">針對繼承者完全信任。 這個類別無法繼承由部分信任的程式碼。</permission>
    <block subset="none" type="overrides">
      <para>在.NET framework 1.0 和 1.1 版中，程式碼提供者包括實作<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />， <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />， <see cref="T:System.CodeDom.Compiler.ICodeParser" />，和<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />。在 [！INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />， <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />，並<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />方法已經過時，與方法的<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />並<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />直接用於<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />類別。您應該在您的程式碼提供者實作中覆寫這些方法，並呼叫基底方法。</para>
    </block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個類別不能由部分信任的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 物件，指示編譯的設定值。</param>
        <param name="compilationUnits">
          <see cref="T:System.CodeDom.CodeCompileUnit" /> 型別的陣列，表示要編譯的程式碼。</param>
        <summary>使用指定的編譯器設定，根據 <see cref="N:System.CodeDom" /> 物件之指定陣列所包含的 <see cref="T:System.CodeDom.CodeCompileUnit" /> 樹狀結構，編譯一個組件。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 物件，指示編譯的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeCompiler>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeCompiler>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />與預先存在的提供者，使用程式碼編譯器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼編譯器呼叫的基底類別方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="fileNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 物件，指示編譯的設定值。</param>
        <param name="fileNames">要編譯的檔案名稱陣列。</param>
        <summary>使用指定的編譯器設定，在指定檔案所包含的原始程式碼中，編譯組件。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 物件，表示編譯的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeCompiler>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeCompiler>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />與預先存在的提供者，使用程式碼編譯器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼編譯器呼叫的基底類別方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="sources" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 物件，指示這個編譯的編譯器設定。</param>
        <param name="sources">要編譯的原始程式碼字串陣列。</param>
        <summary>使用指定的編譯器設定，在含有原始程式碼的指定陣列中，編譯一個組件。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 物件，表示編譯的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeCompiler>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeCompiler>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />與預先存在的提供者，使用程式碼編譯器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼編譯器呼叫的基底類別方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，請建立新的程式碼編譯器。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />，可以用來編譯以 <see cref="N:System.CodeDom" /> 為基礎的原始程式碼表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是中的過時[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]。 建議的替代做法是呼叫<xref:System.CodeDom.Compiler.ICodeCompiler>直接用於程式碼提供者的方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在 [！INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，您應該實作<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />中的成員<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />類別，並擲回<see cref="T:System.NotSupportedException" />會呼叫這個方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要建立逸出識別項的字串。</param>
        <summary>為指定值建立逸出識別項。</summary>
        <returns>值的逸出識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> 測試與任何保留識別項的衝突是否或語言關鍵字，如果是的話，會傳回具有特定語言逸出程式碼格式設定的對等名稱。 這被指逸出識別項。 逸出識別項包含相同`value`但加上逸出程式碼格式，以便區別的關鍵字。 兩個實作範例是上述`value`與"@"或方括號`value`與"["和"]"。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，請建立新的程式碼產生器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，請建立新的程式碼產生器。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可以用來產生以 <see cref="N:System.CodeDom" /> 為基礎的原始程式碼表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是中的過時[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]。 建議的替代做法是呼叫<xref:System.CodeDom.Compiler.ICodeGenerator>方法中直接提供<xref:System.CodeDom.Compiler.CodeDomProvider>類別。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在 [！INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，您應該實作<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />中的成員<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />類別，並擲回<see cref="T:System.NotSupportedException" />會呼叫這個方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">用來輸出的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>在衍生類別中覆寫時，請使用指定的輸出 <see cref="T:System.IO.TextWriter" /> 建立新的程式碼產生器。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可以用來產生以 <see cref="N:System.CodeDom" /> 為基礎的原始程式碼表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用指定<xref:System.IO.TextWriter>輸出。 這個方法支援以累加方式更新原始碼的更多最佳化的程式碼產生。  
  
> [!NOTE]
>  基底類別實作會呼叫<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法，這是中的過時[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]並導致<xref:System.NotSupportedException>如果<xref:System.CodeDom.Compiler.ICodeGenerator>就不會傳回物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要輸出的檔案名稱。</param>
        <summary>在衍生類別中覆寫時，請使用指定的輸出檔名建立新的程式碼產生器。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可以用來產生以 <see cref="N:System.CodeDom" /> 為基礎的原始程式碼表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用指定的檔案名稱輸出。  
  
> [!NOTE]
>  基底類別實作會呼叫<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法，這是中的過時[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]並導致<xref:System.NotSupportedException>如果<xref:System.CodeDom.Compiler.ICodeGenerator>就不會傳回物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，請建立新的程式碼剖析器。</summary>
        <returns>可以用來剖析原始程式碼的 <see cref="T:System.CodeDom.Compiler.ICodeParser" />。 這個基底實作一定會傳回 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得指定語言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">語言名稱。</param>
        <summary>取得指定語言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 執行個體。</summary>
        <returns>為特定語言名稱實作的 CodeDOM 提供者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法最常用的應用程式，可能會選擇性地使用數個提供者的其中一個建立的程式碼提供者執行個體。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 可讓您指定在執行階段，因此您想要具現化的程式碼提供者。 如果您知道在哪一個程式碼所要使用的提供者的設計階段，您應該建立該程式碼提供者的執行個體而不必使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法會傳回<xref:System.CodeDom.Compiler.CodeDomProvider>執行個體的特定語言名稱，它是類似於呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>與語言提供者類型的方法。 使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>當您想要以動態方式尋找語言名稱的設定提供者實作。  
  
 如果一個以上的提供者實作設定的語言名稱<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>傳回最後一個相符的組態項目提供者執行個體。  
  
 使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>時您想要的特定語言提供者實作的方法多載。 例如，使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法來取得支援的語言名稱的提供者執行個體`"CSharp"`; 使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>方法多載來取得提供者執行個體，專為<xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType>實作。 您應該使用 [\]，CultureInfo、 物件\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType > 如果您有多個語言的程式碼提供者，而且您想要具現化特定程式碼提供者的方法。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法會檢查是否至少一個提供者實作會支援特定的語言。 您可以驗證名稱使用的語言<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>再傳遞給<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>。 如果您不支援的語言將名稱傳遞給<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A><xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>就會擲回。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法可用來判斷所有<xref:System.CodeDom.Compiler.CodeDomProvider>實作的電腦上，包括開發人員和中所識別的編譯器廠商所提供的其他實作[ &lt;system.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)電腦組態檔 (Machine.config) 中。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法傳回的執行個體<xref:System.CodeDom.Compiler.CodeDomProvider>特定語言的實作。  
  
 語言名稱不區分大小寫。  
  
   
  
## Examples  
 下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作的輸入的語言和顯示語言提供者所設定的設定。 此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="language" /> 在這部電腦上沒有已設定的提供者。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="language" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="language">語言名稱。</param>
        <param name="providerOptions">來自組態檔的提供者選項集合。</param>
        <summary>取得指定之語言和提供者選項的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 執行個體。</summary>
        <returns>為特定語言名稱和選項實作的 CodeDOM 提供者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法最常用的應用程式，可能會選擇性地使用數個提供者的其中一個建立的程式碼提供者執行個體。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> 可讓您指定在執行階段，因此您想要具現化的程式碼提供者的版本。 如果您知道在哪一個程式碼所要使用的提供者的設計階段，您應該建立而不是使用該程式碼提供者執行個體<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>方法。  
  
 使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>想要以動態方式尋找特定的語言和選項的設定的提供者實作時。 語言名稱不區分大小寫。 如需支援的提供者選項的資訊，請參閱特定的 CodeDOM 提供者文件。  
  
 驗證提供者和呼叫提供者，如果一個以上的提供者實作設定的語言名稱的相關資訊，請參閱 < 備註 > 一節<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29>方法。  
  
   
  
## Examples  
 下列範例示範如何建立提供者執行個體使用`providerOptions`參數。  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要產生有效識別項的字串。</param>
        <summary>為指定值建立有效的識別項。</summary>
        <returns>指定值的有效識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> 測試是否與保留衝突的識別項或多個語言關鍵字，如果因此，嘗試傳回有效的識別項名稱，並不會衝突。 傳回的識別項通常只會稍微修改，以便識別項區別的關鍵字;例如，名稱可能會加底線 ("_") 字元。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前語言的原始程式碼檔案所使用的預設副檔名。</summary>
        <value>對應至目前語言的原始程式碼的檔案名稱的副檔名。 這個基底實作一定會傳回 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程式碼產生器和程式碼編譯器會使用這個屬性表示應該產生或使用何種副檔名。  
  
   
  
## Examples  
 下列程式碼範例建立的執行個體<xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>。 此範例會顯示提供者名稱、 新的提供者執行個體的雜湊程式碼和預設檔案名稱副檔名。  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="compileUnit">要為其產生程式碼的 <see cref="T:System.CodeDom.CodeCompileUnit" />。</param>
        <param name="writer">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</param>
        <summary>產生指定程式碼文件物件模型 (CodeDOM) 編譯單位 (Compilation Unit) 的程式碼，並使用指定的選項將其傳送至指定的文字寫入器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A>方法來產生程式碼中的"Hello World"應用程式<xref:System.CodeDom.CodeCompileUnit>。 這個範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CodeDomProvider>類別。  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.CodeDom.CodeExpression" /> 物件，指示要為其產生程式碼的運算式。</param>
        <param name="writer">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</param>
        <summary>產生指定程式碼文件物件模型 (CodeDOM) 運算式的程式碼，並使用指定的選項將其傳送至指定的文字寫入器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.CodeDom.CodeTypeMember" /> 物件，指示要為其產生程式碼的成員。</param>
        <param name="writer">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</param>
        <summary>產生指定程式碼文件物件模型 (CodeDOM) 成員宣告的程式碼，並使用指定的選項將其傳送至指定的文字寫入器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基底類別實作會擲回<xref:System.NotImplementedException>。 請參閱<xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType>文件描述此方法的實作。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A>方法實作<xref:Microsoft.CSharp.CSharpCodeProvider>和<xref:Microsoft.VisualBasic.VBCodeProvider>類別。  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不可以在衍生類別中覆寫這個方法。</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">
          <see cref="T:System.CodeDom.CodeNamespace" /> 物件，指示要為其產生程式碼的命名空間。</param>
        <param name="writer">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</param>
        <summary>產生指定程式碼文件物件模型 (CodeDOM) 命名空間的程式碼，並使用指定選項將其傳送至指定的文字寫入器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="statement">
          <see cref="T:System.CodeDom.CodeStatement" />，包含要為其產生程式碼的 CodeDOM 項目。</param>
        <param name="writer">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</param>
        <summary>產生指定程式碼文件物件模型 (CodeDOM) 陳述式的程式碼，並使用指定選項將其傳送至指定的文字寫入器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeType">
          <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 物件，指示要為其產生程式碼的型別。</param>
        <param name="writer">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</param>
        <summary>產生指定程式碼文件物件模型 (CodeDOM) 型別宣告的程式碼，並使用指定選項將其傳送至指定的文字寫入器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這部電腦的語言提供者和編譯器組態設定。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 型別的陣列，表示所有已設定 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作的設定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法來列舉電腦上的語言提供者設定。  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]中, 未指定.NET Framework 所提供的預設語言提供者[ &lt;system.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)編譯器組態區段，且無法移除，因此這個方法會傳回預設的提供者和任何指定的組態檔中的相關資訊。  
  
   
  
## Examples  
 下列程式碼範例列舉電腦上的語言提供者，並顯示每個語言提供者的組態和編譯器設定。 此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">語言名稱。</param>
        <summary>傳回指定語言的語言提供者和編譯器組態設定。</summary>
        <returns>已設定 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 實作設定填入的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中的機器組態檔案會包含每個語言提供者和編譯器組態設定<xref:System.CodeDom.Compiler.CodeDomProvider>在電腦上的實作。 電腦組態檔的相關資訊，請參閱中的機器設定檔 」 一節[設定應用程式](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f)。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法會搜尋指定的語言名稱的每個提供者組態項目。 傳回<xref:System.CodeDom.Compiler.CompilerInfo>執行個體會包含已設定的語言提供者和編譯器設定。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法會檢查是否至少一個提供者實作會支援特定的語言。 您可以驗證名稱使用的語言<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>再傳遞給<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>。 這可避免擲回<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>當您存取<xref:System.CodeDom.Compiler.CompilerInfo>不支援的語言名稱的執行個體。  
  
 如果一個以上的提供者實作設定為輸入的語言名稱<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>從最後一個相符的提供者組態項目傳回的設定。  
  
 語言名稱不區分大小寫。  
  
   
  
## Examples  
 下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作的輸入的語言和顯示語言提供者所設定的設定。 此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <paramref name="language" /> 在這部電腦上沒有已設定的提供者。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="language" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">物件的類型，要為其擷取類型轉換子。</param>
        <summary>取得指定資料型別的 <see cref="T:System.ComponentModel.TypeConverter" />。</summary>
        <returns>如果找不到特定型別的 <see cref="T:System.ComponentModel.TypeConverter" />，則為特定型別的 <see cref="T:System.ComponentModel.TypeConverter" /> 或 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生的類別可以覆寫這個方法，以提供特定資料類型的特定類型的型別轉換子。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">副檔名。</param>
        <summary>傳回與指定副檔名關聯的語言名稱，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 編譯器組態區段的設定。</summary>
        <returns>與指定副檔名關聯的語言名稱，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 編譯器組態設定的設定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中的機器組態檔 (Machine.config) 包含每個語言提供者和編譯器組態設定<xref:System.CodeDom.Compiler.CodeDomProvider>上的實作電腦。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>方法會搜尋指定的副檔名為每個提供者組態項目。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法會檢查是否至少一個提供者實作會支援特定的副檔名。 您可以驗證檔案名稱副檔名 using<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>再傳遞給<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>。 這可防止<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>擲回<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>不支援的檔案名稱副檔名。  
  
 如果提供者實作支援的輸入的檔案名稱副檔名，而且有多個支援的語言，然後設定該提供者，<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>傳回該提供者的第一個語言名稱。 如果輸入的檔案名稱副檔名，設定一個以上的提供者實作<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>傳回語言名稱，從最後一個相符的提供者組態項目。  
  
 語言名稱和檔案名稱副檔名不區分大小寫。  
  
   
  
## Examples  
 下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作輸入的副檔名，並顯示已設定的語言提供者的設定。 此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <paramref name="extension" /> 在這部電腦上沒有已設定的語言提供者。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="extension" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.CodeDom.CodeTypeReference" />，表示要傳回的型別。</param>
        <summary>取得由指定的 <see cref="T:System.CodeDom.CodeTypeReference" /> 所指示的型別。</summary>
        <returns>指定型別的文字表示，針對這個程式碼產生器產生程式碼所使用的語言格式化。 例如，在 Visual Basic 中，傳入 <see cref="T:System.CodeDom.CodeTypeReference" /> 型別的 <see cref="T:System.Int32" /> 會傳回 "Integer"。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">副檔名。</param>
        <summary>測試副檔名在電腦上是否已設定關聯的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作。</summary>
        <returns>如果指定副檔名已設定 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中的機器組態檔 (Machine.config) 包含每個語言提供者和編譯器組態設定<xref:System.CodeDom.Compiler.CodeDomProvider>上的實作電腦。 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法會搜尋指定的副檔名的提供者組態項目。  
  
 檔案名稱副檔名不區分大小寫。  
  
   
  
## Examples  
 下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作輸入的副檔名，並顯示已設定的語言提供者的設定。 此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="extension" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">語言名稱。</param>
        <summary>測試語言在電腦上是否已設定 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作。</summary>
        <returns>如果指定語言已設定 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中的機器組態檔 (Machine.config) 包含每個語言提供者和編譯器組態設定<xref:System.CodeDom.Compiler.CodeDomProvider>上的實作電腦。 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法會搜尋指定的語言名稱的提供者組態項目。  
  
 語言名稱不區分大小寫。  
  
   
  
## Examples  
 下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作的輸入的語言和顯示語言提供者所設定的設定。 此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="language" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要驗證為有效識別項的值。</param>
        <summary>傳回值，指出指定的值是否為目前語言的有效識別項。</summary>
        <returns>如果 <paramref name="value" /> 參數是有效的識別項，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會測試識別項是否有效。 <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A>方法是特定的提供者。 適用於一個提供者的識別項不可能適用於其他提供者。 如果`value`包含字元的 ASCII 字元範圍中，檢查可能用來編譯程式碼的所有語言的識別碼。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>當覆寫<see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />在衍生類別中，設計方法，以傳回<see langword="true" />值符合語言的規則，而且不會使用的關鍵字衝突時，才可以。如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得語言功能識別項。</summary>
        <value>
          <see cref="T:System.CodeDom.Compiler.LanguageOptions" />，表示語言的特殊功能。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="codeStream">
          <see cref="T:System.IO.TextReader" /> 物件，用於讀取要剖析的程式碼。</param>
        <summary>將指定文字資料流中所讀取的程式碼編譯成 <see cref="T:System.CodeDom.CodeCompileUnit" />。</summary>
        <returns>
          <see cref="T:System.CodeDom.CodeCompileUnit" />，含有剖析程式碼的表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeParser>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeParser>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法，建立使用過時的衍生類別中剖析器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />與預先存在的提供者，使用程式碼剖析器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeParser" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼剖析器呼叫基底類別方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">
          <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> 物件，指示要驗證的程式碼產生支援型別。</param>
        <param name="supports">
          <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> 物件，指示要驗證的程式碼產生支援型別。</param>
        <summary>傳回值，指出是否提供指定程式碼產生支援。</summary>
        <returns>如果提供指定程式碼產生支援，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可以呼叫具有數目<xref:System.CodeDom.Compiler.GeneratorSupport>次要加入一組二進位檔與適當的功能旗標來測試一組功能旗標`OR`運算子 (&#124;)。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。 在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。 如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</exception>
        <block subset="none" type="overrides">
          <para>如果您覆寫這個方法，您必須呼叫基底類別的對應方法。基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>