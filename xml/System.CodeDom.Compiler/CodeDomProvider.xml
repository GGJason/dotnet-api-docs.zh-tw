<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2e7aff308fae45fc690174f3883b758dac1b13d3" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52193990" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="246de-101">提供基底類別 (Base Class) 給 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作。</span>
      <span class="sxs-lookup">
        <span data-stu-id="246de-101">Provides a base class for <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementations.</span>
      </span>
      <span data-ttu-id="246de-102">這個類別是抽象的。</span>
      <span class="sxs-lookup">
        <span data-stu-id="246de-102">This class is abstract.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-103">A<xref:System.CodeDom.Compiler.CodeDomProvider>可用來建立和擷取的程式碼產生器和程式碼編譯器的執行個體。</span><span class="sxs-lookup"><span data-stu-id="246de-103">A <xref:System.CodeDom.Compiler.CodeDomProvider> can be used to create and retrieve instances of code generators and code compilers.</span></span> <span data-ttu-id="246de-104">程式碼產生器可以用來產生特定語言的程式碼，且程式碼編譯器可將程式碼編譯為組件。</span><span class="sxs-lookup"><span data-stu-id="246de-104">Code generators can be used to generate code in a particular language, and code compilers can be used to compile code into assemblies.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-105">在  [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]、 方法可在程式碼產生器和程式碼編譯器都可以直接從程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-105">In the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], the methods made available in the code generator and code compiler are available directly from the code provider.</span></span> <span data-ttu-id="246de-106">您不需要呼叫<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>或<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>來存取這些方法與這些方法會標記為過時。</span><span class="sxs-lookup"><span data-stu-id="246de-106">You do not need to call <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> or <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> to access the methods, and those methods are marked as obsolete.</span></span> <span data-ttu-id="246de-107">這適用於預先存在的以及新的程式碼提供者實作。</span><span class="sxs-lookup"><span data-stu-id="246de-107">This applies to preexisting as well as new code provider implementations.</span></span>  
  
 <span data-ttu-id="246de-108">A<xref:System.CodeDom.Compiler.CodeDomProvider>實作通常會提供程式碼產生和/或程式碼編譯介面，以產生程式碼和管理單一程式設計語言的編譯。</span><span class="sxs-lookup"><span data-stu-id="246de-108">A <xref:System.CodeDom.Compiler.CodeDomProvider> implementation typically provides code generation and/or code compilation interfaces for generating code and managing compilation for a single programming language.</span></span> <span data-ttu-id="246de-109">有幾種語言都受到<xref:System.CodeDom.Compiler.CodeDomProvider>隨附的實作[!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="246de-109">Several languages are supported by <xref:System.CodeDom.Compiler.CodeDomProvider> implementations that ship with the [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)].</span></span> <span data-ttu-id="246de-110">這些語言包括 C#、 Visual Basic、 c + + 和 JScript。</span><span class="sxs-lookup"><span data-stu-id="246de-110">These languages include C#, Visual Basic, C++, and JScript.</span></span> <span data-ttu-id="246de-111">開發人員或編譯器廠商可以實作<xref:System.CodeDom.Compiler.ICodeGenerator>並<xref:System.CodeDom.Compiler.ICodeCompiler>介面，並提供<xref:System.CodeDom.Compiler.CodeDomProvider>延伸到其他程式設計語言支援 CodeDOM。</span><span class="sxs-lookup"><span data-stu-id="246de-111">Developers or compiler vendors can implement the <xref:System.CodeDom.Compiler.ICodeGenerator> and <xref:System.CodeDom.Compiler.ICodeCompiler> interfaces and provide a <xref:System.CodeDom.Compiler.CodeDomProvider> that extends CodeDOM support to other programming languages.</span></span>  
  
 <span data-ttu-id="246de-112">[ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)機器組態檔 (Machine.config) 提供一個機制，讓開發人員和編譯器廠商新增組態設定的其他<xref:System.CodeDom.Compiler.CodeDomProvider>實作。</span><span class="sxs-lookup"><span data-stu-id="246de-112">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) provides a mechanism for developers and compiler vendors to add configuration settings for additional <xref:System.CodeDom.Compiler.CodeDomProvider> implementations.</span></span>  
  
 <span data-ttu-id="246de-113"><xref:System.CodeDom.Compiler.CodeDomProvider>類別提供靜態方法來探索及列舉<xref:System.CodeDom.Compiler.CodeDomProvider>的電腦上的實作。</span><span class="sxs-lookup"><span data-stu-id="246de-113">The <xref:System.CodeDom.Compiler.CodeDomProvider> class provides static methods to discover and enumerate the <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer.</span></span> <span data-ttu-id="246de-114"><xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法會傳回所有的設定<xref:System.CodeDom.Compiler.CodeDomProvider>的電腦上的實作。</span><span class="sxs-lookup"><span data-stu-id="246de-114">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method returns the settings for all <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer.</span></span> <span data-ttu-id="246de-115"><xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法會傳回特定的設定<xref:System.CodeDom.Compiler.CodeDomProvider>實作中，以程式設計的語言名稱。</span><span class="sxs-lookup"><span data-stu-id="246de-115">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> method returns the settings for a specific <xref:System.CodeDom.Compiler.CodeDomProvider> implementation, based on the programming language name.</span></span> <span data-ttu-id="246de-116"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法傳回的執行個體<xref:System.CodeDom.Compiler.CodeDomProvider>特定語言的實作。</span><span class="sxs-lookup"><span data-stu-id="246de-116">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns an instance of a <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for a specific language.</span></span>  
  
 <span data-ttu-id="246de-117">如需組態檔中的語言提供者設定的詳細資訊，請參閱 <<c0> [ 編譯器和語言提供者設定結構描述](~/docs/framework/configure-apps/file-schema/compiler/index.md)。</span><span class="sxs-lookup"><span data-stu-id="246de-117">For more details on language provider settings in the configuration file, see [Compiler and Language Provider Settings Schema](~/docs/framework/configure-apps/file-schema/compiler/index.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-118">此類別可讓連結要求和繼承要求在類別層級。</span><span class="sxs-lookup"><span data-stu-id="246de-118">This class makes a link demand and an inheritance demand at the class level.</span></span> <span data-ttu-id="246de-119">A<xref:System.Security.SecurityException>立即呼叫端或衍生的類別不具有完全信任權限時，就會擲回。</span><span class="sxs-lookup"><span data-stu-id="246de-119">A <xref:System.Security.SecurityException> is thrown if either the immediate caller or the derived class does not have full trust permission.</span></span> <span data-ttu-id="246de-120">如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)並[繼承要求](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="246de-120">For details about security demands, see [Link Demands](~/docs/framework/misc/link-demands.md) and [Inheritance Demands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-121">下列範例程式可以產生和編譯的程式會列印"Hello World"使用 CodeDOM 模型為基礎的原始碼<xref:System.Console>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-121">The following example program can generate and compile source code based on a CodeDOM model of a program that prints "Hello World" using the <xref:System.Console> class.</span></span> <span data-ttu-id="246de-122">提供 Windows Form 使用者介面。</span><span class="sxs-lookup"><span data-stu-id="246de-122">A Windows Forms user interface is provided.</span></span> <span data-ttu-id="246de-123">使用者可以選取目標程式從幾個選項的語言： C#、 Visual Basic 和 JScript。</span><span class="sxs-lookup"><span data-stu-id="246de-123">The user can select the target programming language from several selections: C#, Visual Basic, and JScript.</span></span>  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
      <span data-ttu-id="246de-124">針對完全信任立即呼叫端。</span>
      <span class="sxs-lookup">
        <span data-stu-id="246de-124">for full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="246de-125">這個類別不能由部分信任的程式碼。</span>
      <span class="sxs-lookup">
        <span data-stu-id="246de-125">This class cannot be used by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="246de-126">針對繼承者完全信任。</span>
      <span class="sxs-lookup">
        <span data-stu-id="246de-126">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="246de-127">這個類別無法繼承由部分信任的程式碼。</span>
      <span class="sxs-lookup">
        <span data-stu-id="246de-127">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="246de-128">在.NET framework 1.0 和 1.1 版中，程式碼提供者包括實作<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />， <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />， <see cref="T:System.CodeDom.Compiler.ICodeParser" />，和<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />。</span>
        <span class="sxs-lookup">
          <span data-stu-id="246de-128">In the .NET Framework versions 1.0 and 1.1, code providers consist of implementations of <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, and <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />.</span>
        </span>
        <span data-ttu-id="246de-129">中[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，則<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />， <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />，和<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />方法已經過時，和方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />並<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />直接用於<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />類別。</span>
        <span class="sxs-lookup">
          <span data-stu-id="246de-129">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, and <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> methods are obsolete, and the methods of <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> and <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> are directly available in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class.</span>
        </span>
        <span data-ttu-id="246de-130">您應該在您的程式碼提供者實作中覆寫這些方法，並呼叫基底方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="246de-130">You should override those methods in your code provider implementation and not call the base methods.</span>
        </span>
      </para>
    </block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">
      <span data-ttu-id="246de-131">編譯器和語言提供者設定結構描述</span>
      <span class="sxs-lookup">
        <span data-stu-id="246de-131">Compiler and Language Provider Settings Schema</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="246de-132">初始化 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-132">Initializes a new instance of the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="246de-133">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-133">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="246de-134">這個類別不能由部分信任的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-134">This class cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="246de-135">
            <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 物件，指示編譯的設定值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-135">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the settings for the compilation.</span>
          </span>
        </param>
        <param name="compilationUnits">
          <span data-ttu-id="246de-136">
            <see cref="T:System.CodeDom.CodeCompileUnit" /> 型別的陣列，表示要編譯的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-136">An array of type <see cref="T:System.CodeDom.CodeCompileUnit" /> that indicates the code to compile.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-137">使用指定的編譯器設定，根據 <see cref="N:System.CodeDom" /> 物件之指定陣列所包含的 <see cref="T:System.CodeDom.CodeCompileUnit" /> 樹狀結構，編譯一個組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-137">Compiles an assembly based on the <see cref="N:System.CodeDom" /> trees contained in the specified array of <see cref="T:System.CodeDom.CodeCompileUnit" /> objects, using the specified compiler settings.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-138">
            <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 物件，指示編譯的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-138">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of the compilation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-139">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeCompiler>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-139">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="246de-140">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-140">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-141">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeCompiler>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-141">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-142">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-142">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-143">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-143">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-144">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />與預先存在的提供者，使用程式碼編譯器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-144">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span>
            </span>
            <span data-ttu-id="246de-145">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-145">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-146">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼編譯器呼叫的基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-146">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="fileNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="246de-147">
            <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 物件，指示編譯的設定值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-147">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the settings for the compilation.</span>
          </span>
        </param>
        <param name="fileNames">
          <span data-ttu-id="246de-148">要編譯的檔案名稱陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-148">An array of the names of the files to compile.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-149">使用指定的編譯器設定，在指定檔案所包含的原始程式碼中，編譯組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-149">Compiles an assembly from the source code contained in the specified files, using the specified compiler settings.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-150">
            <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 物件，表示編譯的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-150">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of compilation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-151">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeCompiler>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-151">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="246de-152">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-152">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-153">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeCompiler>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-153">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-154">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-154">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-155">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-155">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-156">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />與預先存在的提供者，使用程式碼編譯器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-156">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span>
            </span>
            <span data-ttu-id="246de-157">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-157">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-158">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼編譯器呼叫的基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-158">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="sources" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="246de-159">
            <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 物件，指示這個編譯的編譯器設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-159">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the compiler settings for this compilation.</span>
          </span>
        </param>
        <param name="sources">
          <span data-ttu-id="246de-160">要編譯的原始程式碼字串陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-160">An array of source code strings to compile.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-161">使用指定的編譯器設定，在含有原始程式碼的指定陣列中，編譯一個組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-161">Compiles an assembly from the specified array of strings containing source code, using the specified compiler settings.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-162">
            <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 物件，表示編譯的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-162">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of compilation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-163">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeCompiler>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-163">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="246de-164">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-164">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-165">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeCompiler>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-165">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-166">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-166">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-167">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-167">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-168">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />與預先存在的提供者，使用程式碼編譯器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-168">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span>
            </span>
            <span data-ttu-id="246de-169">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-169">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-170">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼編譯器呼叫的基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-170">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="246de-171">在衍生類別中覆寫時，請建立新的程式碼編譯器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-171">When overridden in a derived class, creates a new code compiler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-172">
            <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />，可以用來編譯以 <see cref="N:System.CodeDom" /> 為基礎的原始程式碼表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-172">An <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> that can be used for compilation of <see cref="N:System.CodeDom" /> based source code representations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-173">這個方法是中的過時[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="246de-173">This method is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)].</span></span> <span data-ttu-id="246de-174">建議的替代做法是呼叫<xref:System.CodeDom.Compiler.ICodeCompiler>直接用於程式碼提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-174">The recommended alternative is to call the <xref:System.CodeDom.Compiler.ICodeCompiler> methods that are directly available in the code provider.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-175">在  [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，您應該實作<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />中的成員<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />類別，並擲回<see cref="T:System.NotSupportedException" />會呼叫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-175">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], you should implement the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> members in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class and throw a <see cref="T:System.NotSupportedException" /> when this method is called.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="246de-176">要建立逸出識別項的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-176">The string for which to create an escaped identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-177">為指定值建立逸出識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-177">Creates an escaped identifier for the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-178">值的逸出識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-178">The escaped identifier for the value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-179"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> 測試與任何保留識別項的衝突是否或語言關鍵字，如果是的話，會傳回具有特定語言逸出程式碼格式設定的對等名稱。</span><span class="sxs-lookup"><span data-stu-id="246de-179"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> tests whether the identifier conflicts with any reserved or language keywords, and if so, returns an equivalent name with language-specific escape code formatting.</span></span> <span data-ttu-id="246de-180">這被指逸出識別項。</span><span class="sxs-lookup"><span data-stu-id="246de-180">This is referred to an escaped identifier.</span></span> <span data-ttu-id="246de-181">逸出識別項包含相同`value`但加上逸出程式碼格式，以便區別的關鍵字。</span><span class="sxs-lookup"><span data-stu-id="246de-181">The escaped identifier contains the same `value` but has escape-code formatting added to differentiate the identifier from the keyword.</span></span> <span data-ttu-id="246de-182">兩個實作範例是上述`value`與"@"或方括號`value`與"["和"]"。</span><span class="sxs-lookup"><span data-stu-id="246de-182">Two implementation examples are preceding the `value` with "@" or bracketing the `value` with "[" and "]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-183">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-183">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-184">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-184">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-185">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-185">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-186">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-186">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-187">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-187">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-188">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-188">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-189">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-189">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-190">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-190">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="246de-191">在衍生類別中覆寫時，請建立新的程式碼產生器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-191">When overridden in a derived class, creates a new code generator.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="246de-192">在衍生類別中覆寫時，請建立新的程式碼產生器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-192">When overridden in a derived class, creates a new code generator.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-193">
            <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可以用來產生以 <see cref="N:System.CodeDom" /> 為基礎的原始程式碼表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-193">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-194">這個方法是中的過時[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="246de-194">This method is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)].</span></span> <span data-ttu-id="246de-195">建議的替代做法是呼叫<xref:System.CodeDom.Compiler.ICodeGenerator>方法中直接提供<xref:System.CodeDom.Compiler.CodeDomProvider>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-195">The recommended alternative is to call the <xref:System.CodeDom.Compiler.ICodeGenerator> methods that are directly available in the <xref:System.CodeDom.Compiler.CodeDomProvider> class.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-196">在  [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，您應該實作<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />中的成員<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />類別，並擲回<see cref="T:System.NotSupportedException" />會呼叫這個方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-196">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], you should implement the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> members in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class and throw a <see cref="T:System.NotSupportedException" /> when this method is called.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">
          <span data-ttu-id="246de-197">用來輸出的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-197">A <see cref="T:System.IO.TextWriter" /> to use to output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-198">在衍生類別中覆寫時，請使用指定的輸出 <see cref="T:System.IO.TextWriter" /> 建立新的程式碼產生器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-198">When overridden in a derived class, creates a new code generator using the specified <see cref="T:System.IO.TextWriter" /> for output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-199">
            <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可以用來產生以 <see cref="N:System.CodeDom" /> 為基礎的原始程式碼表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-199">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-200">這個方法會使用指定<xref:System.IO.TextWriter>輸出。</span><span class="sxs-lookup"><span data-stu-id="246de-200">This method uses the specified <xref:System.IO.TextWriter> for output.</span></span> <span data-ttu-id="246de-201">這個方法支援以累加方式更新原始碼的更多最佳化的程式碼產生。</span><span class="sxs-lookup"><span data-stu-id="246de-201">This method supports more optimized code generation that incrementally updates the source code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-202">基底類別實作會呼叫<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法，這是中的過時[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]並導致<xref:System.NotSupportedException>如果<xref:System.CodeDom.Compiler.ICodeGenerator>就不會傳回物件。</span><span class="sxs-lookup"><span data-stu-id="246de-202">The base class implementation calls the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method, which is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] and results in a <xref:System.NotSupportedException> if an <xref:System.CodeDom.Compiler.ICodeGenerator> object is not returned.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="246de-203">要輸出的檔案名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-203">The file name to output to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-204">在衍生類別中覆寫時，請使用指定的輸出檔名建立新的程式碼產生器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-204">When overridden in a derived class, creates a new code generator using the specified file name for output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-205">
            <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可以用來產生以 <see cref="N:System.CodeDom" /> 為基礎的原始程式碼表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-205">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-206">這個方法會使用指定的檔案名稱輸出。</span><span class="sxs-lookup"><span data-stu-id="246de-206">This method uses the specified file name for output.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-207">基底類別實作會呼叫<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法，這是中的過時[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]並導致<xref:System.NotSupportedException>如果<xref:System.CodeDom.Compiler.ICodeGenerator>就不會傳回物件。</span><span class="sxs-lookup"><span data-stu-id="246de-207">The base class implementation calls the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method, which is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] and results in a <xref:System.NotSupportedException> if an <xref:System.CodeDom.Compiler.ICodeGenerator> object is not returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="246de-208">在衍生類別中覆寫時，請建立新的程式碼剖析器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-208">When overridden in a derived class, creates a new code parser.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-209">可以用來剖析原始程式碼的 <see cref="T:System.CodeDom.Compiler.ICodeParser" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-209">An <see cref="T:System.CodeDom.Compiler.ICodeParser" /> that can be used to parse source code.</span>
          </span>
          <span data-ttu-id="246de-210">這個基底實作一定會傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-210">The base implementation always returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="246de-211">取得指定語言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-211">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">
          <span data-ttu-id="246de-212">語言名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-212">The language name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-213">取得指定語言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-213">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-214">為特定語言名稱實作的 CodeDOM 提供者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-214">A CodeDOM provider that is implemented for the specified language name.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-215">這個方法最常用的應用程式，可能會選擇性地使用數個提供者的其中一個建立的程式碼提供者執行個體。</span><span class="sxs-lookup"><span data-stu-id="246de-215">This method is most commonly used to create an instance of a code provider in an application that may optionally use one of several providers.</span></span> <span data-ttu-id="246de-216"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 可讓您指定在執行階段，因此您想要具現化的程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-216"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> allows you to specify at run time the code provider you wish to instantiate.</span></span> <span data-ttu-id="246de-217">如果您知道在哪一個程式碼所要使用的提供者的設計階段，您應該建立該程式碼提供者的執行個體而不必使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="246de-217">If you know at design time which code provider is to be used, you should create an instance of that code provider rather than use the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method.</span></span>  
  
 <span data-ttu-id="246de-218"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法會傳回<xref:System.CodeDom.Compiler.CodeDomProvider>執行個體的特定語言名稱，它是類似於呼叫<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>與語言提供者類型的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-218">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns a <xref:System.CodeDom.Compiler.CodeDomProvider> instance for a specific language name; it is similar to calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method with the language provider type.</span></span> <span data-ttu-id="246de-219">使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>當您想要以動態方式尋找語言名稱的設定提供者實作。</span><span class="sxs-lookup"><span data-stu-id="246de-219">Use <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> when you want to dynamically find a configured provider implementation for a language name.</span></span>  
  
 <span data-ttu-id="246de-220">如果一個以上的提供者實作設定的語言名稱<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>傳回最後一個相符的組態項目提供者執行個體。</span><span class="sxs-lookup"><span data-stu-id="246de-220">If more than one provider implementation is configured for the language name, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> returns a provider instance for the last matching configuration element.</span></span>  
  
 <span data-ttu-id="246de-221">使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>時您想要的特定語言提供者實作的方法多載。</span><span class="sxs-lookup"><span data-stu-id="246de-221">Use the <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method overload when you want a specific language provider implementation.</span></span> <span data-ttu-id="246de-222">例如，使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法來取得支援的語言名稱的提供者執行個體`"CSharp"`; 使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>方法多載來取得提供者執行個體，專為<xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType>實作。</span><span class="sxs-lookup"><span data-stu-id="246de-222">For example, use the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method to get a provider instance that supports the language name `"CSharp"`; use the <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method overload to get a provider instance specifically for the <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="246de-223">您應該使用 [\]，CultureInfo、 物件\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType > 如果您有多個語言的程式碼提供者，而且您想要具現化特定程式碼提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-223">You should use the [\], CultureInfo, Object\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method if you have multiple code providers for a language and you desire to instantiate a specific code provider.</span></span>  
  
 <span data-ttu-id="246de-224"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法會檢查是否至少一個提供者實作會支援特定的語言。</span><span class="sxs-lookup"><span data-stu-id="246de-224">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method checks whether at least one provider implementation supports a specific language.</span></span> <span data-ttu-id="246de-225">您可以驗證名稱使用的語言<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>再傳遞給<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>。</span><span class="sxs-lookup"><span data-stu-id="246de-225">You can validate a language name using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>.</span></span> <span data-ttu-id="246de-226">如果您不支援的語言將名稱傳遞給<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A><xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="246de-226">If you pass an unsupported language name to <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> is thrown.</span></span>  
  
 <span data-ttu-id="246de-227"><xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法可用來判斷所有<xref:System.CodeDom.Compiler.CodeDomProvider>實作的電腦上，包括開發人員和中所識別的編譯器廠商所提供的其他實作[ &lt;system.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)電腦組態檔 (Machine.config) 中。</span><span class="sxs-lookup"><span data-stu-id="246de-227">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method can be used to determine all <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer, including additional implementations provided by developers and compiler vendors that are identified in the [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config).</span></span>  
  
 <span data-ttu-id="246de-228"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法傳回的執行個體<xref:System.CodeDom.Compiler.CodeDomProvider>特定語言的實作。</span><span class="sxs-lookup"><span data-stu-id="246de-228">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns an instance of a <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for a specific language.</span></span>  
  
 <span data-ttu-id="246de-229">語言名稱不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="246de-229">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-230">下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作的輸入的語言和顯示語言提供者所設定的設定。</span><span class="sxs-lookup"><span data-stu-id="246de-230">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="246de-231">此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-231">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <span data-ttu-id="246de-232">
            <paramref name="language" /> 在這部電腦上沒有已設定的提供者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-232">The <paramref name="language" /> does not have a configured provider on this computer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="246de-233">
            <paramref name="language" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-233">The <paramref name="language" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="246de-234">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-234">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="246de-235">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-235">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="246de-236">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-236">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="language">
          <span data-ttu-id="246de-237">語言名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-237">The language name.</span>
          </span>
        </param>
        <param name="providerOptions">
          <span data-ttu-id="246de-238">來自組態檔的提供者選項集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-238">A collection of provider options from the configuration file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-239">取得指定之語言和提供者選項的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-239">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language and provider options.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-240">為特定語言名稱和選項實作的 CodeDOM 提供者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-240">A CodeDOM provider that is implemented for the specified language name and options.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-241">這個方法最常用的應用程式，可能會選擇性地使用數個提供者的其中一個建立的程式碼提供者執行個體。</span><span class="sxs-lookup"><span data-stu-id="246de-241">This method is most commonly used to create an instance of a code provider in an application that may optionally use one of several providers.</span></span> <span data-ttu-id="246de-242"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> 可讓您指定在執行階段，因此您想要具現化的程式碼提供者的版本。</span><span class="sxs-lookup"><span data-stu-id="246de-242"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> enables you to specify at run time the version of the code provider you want to instantiate.</span></span> <span data-ttu-id="246de-243">如果您知道在哪一個程式碼所要使用的提供者的設計階段，您應該建立而不是使用該程式碼提供者執行個體<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="246de-243">If you know at design time which code provider is to be used, you should create an instance of that code provider instead of using the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> method.</span></span>  
  
 <span data-ttu-id="246de-244">使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>想要以動態方式尋找特定的語言和選項的設定的提供者實作時。</span><span class="sxs-lookup"><span data-stu-id="246de-244">Use <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> when you want to dynamically find a configured provider implementation for a specific language and options.</span></span> <span data-ttu-id="246de-245">語言名稱不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="246de-245">Language names are case-insensitive.</span></span> <span data-ttu-id="246de-246">如需支援的提供者選項的資訊，請參閱特定的 CodeDOM 提供者文件。</span><span class="sxs-lookup"><span data-stu-id="246de-246">For information about supported provider options, see the specific CodeDOM provider documentation.</span></span>  
  
 <span data-ttu-id="246de-247">驗證提供者和呼叫提供者，如果一個以上的提供者實作設定的語言名稱的相關資訊，請參閱 < 備註 > 一節<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="246de-247">For information about validating a provider and calling a provider if more than one provider implementation is configured for the language name, see the Remarks section of the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-248">下列範例示範如何建立提供者執行個體使用`providerOptions`參數。</span><span class="sxs-lookup"><span data-stu-id="246de-248">The following example shows how to create an instance of a provider by using the `providerOptions` parameter.</span></span>  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="246de-249">要產生有效識別項的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-249">The string for which to generate a valid identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-250">為指定值建立有效的識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-250">Creates a valid identifier for the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-251">指定值的有效識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-251">A valid identifier for the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-252"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> 測試是否與保留衝突的識別項或多個語言關鍵字，如果因此，嘗試傳回有效的識別項名稱，並不會衝突。</span><span class="sxs-lookup"><span data-stu-id="246de-252"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> tests whether the identifier conflicts with reserved or language keywords, and if so, attempts to return a valid identifier name that does not conflict.</span></span> <span data-ttu-id="246de-253">傳回的識別項通常只會稍微修改，以便識別項區別的關鍵字;例如，名稱可能會加底線 ("_") 字元。</span><span class="sxs-lookup"><span data-stu-id="246de-253">Usually the returned identifier is only slightly modified to differentiate the identifier from the keyword; for example, the name might be preceded by the underscore ("_") character.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-254">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-254">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-255">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-255">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-256">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-256">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-257">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-257">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-258">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-258">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-259">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-259">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-260">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-260">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-261">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-261">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="246de-262">取得目前語言的原始程式碼檔案所使用的預設副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-262">Gets the default file name extension to use for source code files in the current language.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="246de-263">對應至目前語言的原始程式碼的檔案名稱的副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-263">A file name extension corresponding to the extension of the source files of the current language.</span>
          </span>
          <span data-ttu-id="246de-264">這個基底實作一定會傳回 <see cref="F:System.String.Empty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-264">The base implementation always returns <see cref="F:System.String.Empty" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-265">程式碼產生器和程式碼編譯器會使用這個屬性表示應該產生或使用何種副檔名。</span><span class="sxs-lookup"><span data-stu-id="246de-265">This property is used by code generators and code compilers to indicate what file extensions should be generated or used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-266">下列程式碼範例建立的執行個體<xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="246de-266">The following code example creates an instance of <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>.</span></span> <span data-ttu-id="246de-267">此範例會顯示提供者名稱、 新的提供者執行個體的雜湊程式碼和預設檔案名稱副檔名。</span><span class="sxs-lookup"><span data-stu-id="246de-267">The example displays the provider name, hash code and default file name extension for the new provider instance.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="compileUnit">
          <span data-ttu-id="246de-268">要為其產生程式碼的 <see cref="T:System.CodeDom.CodeCompileUnit" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-268">A <see cref="T:System.CodeDom.CodeCompileUnit" /> for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="246de-269">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-269">The <see cref="T:System.IO.TextWriter" /> to which the output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="246de-270">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-270">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-271">產生指定程式碼文件物件模型 (CodeDOM) 編譯單位 (Compilation Unit) 的程式碼，並使用指定的選項將其傳送至指定的文字寫入器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-271">Generates code for the specified Code Document Object Model (CodeDOM) compilation unit and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-272">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-272">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-273">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-273">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-274">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-274">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-275">下列程式碼範例示範使用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A>方法來產生程式碼中的"Hello World"應用程式<xref:System.CodeDom.CodeCompileUnit>。</span><span class="sxs-lookup"><span data-stu-id="246de-275">The following code example shows the use of the <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> method to generate code for a "Hello World" application from a <xref:System.CodeDom.CodeCompileUnit>.</span></span> <span data-ttu-id="246de-276">這個範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CodeDomProvider>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-276">This example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CodeDomProvider> class.</span></span>  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-277">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-277">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-278">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-278">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-279">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-279">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-280">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-280">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-281">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-281">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="246de-282">
            <see cref="T:System.CodeDom.CodeExpression" /> 物件，指示要為其產生程式碼的運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-282">A <see cref="T:System.CodeDom.CodeExpression" /> object that indicates the expression for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="246de-283">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-283">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="246de-284">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-284">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-285">產生指定程式碼文件物件模型 (CodeDOM) 運算式的程式碼，並使用指定的選項將其傳送至指定的文字寫入器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-285">Generates code for the specified Code Document Object Model (CodeDOM) expression and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-286">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-286">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-287">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-287">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-288">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-288">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-289">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-289">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-290">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-290">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-291">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-291">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-292">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-292">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-293">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-293">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="246de-294">
            <see cref="T:System.CodeDom.CodeTypeMember" /> 物件，指示要為其產生程式碼的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-294">A <see cref="T:System.CodeDom.CodeTypeMember" /> object that indicates the member for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="246de-295">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-295">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="246de-296">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-296">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-297">產生指定程式碼文件物件模型 (CodeDOM) 成員宣告的程式碼，並使用指定的選項將其傳送至指定的文字寫入器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-297">Generates code for the specified Code Document Object Model (CodeDOM) member declaration and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-298">基底類別實作會擲回<xref:System.NotImplementedException>。</span><span class="sxs-lookup"><span data-stu-id="246de-298">The base class implementation throws a <xref:System.NotImplementedException>.</span></span> <span data-ttu-id="246de-299">請參閱<xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType>文件描述此方法的實作。</span><span class="sxs-lookup"><span data-stu-id="246de-299">See <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> for documentation describing an implementation of this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-300">下列程式碼範例示範使用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A>方法實作<xref:Microsoft.CSharp.CSharpCodeProvider>和<xref:Microsoft.VisualBasic.VBCodeProvider>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-300">The following code example shows the use of the <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> method as implemented by the <xref:Microsoft.CSharp.CSharpCodeProvider> and <xref:Microsoft.VisualBasic.VBCodeProvider> classes.</span></span>  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-301">不可以在衍生類別中覆寫這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-301">This method is not overridden in a derived class.</span>
          </span>
        </exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">
          <span data-ttu-id="246de-302">
            <see cref="T:System.CodeDom.CodeNamespace" /> 物件，指示要為其產生程式碼的命名空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-302">A <see cref="T:System.CodeDom.CodeNamespace" /> object that indicates the namespace for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="246de-303">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-303">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="246de-304">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-304">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-305">產生指定程式碼文件物件模型 (CodeDOM) 命名空間的程式碼，並使用指定選項將其傳送至指定的文字寫入器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-305">Generates code for the specified Code Document Object Model (CodeDOM) namespace and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-306">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-306">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-307">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-307">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-308">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-308">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-309">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-309">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-310">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-310">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-311">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-311">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-312">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-312">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-313">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-313">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="statement">
          <span data-ttu-id="246de-314">
            <see cref="T:System.CodeDom.CodeStatement" />，包含要為其產生程式碼的 CodeDOM 項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-314">A <see cref="T:System.CodeDom.CodeStatement" /> containing the CodeDOM elements for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="246de-315">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-315">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="246de-316">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-316">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-317">產生指定程式碼文件物件模型 (CodeDOM) 陳述式的程式碼，並使用指定選項將其傳送至指定的文字寫入器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-317">Generates code for the specified Code Document Object Model (CodeDOM) statement and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-318">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-318">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-319">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-319">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-320">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-320">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-321">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-321">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-322">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-322">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-323">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-323">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-324">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-324">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-325">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-325">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeType">
          <span data-ttu-id="246de-326">
            <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 物件，指示要為其產生程式碼的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-326">A <see cref="T:System.CodeDom.CodeTypeDeclaration" /> object that indicates the type for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="246de-327">接收輸出程式碼的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-327">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="246de-328">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，表示要用來產生程式碼的選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-328">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-329">產生指定程式碼文件物件模型 (CodeDOM) 型別宣告的程式碼，並使用指定選項將其傳送至指定的文字寫入器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-329">Generates code for the specified Code Document Object Model (CodeDOM) type declaration and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-330">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-330">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-331">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-331">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-332">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-332">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-333">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-333">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-334">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-334">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-335">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-335">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-336">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-336">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-337">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-337">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="246de-338">傳回這部電腦的語言提供者和編譯器組態設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-338">Returns the language provider and compiler configuration settings for this computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-339">
            <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 型別的陣列，表示所有已設定 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作的設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-339">An array of type <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> representing the settings of all configured <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-340">使用<xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法來列舉電腦上的語言提供者設定。</span><span class="sxs-lookup"><span data-stu-id="246de-340">Use the <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method to enumerate the language provider settings on a computer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-341">在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]中, 未指定.NET Framework 所提供的預設語言提供者[ &lt;system.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)編譯器組態區段，且無法移除，因此這個方法會傳回預設的提供者和任何指定的組態檔中的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="246de-341">In the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], the default language providers supplied by the .NET Framework are not specified in the [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) compiler configuration section and cannot be removed, so this method returns information about the default providers and any specified in the configuration file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-342">下列程式碼範例列舉電腦上的語言提供者，並顯示每個語言提供者的組態和編譯器設定。</span><span class="sxs-lookup"><span data-stu-id="246de-342">The following code example enumerates the language providers on the computer and displays the configuration and compiler settings for each language provider.</span></span> <span data-ttu-id="246de-343">此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-343">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="246de-344">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-344">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="246de-345">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-345">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="246de-346">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-346">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">
          <span data-ttu-id="246de-347">編譯器和語言提供者設定結構描述</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-347">Compiler and Language Provider Settings Schema</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">
          <span data-ttu-id="246de-348">語言名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-348">A language name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-349">傳回指定語言的語言提供者和編譯器組態設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-349">Returns the language provider and compiler configuration settings for the specified language.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-350">已設定 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 實作設定填入的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-350">A <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> object populated with settings of the configured <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-351">[ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中的機器組態檔案會包含每個語言提供者和編譯器組態設定<xref:System.CodeDom.Compiler.CodeDomProvider>在電腦上的實作。</span><span class="sxs-lookup"><span data-stu-id="246de-351">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="246de-352">電腦組態檔的相關資訊，請參閱中的機器設定檔 」 一節[設定應用程式](~/docs/framework/configure-apps/index.md)。</span><span class="sxs-lookup"><span data-stu-id="246de-352">For information about machine configuration files, see the Machine Configuration Files section in [Configuring Apps](~/docs/framework/configure-apps/index.md).</span></span> <span data-ttu-id="246de-353"><xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法會搜尋指定的語言名稱的每個提供者組態項目。</span><span class="sxs-lookup"><span data-stu-id="246de-353">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> method searches each provider configuration element for the specified language name.</span></span> <span data-ttu-id="246de-354">傳回<xref:System.CodeDom.Compiler.CompilerInfo>執行個體會包含已設定的語言提供者和編譯器設定。</span><span class="sxs-lookup"><span data-stu-id="246de-354">The returned <xref:System.CodeDom.Compiler.CompilerInfo> instance contains the configured language provider and compiler settings.</span></span>  
  
 <span data-ttu-id="246de-355"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法會檢查是否至少一個提供者實作會支援特定的語言。</span><span class="sxs-lookup"><span data-stu-id="246de-355">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method checks whether at least one provider implementation supports a specific language.</span></span> <span data-ttu-id="246de-356">您可以驗證名稱使用的語言<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>再傳遞給<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>。</span><span class="sxs-lookup"><span data-stu-id="246de-356">You can validate a language name using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>.</span></span> <span data-ttu-id="246de-357">這可避免擲回<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>當您存取<xref:System.CodeDom.Compiler.CompilerInfo>不支援的語言名稱的執行個體。</span><span class="sxs-lookup"><span data-stu-id="246de-357">This prevents throwing a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> when you access the <xref:System.CodeDom.Compiler.CompilerInfo> instance for an unsupported language name.</span></span>  
  
 <span data-ttu-id="246de-358">如果一個以上的提供者實作設定為輸入的語言名稱<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>從最後一個相符的提供者組態項目傳回的設定。</span><span class="sxs-lookup"><span data-stu-id="246de-358">If more than one provider implementation is configured for the input language name, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> returns the settings from the last matching provider configuration element.</span></span>  
  
 <span data-ttu-id="246de-359">語言名稱不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="246de-359">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-360">下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作的輸入的語言和顯示語言提供者所設定的設定。</span><span class="sxs-lookup"><span data-stu-id="246de-360">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="246de-361">此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-361">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <span data-ttu-id="246de-362">
            <paramref name="language" /> 在這部電腦上沒有已設定的提供者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-362">The <paramref name="language" /> does not have a configured provider on this computer.</span>
          </span>
        </exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <span data-ttu-id="246de-363">
            <paramref name="language" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-363">The <paramref name="language" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="246de-364">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-364">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="246de-365">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-365">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="246de-366">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-366">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">
          <span data-ttu-id="246de-367">編譯器和語言提供者設定結構描述</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-367">Compiler and Language Provider Settings Schema</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="246de-368">物件的類型，要為其擷取類型轉換子。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-368">The type of object to retrieve a type converter for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-369">取得指定資料型別的 <see cref="T:System.ComponentModel.TypeConverter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-369">Gets a <see cref="T:System.ComponentModel.TypeConverter" /> for the specified data type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-370">如果找不到特定型別的 <see cref="T:System.ComponentModel.TypeConverter" />，則為特定型別的 <see cref="T:System.ComponentModel.TypeConverter" /> 或 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-370">A <see cref="T:System.ComponentModel.TypeConverter" /> for the specified type, or <see langword="null" /> if a <see cref="T:System.ComponentModel.TypeConverter" /> for the specified type cannot be found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-371">在衍生的類別可以覆寫這個方法，以提供特定資料類型的特定類型的型別轉換子。</span><span class="sxs-lookup"><span data-stu-id="246de-371">A derived class can override this method to provide specific types of type converters for specific data types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">
          <span data-ttu-id="246de-372">副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-372">A file name extension.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-373">傳回與指定副檔名關聯的語言名稱，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 編譯器組態區段的設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-373">Returns a language name associated with the specified file name extension, as configured in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> compiler configuration section.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-374">與指定副檔名關聯的語言名稱，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 編譯器組態設定的設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-374">A language name associated with the file name extension, as configured in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> compiler configuration settings.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-375">[ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中的機器組態檔 (Machine.config) 包含每個語言提供者和編譯器組態設定<xref:System.CodeDom.Compiler.CodeDomProvider>上的實作電腦。</span><span class="sxs-lookup"><span data-stu-id="246de-375">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="246de-376"><xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>方法會搜尋指定的副檔名為每個提供者組態項目。</span><span class="sxs-lookup"><span data-stu-id="246de-376">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> method searches each provider configuration element for the specified file name extension.</span></span>  
  
 <span data-ttu-id="246de-377"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法會檢查是否至少一個提供者實作會支援特定的副檔名。</span><span class="sxs-lookup"><span data-stu-id="246de-377">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> method checks whether at least one provider implementation supports a specific file name extension.</span></span> <span data-ttu-id="246de-378">您可以驗證檔案名稱副檔名 using<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>再傳遞給<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>。</span><span class="sxs-lookup"><span data-stu-id="246de-378">You can validate a file name extension using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>.</span></span> <span data-ttu-id="246de-379">這可防止<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>擲回<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>不支援的檔案名稱副檔名。</span><span class="sxs-lookup"><span data-stu-id="246de-379">This prevents <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> from throwing a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> for an unsupported file name extension.</span></span>  
  
 <span data-ttu-id="246de-380">如果提供者實作支援的輸入的檔案名稱副檔名，而且有多個支援的語言，然後設定該提供者，<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>傳回該提供者的第一個語言名稱。</span><span class="sxs-lookup"><span data-stu-id="246de-380">If a provider implementation supports the input file name extension, and there are multiple supported languages configured for that provider, then <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> returns the first language name for that provider.</span></span> <span data-ttu-id="246de-381">如果輸入的檔案名稱副檔名，設定一個以上的提供者實作<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>傳回語言名稱，從最後一個相符的提供者組態項目。</span><span class="sxs-lookup"><span data-stu-id="246de-381">If more than one provider implementation is configured for the input file name extension, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> returns the language name from the last matching provider configuration element.</span></span>  
  
 <span data-ttu-id="246de-382">語言名稱和檔案名稱副檔名不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="246de-382">Language names and file name extensions are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-383">下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作輸入的副檔名，並顯示已設定的語言提供者的設定。</span><span class="sxs-lookup"><span data-stu-id="246de-383">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input file name extension and displays the configured settings for the language provider.</span></span> <span data-ttu-id="246de-384">此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-384">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <span data-ttu-id="246de-385">
            <paramref name="extension" /> 在這部電腦上沒有已設定的語言提供者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-385">The <paramref name="extension" /> does not have a configured language provider on this computer.</span>
          </span>
        </exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <span data-ttu-id="246de-386">
            <paramref name="extension" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-386">The <paramref name="extension" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="246de-387">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-387">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="246de-388">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-388">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="246de-389">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-389">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">
          <span data-ttu-id="246de-390">編譯器和語言提供者設定結構描述</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-390">Compiler and Language Provider Settings Schema</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="246de-391">
            <see cref="T:System.CodeDom.CodeTypeReference" />，表示要傳回的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-391">A <see cref="T:System.CodeDom.CodeTypeReference" /> that indicates the type to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-392">取得由指定的 <see cref="T:System.CodeDom.CodeTypeReference" /> 所指示的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-392">Gets the type indicated by the specified <see cref="T:System.CodeDom.CodeTypeReference" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-393">指定型別的文字表示，針對這個程式碼產生器產生程式碼所使用的語言格式化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-393">A text representation of the specified type, formatted for the language in which code is generated by this code generator.</span>
          </span>
          <span data-ttu-id="246de-394">例如，在 Visual Basic 中，傳入 <see cref="T:System.CodeDom.CodeTypeReference" /> 型別的 <see cref="T:System.Int32" /> 會傳回 "Integer"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-394">In Visual Basic, for example, passing in a <see cref="T:System.CodeDom.CodeTypeReference" /> for the <see cref="T:System.Int32" /> type will return "Integer".</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-395">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-395">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-396">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-396">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-397">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-397">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-398">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-398">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-399">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-399">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-400">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-400">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-401">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-401">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-402">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-402">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">
          <span data-ttu-id="246de-403">副檔名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-403">A file name extension.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-404">測試副檔名在電腦上是否已設定關聯的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-404">Tests whether a file name extension has an associated <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation configured on the computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-405">如果指定副檔名已設定 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-405">
              <see langword="true" /> if a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation is configured for the specified file name extension; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-406">[ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中的機器組態檔 (Machine.config) 包含每個語言提供者和編譯器組態設定<xref:System.CodeDom.Compiler.CodeDomProvider>上的實作電腦。</span><span class="sxs-lookup"><span data-stu-id="246de-406">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="246de-407"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法會搜尋指定的副檔名的提供者組態項目。</span><span class="sxs-lookup"><span data-stu-id="246de-407">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> method searches the provider configuration elements for the specified file name extension.</span></span>  
  
 <span data-ttu-id="246de-408">檔案名稱副檔名不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="246de-408">File name extensions are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-409">下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作輸入的副檔名，並顯示已設定的語言提供者的設定。</span><span class="sxs-lookup"><span data-stu-id="246de-409">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input file name extension and displays the configured settings for the language provider.</span></span> <span data-ttu-id="246de-410">此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-410">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="246de-411">
            <paramref name="extension" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-411">The <paramref name="extension" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="246de-412">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-412">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="246de-413">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-413">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="246de-414">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-414">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">
          <span data-ttu-id="246de-415">編譯器和語言提供者設定結構描述</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-415">Compiler and Language Provider Settings Schema</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">
          <span data-ttu-id="246de-416">語言名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-416">The language name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-417">測試語言在電腦上是否已設定 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-417">Tests whether a language has a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation configured on the computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-418">如果指定語言已設定 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 實作，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-418">
              <see langword="true" /> if a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation is configured for the specified language; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-419">[ &lt;System.codedom&gt;項目](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中的機器組態檔 (Machine.config) 包含每個語言提供者和編譯器組態設定<xref:System.CodeDom.Compiler.CodeDomProvider>上的實作電腦。</span><span class="sxs-lookup"><span data-stu-id="246de-419">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="246de-420"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法會搜尋指定的語言名稱的提供者組態項目。</span><span class="sxs-lookup"><span data-stu-id="246de-420">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method searches the provider configuration elements for the specified language name.</span></span>  
  
 <span data-ttu-id="246de-421">語言名稱不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="246de-421">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="246de-422">下列程式碼範例會判斷<xref:System.CodeDom.Compiler.CodeDomProvider>實作的輸入的語言和顯示語言提供者所設定的設定。</span><span class="sxs-lookup"><span data-stu-id="246de-422">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="246de-423">此程式碼範例是針對提供之較大範例的一部分<xref:System.CodeDom.Compiler.CompilerInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="246de-423">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="246de-424">
            <paramref name="language" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-424">The <paramref name="language" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="246de-425">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-425">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="246de-426">針對完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-426">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="246de-427">這個成員無法供部分信任的程式碼使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-427">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">
          <span data-ttu-id="246de-428">編譯器和語言提供者設定結構描述</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-428">Compiler and Language Provider Settings Schema</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="246de-429">要驗證為有效識別項的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-429">The value to verify as a valid identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-430">傳回值，指出指定的值是否為目前語言的有效識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-430">Returns a value that indicates whether the specified value is a valid identifier for the current language.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-431">如果 <paramref name="value" /> 參數是有效的識別項，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-431">
              <see langword="true" /> if the <paramref name="value" /> parameter is a valid identifier; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-432">這個方法會測試識別項是否有效。</span><span class="sxs-lookup"><span data-stu-id="246de-432">This method tests whether an identifier is valid.</span></span> <span data-ttu-id="246de-433"><xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A>方法是特定的提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-433">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> method is provider specific.</span></span> <span data-ttu-id="246de-434">適用於一個提供者的識別項不可能適用於其他提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-434">Identifiers that are valid for one provider might not be valid for other providers.</span></span> <span data-ttu-id="246de-435">如果`value`包含字元的 ASCII 字元範圍中，檢查可能用來編譯程式碼的所有語言的識別碼。</span><span class="sxs-lookup"><span data-stu-id="246de-435">If `value` contains characters outside of the ASCII character range, check the identifier for all the languages that might be used to compile the code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-436">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-436">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-437">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-437">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-438">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-438">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-439">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-439">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-440">當覆寫<see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />在衍生類別中，設計方法，以傳回<see langword="true" />值符合語言的規則，而且不會使用的關鍵字衝突時，才可以。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-440">When overriding <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> in a derived class, design the method to return <see langword="true" /> only if the value fits the rules of the language and does not conflict with a keyword.</span>
            </span>
            <span data-ttu-id="246de-441">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-441">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-442">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-442">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-443">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-443">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-444">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-444">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="246de-445">取得語言功能識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-445">Gets a language features identifier.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="246de-446">
            <see cref="T:System.CodeDom.Compiler.LanguageOptions" />，表示語言的特殊功能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-446">A <see cref="T:System.CodeDom.Compiler.LanguageOptions" /> that indicates special features of the language.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="codeStream">
          <span data-ttu-id="246de-447">
            <see cref="T:System.IO.TextReader" /> 物件，用於讀取要剖析的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-447">A <see cref="T:System.IO.TextReader" /> object that is used to read the code to be parsed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-448">將指定文字資料流中所讀取的程式碼編譯成 <see cref="T:System.CodeDom.CodeCompileUnit" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-448">Compiles the code read from the specified text stream into a <see cref="T:System.CodeDom.CodeCompileUnit" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-449">
            <see cref="T:System.CodeDom.CodeCompileUnit" />，含有剖析程式碼的表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-449">A <see cref="T:System.CodeDom.CodeCompileUnit" /> that contains a representation of the parsed code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="246de-450">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeParser>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-450">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeParser> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> method of the provider.</span></span> <span data-ttu-id="246de-451">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-451">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-452">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeParser>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-452">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeParser> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-453">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-453">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-454">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-454">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-455">基底類別方法，建立使用過時的衍生類別中剖析器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />與預先存在的提供者，使用程式碼剖析器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-455">The base-class method creates a parser in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> method for compatibility with preexisting providers that use code parsers.</span>
            </span>
            <span data-ttu-id="246de-456">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeParser" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-456">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeParser" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-457">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼剖析器呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-457">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code parser.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">
          <span data-ttu-id="246de-458">
            <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> 物件，指示要驗證的程式碼產生支援型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-458">A <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> object that indicates the type of code generation support to verify.</span>
          </span>
        </param>
        <param name="supports">
          <span data-ttu-id="246de-459">
            <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> 物件，指示要驗證的程式碼產生支援型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-459">A <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> object that indicates the type of code generation support to verify.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="246de-460">傳回值，指出是否提供指定程式碼產生支援。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-460">Returns a value indicating whether the specified code generation support is provided.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="246de-461">如果提供指定程式碼產生支援，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-461">
              <see langword="true" /> if the specified code generation support is provided; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="246de-462">這個方法可以呼叫具有數目<xref:System.CodeDom.Compiler.GeneratorSupport>次要加入一組二進位檔與適當的功能旗標來測試一組功能旗標`OR`運算子 (&#124;)。</span><span class="sxs-lookup"><span data-stu-id="246de-462">This method can be called with a number of <xref:System.CodeDom.Compiler.GeneratorSupport> flags at once to test for a set of capabilities by joining a set of appropriate capability flags together with a binary `OR` operator (&#124;).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="246de-463">在.NET framework 1.0 和 1.1 版中，這個方法會提供<xref:System.CodeDom.Compiler.ICodeGenerator>所傳回的實作<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供者的方法。</span><span class="sxs-lookup"><span data-stu-id="246de-463">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="246de-464">在 2.0 版中，呼叫此方法會直接在程式碼提供者上即使它不會覆寫程式碼提供者。</span><span class="sxs-lookup"><span data-stu-id="246de-464">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="246de-465">如果程式碼提供者不會覆寫此方法中，<xref:System.CodeDom.Compiler.ICodeGenerator>實作稱為 「 基底類別。</span><span class="sxs-lookup"><span data-stu-id="246de-465">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="246de-466">此方法或 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法都沒有在衍生類別中覆寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="246de-466">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="246de-467">如果您覆寫這個方法，您必須呼叫基底類別的對應方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-467">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="246de-468">基底類別方法使用過時的衍生類別中建立產生器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />與預先存在的提供者，使用程式碼產生器的相容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-468">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="246de-469">然後呼叫的對等方法的基底類別方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />實作來執行這項功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-469">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="246de-470">您會收到<see cref="T:System.NotImplementedException" />如果您從程式碼提供者不使用程式碼產生器中呼叫基底類別方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="246de-470">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>