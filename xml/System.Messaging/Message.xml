<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="452b72d229254f13a5d2827bfeca0ec97c6f6675" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30461092" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供定義訊息佇列訊息所需屬性的存取。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.Message>類別查看，或從佇列接收訊息或傳送訊息至佇列時，讓訊息屬性的良好控制。  
  
 <xref:System.Messaging.MessageQueue> 使用<xref:System.Messaging.Message>類別查看，或從佇列接收訊息時，因為同時<xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType>和<xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType>方法建立的新執行個體<xref:System.Messaging.Message>類別，並設定執行個體的屬性。 <xref:System.Messaging.Message>類別的唯讀屬性會套用至從佇列擷取訊息，而讀取/寫入屬性套用至傳送和擷取訊息。 當<xref:System.Messaging.MessageQueue>查看或接收訊息佇列中，從其<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>屬性決定訊息的屬性擷取。  
  
 <xref:System.Messaging.MessageQueue>類別的<xref:System.Messaging.MessageQueue.Send%2A>方法可讓您指定任何物件型別，正在傳送至該佇列的訊息。 您可以使用<xref:System.Messaging.MessageQueue>執行個體的<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性可指定泛型訊息傳送至佇列的設定。 類型的設定包含格式子、 標籤、 加密及驗證。 您也可以指定適當的值<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>協調訊息的應用程式認可和報告訊息至回應的成員。 使用<xref:System.Messaging.Message>將訊息傳送至佇列的執行個體可讓您彈性地存取和修改其中許多屬性 — 針對單一訊息或訊息的訊息為基礎。 <xref:System.Messaging.Message> 屬性會優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>。  
  
 訊息資料儲存在<xref:System.Messaging.Message.Body%2A>屬性以及較小的範圍<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>屬性。 當加密、 序列化，或還原序列化的內容訊息資料<xref:System.Messaging.Message.Body%2A>屬性會受到影響。  
  
 內容<xref:System.Messaging.Message.Body%2A>傳送訊息，使用時，屬性會序列化<xref:System.Messaging.Message.Formatter%2A>您指定的屬性。 序列化的內容存在於<xref:System.Messaging.Message.BodyStream%2A>屬性。 您也可以設定<xref:System.Messaging.Message.BodyStream%2A>屬性直接管理，例如，若要將檔案傳送為訊息的資料內容。 您可以變更<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>隨時傳送訊息，並將資料序列化屬性適當地呼叫時<xref:System.Messaging.MessageQueue.Send%2A>。  
  
 所定義之屬性<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType>屬性僅適用於不是類型的訊息<xref:System.Messaging.Message>。 如果您指定<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性<xref:System.Messaging.MessageQueue>、 相同的已命名屬性中的<xref:System.Messaging.Message>傳送至該佇列的原因来忽略這些預設屬性的執行個體。  
  
 如需執行個體的初始屬性值的清單<xref:System.Messaging.Message>，請參閱<xref:System.Messaging.Message.%23ctor%2A>建構函式。  
  
   
  
## Examples  
 下列程式碼範例示範的格式化訊息本文會使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下列程式碼範例示範的格式化訊息本文會使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.Message" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化包含空主體之 <see cref="T:System.Messaging.Message" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的新執行個體使用此多載<xref:System.Messaging.Message>具有空白主體的類別。  
  
 指定<xref:System.Messaging.Message.Body%2A>屬性或<xref:System.Messaging.Message.BodyStream%2A>屬性，才能傳送<xref:System.Messaging.Message>物件。 <xref:System.Messaging.Message.Body%2A>屬性可以是任何可序列化，例如字串、 結構物件、 類別執行個體或內嵌的物件的物件。  
  
 除非您直接寫入訊息的內容<xref:System.Messaging.Message.BodyStream%2A>屬性，將<xref:System.Messaging.Message.Formatter%2A>之前傳送訊息的屬性。 使用序列化本文<xref:System.Messaging.Message.Formatter%2A>屬性的值時<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>執行個體。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.Message>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 下列程式碼範例會將兩個不同優先順序的訊息傳送至佇列，接著擷取它們。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">要序列化到訊息主體中的物件。</param>
        <summary>使用 <see cref="T:System.Messaging.Message" /> 將指定物件序列化到訊息主體中，以初始化 <see cref="T:System.Messaging.XmlMessageFormatter" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的新執行個體使用此多載<xref:System.Messaging.Message>類別，其中包含<xref:System.Messaging.Message.Body%2A>所指定`body`參數。 `body`參數可以是任何可序列化，例如字串、 結構物件、 類別執行個體或內嵌的物件的物件。 使用序列化本文<xref:System.Messaging.XmlMessageFormatter>除非您變更<xref:System.Messaging.Message.Formatter%2A>屬性之後再<xref:System.Messaging.Message>傳送。 如果您變更<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>屬性在任何時間，然後再呼叫<xref:System.Messaging.MessageQueue.Send%2A>，訊息將根據新的屬性值來序列化。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.Message>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 參數。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 下列程式碼範例會建立新的佇列，傳送訊息，將包含訂單，然後再擷取它。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">要序列化到訊息主體中的物件。</param>
        <param name="formatter">
          <see cref="T:System.Messaging.IMessageFormatter" />，指定用於序列化訊息主體的格式子。</param>
        <summary>使用指定的格式子將指定物件序列化至訊息主體，初始化 <see cref="T:System.Messaging.Message" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的新執行個體使用此多載<xref:System.Messaging.Message>類別，其中包含<xref:System.Messaging.Message.Body%2A>所指定`body`參數，以及使用任何有效的格式器序列化內文。 `body`參數是可序列化，例如字串、 結構物件、 類別執行個體或內嵌的物件的任何物件。 如果您變更<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>屬性在任何時間，然後再呼叫<xref:System.Messaging.MessageQueue.Send%2A>，訊息將根據新的屬性值來序列化。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.Message>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 參數。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` 參數。|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要傳回至負責傳送之應用程式的認可訊息類型。</summary>
        <value>其中一個 <see cref="T:System.Messaging.AcknowledgeTypes" /> 值，表示系統在管理佇列中張貼的認可訊息類型，以及將認可傳回負責傳送之應用程式的條件。 預設值為 <see langword="None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A>屬性會指定傳送應用程式所要求的認可訊息的類型。 設定<xref:System.Messaging.Message.AcknowledgeType%2A>之前傳送的訊息，要求通知的特定項目屬性 — 比方說，訊息到達目的地佇列、 已擷取訊息或防止訊息到達，或從擷取逾時目的地佇列。  
  
 訊息佇列會通知傳回傳送通知訊息至<xref:System.Messaging.Message.AdministrationQueue%2A>原始訊息所指定的屬性。 認可訊息的<xref:System.Messaging.Message.Acknowledgment%2A>屬性會指出認可所代表的類型。 例如，如果已傳送通知訊息，因為郵件無法送達目的地之前<xref:System.Messaging.Message.TimeToReachQueue%2A>間隔到期，<xref:System.Messaging.Message.Acknowledgment%2A>的認可訊息的屬性會包含值`ReachQueueTimeout`。  
  
   
  
## Examples  
 下列程式碼範例會將傳送和接收訊息，其中包含與佇列的順序。 它特別要求正值通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息以忽略 <see cref="P:System.Messaging.Message.AcknowledgeType" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個訊息所表示的認可分類。</summary>
        <value>其中一個 <see cref="T:System.Messaging.Acknowledgment" /> 列舉值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您收到來自管理佇列的訊息時，讀取<xref:System.Messaging.Message.Acknowledgment%2A>屬性，確認原始訊息的狀態。  
  
 當訊息傳送至其目的地佇列時，訊息佇列可以要求張貼通知訊息。 比方說，這類訊息可能表示訊息已到達，且指定的逾時內已擷取還是有可能表示發生了什麼錯誤在傳遞失敗。 目的地佇列傳回通知訊息，並將它們公佈到原始訊息中指定的管理佇列<xref:System.Messaging.Message.AdministrationQueue%2A>屬性。 <xref:System.Messaging.Message.Id%2A>的認可訊息的屬性會識別的通知訊息，而不是在原始訊息。 您可以在通知中找到的原始訊息的識別項<xref:System.Messaging.Message>執行個體的<xref:System.Messaging.Message.CorrelationId%2A>屬性。  
  
 如果這個<xref:System.Messaging.Message>執行個體表示通知訊息，<xref:System.Messaging.Message.Acknowledgment%2A>屬性會指定類型的通知。 否則，<xref:System.Messaging.Message.Acknowledgment%2A>屬性包含值`Normal`。  
  
 使用<xref:System.Messaging.Message.AcknowledgeType%2A>指定情況下會傳回認可原始訊息的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定接收訊息佇列產生之認可訊息的佇列。</summary>
        <value>指定用於系統產生認可訊息之管理佇列的 <see cref="T:System.Messaging.MessageQueue" />。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中指定的佇列<xref:System.Messaging.Message.AdministrationQueue%2A>屬性可以是任何非交易式佇列。 傳送至管理佇列的認可訊息可以指示原始訊息是否已抵達其目的端佇列，以及是否已從佇列中移除。  
  
 當<xref:System.Messaging.Message.AcknowledgeType%2A>屬性有任何值以外`None`，傳送應用程式必須指定要做為管理佇列的佇列。  
  
   
  
## Examples  
 下列程式碼範例會將傳送和接收訊息，其中包含與佇列的順序。 它特別要求正值通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AdministrationQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定額外的應用程式特定資訊。</summary>
        <value>應用程式的特定資訊。 預設值是零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A>屬性包含應用程式特有的資訊，您可以用來組織不同類型的訊息。 例如，您可以使用應用程式特有的索引。 要解譯的應用程式負責<xref:System.Messaging.Message.AppSpecific%2A>屬性資訊。  
  
 可能的話，您應該在訊息本文包含訊息資料而非<xref:System.Messaging.Message.AppSpecific%2A>屬性。  
  
 當使用外部佇列，使用<xref:System.Messaging.Message.Extension%2A>屬性來指定訊息佇列中的訊息屬性不存在。 如同<xref:System.Messaging.Message.AppSpecific%2A>屬性，是要了解的內容的應用程式責任<xref:System.Messaging.Message.Extension%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AppSpecific" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息到達目的端佇列的時間。</summary>
        <value>
          <see cref="T:System.DateTime" />，表示訊息到達目的端佇列的時間。 時間會被從 GMT 調整為目的端佇列所在處的電腦上的本地時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息的<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性會指出速度必須從目的地佇列接收訊息。 <xref:System.Messaging.Message.TimeToBeReceived%2A>屬性計時器啟動時傳送訊息，不會在訊息送達佇列中。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.ArrivedTime%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.ArrivedTime" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否應該將傳送者識別碼附加至訊息。</summary>
        <value>
          如果 <see cref="P:System.Messaging.Message.SenderId" /> 應該附加在訊息上，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A>屬性是位元組陣列，代表傳送使用者的識別項。 寄件者識別碼由訊息佇列設定，並由接收佇列管理員用來驗證寄件者是否有佇列的存取權限。  
  
 如果沒有寄件者識別碼會指出傳送應用程式的訊息佇列應該不驗證訊息的寄件者，也驗證寄件者的存取權限到接收佇列。 <xref:System.Messaging.Message.SenderId%2A>是值得信任，只有當訊息已驗證到達目的地佇列。 如果佇列接受已驗證的訊息，然後到達目的地佇列時，會拒絕訊息<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>或<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>屬性是`false`。  
  
> [!CAUTION]
>  如果拒絕訊息時，很可能傳送至寄不出信件佇列 (如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`true`)，或忽略它。 當訊息無法抵達佇列時，您可以要求通知。 否則，當<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`訊息可能會遺失，而不發出警告。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.AttachSenderId%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AttachSenderId" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得指出訊息是否已驗證的值。</summary>
        <value>
          如果訊息進入佇列時需要驗證則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A>屬性僅供在應用程式在互動訊息正在嘗試判斷是否已要求驗證。 如果訊息在佇列中，已驗證訊息。 相反地，如果<xref:System.Messaging.Message.Authenticated%2A>屬性是`true`，它收到該訊息時，接收佇列管理員會驗證訊息。  
  
 您無法判斷是否訊息無法通過驗證它的內容。 訊息佇列會捨棄驗證失敗之前傳送至佇列的訊息。 不過，您可以要求會傳送通知訊息，如果傳遞失敗可防止訊息到達佇列。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.Authenticated%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Authenticated" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來產生訊息之數位簽章的密碼編譯提供者名稱。</summary>
        <value>用來產生訊息的數位簽章的密碼編譯提供者的名稱。 預設值為 Microsoft Base Cryptographic Provider 1.0 版。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您通常會使用<xref:System.Messaging.Message.AuthenticationProviderName%2A>使用外部佇列時。 訊息佇列要求的驗證提供者名稱和密碼編譯提供者 （驗證提供者），以驗證傳送至外部佇列的訊息和訊息傳遞至訊息的數位簽章驗證提供者類型從外部佇列的佇列。  
  
 傳送郵件時，一定會設定<xref:System.Messaging.Message.AuthenticationProviderName%2A>和<xref:System.Messaging.Message.ConnectorType%2A>屬性放在一起。 當傳送訊息時，訊息佇列會忽略驗證提供者名稱如果也沒有設定連接器類型。  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A>屬性不可以是`null`，但它可以是空字串 ("")。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">無法設定 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 屬性。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 被設定為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來產生訊息之數位簽章的密碼編譯提供者類型。</summary>
        <value>其中一個 <see cref="T:System.Messaging.CryptographicProviderType" /> 值。 預設值為 <see langword="RSA_FULL" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您通常會使用<xref:System.Messaging.Message.AuthenticationProviderType%2A>時使用外部的佇列，以指定的密碼編譯服務提供者是與訊息相關聯的屬性。 訊息佇列要求的驗證提供者名稱和密碼編譯提供者 （驗證提供者），以驗證傳送至外部佇列的訊息和訊息傳遞至訊息的數位簽章驗證提供者類型從外部佇列的佇列。  
  
 只有`RsaFull`用來搭配訊息。  
  
 傳送郵件時，一定會設定<xref:System.Messaging.Message.AuthenticationProviderType%2A>和<xref:System.Messaging.Message.ConnectorType%2A>屬性放在一起。 當傳送訊息時，訊息佇列會忽略驗證提供者類型如果也沒有設定連接器類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">無法設定 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 屬性。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息的內容。</summary>
        <value>指定訊息內容的物件。 物件可以是字串、日期、貨幣、數字、位元組陣列或任何 Managed 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息的<xref:System.Messaging.Message.Body%2A>屬性通常會包含與訊息相關聯的資料。 雖然您也可以傳送應用程式特定資料<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>屬性，您應該包含在訊息資料<xref:System.Messaging.Message.Body%2A>盡可能的訊息。 只有<xref:System.Messaging.Message.Body%2A>屬性內容已序列化或加密。  
  
 <xref:System.Messaging.Message.Body%2A>屬性可以包含任何物件，其大小不超過 4 MB。 如果您使用<xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType>的類型不是任何物件傳送至<xref:System.Messaging.Message>至<xref:System.Messaging.MessageQueue>，該物件會位於<xref:System.Messaging.Message.Body%2A>屬性<xref:System.Messaging.Message>所傳回的執行個體<xref:System.Messaging.MessageQueue.Peek%2A>或<xref:System.Messaging.MessageQueue.Receive%2A>。  
  
 中的字串引數`MessageQueue.Send("hello.")`是一般物件的範例。  
  
 <xref:System.Messaging.Message.BodyType%2A>屬性表示訊息本文中所儲存的資訊類型。 訊息佇列會使用這項資訊來識別的型別<xref:System.Messaging.Message.Body%2A>屬性內容。  
  
 指定<xref:System.Messaging.Message.Body%2A>屬性或<xref:System.Messaging.Message.BodyStream%2A>屬性，才能傳送<xref:System.Messaging.Message>物件。 <xref:System.Messaging.Message.Body%2A>屬性可以是任何可序列化的物件，例如文字字串、 物件結構、 類別執行個體或內嵌的物件。  
  
 除非您直接寫入訊息的內容<xref:System.Messaging.Message.BodyStream%2A>屬性，將<xref:System.Messaging.Message.Formatter%2A>之前傳送訊息的屬性。 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用包含在這個格式器序列化執行個體，本文<xref:System.Messaging.Message.Formatter%2A>屬性。 如果您未指定的值傳送訊息<xref:System.Messaging.Message.Formatter%2A>屬性，格式子預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
> [!NOTE]
>  嘗試設定的訊息本文<xref:System.Decimal.MaxValue>會導致<xref:System.OverflowException>時`Send`方法<xref:System.Messaging.MessageQueue>類別稱為和<xref:System.Messaging.ActiveXMessageFormatter>用。  
  
   
  
## Examples  
 下列程式碼範例會將兩個不同優先順序的訊息傳送至佇列，接著擷取它們。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.Message.Formatter" /> 屬性為 <see langword="null" />。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Body" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息主體中的資訊。</summary>
        <value>
          <see cref="T:System.IO.Stream" />，含有包含於訊息 <see cref="P:System.Messaging.Message.Body" /> 中的序列化資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息的主體可以包含的任何類型的資訊，例如字串、 日期、 貨幣、 數字、 位元組陣列或任何 managed 的物件。 這項資訊會序列化為<xref:System.IO.Stream>傳遞至佇列。  
  
 指定<xref:System.Messaging.Message.Body%2A>屬性或<xref:System.Messaging.Message.BodyStream%2A>屬性，才能傳送<xref:System.Messaging.Message>物件。 如果您設定<xref:System.Messaging.Message.Body%2A>屬性，內容序列化成<xref:System.Messaging.Message.BodyStream%2A>屬性。 不過，您可以選擇寫入<xref:System.Messaging.Message.BodyStream%2A>直接屬性。 例如，當您想要開啟的檔案連接，並做為您的訊息主體資料流內容，這十分有用。  
  
 除非您直接寫入訊息的內容<xref:System.Messaging.Message.BodyStream%2A>屬性，將<xref:System.Messaging.Message.Formatter%2A>之前傳送訊息的屬性。 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用包含在這個格式器序列化執行個體，本文<xref:System.Messaging.Message.Formatter%2A>屬性。 如果您未指定的值傳送訊息<xref:System.Messaging.Message.Formatter%2A>屬性，格式子預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
 如果您設定<xref:System.Messaging.Message.UseEncryption%2A>屬性`true`針對此訊息的本文，將會加密訊息傳送時，不會在您設定<xref:System.Messaging.Message.Body%2A>屬性。 因此，<xref:System.Messaging.Message.BodyStream%2A>屬性不會進行加密。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Body" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息本文包含的資料類型。</summary>
        <value>訊息主體的真正型別，例如字串、日期、貨幣或數字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列會辨識本文內容，做為物件或序列化資料流。 <xref:System.Messaging.Message.BodyType%2A>屬性會指出內的物件類型<xref:System.Messaging.Message.Body%2A>訊息屬性。  
  
 <xref:System.Messaging.XmlMessageFormatter>訊息本文中會執行原生類型與物件之間的繫結。 如果您使用<xref:System.Messaging.XmlMessageFormatter>，格式器集<xref:System.Messaging.Message.BodyType%2A>為您的屬性。  
  
 其他格式子可繫結功能也，如下列 C# 程式碼所示。  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.BodyType%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Body" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出通常由訊息佇列設定的一些訊息屬性已由負責傳送的應用程式設定。</summary>
        <value>應用程式定義的 <see cref="T:System.Guid" />，要與連接器應用程式或訊息加密配合使用。 這個 <see cref="T:System.Guid" /> 允許接收應用程式解譯通常由 Message Queuing 設定，但是卻由傳送應用程式設定的訊息屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列要求<xref:System.Messaging.Message.ConnectorType%2A>設定屬性，每當應用程式設定通常設定由訊息佇列的訊息屬性。 應用程式通常使用<xref:System.Messaging.Message.ConnectorType%2A>下列兩個案例中：  
  
-   每當連接器應用程式將訊息傳遞。 <xref:System.Messaging.Message.ConnectorType%2A>告知傳送和接收的應用程式如何解譯訊息的安全性與認可屬性。  
  
-   每當傳送應用程式，而不是訊息佇列時，會加密訊息。 <xref:System.Messaging.Message.ConnectorType%2A>告知訊息佇列 」 使用<xref:System.Messaging.Message.DestinationSymmetricKey%2A>來解密訊息的屬性值。  
  
 您必須設定<xref:System.Messaging.Message.ConnectorType%2A>屬性，如果您設定了任何下列的屬性 （否則佇列會忽略這些屬性將訊息傳送時）：  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.ConnectorType" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定認可、報告和回應訊息用來參考原始訊息的訊息識別項。</summary>
        <value>原始訊息的 <see cref="P:System.Messaging.Message.Id" /> 屬性指定的訊息識別項。 訊息佇列產生認可或報告訊息，以及應用程式產生回應訊息時，所使用的相互關聯識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當訊息佇列產生認可或報告訊息時，它會使用相互關聯識別項屬性，來指定原始訊息的訊息識別項。 因此，相互關係識別項會將報告或認可訊息連結到原始訊息。  
  
 傳送應用程式可以再比對通知或報表與原始訊息使用<xref:System.Messaging.Message.CorrelationId%2A>屬性來識別原始訊息的<xref:System.Messaging.Message.Id%2A>屬性。  
  
 連接器應用程式也必須設定<xref:System.Messaging.Message.CorrelationId%2A>認可和報告訊息至原始訊息的訊息識別項的屬性。  
  
 當您的應用程式會將回應訊息傳送至傳送應用程式時，您可以設定<xref:System.Messaging.Message.CorrelationId%2A>原始訊息的訊息識別項的回應訊息的屬性。 傳送應用程式則可以符合您的回應訊息已傳送的訊息。  
  
   
  
## Examples  
 下列程式碼範例會將傳送和接收包含訂單與佇列的訊息。 它特別要求正值通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.CorrelationId" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.CorrelationId" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息要使用的目的端佇列。</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" />，會為訊息指定要使用的目的端佇列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A>屬性最常用來判斷訊息已到達日誌或寄不出信件佇列中的原始目的端。 通常，您不需要檢查這個屬性，因為您通常會從其目的地佇列擷取訊息。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.DestinationQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.DestinationQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來為應用程式加密訊息或傳送至外部佇列的訊息加密的對稱金鑰。</summary>
        <value>位元組值陣列，指定用來加密訊息的目的端對稱金鑰。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 兩個案例都需要您使用<xref:System.Messaging.Message.DestinationSymmetricKey%2A>屬性。 首先，當您的應用程式，而不是訊息佇列，加密訊息。 第二個是加密的訊息傳送至以外訊息佇列的佇列系統時。  
  
 設定此屬性之前，您必須加密對稱金鑰與接收佇列管理員的公開金鑰。 當您傳送應用程式加密的訊息時，接收佇列管理員會使用對稱金鑰來解密訊息，再將它傳送到其目的地佇列。  
  
 如果您將訊息傳送至外部佇列時，使用適當的連接器應用程式，將加密的訊息轉送以附加的對稱金鑰至接收應用程式第一次接收訊息。 就接收的應用程式來解密訊息使用對稱金鑰的責任。  
  
 當您將<xref:System.Messaging.Message.DestinationSymmetricKey%2A>屬性，您也必須設定<xref:System.Messaging.Message.ConnectorType%2A>屬性。 當傳送訊息時，訊息佇列會忽略<xref:System.Messaging.Message.DestinationSymmetricKey%2A>屬性如果<xref:System.Messaging.Message.ConnectorType%2A>也未設定屬性。  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A>屬性具有最大陣列大小為 256。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息佇列用來驗證訊息的數位簽章。</summary>
        <value>位元組值陣列，指定用來驗證訊息的 Message Queuing 1.0 數位簽章。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 驗證所送出訊息佇列版本 1.0 的訊息時，訊息佇列會使用數位簽章。 在大部分情況下，訊息佇列會產生並設定<xref:System.Messaging.Message.DigitalSignature%2A>時傳送的應用程式要求驗證的屬性。 接收應用程式會使用這個屬性來擷取附加至訊息的數位簽章。  
  
 您只能使用<xref:System.Messaging.Message.DigitalSignature%2A>執行訊息佇列版本 2.0 時的屬性。 要求驗證時，傳送應用程式必須指定 Message Queuing 1.0 版簽章。 如果傳送應用程式傳送的訊息佇列版本 2.0 簽章，此屬性會包含四個位元組，每個包含零的緩衝區。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>屬性，搭配<xref:System.Messaging.Message.SenderCertificate%2A>屬性，也會使用連接器應用程式傳送訊息時。 在此案例中，連接器應用程式，而不是訊息佇列，會產生數位簽章，它會根據使用者傳送訊息的憑證。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>屬性具有最大陣列大小為 256。  
  
 當您將<xref:System.Messaging.Message.DigitalSignature%2A>屬性，您也必須設定<xref:System.Messaging.Message.ConnectorType%2A>屬性。 當傳送訊息時，訊息佇列會忽略<xref:System.Messaging.Message.DigitalSignature%2A>屬性如果<xref:System.Messaging.Message.ConnectorType%2A>也未設定屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.DigitalSignature" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DigitalSignature" /> 屬性為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來加密私用訊息主體的加密演算法。</summary>
        <value>其中一個 <see cref="T:System.Messaging.EncryptionAlgorithm" /> 列舉值。 預設值為 <see langword="RC2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果訊息是私用 （加密），它會加密再傳送並接收時加以解密。 <xref:System.Messaging.Message.EncryptionAlgorithm%2A>屬性會指定用來加密私用訊息之訊息主體的演算法。  
  
 佇列可以要求傳入訊息加密。 如果應用程式傳送未加密的 （非私用） 訊息到佇列僅接受之私用訊息，或是如果它傳送至佇列的私用訊息，只接受非私用訊息，佇列會拒絕訊息。 傳送應用程式可以要求在此情況下，傳回負值通知訊息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與訊息關聯的其他應用程式定義資訊。</summary>
        <value>位元組值陣列，提供與訊息相關聯的應用程式定義資訊。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A>屬性提供應用程式定義的資訊，例如大型二進位物件，與訊息相關聯。 它是解譯的內容接收的應用程式的責任<xref:System.Messaging.Message.Extension%2A>屬性。  
  
 如果可行，您應該包含在訊息資料<xref:System.Messaging.Message.Body%2A>訊息屬性而非<xref:System.Messaging.Message.Extension%2A>屬性。  
  
 當使用外部佇列，使用<xref:System.Messaging.Message.Extension%2A>屬性來指定訊息佇列中的訊息屬性不存在。  
  
 非 Microsoft Message Queuing 的佇列系統中存在的外部索引的佇列。 訊息佇列會與透過連接器應用程式的這類佇列通訊。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Extension" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.Extension" /> 屬性為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來將物件序列化成訊息主體，或者從訊息主體將物件還原序列化的格式子。</summary>
        <value>產生要對訊息主體寫入或讀取的資料流的 <see cref="T:System.Messaging.IMessageFormatter" />。 預設值為 <see cref="T:System.Messaging.XmlMessageFormatter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.Message.Formatter%2A>讀取和寫入訊息時的屬性。 當訊息傳送至佇列時，格式器序列化<xref:System.Messaging.Message.Body%2A>成可以傳送至訊息佇列的資料流的屬性。 格式器時從佇列讀取時，會將訊息資料還原序列化<xref:System.Messaging.Message.Body%2A>屬性。  
  
 除非您直接寫入訊息的內容<xref:System.Messaging.Message.BodyStream%2A>屬性，將<xref:System.Messaging.Message.Formatter%2A>之前傳送訊息的屬性。 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用包含在這個格式器序列化執行個體，本文<xref:System.Messaging.Message.Formatter%2A>屬性。 如果您未指定的值傳送訊息<xref:System.Messaging.Message.Formatter%2A>屬性，格式子預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
   
  
## Examples  
 下列程式碼範例示範的格式化訊息本文會使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下列程式碼範例示範的格式化訊息本文會使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.Formatter" /> 屬性為 <see langword="null" />。</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息佇列驗證訊息或為訊息建立數位簽章時使用的雜湊演算法。</summary>
        <value>其中一個 <see cref="T:System.Messaging.HashAlgorithm" /> 列舉值。 對 Windows XP 來說，預設值為 <see langword="SHA" />。 否則，預設值為 <see langword="MD5" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 來源電腦上，訊息佇列會使用雜湊演算法建立一則訊息的數位簽章時。 目標佇列管理員再使用相同的雜湊演算法，來驗證訊息接收時。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.HashAlgorithm" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息的識別項。</summary>
        <value>訊息的唯一識別項，由訊息佇列產生。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列在傳送訊息時，會產生訊息識別項。 識別項是 20 個位元組所組成，並且包含兩個項目： 電腦<xref:System.Guid>傳送端電腦的電腦上訊息的唯一識別碼。 這兩個項目合併起來產生網路上唯一的訊息識別項。  
  
 訊息佇列會產生所有訊息的訊息識別項，包括認可和報告訊息。 由訊息佇列的抵達或失敗的原始、 已傳送的訊息通常傳送通知訊息。 您可以找到<xref:System.Messaging.Message.Id%2A>原始訊息中的屬性值<xref:System.Messaging.Message.CorrelationId%2A>的認可訊息的屬性。  
  
 您也可以使用<xref:System.Messaging.Message.Id%2A>屬性時的回應訊息傳送至回應佇列。 若要在回應訊息中包含原始訊息的識別項，設定<xref:System.Messaging.Message.CorrelationId%2A>屬性的回應訊息給<xref:System.Messaging.Message.Id%2A>原始訊息的屬性。 讀取回應訊息的應用程式然後可以使用回應訊息的相互關聯識別碼來識別原始訊息。  
  
   
  
## Examples  
 下列程式碼範例會將傳送和接收訊息，其中包含與佇列的順序。 它特別要求正值通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Id" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定沒有逾時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> 和<xref:System.Messaging.Message.TimeToReachQueue%2A>需要值，指定的逾時。先前的逾時是從佇列接收訊息所允許的最長時間。 對於後者，逾時是訊息到達佇列所允許的時間。 在這兩種情況下，您可以指定逾時秒數，或使用<xref:System.Messaging.Message.InfiniteTimeout>表示沒有逾時。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Messaging.Message.InfiniteTimeout>欄位。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出訊息是否為交易中最先傳送的訊息。</summary>
        <value>
          如果訊息是異動中最先傳送的訊息為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收應用程式使用<xref:System.Messaging.Message.IsFirstInTransaction%2A>屬性，確認訊息已傳送到單一佇列在單一交易中的第一個訊息。  
  
 這個屬性是只能搭配訊息佇列版本 2.0 和更新版本。  
  
 若要確認交易界限，您可以使用<xref:System.Messaging.Message.IsFirstInTransaction%2A>屬性一起使用，其他兩個屬性：<xref:System.Messaging.Message.IsLastInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。 使用先前檢查訊息是否已在交易中，傳送的最後一個訊息並使用後者來擷取交易的識別碼。  
  
 如果只在交易中，傳送一個訊息<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性都設定為`true`。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.IsFirstInTransaction%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出訊息是否為交易中最後傳送的訊息。</summary>
        <value>
          如果訊息是單一交易中最後傳送的訊息為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收應用程式使用<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性，確認訊息已傳送到單一佇列在單一交易中的最後一個訊息。  
  
 這個屬性是只能搭配訊息佇列版本 2.0 和更新版本。  
  
 若要確認交易界限，您可以使用<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性一起使用，其他兩個屬性：<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。 使用先前檢查訊息是否已在交易中，傳送的第一個訊息並使用後者來擷取交易的識別碼。  
  
 如果只在交易中，傳送一個訊息<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性都設定為`true`。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.IsLastInTransaction" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式定義的 Unicode 字串，這個字串會描述訊息。</summary>
        <value>訊息的標記。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息標籤可以用於多種用途。 例如，您可以將它用於顯示，或者根據標籤值對訊息進行選擇性的處理。 標籤並不需要是唯一的訊息。  
  
 訊息佇列和訊息標籤表示應用程式定義的值，這個值會以人們可讀取 (Human-Readable) 的詞彙協助識別佇列或訊息。 它負責解譯標籤內容，其不具有實質意義至訊息佇列應用程式的應用程式。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.Label%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Label" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 MSMQ 3.0 中介紹。 取得訊息的查詢識別項。</summary>
        <value>訊息的查詢識別項，由訊息佇列產生，且對於訊息所在佇列是唯一的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A>屬性提供唯讀存取訊息的查閱識別項。 在 MSMQ 3.0 中引進的查閱識別項是 64 位元識別碼是由訊息佇列產生並指派給每個訊息時訊息放置在佇列中。 查閱識別項不會傳送訊息時產生的訊息識別項相同。  
  
 訊息佇列會產生為所有的連接器，以及傳出佇列會放在任何佇列，包括應用程式產生的目的、 管理和報告佇列，以及由系統產生筆記本中，寄不出的信件訊息的查閱識別項。 換句話說，這包括這兩個傳送由傳送應用程式和訊息佇列的訊息。 查閱識別項是唯一至佇列，並在佇列外不具意義。  
  
 如果將訊息傳送至數個目的地佇列，或是如果訊息的複本儲存在電腦日誌或佇列日誌中，每個訊息的複本將有它自己的查詢識別時它會放在其各自的佇列。  
  
 <xref:System.Messaging.Message.LookupId%2A>屬性只能讀取從佇列擷取的訊息。  
  
 查閱識別項用來讀取佇列中的特定訊息。 一旦知道訊息的查閱識別項，接收應用程式可以呼叫<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>或<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>直接移至該訊息並查看，或從佇列中，不同於資料指標必須從佇列前端開始擷取它的函式和結束時的佇列中，瀏覽  
  
 取得佇列中訊息的查閱識別項是應用程式的責任。 取得查詢的識別項的一種可能的方式是建立快取的每個訊息的識別項，因為它們被放在佇列中的元件會叫用的目的地佇列的觸發程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.LookupId" /> 屬性。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息類型：<see langword="Normal" />、<see langword="Acknowledgment" /> 或 <see langword="Report" />。</summary>
        <value>其中一個 <see cref="P:System.Messaging.Message.MessageType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列傳送訊息時，通常設定這個屬性。 訊息佇列的訊息可以是下列其中一個類型：  
  
-   `Normal`這一般訊息從傳送至佇列，應用程式或回應訊息傳回給傳送應用程式。  
  
-   `Acknowledgement`會在訊息佇列產生每當傳送應用程式要求。 例如，訊息佇列可以產生正或負訊息，以表示原始訊息已抵達或已被讀取。 訊息佇列會將適當的認可訊息傳回給傳送應用程式所指定的管理佇列。  
  
-   `Report`會在訊息佇列產生每當報告佇列在來源佇列管理員定義。 追蹤功能啟用時，只要原始訊息進入或離開訊息佇列伺服器，訊息佇列就會傳送報告訊息至訊息佇列報告佇列。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.MessageType%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.MessageType" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息的優先權，用來決定訊息放置在佇列中的位置。</summary>
        <value>其中一個 <see cref="T:System.Messaging.MessagePriority" /> 值，表示非交易訊息的優先層級。 預設值為 <see langword="Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A>屬性會影響訊息佇列處理的方式在訊息路由時，以及當它到達其目的地。 較高優先權的訊息在路由期間會給予喜好設定，並且插入目的端佇列的前端。 優先權相同的訊息會根據抵達時間放置在佇列中。  
  
 您可以設定只針對非交易式訊息的有意義的優先權。 訊息佇列會自動設定交易式訊息的優先權`Lowest`，因而導致交易式訊息的優先權會被忽略。  
  
   
  
## Examples  
 下列程式碼範例會將兩個不同優先順序的訊息傳送至佇列，接著擷取它們。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Priority" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出當發生電腦故障或網路問題時是否保證傳遞訊息。</summary>
        <value>
          如果保證傳送訊息 (路由途中將訊息儲存在磁碟上) 則為 <see langword="true" />，如果不保證傳送則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A>屬性會指出是否保證訊息傳遞，即使目的地佇列來路由訊息時電腦當機。  
  
 如果訊息的傳遞保證，訊息儲存在本機的路由中的每一個步驟，直到訊息成功轉送至下一部電腦。 設定<xref:System.Messaging.Message.Recoverable%2A>屬性`true`可能會影響輸送量。  
  
 如果交易式訊息，訊息佇列會自動將訊息視為可復原，不論值<xref:System.Messaging.Message.Recoverable%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.Recoverable%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Recoverable" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定接收應用程式產生的回應訊息的佇列。</summary>
        <value>傳回應用程式產生的回應訊息的 <see cref="T:System.Messaging.MessageQueue" />。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A>屬性會識別接收應用程式產生的回應訊息，以便接收應用程式傳回給傳送應用程式的佇列。 傳送應用程式會在應用程式傳送其訊息時指定回應佇列。 任何可用的佇列都可以指定為回應佇列。  
  
 傳回至回應佇列的訊息是應用程式指定的。 應用程式必須定義訊息的內容以及接收訊息時要採取的動作。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.ResponseQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.ResponseQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息的安全性內容。</summary>
        <value>如果先前已設定屬性，則為包含訊息之安全性內容的 <see cref="T:System.Messaging.SecurityContext" /> 物件，否則為 NULL。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來驗證訊息的安全憑證。</summary>
        <value>位元組值陣列，表示安全憑證，訊息佇列會使用這個憑證驗證訊息的傳送者。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收應用程式會使用<xref:System.Messaging.Message.SenderCertificate%2A>屬性時包含外部安全性憑證的訊息。  
  
 訊息佇列可以驗證訊息的內部或外部的安全性憑證。 訊息佇列會提供用來驗證訊息完整性的內部憑證。 憑證授權單位提供的外部憑證，您可以透過存取<xref:System.Messaging.Message.SenderCertificate%2A>訊息屬性。 除了讓訊息佇列來驗證訊息、 外部憑證可讓接收應用程式進一步驗證寄件者。 發生內部憑證已經沒有可用的值，可接收的應用程式。  
  
 必須以目錄服務的訊息佇列系統註冊的外部憑證。 外部憑證包含憑證授權單位、 憑證使用者、 憑證的有效期、 公開金鑰憑證的使用者和憑證授權單位的簽章的相關資訊。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SenderCertificate" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得傳送使用者的識別項。</summary>
        <value>識別傳送者的位元組值陣列。 接收佇列管理員會在驗證訊息時使用識別項，以驗證訊息傳送者和傳送者對佇列的存取權限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Messaging.Message.AttachSenderId%2A>屬性是`false`，在指定的寄件者識別元<xref:System.Messaging.Message.SenderId%2A>傳送時，訊息不附加屬性。 這表示訊息佇列將訊息傳送到目的地佇列時，不應該驗證寄件者。 如果<xref:System.Messaging.Message.AttachSenderId%2A>屬性是`true`、<xref:System.Messaging.Message.SenderId%2A>屬性值是值得信任，只有當訊息已驗證。 使用<xref:System.Messaging.Message.Authenticated%2A>屬性搭配<xref:System.Messaging.Message.SenderId%2A>屬性來驗證寄件者的存取權。  
  
 連接器應用程式是使用連接器伺服器以提供訊息佇列和其他佇列的系統之間的通訊的應用程式。 訊息佇列會要求連接器應用程式提供寄件者識別。 您必須設定<xref:System.Messaging.Message.ConnectorType%2A>當連接器應用程式透過傳送訊息的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SenderId" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來傳送訊息的訊息佇列版本。</summary>
        <value>被用來傳送訊息的訊息佇列的版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A>屬性是非常重要，對於某些特定功能。 例如，只要 Message Queuing 2.0 和更新版本，支援交易處理和數位簽章可用來驗證 MSMQ 1.0 所傳送的訊息。  
  
 傳送佇列管理員設定<xref:System.Messaging.Message.SenderVersion%2A>傳送訊息時的屬性。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.SenderVersion%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SenderVersion" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得來源佇列管理員傳送訊息時傳送電腦上的日期和時間。</summary>
        <value>
          <see cref="T:System.DateTime" />，表示訊息傳送的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A>屬性會為此電腦的本機時間調整的執行個體<xref:System.Messaging.Message>建立類別。 這個時區可以不同於來源和目的地佇列。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.SentTime%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SentTime" /> 屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得發出訊息的電腦。</summary>
        <value>傳送訊息之來源電腦的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 格式<xref:System.Messaging.Message.SourceMachine%2A>屬性不包含上述兩個正斜線 (\\\\)。 例如，`myServer`有效<xref:System.Messaging.Message.SourceMachine%2A>。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.SourceMachine%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SourceMachine" /> 屬性。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">無法存取電腦資訊或目錄服務。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要從目的端佇列擷取訊息的最長時間。</summary>
        <value>從目的地佇列接收已傳送訊息所使用的總時間。 預設值為 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A>屬性會指定傳送訊息從目的地佇列等候接收的總時間。 時間限制包括花在到達目的地佇列以及之前接收到訊息佇列中等待的時間花費的時間。  
  
> [!CAUTION]
>  當使用依存性用戶端電腦，請確定用戶端電腦上的時鐘與執行訊息佇列伺服器的時鐘同步處理。 否則，無法預期的行為可能會造成傳送訊息時其<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性不是<xref:System.Messaging.Message.InfiniteTimeout>。  
  
 如果指定的間隔<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性到期之前從佇列移除訊息，訊息佇列捨棄的訊息中有兩種。 如果訊息的 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 屬性是 `true`，訊息就會傳送到寄不出的信件佇列。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，會忽略該訊息。  
  
 您可以設定訊息的<xref:System.Messaging.Message.AcknowledgeType%2A>屬性來要求的訊息佇列傳送負認可訊息傳回傳送應用程式計時器終止之前，不會擷取訊息。  
  
 如果所指定的值<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性是所指定的值小於<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性，<xref:System.Messaging.Message.TimeToBeReceived%2A>優先。  
  
 當在單一交易中傳送數個訊息時，訊息佇列會使用<xref:System.Messaging.Message.TimeToBeReceived%2A>的第一個訊息的屬性。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">為 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 指定的值無效。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息抵達佇列的最大時間量。</summary>
        <value>從傳送訊息開始至訊息到達目的地佇列的時間限制。 預設值為 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的間隔<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性過期的訊息抵達其目的地之前，訊息佇列會捨棄中有兩種訊息。 如果訊息的 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 屬性是 `true`，訊息就會傳送到寄不出的信件佇列。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，會忽略該訊息  
  
 您可以設定他訊息<xref:System.Messaging.Message.AcknowledgeType%2A>屬性來要求的訊息佇列傳送負認可訊息傳回傳送應用程式在計時器逾時前未到達的訊息。  
  
 如果<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性設定為 0 秒時，訊息佇列一次嘗試將訊息傳送至其目的地 — 如果佇列等待訊息。 如果本機佇列，訊息永遠會到達。  
  
 如果所指定的值<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性所指定的值大於<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性，<xref:System.Messaging.Message.TimeToBeReceived%2A>優先。  
  
 當在單一交易中傳送數個訊息時，訊息佇列會使用<xref:System.Messaging.Message.TimeToReachQueue%2A>的第一個訊息的屬性。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">為 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 指定的值無效。 可能表示負數。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息所屬交易的識別項。</summary>
        <value>與訊息相關聯之交易的識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收應用程式使用<xref:System.Messaging.Message.TransactionId%2A>屬性，確認已為特定交易的一部分傳送一則訊息。 交易識別項包含傳送端電腦 （第一個 16 位元），後面接著一個 4 位元組交易序號識別的項。  
  
 這個屬性是僅供訊息佇列版本 2.0 和更新版本。  
  
 交易識別項不保證是唯一的因為交易序號不持續性，而且它們重新啟動一段 2 <sup>20</sup>。 訊息佇列僅保證，後續的交易都會都有不同的交易序號。  
  
 您可以使用<xref:System.Messaging.Message.TransactionId%2A>屬性連同<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性，以驗證交易界限。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.TransactionId%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.TransactionId" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得來源電腦上的異動狀態佇列。</summary>
        <value>來源電腦上的異動狀態佇列，用來傳回認可訊息至傳送的應用程式。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A>屬性識別讀取回條認可接收連接器應用程式的來源電腦上的交易式佇列。 訊息佇列設定屬性，並擷取交易式訊息傳送至外部佇列時，連接器應用程式會使用屬性。  
  
 非 Microsoft Message Queuing 的佇列系統中存在的外部索引的佇列。 訊息佇列會與透過連接器應用程式的這類佇列通訊。  
  
 連接器應用程式可以傳送認可訊息傳回給傳送應用程式使用的交易狀態佇列。 即使傳送應用程式不會要求其他認可的交易狀態應該會收到這些通知。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.TransactionStatusQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
 -或-  
  
 篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出訊息在傳送之前是否已經 (或必須) 驗證。</summary>
        <value>
          如果傳送的應用程式要求訊息的驗證則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A>屬性會指定是否需要驗證訊息。 如果傳送應用程式要求驗證，訊息佇列的數位簽章，並使用它來簽署訊息在傳送和接收時，驗證訊息。  
  
 如果<xref:System.Messaging.Message.UseAuthentication%2A>是`false`和訊息已傳送至只接受已驗證的訊息佇列、 到達佇列時，將會拒絕訊息。  
  
 您無法判斷是否訊息無法通過驗證它的內容。 傳送至佇列之前，訊息佇列就會捨棄這類訊息。 不過，您可以要求會傳送通知訊息，如果傳遞失敗可防止訊息到達佇列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseAuthentication" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否應該將無法傳遞的訊息複本傳送至無法投遞的信件佇列。</summary>
        <value>
          如果訊息傳遞錯誤會導致將訊息複本傳送至無法投遞的信件佇列，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>和<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性會指定如何追蹤訊息佇列訊息。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`true`，傳遞失敗 （非交易式訊息），導致傳送至非交易式寄不出信件佇列無法傳送訊息的電腦上的訊息。 傳遞失敗可能被因郵件計時器過期，例如。  
  
 在交易式訊息的傳遞失敗，訊息佇列傳送訊息至交易式寄不出信件佇列中所有負數且不確定的情況下在來源電腦上。  
  
 當您將訊息儲存在寄不出信件佇列時，則應清除定期以移除不再需要的訊息佇列。 計算儲存在寄不出信件佇列對佇列所在的電腦的大小配額的訊息。 電腦配額由系統管理員所設定，並指的是配置來儲存訊息的整個電腦上，不只是在單一佇列的大小。  
  
 您不會建立日誌或寄不出的信件佇列。 這些是訊息佇列會產生這兩個系統佇列。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否將訊息設成私用。</summary>
        <value>
          如果要求訊息佇列為訊息加密則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果訊息是私人的其主體已加密，然後再傳送和接收時解密。 若要傳送的私用訊息，傳送應用程式必須指定用於加密和 （選擇性） 的加密演算法。  
  
 傳送私用的訊息時，您的應用程式不必執行訊息加密。 訊息佇列可以為您加密訊息本文，如果您的應用程式傳送 Microsoft Windows 2000 的企業、 可存取目錄服務中的訊息。 接收私用的訊息時，接收佇列管理員一律會解密訊息內文。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.UseEncryption%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseEncryption" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出訊息複本是否應保留在原始電腦上的電腦日誌中。</summary>
        <value>
          如果要求在訊息成功地傳輸 (從原始電腦至下一個伺服器) 後，在原始電腦的電腦日誌中保留訊息的複本則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>和<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性會指定如何追蹤訊息佇列訊息。 如果<xref:System.Messaging.Message.UseJournalQueue%2A>是`true`，然後複本就會保留在訊息已傳送的每個步驟的起始電腦上電腦日誌中。  
  
 如果目的地佇列是在遠端電腦上傳送的訊息只會複製到日誌佇列。 如果目的地是本機電腦上，訊息會直接傳送至佇列。沒有任何需要日誌的中間步驟。  
  
 當您將訊息儲存在日誌佇列中時，清除佇列，定期以移除不再需要的訊息。 計算儲存在日誌佇列的佇列所在的電腦配額的訊息。 （由系統管理員會設定電腦配額）。  
  
 您不會建立日誌或寄不出的信件佇列。 這些是訊息佇列會產生這兩個系統佇列。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.UseJournalQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseJournalQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出當訊息向其目的佇列移動時是否要追蹤訊息。</summary>
        <value>
          如果原始訊息路由至目的佇列的每個中間步驟都會產生要傳送至系統報告佇列的報告，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A>屬性會指定是否要向其目的地佇列為時加以追蹤訊息的路由。 如果`true`，的每當訊息通過訊息佇列路由伺服器傳送 （由訊息佇列產生） 報告訊息至報告佇列。 來源佇列管理員所指定的報告佇列。 報告佇列都不限於報告訊息產生的訊息佇列。您應用程式所產生的訊息也可以傳送至報告佇列。  
  
 使用追蹤牽涉到設定 Active Directory，並指定訊息佇列企業報告佇列。 系統管理員設定這些設定。  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息的值<xref:System.Messaging.Message.UseTracing%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseTracing" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>