<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ad7acb0d32b9a05dce69496cdb0e4f4aada33827" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233402" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供定義訊息佇列訊息所需屬性的存取。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.Message>類別查看，或從佇列接收訊息或傳送訊息至佇列時，讓訊息屬性的良好控制。  
  
 <xref:System.Messaging.MessageQueue> 會使用<xref:System.Messaging.Message>類別窺視或接收來自佇列訊息時，因為同時<xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType>並<xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType>方法建立的新執行個體<xref:System.Messaging.Message>類別，並設定執行個體的屬性。 <xref:System.Messaging.Message>類別的唯讀屬性會套用至從佇列擷取訊息，而讀取/寫入屬性套用至傳送和擷取訊息。 當<xref:System.Messaging.MessageQueue>窺視或接收來自佇列的訊息其<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>屬性會決定哪些訊息的屬性擷取。  
  
 <xref:System.Messaging.MessageQueue>類別的<xref:System.Messaging.MessageQueue.Send%2A>方法可讓您指定任何物件的類型傳送至該佇列的訊息。 您可以使用<xref:System.Messaging.MessageQueue>執行個體的<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性可指定泛型訊息傳送至佇列的設定。 類型的設定包含格式器、 標籤、 加密及驗證。 您也可以指定適當的值<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員時協調回應通知和報表的訊息應用程式訊息。 使用<xref:System.Messaging.Message>將訊息傳送至佇列的執行個體可讓您彈性地存取和修改其中許多屬性-單一訊息或訊息的訊息為基礎。 <xref:System.Messaging.Message> 屬性會優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>。  
  
 訊息資料儲存在<xref:System.Messaging.Message.Body%2A>屬性以及較小的範圍<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>屬性。 加密、 序列化或還原序列化的內容訊息資料時<xref:System.Messaging.Message.Body%2A>屬性會受到影響。  
  
 內容<xref:System.Messaging.Message.Body%2A>屬性會序列化在傳送訊息時，使用<xref:System.Messaging.Message.Formatter%2A>您指定的屬性。 序列化的內容位於<xref:System.Messaging.Message.BodyStream%2A>屬性。 您也可以設定<xref:System.Messaging.Message.BodyStream%2A>屬性直接，例如，若要傳送檔案，做為資料內容的訊息。 您可以變更<xref:System.Messaging.Message.Body%2A>或是<xref:System.Messaging.Message.Formatter%2A>當您呼叫隨時傳送訊息，並將資料之前的屬性也會適當地序列化<xref:System.Messaging.MessageQueue.Send%2A>。  
  
 所定義的屬性<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType>屬性只適用於不是類型的訊息<xref:System.Messaging.Message>。 如果您指定<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性<xref:System.Messaging.MessageQueue>，則相同的已命名屬性中的<xref:System.Messaging.Message>傳送至該佇列的原因来忽略這些預設屬性的執行個體。  
  
 如需執行個體的初始屬性值的清單<xref:System.Messaging.Message>，請參閱<xref:System.Messaging.Message.%23ctor%2A>建構函式。  
  
   
  
## Examples  
 下列程式碼範例示範設定格式化的訊息內文使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下列程式碼範例示範設定格式化的訊息內文使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.Message" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化包含空主體之 <see cref="T:System.Messaging.Message" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的新執行個體使用此多載<xref:System.Messaging.Message>具有空白主體的類別。  
  
 指定<xref:System.Messaging.Message.Body%2A>屬性或<xref:System.Messaging.Message.BodyStream%2A>屬性，才能傳送<xref:System.Messaging.Message>物件。 <xref:System.Messaging.Message.Body%2A>屬性可以是任何可序列化，例如文字字串、 結構物件、 類別執行個體或內嵌的物件的物件。  
  
 除非您撰寫的訊息內容直接<xref:System.Messaging.Message.BodyStream%2A>屬性，設定<xref:System.Messaging.Message.Formatter%2A>再傳送訊息的屬性。 使用序列化內文<xref:System.Messaging.Message.Formatter%2A>屬性的值，當時<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>執行個體。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合的因此不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化成二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.Message>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 下列程式碼範例會將兩個不同優先權的訊息傳送至佇列，接著擷取它們。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">要序列化到訊息主體中的物件。</param>
        <summary>使用 <see cref="T:System.Messaging.Message" /> 將指定物件序列化到訊息主體中，以初始化 <see cref="T:System.Messaging.XmlMessageFormatter" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的新執行個體使用此多載<xref:System.Messaging.Message>類別，其中包含<xref:System.Messaging.Message.Body%2A>所指定`body`參數。 `body`參數可以是任何可序列化，例如文字字串、 結構物件、 類別執行個體或內嵌的物件的物件。 使用序列化內文<xref:System.Messaging.XmlMessageFormatter>除非您變更<xref:System.Messaging.Message.Formatter%2A>屬性，才能<xref:System.Messaging.Message>傳送。 如果您變更<xref:System.Messaging.Message.Body%2A>或是<xref:System.Messaging.Message.Formatter%2A>屬性，在任何時間，然後再呼叫<xref:System.Messaging.MessageQueue.Send%2A>，訊息會根據新的屬性值序列化。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合的因此不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化成二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.Message>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 參數。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 下列程式碼範例會建立新的佇列，傳送包含訂單，然後再擷取它的訊息。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">要序列化到訊息主體中的物件。</param>
        <param name="formatter"><see cref="T:System.Messaging.IMessageFormatter" />，指定用於序列化訊息主體的格式子。</param>
        <summary>使用指定的格式子將指定物件序列化至訊息主體，初始化 <see cref="T:System.Messaging.Message" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的新執行個體使用此多載<xref:System.Messaging.Message>類別，其中包含<xref:System.Messaging.Message.Body%2A>所指定`body`參數，以及使用任何有效的格式器序列化內文。 `body`參數是任何可序列化，例如文字字串、 結構物件、 類別執行個體或內嵌的物件的物件。 如果您變更<xref:System.Messaging.Message.Body%2A>或是<xref:System.Messaging.Message.Formatter%2A>屬性，在任何時間，然後再呼叫<xref:System.Messaging.MessageQueue.Send%2A>，訊息會根據新的屬性值序列化。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合的因此不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化成二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.Message>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 參數。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` 參數。|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要傳回至負責傳送之應用程式的認可訊息類型。</summary>
        <value>其中一個 <see cref="T:System.Messaging.AcknowledgeTypes" /> 值，表示系統在管理佇列中張貼的認可訊息類型，以及將認可傳回負責傳送之應用程式的條件。 預設為 <see langword="None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A>屬性會指定傳送應用程式所要求的通知訊息的類型。 設定<xref:System.Messaging.Message.AcknowledgeType%2A>傳送的訊息，例如要求的特定項目-通知、 到達其目的地佇列的訊息，已擷取訊息或防止訊息到達，或從擷取的逾時之前的屬性目的地佇列。  
  
 訊息佇列將通知傳回傳送通知訊息至<xref:System.Messaging.Message.AdministrationQueue%2A>原始訊息所指定的屬性。 通知訊息的<xref:System.Messaging.Message.Acknowledgment%2A>屬性會指出通知它所代表的型別。 例如，如果已傳送通知訊息，因為郵件無法送達目的地之前<xref:System.Messaging.Message.TimeToReachQueue%2A>間隔到期時，<xref:System.Messaging.Message.Acknowledgment%2A>的通知訊息的屬性會包含值`ReachQueueTimeout`。  
  
   
  
## Examples  
 下列程式碼範例會傳送，並收到包含訂單與佇列的訊息。 它特別要求正面確認通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息以忽略 <see cref="P:System.Messaging.Message.AcknowledgeType" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個訊息所表示的認可分類。</summary>
        <value>其中一個 <see cref="T:System.Messaging.Acknowledgment" /> 列舉值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您收到來自管理佇列的訊息時，閱讀<xref:System.Messaging.Message.Acknowledgment%2A>屬性，確認原始訊息的狀態。  
  
 當訊息傳送至其目的地佇列時，訊息佇列可以要求張貼通知訊息。 比方說，這類訊息可能表示訊息到達，並且擷取在指定的逾時，還是有可能表示問題出在哪裡發生傳遞失敗。 目的地佇列傳回通知訊息，並將它們公佈到原始訊息中指定的管理佇列<xref:System.Messaging.Message.AdministrationQueue%2A>屬性。 <xref:System.Messaging.Message.Id%2A>的通知訊息的屬性會識別的通知訊息，而不是在原始的訊息。 您可以在通知中找到的原始訊息識別碼<xref:System.Messaging.Message>執行個體的<xref:System.Messaging.Message.CorrelationId%2A>屬性。  
  
 如果這個<xref:System.Messaging.Message>執行個體表示通知訊息，<xref:System.Messaging.Message.Acknowledgment%2A>屬性會指定類型的通知。 否則，請<xref:System.Messaging.Message.Acknowledgment%2A>屬性包含值`Normal`。  
  
 使用<xref:System.Messaging.Message.AcknowledgeType%2A>屬性的原始訊息至指定的情況下會傳回通知。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定接收訊息佇列產生之認可訊息的佇列。</summary>
        <value>指定用於系統產生認可訊息之管理佇列的 <see cref="T:System.Messaging.MessageQueue" />。 預設為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中指定的佇列<xref:System.Messaging.Message.AdministrationQueue%2A>屬性可以是任何非交易式佇列。 傳送至管理佇列的認可訊息可以指示原始訊息是否已抵達其目的端佇列，以及是否已從佇列中移除。  
  
 當<xref:System.Messaging.Message.AcknowledgeType%2A>屬性中有任何值以外的其他`None`，傳送應用程式必須指定要做為管理佇列的佇列。  
  
   
  
## Examples  
 下列程式碼範例會傳送，並收到包含訂單與佇列的訊息。 它特別要求正面確認通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AdministrationQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定額外的應用程式特定資訊。</summary>
        <value>應用程式的特定資訊。 預設值是零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A>屬性包含應用程式特有的資訊可供您組織不同類型的訊息。 例如，您可以使用應用程式特有的索引。 要解譯的應用程式負責<xref:System.Messaging.Message.AppSpecific%2A>屬性資訊。  
  
 可能的話，您應該納入訊息資料訊息的本文而不是<xref:System.Messaging.Message.AppSpecific%2A>屬性。  
  
 當使用外部佇列，使用<xref:System.Messaging.Message.Extension%2A>屬性來指定在訊息佇列的訊息屬性不存在。 如同<xref:System.Messaging.Message.AppSpecific%2A>屬性，它是要了解的內容的應用程式責任<xref:System.Messaging.Message.Extension%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AppSpecific" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息到達目的端佇列的時間。</summary>
        <value><see cref="T:System.DateTime" />，表示訊息到達目的端佇列的時間。 時間會被從 GMT 調整為目的端佇列所在處的電腦上的本地時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息的<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性會指出速度必須從目的端佇列接收訊息。 <xref:System.Messaging.Message.TimeToBeReceived%2A>屬性計時器就會在傳送訊息時，只有在訊息到達佇列時，不會啟動。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.ArrivedTime%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.ArrivedTime" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否應該將傳送者識別碼附加至訊息。</summary>
        <value>如果 <see cref="P:System.Messaging.Message.SenderId" /> 應該附加在訊息上，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A>屬性是位元組陣列，表示傳送的使用者識別碼。 寄件者識別碼由訊息佇列設定，並依接收的佇列管理員可用來驗證寄件者是否有佇列的存取權限。  
  
 沒有寄件者識別碼會指出傳送應用程式，訊息佇列應該不驗證訊息的寄件者，也驗證寄件者的存取權限到接收佇列中。 <xref:System.Messaging.Message.SenderId%2A>是值得信任，只有當訊息已驗證，當它到達目的地佇列。 如果佇列接受已驗證的訊息並到達目的地佇列時，會拒絕訊息<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>或<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>屬性是`false`。  
  
> [!CAUTION]
>  如果拒絕訊息時，它會傳送至無法投遞的信件佇列 (如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`true`)，或忽略它。 當訊息無法抵達佇列時，您可以要求通知。 否則，當<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`訊息可能會遺失，而不發出警告。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.AttachSenderId%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AttachSenderId" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得指出訊息是否已驗證的值。</summary>
        <value>如果訊息進入佇列時需要驗證則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A>屬性僅供應用程式在互動訊息正在嘗試判斷是否已要求驗證。 如果訊息在佇列中，訊息已驗證。 相反地，如果<xref:System.Messaging.Message.Authenticated%2A>屬性是`true`，接收佇列管理員會驗證訊息，當它收到該訊息。  
  
 您無法判斷是否訊息無法通過驗證藉由查看其屬性。 訊息佇列會捨棄驗證失敗之前傳送至佇列的訊息。 不過，您可以要求，如果傳遞失敗可防止訊息到達佇列中之傳送通知訊息。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.Authenticated%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Authenticated" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來產生訊息之數位簽章的密碼編譯提供者名稱。</summary>
        <value>用來產生訊息的數位簽章的密碼編譯提供者的名稱。 預設值為 Microsoft Base Cryptographic Provider 1.0 版。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您通常會使用<xref:System.Messaging.Message.AuthenticationProviderName%2A>使用外部佇列時。 訊息佇列要求的驗證提供者名稱和密碼編譯提供者 （驗證提供者），來驗證傳送至外部佇列的訊息和訊息傳遞至訊息的數位簽章的驗證提供者類型從外部佇列的佇列。  
  
 傳送郵件時，一律設<xref:System.Messaging.Message.AuthenticationProviderName%2A>和<xref:System.Messaging.Message.ConnectorType%2A>屬性放在一起。 當傳送訊息時，訊息佇列會忽略驗證提供者名稱如果也沒有設定連接器類型。  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A>屬性不可以是`null`，但它可以是空字串 ("")。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">無法設定 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 屬性。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 被設定為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來產生訊息之數位簽章的密碼編譯提供者類型。</summary>
        <value>其中一個 <see cref="T:System.Messaging.CryptographicProviderType" /> 值。 預設為 <see langword="RSA_FULL" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您通常會使用<xref:System.Messaging.Message.AuthenticationProviderType%2A>時使用指定的密碼編譯服務提供者是與訊息相關聯的外部索引佇列的屬性。 訊息佇列要求的驗證提供者名稱和密碼編譯提供者 （驗證提供者），來驗證傳送至外部佇列的訊息和訊息傳遞至訊息的數位簽章的驗證提供者類型從外部佇列的佇列。  
  
 只有`RsaFull`旨在搭配訊息。  
  
 傳送郵件時，一律設<xref:System.Messaging.Message.AuthenticationProviderType%2A>和<xref:System.Messaging.Message.ConnectorType%2A>屬性放在一起。 當傳送訊息時，訊息佇列會忽略驗證提供者類型如果也沒有設定連接器類型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">無法設定 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 屬性。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息的內容。</summary>
        <value>指定訊息內容的物件。 物件可以是字串、日期、貨幣、數字、位元組陣列或任何 Managed 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息的<xref:System.Messaging.Message.Body%2A>屬性通常會包含與訊息相關聯的資料。 雖然您也可以傳送應用程式專屬資料<xref:System.Messaging.Message.AppSpecific%2A>並<xref:System.Messaging.Message.Extension%2A>屬性，您應該包含在訊息資料<xref:System.Messaging.Message.Body%2A>盡可能的訊息。 只有<xref:System.Messaging.Message.Body%2A>要序列化或加密屬性內容。  
  
 <xref:System.Messaging.Message.Body%2A>屬性可包含任何物件，其大小不超過 4 MB。 如果您使用<xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType>的類型不是任何物件傳送<xref:System.Messaging.Message>要<xref:System.Messaging.MessageQueue>，該物件將會位於<xref:System.Messaging.Message.Body%2A>屬性<xref:System.Messaging.Message>所傳回的執行個體<xref:System.Messaging.MessageQueue.Peek%2A>或<xref:System.Messaging.MessageQueue.Receive%2A>。  
  
 中的字串引數`MessageQueue.Send("hello.")`舉例說明這類泛型的物件。  
  
 <xref:System.Messaging.Message.BodyType%2A>屬性會指出所儲存訊息主體中的資訊類型。 訊息佇列會使用這項資訊來識別的型別<xref:System.Messaging.Message.Body%2A>屬性內容。  
  
 指定<xref:System.Messaging.Message.Body%2A>屬性或<xref:System.Messaging.Message.BodyStream%2A>屬性，才能傳送<xref:System.Messaging.Message>物件。 <xref:System.Messaging.Message.Body%2A>屬性可以是任何可序列化的物件，例如文字字串的物件、 結構物件、 類別執行個體或內嵌的物件。  
  
 除非您撰寫的訊息內容直接<xref:System.Messaging.Message.BodyStream%2A>屬性，設定<xref:System.Messaging.Message.Formatter%2A>再傳送訊息的屬性。 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用中所包含的格式器序列化執行個體，主體<xref:System.Messaging.Message.Formatter%2A>屬性。 如果您沒有指定值，以傳送訊息<xref:System.Messaging.Message.Formatter%2A>屬性，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
> [!NOTE]
>  嘗試設定的訊息本文<xref:System.Decimal.MaxValue>會導致<xref:System.OverflowException>當`Send`方法<xref:System.Messaging.MessageQueue>類別稱為和<xref:System.Messaging.ActiveXMessageFormatter>用。  
  
   
  
## Examples  
 下列程式碼範例會將兩個不同優先權的訊息傳送至佇列，接著擷取它們。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.Formatter" /> 屬性為 <see langword="null" />。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Body" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息主體中的資訊。</summary>
        <value><see cref="T:System.IO.Stream" />，含有包含於訊息 <see cref="P:System.Messaging.Message.Body" /> 中的序列化資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息的本文可以包含任何類型的資訊-例如，字串、 日期、 貨幣、 數字、 位元組陣列或任何 managed 的物件。 這項資訊會序列化為<xref:System.IO.Stream>来傳遞至佇列。  
  
 指定<xref:System.Messaging.Message.Body%2A>屬性或<xref:System.Messaging.Message.BodyStream%2A>屬性，才能傳送<xref:System.Messaging.Message>物件。 如果您設定<xref:System.Messaging.Message.Body%2A>屬性，內容會序列化為<xref:System.Messaging.Message.BodyStream%2A>屬性。 不過，您可以選擇撰寫<xref:System.Messaging.Message.BodyStream%2A>直接屬性。 這非常有用，例如，當您想要開啟檔案的連接，並傳送它的內容資料流做為訊息的主體。  
  
 除非您撰寫的訊息內容直接<xref:System.Messaging.Message.BodyStream%2A>屬性，設定<xref:System.Messaging.Message.Formatter%2A>再傳送訊息的屬性。 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用中所包含的格式器序列化執行個體，主體<xref:System.Messaging.Message.Formatter%2A>屬性。 如果您沒有指定值，以傳送訊息<xref:System.Messaging.Message.Formatter%2A>屬性，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
 如果您設定<xref:System.Messaging.Message.UseEncryption%2A>屬性，以`true`針對此訊息本文中，將會加密訊息時，只有在您設定時，不<xref:System.Messaging.Message.Body%2A>屬性。 因此，<xref:System.Messaging.Message.BodyStream%2A>屬性永遠不會加密。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Body" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息本文包含的資料類型。</summary>
        <value>訊息主體的真正型別，例如字串、日期、貨幣或數字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列會辨識本文內容，做為物件或已序列化資料流。 <xref:System.Messaging.Message.BodyType%2A>屬性會指出內的物件型別<xref:System.Messaging.Message.Body%2A>訊息屬性。  
  
 <xref:System.Messaging.XmlMessageFormatter>執行訊息內文中的原生類型與物件之間的繫結。 如果您使用<xref:System.Messaging.XmlMessageFormatter>，格式器集<xref:System.Messaging.Message.BodyType%2A>為您的屬性。  
  
 其他格式器可以提供繫結功能以及下列 C# 程式碼所示。  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.BodyType%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Body" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出通常由訊息佇列設定的一些訊息屬性已由負責傳送的應用程式設定。</summary>
        <value>應用程式定義的 <see cref="T:System.Guid" />，要與連接器應用程式或訊息加密配合使用。 這個 <see cref="T:System.Guid" /> 允許接收應用程式解譯通常由 Message Queuing 設定，但是卻由傳送應用程式設定的訊息屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列需要<xref:System.Messaging.Message.ConnectorType%2A>屬性設定每當應用程式設定通常會設定由訊息佇列的訊息屬性。 應用程式通常使用<xref:System.Messaging.Message.ConnectorType%2A>下列兩種情況：  
  
-   每當連接器應用程式將訊息傳遞。 <xref:System.Messaging.Message.ConnectorType%2A>如何解譯訊息的安全性和通知屬性會告知傳送和接收的應用程式。  
  
-   每當傳送應用程式，而不是訊息佇列時，會加密訊息。 <xref:System.Messaging.Message.ConnectorType%2A>會告知訊息佇列 」 使用<xref:System.Messaging.Message.DestinationSymmetricKey%2A>來解密訊息的屬性值。  
  
 您必須設定<xref:System.Messaging.Message.ConnectorType%2A>屬性，如果您設定下列屬性 （否則佇列會忽略這些屬性在傳送訊息時）：  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.ConnectorType" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定認可、報告和回應訊息用來參考原始訊息的訊息識別項。</summary>
        <value>原始訊息的 <see cref="P:System.Messaging.Message.Id" /> 屬性指定的訊息識別項。 訊息佇列產生認可或報告訊息，以及應用程式產生回應訊息時，所使用的相互關聯識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當訊息佇列產生認可或報告訊息時，它會使用相互關聯識別項屬性，來指定原始訊息的訊息識別項。 因此，相互關係識別項會將報告或認可訊息連結到原始訊息。  
  
 傳送應用程式可以接著使用比對通知或報表與原始訊息<xref:System.Messaging.Message.CorrelationId%2A>屬性來識別原始訊息的<xref:System.Messaging.Message.Id%2A>屬性。  
  
 連接器應用程式也必須設定<xref:System.Messaging.Message.CorrelationId%2A>的認可和報告的訊息為原始訊息的訊息識別項的屬性。  
  
 當您的應用程式會將回應訊息傳送至傳送應用程式時，您可以設定<xref:System.Messaging.Message.CorrelationId%2A>原始訊息的訊息識別項的回應訊息的屬性。 傳送應用程式可以接著比對您的回應訊息已傳送的訊息。  
  
   
  
## Examples  
 下列程式碼範例會傳送，並收到包含訂單與佇列的訊息。 它特別要求正面確認通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.CorrelationId" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.CorrelationId" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息要使用的目的端佇列。</summary>
        <value><see cref="T:System.Messaging.MessageQueue" />，會為訊息指定要使用的目的端佇列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A>屬性最常用於判斷訊息已到達日誌或寄不出信件佇列中的原始目的端。 通常，您不需要檢查這個屬性，因為您通常會從其目的端佇列擷取訊息。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.DestinationQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.DestinationQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來為應用程式加密訊息或傳送至外部佇列的訊息加密的對稱金鑰。</summary>
        <value>位元組值陣列，指定用來加密訊息的目的端對稱金鑰。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 兩個案例要求您使用<xref:System.Messaging.Message.DestinationSymmetricKey%2A>屬性。 第一個時，您的應用程式，而非訊息佇列時，會加密訊息。 第二個是當您將加密的訊息傳送至以外的訊息佇列的佇列系統。  
  
 您設定此屬性之前，您必須加密接收佇列管理員的公用金鑰的對稱金鑰。 當您傳送應用程式加密訊息時，接收佇列管理員會使用對稱金鑰來解密訊息，再將它傳送到其目的地佇列。  
  
 如果您將訊息傳送至外部佇列時，訊息是第一次收到適當的連接器應用程式，將加密的訊息轉送至接收應用程式附加的對稱金鑰。 就接收的應用程式，來解密訊息使用的對稱金鑰的責任。  
  
 當您設定<xref:System.Messaging.Message.DestinationSymmetricKey%2A>屬性，您也必須設定<xref:System.Messaging.Message.ConnectorType%2A>屬性。 當傳送訊息時，訊息佇列會忽略<xref:System.Messaging.Message.DestinationSymmetricKey%2A>屬性如果<xref:System.Messaging.Message.ConnectorType%2A>也未設定屬性。  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A>屬性的最大陣列大小為 256。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息佇列用來驗證訊息的數位簽章。</summary>
        <value>位元組值陣列，指定用來驗證訊息的 Message Queuing 1.0 數位簽章。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在驗證訊息傳送的訊息佇列的 1.0 版時，訊息佇列會使用數位簽章。 在大部分情況下，訊息佇列會產生並設定<xref:System.Messaging.Message.DigitalSignature%2A>傳送應用程式要求驗證時的屬性。 接收應用程式會使用這個屬性來擷取附加至訊息的數位簽章。  
  
 您只能使用<xref:System.Messaging.Message.DigitalSignature%2A>執行 Message Queuing 2.0 版時的屬性。 要求驗證時，傳送應用程式必須指定 Message Queuing 1.0 版簽章。 如果傳送應用程式傳送的訊息佇列版本 2.0 簽章，此屬性會包含四個位元組，每個包含零的緩衝區。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>屬性，連同<xref:System.Messaging.Message.SenderCertificate%2A>屬性，也會使用連接器應用程式傳送訊息時。 在此案例中，連接器應用程式-而不是訊息佇列-會產生數位簽章，則根據在傳送訊息之使用者的憑證。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>屬性的最大陣列大小為 256。  
  
 當您設定<xref:System.Messaging.Message.DigitalSignature%2A>屬性，您也必須設定<xref:System.Messaging.Message.ConnectorType%2A>屬性。 當傳送訊息時，訊息佇列會忽略<xref:System.Messaging.Message.DigitalSignature%2A>屬性如果<xref:System.Messaging.Message.ConnectorType%2A>也未設定屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.DigitalSignature" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DigitalSignature" /> 屬性為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來加密私用訊息主體的加密演算法。</summary>
        <value>其中一個 <see cref="T:System.Messaging.EncryptionAlgorithm" /> 列舉值。 預設為 <see langword="RC2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果訊息是私用 （加密），它會加密之前傳送和接收時加以解密。 <xref:System.Messaging.Message.EncryptionAlgorithm%2A>屬性會指定用來加密私用訊息的訊息本文的演算法。  
  
 佇列可以要求傳入訊息必須加密。 如果應用程式傳送未加密的 （非私用） 訊息到佇列只接受私用訊息，或者如果它傳送至佇列的私用訊息，只接受非私用訊息，佇列會拒絕訊息。 傳送應用程式可以要求此情況下，傳回負值通知訊息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與訊息關聯的其他應用程式定義資訊。</summary>
        <value>位元組值陣列，提供與訊息相關聯的應用程式定義資訊。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A>屬性提供應用程式定義的資訊，例如大型二進位物件，與訊息相關聯。 它是解譯的內容接收的應用程式的責任<xref:System.Messaging.Message.Extension%2A>屬性。  
  
 可能的話，您應該包含在訊息資料<xref:System.Messaging.Message.Body%2A>訊息的屬性而非<xref:System.Messaging.Message.Extension%2A>屬性。  
  
 當使用外部佇列，使用<xref:System.Messaging.Message.Extension%2A>屬性來指定在訊息佇列的訊息屬性不存在。  
  
 在非 Microsoft Message Queuing 的佇列系統中存在的外部索引的佇列。 訊息佇列通訊使用透過連接器應用程式這類佇列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Extension" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Extension" /> 屬性為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來將物件序列化成訊息主體，或者從訊息主體將物件還原序列化的格式子。</summary>
        <value>產生要對訊息主體寫入或讀取的資料流的 <see cref="T:System.Messaging.IMessageFormatter" />。 預設為 <see cref="T:System.Messaging.XmlMessageFormatter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.Message.Formatter%2A>屬性讀取和寫入訊息時。 當訊息傳送至佇列時，格式器序列化<xref:System.Messaging.Message.Body%2A>成可以傳送至訊息佇列的資料流的屬性。 從佇列讀取時，格式器還原序列化成訊息資料<xref:System.Messaging.Message.Body%2A>屬性。  
  
 除非您撰寫的訊息內容直接<xref:System.Messaging.Message.BodyStream%2A>屬性，設定<xref:System.Messaging.Message.Formatter%2A>再傳送訊息的屬性。 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用中所包含的格式器序列化執行個體，主體<xref:System.Messaging.Message.Formatter%2A>屬性。 如果您沒有指定值，以傳送訊息<xref:System.Messaging.Message.Formatter%2A>屬性，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合的因此不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化成二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
   
  
## Examples  
 下列程式碼範例示範設定格式化的訊息內文使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下列程式碼範例示範設定格式化的訊息內文使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Formatter" /> 屬性為 <see langword="null" />。</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息佇列驗證訊息或為訊息建立數位簽章時使用的雜湊演算法。</summary>
        <value>其中一個 <see cref="T:System.Messaging.HashAlgorithm" /> 列舉值。 對 Windows XP 來說，預設值為 <see langword="SHA" />。 否則，預設值為 <see langword="MD5" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 來源電腦上，訊息佇列會使用雜湊演算法建立一則訊息的數位簽章時。 目標佇列管理員再使用相同的雜湊演算法，來驗證訊息接收時。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.HashAlgorithm" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息的識別項。</summary>
        <value>訊息的唯一識別項，由訊息佇列產生。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列在傳送訊息時，會產生的訊息識別項。 識別項是 20 個位元組所組成，並且包含兩個項目： 機器<xref:System.Guid>傳送端電腦的電腦上訊息的唯一識別碼。 這兩個項目合併起來產生網路上唯一的訊息識別項。  
  
 訊息佇列會產生-包括認可和報告訊息的所有訊息的訊息識別項。 由訊息佇列的抵達或失敗的原始、 傳送的訊息通常傳送通知訊息。 您可以找到<xref:System.Messaging.Message.Id%2A>中的原始訊息的屬性值<xref:System.Messaging.Message.CorrelationId%2A>的通知訊息的屬性。  
  
 您也可以使用<xref:System.Messaging.Message.Id%2A>時將回應訊息傳送至回應佇列的屬性。 若要在回應訊息中包含原始訊息的識別碼，設定<xref:System.Messaging.Message.CorrelationId%2A>回應訊息的屬性<xref:System.Messaging.Message.Id%2A>原始訊息的屬性。 讀取回應訊息的應用程式然後可以使用的回應訊息的相互關聯識別碼來識別原始訊息。  
  
   
  
## Examples  
 下列程式碼範例會傳送，並收到包含訂單與佇列的訊息。 它特別要求正面確認通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Id" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定沒有逾時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> 和<xref:System.Messaging.Message.TimeToReachQueue%2A>需要值，指定逾時。如先前的功能，逾時是從佇列接收訊息所允許的最長時間。 對於後者，逾時是允許的訊息到達佇列的時間。 在這兩種情況下，您可以指定逾時秒數，或使用<xref:System.Messaging.Message.InfiniteTimeout>表示沒有逾時。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Messaging.Message.InfiniteTimeout>欄位。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出訊息是否為交易中最先傳送的訊息。</summary>
        <value>如果訊息是異動中最先傳送的訊息為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收應用程式使用<xref:System.Messaging.Message.IsFirstInTransaction%2A>屬性，確認訊息已傳送到單一佇列的單一交易中的第一個訊息。  
  
 這個屬性就只能使用 Message Queuing 2.0 版及更新版本。  
  
 若要驗證交易的界限，您可以使用<xref:System.Messaging.Message.IsFirstInTransaction%2A>屬性，以及兩個其他屬性：<xref:System.Messaging.Message.IsLastInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。 若要檢查訊息是否是在交易中，傳送的最後一個訊息，請使用前者，使用後者來擷取交易的識別碼。  
  
 如果只有在交易中，傳送一則訊息<xref:System.Messaging.Message.IsFirstInTransaction%2A>並<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性都設為`true`。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.IsFirstInTransaction%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出訊息是否為交易中最後傳送的訊息。</summary>
        <value>如果訊息是單一交易中最後傳送的訊息為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收應用程式使用<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性，確認訊息已傳送到單一佇列的單一交易中的最後一個訊息。  
  
 這個屬性就只能使用 Message Queuing 2.0 版及更新版本。  
  
 若要驗證交易的界限，您可以使用<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性，以及兩個其他屬性：<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。 若要檢查訊息是否是在交易中，傳送的第一個訊息，請使用前者，使用後者來擷取交易的識別碼。  
  
 如果只有在交易中，傳送一則訊息<xref:System.Messaging.Message.IsFirstInTransaction%2A>並<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性都設為`true`。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.IsLastInTransaction" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式定義的 Unicode 字串，這個字串會描述訊息。</summary>
        <value>訊息的標記。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息標籤可以用於多種用途。 例如，您可以將它用於顯示，或者根據標籤值對訊息進行選擇性的處理。 標籤不需要是唯一的訊息。  
  
 訊息佇列和訊息標籤表示應用程式定義的值，這個值會以人們可讀取 (Human-Readable) 的詞彙協助識別佇列或訊息。 它負責解譯標籤內容，其中沒有任何內建的意義，訊息佇列應用程式的應用程式。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.Label%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Label" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 MSMQ 3.0 中介紹。 取得訊息的查詢識別項。</summary>
        <value>訊息的查詢識別項，由訊息佇列產生，且對於訊息所在佇列是唯一的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A>屬性提供唯讀存取的訊息查詢識別項。 在 MSMQ 3.0 中引進的查詢識別是 64 位元識別碼，由訊息佇列 」 產生並指派給每個訊息，訊息會放在佇列中時。 查閱識別碼不是在傳送訊息時產生的訊息識別項相同。  
  
 訊息佇列會產生所有位於任何佇列，包括應用程式所產生的目的地、 管理和報告佇列，以及系統產生的日誌、 信件、 連接器和傳出佇列的訊息查詢識別項。 換句話說，這包括這兩個傳送由傳送應用程式和訊息佇列的訊息。 查詢識別項是唯一的佇列和佇列之外沒有意義。  
  
 如果將訊息傳送至數個目的地佇列，或時它會放在其各自的佇列訊息的複本儲存在電腦日誌或佇列日誌中，如果訊息的每個複本會有它自己的查詢識別項。  
  
 <xref:System.Messaging.Message.LookupId%2A>屬性只能讀取從佇列擷取的訊息。  
  
 查閱識別碼用來讀取佇列中的特定訊息。 一旦已知的訊息查詢識別項，接收應用程式可以呼叫<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>或<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>直接移至該訊息並查看或擷取的佇列，不同於必須從佇列前端開始的資料指標的函式和瀏覽佇列的結尾  
  
 取得佇列中訊息的查詢識別項是應用程式的責任。 若要取得的查詢識別項的一種可能方式是建立會叫用快取的每個訊息識別項，因為它們都放在佇列中元件的目的端佇列的觸發程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.LookupId" /> 屬性。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息類型：<see langword="Normal" />、<see langword="Acknowledgment" /> 或 <see langword="Report" />。</summary>
        <value>其中一個 <see cref="P:System.Messaging.Message.MessageType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列在傳送訊息時，通常會設定這個屬性。 訊息佇列的訊息可以是下列其中一個類型：  
  
-   `Normal`其中的一般訊息從傳送至佇列，應用程式，或回應訊息傳回給傳送應用程式。  
  
-   `Acknowledgement`由訊息佇列產生每當傳送應用程式要求。 例如，訊息佇列可以產生正或負訊息，以表示原始訊息已抵達或已被讀取。 訊息佇列會將適當的認可訊息傳回給傳送應用程式所指定的管理佇列。  
  
-   `Report`由訊息佇列產生每當報告佇列在來源佇列管理員定義。 追蹤功能啟用時，只要原始訊息進入或離開訊息佇列伺服器，訊息佇列就會傳送報告訊息至訊息佇列報告佇列。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.MessageType%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.MessageType" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息的優先權，用來決定訊息放置在佇列中的位置。</summary>
        <value>其中一個 <see cref="T:System.Messaging.MessagePriority" /> 值，表示非交易訊息的優先層級。 預設為 <see langword="Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A>屬性會影響訊息佇列處理的方式在訊息移動時，以及當它到達其目的地。 較高優先權的訊息在路由期間會給予喜好設定，並且插入目的端佇列的前端。 優先權相同的訊息會根據抵達時間放置在佇列中。  
  
 您可以設定有意義的優先順序只針對非交易式訊息。 訊息佇列會自動設定交易式訊息的優先權`Lowest`，因而導致交易式訊息的優先權會被忽略。  
  
   
  
## Examples  
 下列程式碼範例會將兩個不同優先權的訊息傳送至佇列，接著擷取它們。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Priority" /> 屬性。</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出當發生電腦故障或網路問題時是否保證傳遞訊息。</summary>
        <value>如果保證傳送訊息 (路由途中將訊息儲存在磁碟上) 則為 <see langword="true" />，如果不保證傳送則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A>屬性會指出是否保證訊息傳遞-即使電腦損毀時的訊息目的端佇列途中。  
  
 如果郵件的傳遞保證，訊息會儲存在本機的路由中的每一個步驟，直到訊息成功轉送至下一步 的電腦。 設定<xref:System.Messaging.Message.Recoverable%2A>屬性設`true`可能會影響輸送量。  
  
 如果交易式訊息，訊息佇列會自動將訊息視為可復原，不論值<xref:System.Messaging.Message.Recoverable%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.Recoverable%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.Recoverable" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定接收應用程式產生的回應訊息的佇列。</summary>
        <value>傳回應用程式產生的回應訊息的 <see cref="T:System.Messaging.MessageQueue" />。 預設為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A>屬性會識別接收應用程式產生的回應訊息，以便接收應用程式傳回給傳送應用程式的佇列。 傳送應用程式會在應用程式傳送其訊息時指定回應佇列。 任何可用的佇列都可以指定為回應佇列。  
  
 傳回至回應佇列的訊息是應用程式指定的。 應用程式必須定義訊息的內容以及接收訊息時要採取的動作。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.ResponseQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.ResponseQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息的安全性內容。</summary>
        <value>如果先前已設定屬性，則為包含訊息之安全性內容的 <see cref="T:System.Messaging.SecurityContext" /> 物件，否則為 NULL。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來驗證訊息的安全憑證。</summary>
        <value>位元組值陣列，表示安全憑證，訊息佇列會使用這個憑證驗證訊息的傳送者。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收應用程式會使用<xref:System.Messaging.Message.SenderCertificate%2A>屬性時的訊息包含外部的安全性憑證。  
  
 訊息佇列可以驗證訊息使用的內部或外部的安全性憑證。 訊息佇列會提供內部憑證，用來驗證訊息的完整性。 憑證授權單位提供的外部憑證，您可以透過存取<xref:System.Messaging.Message.SenderCertificate%2A>訊息屬性。 除了讓訊息佇列來驗證訊息、 的外部憑證可讓接收應用程式進一步驗證寄件者。 內部憑證沒有任何可用的值，以接收應用程式。  
  
 必須以目錄服務的訊息佇列系統註冊的外部憑證。 外部憑證包含憑證授權單位、 憑證的使用者、 憑證的有效期間、 公開金鑰憑證的使用者和憑證授權單位的簽章的相關資訊。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SenderCertificate" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得傳送使用者的識別項。</summary>
        <value>識別傳送者的位元組值陣列。 接收佇列管理員會在驗證訊息時使用識別項，以驗證訊息傳送者和傳送者對佇列的存取權限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Messaging.Message.AttachSenderId%2A>屬性是`false`，在指定的寄件者識別碼<xref:System.Messaging.Message.SenderId%2A>時傳送未屬性附加至訊息。 這表示訊息佇列傳送訊息到目的端佇列時，不應該驗證寄件者。 如果<xref:System.Messaging.Message.AttachSenderId%2A>屬性是`true`，則<xref:System.Messaging.Message.SenderId%2A>屬性值是訊息已驗證時，才值得信任。 使用<xref:System.Messaging.Message.Authenticated%2A>屬性搭配<xref:System.Messaging.Message.SenderId%2A>屬性，確認 寄件者的存取權限。  
  
 連接器應用程式是使用連接器伺服器來提供訊息佇列與其他佇列的系統之間通訊的應用程式。 訊息佇列需要連接器應用程式提供寄件者識別碼。 您必須設定<xref:System.Messaging.Message.ConnectorType%2A>時透過連接器應用程式傳送訊息的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SenderId" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來傳送訊息的訊息佇列版本。</summary>
        <value>被用來傳送訊息的訊息佇列的版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A>屬性是很重要的特定功能。 比方說，只能由 Message Queuing 2.0 和更新版本，支援交易處理和數位簽章用來驗證 MSMQ 1.0 所傳送的訊息。  
  
 傳送佇列管理員設定<xref:System.Messaging.Message.SenderVersion%2A>在傳送訊息時的屬性。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.SenderVersion%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SenderVersion" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得來源佇列管理員傳送訊息時傳送電腦上的日期和時間。</summary>
        <value><see cref="T:System.DateTime" />，表示訊息傳送的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A>屬性會調整為此電腦的當地時間的執行個體<xref:System.Messaging.Message>類別所建立。 這個時區可能是不同的來源和目的端佇列。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.SentTime%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SentTime" /> 屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得發出訊息的電腦。</summary>
        <value>傳送訊息之來源電腦的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 格式<xref:System.Messaging.Message.SourceMachine%2A>屬性不包含上述兩個正斜線 (\\\\)。 例如，`myServer`有效<xref:System.Messaging.Message.SourceMachine%2A>。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.SourceMachine%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.SourceMachine" /> 屬性。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">無法存取電腦資訊或目錄服務。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要從目的端佇列擷取訊息的最長時間。</summary>
        <value>從目的地佇列接收已傳送訊息所使用的總時間。 預設值為 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A>屬性會指定從目的端佇列接收已傳送的訊息的總時間。 時間限制包含連到目的端佇列和所花費的時間，才能接收訊息佇列中等候所花費的時間。  
  
> [!CAUTION]
>  當使用依存性用戶端電腦，請務必執行訊息佇列伺服器的時鐘同步處理用戶端電腦上的時鐘。 傳送訊息時，無法預期的行為，否則可能會造成其<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性不是<xref:System.Messaging.Message.InfiniteTimeout>。  
  
 如果指定的間隔<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性到期之前從佇列移除訊息，訊息佇列捨棄的訊息中有兩種。 如果訊息的 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 屬性是 `true`，訊息就會傳送到寄不出的信件佇列。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，會忽略該訊息。  
  
 您可以設定訊息的<xref:System.Messaging.Message.AcknowledgeType%2A>屬性來要求的訊息佇列傳送負值通知訊息回到傳送應用程式如果在計時器終止前，不會擷取訊息。  
  
 如果所指定的值<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性是所指定的值小於<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性，<xref:System.Messaging.Message.TimeToBeReceived%2A>會優先使用。  
  
 當在單一交易中傳送數個訊息時，訊息佇列會使用<xref:System.Messaging.Message.TimeToBeReceived%2A>第一個訊息的屬性。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">為 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 指定的值無效。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息抵達佇列的最大時間量。</summary>
        <value>從傳送訊息開始至訊息到達目的地佇列的時間限制。 預設為 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的間隔<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性到期的訊息抵達其目的地之前，訊息佇列捨棄的訊息中有兩種。 如果訊息的 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 屬性是 `true`，訊息就會傳送到寄不出的信件佇列。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，會忽略該訊息  
  
 您可以設定他的訊息<xref:System.Messaging.Message.AcknowledgeType%2A>屬性來要求的訊息佇列傳送負值通知訊息回到傳送應用程式如果在計時器終止前未到達的訊息。  
  
 如果<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性設定為 0 秒時，訊息佇列會嘗試一次將訊息傳送至其目的地-如果佇列正等待訊息。 如果本機佇列，訊息永遠會到達。  
  
 如果所指定的值<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性所指定的值大於<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性，<xref:System.Messaging.Message.TimeToBeReceived%2A>會優先使用。  
  
 當在單一交易中傳送數個訊息時，訊息佇列會使用<xref:System.Messaging.Message.TimeToReachQueue%2A>第一個訊息的屬性。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">為 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 指定的值無效。 可能表示負數。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息所屬交易的識別項。</summary>
        <value>與訊息相關聯之交易的識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收應用程式使用<xref:System.Messaging.Message.TransactionId%2A>屬性，確認已為特定交易的一部分傳送一則訊息。 交易識別碼包含在傳送端電腦 （第一個 16 位元），後面接著一個 4 位元組交易序號的識別碼。  
  
 這個屬性是僅適用於訊息佇列版本 2.0 和更新版本。  
  
 交易識別項不保證是唯一的因為交易序號不具持續性，然後他們重新 2 <sup>20</sup>。 訊息佇列只能保證，後續的交易都會都有不同的交易序號。  
  
 您可以使用<xref:System.Messaging.Message.TransactionId%2A>屬性連同<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性，以確認交易界限。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.TransactionId%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.TransactionId" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得來源電腦上的異動狀態佇列。</summary>
        <value>來源電腦上的異動狀態佇列，用來傳回認可訊息至傳送的應用程式。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A>屬性會識別讀取回條通知接收連接器應用程式的來源電腦上的交易式佇列。 訊息佇列設定屬性，並擷取交易式傳送至外部佇列的訊息時，連接器應用程式會使用屬性。  
  
 在非 Microsoft Message Queuing 的佇列系統中存在的外部索引的佇列。 訊息佇列通訊使用透過連接器應用程式這類佇列。  
  
 連接器應用程式可以使用的異動狀態佇列來傳送通知訊息傳回給傳送應用程式。 即使傳送的應用程式不會要求其他認可的交易狀態應該會收到這些通知。  
  
   
  
## Examples  
 下列程式碼範例會顯示訊息的值<xref:System.Messaging.Message.TransactionStatusQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未傳送訊息。 這個屬性只能在從佇列擷取的訊息中讀取。  
  
-或- 
篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出訊息在傳送之前是否已經 (或必須) 驗證。</summary>
        <value>如果傳送的應用程式要求訊息的驗證則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A>屬性會指定訊息是否需要進行驗證。 如果傳送應用程式要求驗證時，訊息佇列會建立數位簽章，並使用它來簽署訊息，傳送和接收時，驗證訊息。  
  
 如果<xref:System.Messaging.Message.UseAuthentication%2A>是`false`和訊息傳送至佇列只接受已驗證的訊息、 在到達佇列的訊息將會遭到拒絕。  
  
 您無法判斷是否訊息無法通過驗證藉由查看其屬性。 訊息佇列會捨棄這類訊息之前傳送至佇列。 不過，您可以要求，如果傳遞失敗可防止訊息到達佇列中之傳送通知訊息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseAuthentication" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否應該將無法傳遞的訊息複本傳送至無法投遞的信件佇列。</summary>
        <value>如果訊息傳遞錯誤會導致將訊息複本傳送至無法投遞的信件佇列，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>和<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性會指定如何追蹤訊息佇列的訊息。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`true`，傳遞失敗 （的非交易式訊息），會導致訊息傳送至非異動式寄不出信件佇列無法傳遞訊息的電腦上。 傳遞失敗，可能是郵件計時器過期，例如所造成的。  
  
 在交易式訊息的傳遞失敗，訊息佇列傳送訊息至交易式寄不出信件佇列在所有負數且不確定的情況下在來源機器上。  
  
 當您將訊息儲存在寄不出信件佇列中時，您應該清除定期以移除不再需要的訊息佇列。 在寄不出信件佇列對佇列所在的電腦的大小配額的計數中儲存的訊息。 電腦配額由系統管理員所設定，而是指配置來儲存訊息的整個電腦上，不只是在單一佇列的大小。  
  
 您不想建立日誌或寄不出信件佇列。 這些是訊息佇列產生這兩個系統佇列。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否將訊息設成私用。</summary>
        <value>如果要求訊息佇列為訊息加密則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若為私人訊息之前傳送和接收時解密加密其主體。 若要傳送的私用訊息，傳送應用程式必須指定用於加密和 （選擇性） 的加密演算法。  
  
 傳送私人訊息時，您的應用程式不必執行訊息加密。 訊息佇列可讓您加密訊息本文，如果您的應用程式會傳送 Microsoft Windows 2000 企業中，有權存取目錄服務內的訊息。 接收私用的訊息時，接收佇列管理員一律會解密訊息內文。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.UseEncryption%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseEncryption" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出訊息複本是否應保留在原始電腦上的電腦日誌中。</summary>
        <value>如果要求在訊息成功地傳輸 (從原始電腦至下一個伺服器) 後，在原始電腦的電腦日誌中保留訊息的複本則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>和<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性會指定如何追蹤訊息佇列的訊息。 如果<xref:System.Messaging.Message.UseJournalQueue%2A>是`true`，則複本會保存每個步驟，訊息會傳輸原始的電腦上電腦日誌中。  
  
 如果目的地佇列是在遠端電腦上，則傳送的訊息只會複製到日誌佇列。 如果目的地是在本機電腦上，訊息會直接傳送至佇列沒有任何需要的日誌功能的中繼步驟。  
  
 當您將訊息儲存在日誌佇列中時，清除 定期以移除不再需要的訊息佇列。 計算儲存在日誌佇列的佇列所在的電腦配額的訊息。 （由系統管理員會設定電腦配額）。  
  
 您不想建立日誌或寄不出信件佇列。 這些是訊息佇列產生這兩個系統佇列。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.UseJournalQueue%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseJournalQueue" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出當訊息向其目的佇列移動時是否要追蹤訊息。</summary>
        <value>如果原始訊息路由至目的佇列的每個中間步驟都會產生要傳送至系統報告佇列的報告，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A>屬性會指定是否要向其目的佇列移動追蹤之訊息的路由。 如果`true`，訊息會通過訊息佇列路由伺服器每次傳送 （由訊息佇列產生） 報告訊息至報告佇列。 來源佇列管理員所指定的報告佇列。 報告佇列並不限於由訊息佇列; 產生的報告訊息您應用程式所產生的訊息也會傳送到報告佇列。  
  
 使用追蹤，牽涉到設定 Active Directory，並指定訊息佇列企業版的報告佇列。 系統管理員會設定這些設定。  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息的值<xref:System.Messaging.Message.UseTracing%2A>屬性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">篩選訊息佇列以忽略 <see cref="P:System.Messaging.Message.UseTracing" /> 屬性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>