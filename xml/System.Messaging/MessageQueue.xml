<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="69f2777a276f8aef609d1f9fef1f688a44f8ef6f" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52217442" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供 Message Queuing 伺服器上的佇列存取。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing 技術可讓在不同時間執行的應用程式跨越可能暫時離線的異質的網路和系統進行通訊。 應用程式傳送、 接收或窺視 （讀取但不移除） 來自佇列的訊息。 訊息佇列是的選用元件[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]和 Windows NT 和必須另外安裝。  
  
 <xref:System.Messaging.MessageQueue>類別是一個包裝函式訊息佇列。 有多個版本的訊息佇列，並使用<xref:System.Messaging.MessageQueue>類別可能會導致稍微不同的行為，而您使用視作業系統而定。 針對每個版本的訊息佇列的特定功能的相關資訊，請參閱 MSDN 中的平台 SDK 中的 」 的訊息佇列中的新 > 主題。  
  
 <xref:System.Messaging.MessageQueue>類別會提供訊息佇列 」 佇列的參考。 您可以指定路徑，以在<xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式來連線到現有的資源，或者您可以在伺服器上建立新的佇列。 您可以呼叫之前<xref:System.Messaging.MessageQueue.Send%28System.Object%29>， <xref:System.Messaging.MessageQueue.Peek%2A>，或<xref:System.Messaging.MessageQueue.Receive%2A>，您必須建立關聯的新執行個體<xref:System.Messaging.MessageQueue>類別與現有的佇列。 此時，例如操作佇列屬性<xref:System.Messaging.MessageQueue.Category%2A>和<xref:System.Messaging.MessageQueue.Label%2A>。  
  
 <xref:System.Messaging.MessageQueue> 支援兩種擷取訊息類型： 同步和非同步。 同步方法中，<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.Receive%2A>，使得處理序執行緒等待新訊息到達佇列中指定的時間間隔。 非同步方法中，<xref:System.Messaging.MessageQueue.BeginPeek%2A>和<xref:System.Messaging.MessageQueue.BeginReceive%2A>，允許主應用程式工作繼續在個別的執行緒，直到訊息抵達佇列中。 這些方法的運作使用回呼物件和狀態物件來傳達執行緒之間的資訊。  
  
 當您建立的新執行個體<xref:System.Messaging.MessageQueue>類別，您不需要建立新的 「 訊息佇列 」 佇列。 相反地，您可以使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>， <xref:System.Messaging.MessageQueue.Delete%28System.String%29>，和<xref:System.Messaging.MessageQueue.Purge%2A>方法來管理伺服器上的佇列。  
  
 不同於<xref:System.Messaging.MessageQueue.Purge%2A>，<xref:System.Messaging.MessageQueue.Create%28System.String%29>並<xref:System.Messaging.MessageQueue.Delete%28System.String%29>會`static`成員，因此您可以呼叫它們，而不需要建立的新執行個體<xref:System.Messaging.MessageQueue>類別。  
  
 您可以設定<xref:System.Messaging.MessageQueue>物件的<xref:System.Messaging.MessageQueue.Path%2A>具有三個名稱的其中一個屬性： 易記的名稱， <xref:System.Messaging.MessageQueue.FormatName%2A>，或<xref:System.Messaging.MessageQueue.Label%2A>。 由佇列所定義的易記名稱<xref:System.Messaging.MessageQueue.MachineName%2A>並<xref:System.Messaging.MessageQueue.QueueName%2A>屬性，是<xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A>公用佇列，和<xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A>私用佇列。 <xref:System.Messaging.MessageQueue.FormatName%2A>屬性允許離線存取訊息佇列。 最後，您可以使用佇列<xref:System.Messaging.MessageQueue.Label%2A>屬性來設定佇列的<xref:System.Messaging.MessageQueue.Path%2A>。  
  
 如需執行個體的初始屬性值的清單<xref:System.Messaging.MessageQueue>，請參閱<xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式。  
  
   
  
## Examples  
 下列程式碼範例，請建立新<xref:System.Messaging.MessageQueue>物件使用不同的路徑名稱語法類型。 在每個案例中，它會傳送訊息至佇列的路徑定義於建構函式。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 下列程式碼範例將訊息傳送至佇列，並接收來自佇列中，使用呼叫的應用程式特定類別的訊息`Order`。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>只有<see cref="M:System.Messaging.MessageQueue.GetAllMessages" />方法是安全執行緒。</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。 在預設建構函式將新執行個體初始化之後，您必須先設定執行個體的 <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性，才能夠使用執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的新執行個體使用此多載<xref:System.Messaging.MessageQueue>未立即繫結至訊息佇列伺服器上佇列的類別。 之前使用此執行個體，您必須連接到現有的 「 訊息佇列 」 佇列設定<xref:System.Messaging.MessageQueue.Path%2A>屬性。 或者，您可以設定<xref:System.Messaging.MessageQueue>參考<xref:System.Messaging.MessageQueue.Create%28System.String%29>方法的傳回值，藉此建立新的 「 訊息佇列 」 佇列。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式具現化的新執行個體<xref:System.Messaging.MessageQueue>類別; 它不會建立新的 「 訊息佇列 」 佇列。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.MessageQueue>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|預設建構函式所設定的值<xref:System.Messaging.DefaultPropertiesToSend>類別。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|預設建構函式所設定的值<xref:System.Messaging.MessagePropertyFilter>類別。 所有篩選器值都會設為`true`。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 下列程式碼範例會建立新<xref:System.Messaging.MessageQueue>。  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 所參考的佇列位置。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體，這個執行個體會參考指定路徑的訊息佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載，當您想要將繫結新<xref:System.Messaging.MessageQueue>特定訊息佇列 」 佇列，您知道的路徑，格式名稱或標籤的執行個體。 如果您想要授與獨佔存取權的第一個應用程式參考的佇列，則必須將<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>屬性設`true`或使用傳遞的讀取權限限制參數的建構函式。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式具現化的新執行個體<xref:System.Messaging.MessageQueue>類別; 它不會建立新的 「 訊息佇列 」 佇列。 若要建立新的佇列中訊息佇列，請使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 語法`path`參數取決於佇列類型它的參考下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
|電腦日誌佇列|`MachineName`\\`Journal$`|  
|機器無法投遞的信件佇列|`MachineName`\\`Deadletter$`|  
|電腦交易式寄不出信件佇列|`MachineName`\\`XactDeadletter$`|  
  
 或者，您可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>來描述佇列路徑下, 表所示。  
  
|參考資料|語法|範例|  
|---------------|------------|-------------|  
|格式名稱|`FormatName:` [*格式名稱*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|標籤|`Label:` [*標籤*]|`Label:` TheLabel|  
  
 若要離線工作，您必須使用格式名稱語法不建構函式的路徑名稱語法。 否則，因為主要網域控制站無法使用路徑解析成的格式名稱，便會擲回例外狀況。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.MessageQueue>。 這些值依 「 訊息佇列 」 佇列的屬性所指定的路徑`path`參數。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|預設建構函式所設定的值<xref:System.Messaging.DefaultPropertiesToSend>類別。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`如果訊息佇列 」 佇列的隱私權等級設定為"Body";否則， `false`。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|「 訊息佇列 」 佇列的電腦名稱屬性的值。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|預設建構函式所設定的值<xref:System.Messaging.MessagePropertyFilter>類別。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>如果未設定建構函式。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>如果未設定建構函式。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`如果已啟用訊息佇列物件的日誌設定否則， `false`。|  
  
   
  
## Examples  
 下列程式碼範例，請建立新<xref:System.Messaging.MessageQueue>物件使用不同的路徑名稱語法類型。 在每個案例中，它會傳送訊息至佇列的路徑定義於建構函式。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性無效，可能是因為尚未對其進行設定。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列位置，可能是代表本機電腦的 "."。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> 表示將獨佔讀取的存取權限授與存取佇列的第一個應用程式，否則為 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體，這個執行個體會參考指定路徑且具有指定讀取權限制的訊息佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載，當您想要將繫結新<xref:System.Messaging.MessageQueue>到特定訊息佇列 」 佇列，您知道的路徑，格式名稱或標籤。 如果您想要授與獨佔存取權的第一個應用程式參考的佇列，將`sharedModeDenyReceive`參數來`true`。 否則，請設定`sharedModeDenyReceive`要`false`，或使用建構函式只有`path`參數。  
  
 設定`sharedModeDenyReceive`至`true`影響存取 「 訊息佇列 」 佇列，包括其他應用程式的所有物件。 參數的效果不會限制此應用程式的選項。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式建立的新執行個體<xref:System.Messaging.MessageQueue>類別; 它不會建立新的 「 訊息佇列 」 佇列。 若要建立新的佇列中訊息佇列，請使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 語法`path`參數取決於佇列的類型。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
|電腦日誌佇列|`MachineName`\\`Journal$`|  
|機器無法投遞的信件佇列|`MachineName`\\`Deadletter$`|  
|電腦交易式寄不出信件佇列|`MachineName`\\`XactDeadletter$`|  
  
 或者，您可以使用格式名稱或 「 訊息佇列 」 佇列的標籤，來描述為佇列路徑。  
  
|參考資料|語法|範例|  
|---------------|------------|-------------|  
|格式名稱|`FormatName:` [*格式名稱*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|標籤|`Label:` [*標籤*]|`Label:` TheLabel|  
  
 若要離線工作，您必須使用格式名稱語法中，而不是好記名稱語法。 否則，因為網域主控站 （Active Directory 所在） 不適用於將路徑解析成的格式名稱，便會擲回例外狀況。  
  
 如果<xref:System.Messaging.MessageQueue>隨即開啟的佇列`sharedModeDenyReceive`參數設為`true`，任何<xref:System.Messaging.MessageQueue>，接著嘗試從佇列讀取會產生<xref:System.Messaging.MessageQueueException>因為共用違規。 A<xref:System.Messaging.MessageQueueException>如果也會擲回<xref:System.Messaging.MessageQueue>嘗試存取以獨佔模式，而另一個佇列<xref:System.Messaging.MessageQueue>已佇列的非獨佔存取。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.MessageQueue>。 這些值依所指定的路徑上的訊息佇列 」 佇列，屬性`path`參數。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|預設建構函式所設定的值<xref:System.Messaging.DefaultPropertiesToSend>類別。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`如果訊息佇列 」 佇列的隱私權等級設定為"Body";否則， `false`。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|「 訊息佇列 」 佇列的電腦名稱屬性的值。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|預設建構函式所設定的值<xref:System.Messaging.MessagePropertyFilter>類別。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>如果未設定建構函式。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>如果未設定建構函式。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` 參數的值。|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`如果已啟用訊息佇列物件的日誌設定否則， `false`。|  
  
   
  
## Examples  
 下列程式碼範例會建立新<xref:System.Messaging.MessageQueue>獨佔存取權，以設定其路徑中，並將訊息傳送至佇列。  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性無效，可能是因為尚未對其進行設定。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列位置，可能是代表本機電腦的 "."。</param>
        <param name="accessMode">其中一個 <see cref="T:System.Messaging.QueueAccessMode" /> 值。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列位置，可能是代表本機電腦的 "."。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> 表示將獨佔讀取的存取權限授與存取佇列的第一個應用程式，否則為 <see langword="false" />。</param>
        <param name="enableCache">
          <see langword="true" /> 表示建立並使用連接快取，否則為 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立新<xref:System.Messaging.MessageQueue>獨佔讀取存取權與啟用快取的連線。  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列位置，可能是代表本機電腦的 "."。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> 表示將獨佔讀取的存取權限授與存取佇列的第一個應用程式，否則為 <see langword="false" />。</param>
        <param name="enableCache">
          <see langword="true" /> 表示建立並使用連接快取，否則為 <see langword="false" />。</param>
        <param name="accessMode">其中一個 <see cref="T:System.Messaging.QueueAccessMode" /> 值。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示佇列的存取模式。</summary>
        <value>其中一個 <see cref="T:System.Messaging.QueueAccessMode" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 佇列的預設存取模式是`QueueAccessMode.SendAndReceive`，除非您另外指定當呼叫建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出佇列是否只接受已驗證的訊息。</summary>
        <value>如果佇列只接受驗證過的訊息則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息驗證提供一種方法來確保訊息完整性，以及確認誰傳送訊息。 若要要求驗證，傳送應用程式會設定訊息的驗證層級。  
  
 當您設定<xref:System.Messaging.MessageQueue.Authenticate%2A>要`true`，限制在伺服器上，不只對此佇列的存取權<xref:System.Messaging.MessageQueue>執行個體。 使用相同的 「 訊息佇列 」 佇列的所有用戶端會受到影響。  
  
 只接受已驗證的訊息佇列將會拒絕未經驗證的訊息。 若要要求拒絕訊息的通知，傳送應用程式可以設定<xref:System.Messaging.Message.AcknowledgeType%2A>訊息屬性。 因為沒有其他指示的訊息拒絕存在時，傳送應用程式可能會遺失訊息除非您要求，它會傳送到寄不出信件佇列。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.Authenticate%2A>屬性。  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息佇列用來在網路上傳送公用佇列訊息的基礎優先權 (Base Priority)。</summary>
        <value>傳送至 (公用) 佇列的所有訊息的單一基礎優先權。 預設為零 (0)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列的基本優先順序會指定如何路由訊息的佇列會被視為透過網路傳送。 您可以設定<xref:System.Messaging.MessageQueue.BasePriority%2A>授與較高或較低的優先順序，傳送到傳送至其他佇列所指定的佇列的所有訊息的屬性。 設定這個屬性修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體。  
  
 訊息佇列<xref:System.Messaging.MessageQueue.BasePriority%2A>無關<xref:System.Messaging.Message.Priority%2A>屬性的訊息，這會指定在其中傳入的訊息放在佇列中的順序。  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> 適用於使用格式名稱來指定其路徑為公用佇列。 私用佇列的基本優先順序永遠是零 (0)。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.BasePriority%2A>屬性。  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">基礎優先權設定為無效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <summary>啟始非同步窺視作業，方法是告知訊息佇列開始窺視訊息，並在完成時告知事件處理常式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟始沒有逾時的非同步窺視作業。作業要等到訊息可以在佇列中使用之後才算完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件佇列中出現一則訊息時。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發如果佇列中已有一則訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 啟始非同步窺視作業;<xref:System.Messaging.MessageQueue> ，透過的引發會通知<xref:System.Messaging.MessageQueue.PeekCompleted>事件，當訊息到達佇列中。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或藉由擷取結果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步的您可以呼叫它來查看佇列，而不會封鎖目前執行緒的執行。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginPeek%2A>傳回識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，您會使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>已`false`，會引發了完成事件，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立名為事件處理常式`MyPeekCompleted`，將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式的委派，以及呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>起始位於路徑的佇列上的非同步窺視作業 」。 \myQueue"。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，範例窺視的訊息，並將其主體寫入螢幕。 此範例接著會呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A> 以起始新的非同步窺視作業。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <summary>啟始有指定逾時的非同步窺視作業。在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引發<xref:System.Messaging.MessageQueue.PeekCompleted>時可用的訊息佇列中，或指定的時間間隔已過期事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發如果佇列中已有一則訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 啟始非同步窺視作業;<xref:System.Messaging.MessageQueue> ，透過的引發會通知<xref:System.Messaging.MessageQueue.PeekCompleted>事件，當訊息到達佇列中。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或藉由擷取結果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步的您可以呼叫它來查看佇列，而不會封鎖目前執行緒的執行。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginPeek%2A>傳回識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，您會使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 這個多載指定逾時。如果指定的間隔`timeout`參數，此元件會引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件。 因為不存在，後續呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>將會擲回例外狀況。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>已`false`，會引發了完成事件，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立的非同步窺視作業，使用的佇列路徑 」。 \myQueue"。 它會建立事件處理常式`MyPeekCompleted`，並將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 啟始非同步窺視作業，會呼叫逾時值為一分鐘的時間。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件或逾時到期，如果有的話，而且其主體寫到螢幕擷取訊息。 然後<xref:System.Messaging.MessageQueue.BeginPeek%2A>再次呼叫以初始化新的非同步窺視作業，以相同的逾時。  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="stateObject">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <summary>啟始有指定逾時和指定狀態物件的非同步窺視作業，會在作業的整個存留期內提供相關的資訊。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引發<xref:System.Messaging.MessageQueue.PeekCompleted>時可用的訊息佇列中，或指定的時間間隔已過期事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發如果佇列中已有一則訊息。  
  
 您可以使用此多載，將整個作業的存留期會保留作業相關聯的資訊。 事件處理常式可以存取此資訊，請查看<xref:System.IAsyncResult.AsyncState%2A>屬性<xref:System.IAsyncResult>與作業相關聯。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 啟始非同步窺視作業;<xref:System.Messaging.MessageQueue> ，透過的引發會通知<xref:System.Messaging.MessageQueue.PeekCompleted>事件，當訊息到達佇列中。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或藉由擷取結果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步的您可以呼叫它來查看佇列，而不會封鎖目前執行緒的執行。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 傳回<xref:System.IAsyncResult>可識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，您會使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 這個多載指定逾時和狀態物件。 如果指定的間隔`timeout`參數，此元件會引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件。 因為不存在，後續呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>將會擲回例外狀況。  
  
 與作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次，以便起始多項作業，您可以識別每個作業，透過您定義個別的狀態物件。 如需此案例的圖例，請參閱 < 範例 > 一節。  
  
 您也可以將資訊傳遞到處理序執行緒使用的狀態物件。 如果在執行緒啟動，但回呼是在不同的執行緒，在非同步案例中，狀態物件會封送處理，並從事件傳遞的資訊一起傳回。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>已`false`，會引發了完成事件，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立的非同步窺視作業，使用的佇列路徑 」。 \myQueue"。 它會建立事件處理常式`MyPeekCompleted`，並將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 呼叫時，一分鐘的逾時。 每次呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>已識別該特定作業的唯一相關聯的整數。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，或在逾時到期時，擷取訊息，如果有的話，和其主體和作業特定的整數識別碼會寫到螢幕。 然後<xref:System.Messaging.MessageQueue.BeginPeek%2A>會再次呼叫以起始新的非同步窺視作業，使用相同的逾時和就已完成之作業的相關聯的整數。  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="stateObject">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <param name="callback">會接收非同步作業完成通知的 <see cref="T:System.AsyncCallback" />。</param>
        <summary>啟始有指定逾時和指定狀態物件的非同步窺視作業，會在作業的整個存留期內提供相關的資訊。 這個多載會透過回呼，接收作業的事件處理常式的識別通知。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用這個多載時，回呼參數中指定的回呼時叫用直接訊息成為可用的佇列中，或指定的時間間隔已過期;<xref:System.Messaging.MessageQueue.PeekCompleted>不會引發事件。 其他多載<xref:System.Messaging.MessageQueue.BeginPeek%2A>依賴此元件以引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發如果佇列中已有一則訊息。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步的您可以呼叫它來查看佇列，而不會封鎖目前執行緒的執行。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 傳回<xref:System.IAsyncResult>可識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，您會使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 與作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次，以便起始多項作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立的非同步窺視作業。 程式碼範例中傳送訊息至本機訊息佇列，然後呼叫<xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>，並傳入： 逾時值為 10 秒，識別該特定的訊息; 以及的新執行個體的唯一整數<xref:System.AsyncCallback>可識別事件處理常式`MyPeekCompleted`. 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件、 事件處理常式窺視的訊息及螢幕中寫入訊息本文和訊息屬性的整數識別碼。  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="action">其中一個 <see cref="T:System.Messaging.PeekAction" /> 值。 指出要窺視佇列中的目前訊息，還是下一則訊息。</param>
        <param name="state">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" />，接收非同步作業的完成通知。</param>
        <summary>啟始非同步窺視作業，該作業具有指定的逾時，並使用指定的游標、指定的窺視動作和指定的狀態物件。 狀態物件提供整個作業存留期的相關聯資訊。 這個多載會透過回呼，接收作業的事件處理常式的識別通知。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用這個多載時，回呼參數中指定的回呼時叫用直接訊息成為可用時指定的時間間隔已過期，或在佇列訊息。 <xref:System.Messaging.MessageQueue.PeekCompleted>不會引發事件。 其他多載<xref:System.Messaging.MessageQueue.BeginPeek%2A>依賴此元件以引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發如果佇列中已有一則訊息。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步的您可以呼叫它來查看佇列，而不會封鎖目前執行緒的執行。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 傳回<xref:System.IAsyncResult>識別方法所啟動的非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 與作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次，以便起始多項作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">為 <paramref name="action" /> 參數指定 <see langword="PeekAction.Current" /> 或 <see langword="PeekAction.Next" /> 以外的值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <summary>啟始非同步接收作業，方法是告知訊息佇列開始接收訊息，並在完成時告知事件處理常式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟始沒有逾時的非同步接收作業。作業要等到訊息可以在佇列中使用之後才算完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>時從佇列中移除訊息的事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發如果佇列中已有一則訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業;<xref:System.Messaging.MessageQueue> ，透過的引發會通知<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件，當訊息到達佇列中。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步的您可以呼叫它來從佇列接收訊息，而不會封鎖目前執行緒的執行。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，您會使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>已`false`，會引發了完成事件，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，並放在交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>窺視作業在您建立的事件處理常式方法。 您的事件處理常式可能會包含功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例鏈結非同步要求。 它會假設在稱為 「 myQueue 「 本機電腦上沒有佇列。 `Main`函式開始非同步作業所處理的`MyReceiveCompleted`常式。 `MyReceiveCompleted` 處理目前的訊息，並開始新的非同步接收作業。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 下列程式碼範例會排入佇列的非同步要求。 若要在呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>中它的傳回值。 `Main`常式會等到所有的非同步作業完成之前結束。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <summary>啟始有指定逾時的非同步接收作業。在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>時可用的訊息佇列中，或指定的時間間隔已過期事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發如果佇列中已有一則訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業;<xref:System.Messaging.MessageQueue> ，透過的引發會通知<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件，當訊息到達佇列中。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或擷取結果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步的您可以呼叫它來從佇列接收訊息，而不會封鎖目前執行緒的執行。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>已`false`，會引發了完成事件，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，您會使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 這個多載指定逾時。如果指定的間隔`timeout`參數，此元件會引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。 因為不存在，後續呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>將會擲回例外狀況。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，並放在交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>窺視作業在您建立的事件處理常式方法。 您的事件處理常式可能會包含功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立非同步接收作業。 在程式碼範例會建立事件處理常式`MyReceiveCompleted`，並將它附加至<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件處理常式委派。 程式碼範例中傳送訊息至本機訊息佇列，然後呼叫<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>，並傳入逾時值為 10 秒。 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件、 事件處理常式會接收訊息，並將訊息本文寫入至螢幕。  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 參數所指定的值無效，可能是因為它表示負數。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="stateObject">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <summary>啟始有指定逾時和指定狀態物件的非同步接收作業，會在作業的整個存留期內提供相關的資訊。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>時可用的訊息佇列中，或指定的時間間隔已過期事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發如果佇列中已有一則訊息。  
  
 您可以使用此多載，將整個作業的存留期會保留作業相關聯的資訊。 事件處理常式可以偵測這項資訊來看看<xref:System.IAsyncResult.AsyncState%2A>屬性<xref:System.IAsyncResult>與作業相關聯。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業;<xref:System.Messaging.MessageQueue> ，透過的引發會通知<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件，當訊息到達佇列中。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或擷取結果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步的您可以呼叫它來從佇列接收訊息，而不會封鎖目前執行緒的執行。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，您會使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 這個多載指定逾時和狀態物件。 如果指定的間隔`timeout`參數，此元件會引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。 因為不存在，後續呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>將會擲回例外狀況。  
  
 與作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次，以便起始多項作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 您也可以將資訊傳遞到處理序執行緒使用的狀態物件。 如果在執行緒啟動，但回呼是在不同的執行緒，在非同步案例中，狀態物件會封送處理，並從事件傳遞的資訊一起傳回。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，並放在交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>窺視作業在您建立的事件處理常式方法。 您的事件處理常式可能會包含功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立非同步接收作業。 在程式碼範例會建立事件處理常式`MyReceiveCompleted`，並將它附加至<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件處理常式委派。 程式碼範例中傳送訊息至本機訊息佇列，然後呼叫<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>，並傳入逾時值為 10 秒，並識別該特定訊息的唯一整數。 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件、 事件處理常式會接收訊息，並將訊息內文和整數的訊息識別項寫入至螢幕。  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="stateObject">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <param name="callback">會接收非同步作業完成通知的 <see cref="T:System.AsyncCallback" />。</param>
        <summary>啟始有指定逾時和指定狀態物件的非同步接收作業，會在作業的整個存留期內提供相關的資訊。 這個多載會透過回呼，接收作業的事件處理常式的識別通知。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用這個多載時，回呼參數中指定的回呼時叫用直接訊息成為可用的佇列中，或指定的時間間隔已過期;<xref:System.Messaging.MessageQueue.ReceiveCompleted>不會引發事件。 其他多載<xref:System.Messaging.MessageQueue.BeginReceive%2A>依賴此元件以引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發如果佇列中已有一則訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業;<xref:System.Messaging.MessageQueue> ，透過的引發會通知<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件，當訊息到達佇列中。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或擷取結果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步的您可以呼叫它來從佇列接收訊息，而不會封鎖目前執行緒的執行。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，您會使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 與作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次，以便起始多項作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 您也可以將資訊傳遞到處理序執行緒使用的狀態物件。 如果在執行緒啟動，但回呼是在不同的執行緒，在非同步案例中，狀態物件會封送處理，並從事件傳遞的資訊一起傳回。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，並放在交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>窺視作業在您建立的事件處理常式方法。 您的事件處理常式可能會包含功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立非同步接收作業。 程式碼範例中傳送訊息至本機訊息佇列，然後呼叫<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>，並傳入： 逾時值為 10 秒，識別該特定的訊息; 以及的新執行個體的唯一整數<xref:System.AsyncCallback>可識別事件處理常式`MyReceiveCompleted`. 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件、 事件處理常式會接收訊息，並將訊息內文和整數的訊息識別項寫入至螢幕。  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="state">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" />，接收非同步作業的完成通知。</param>
        <summary>初始化非同步接收作業，該作業具有指定的逾時，並使用指定的游標和指定的狀態物件。 狀態物件提供整個作業存留期的相關聯資訊。 這個多載會透過回呼，接收作業的事件處理常式的識別通知。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用這個多載時，回呼參數中指定的回呼時叫用直接訊息成為可用的佇列中，或指定的時間間隔已過期;<xref:System.Messaging.MessageQueue.ReceiveCompleted>不會引發事件。 其他多載<xref:System.Messaging.MessageQueue.BeginReceive%2A>依賴此元件以引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發如果佇列中已有一則訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業;<xref:System.Messaging.MessageQueue> ，透過的引發會通知<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件，當訊息到達佇列中。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或擷取結果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成的非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步的您可以呼叫它來從佇列接收訊息，而不會封鎖目前執行緒的執行。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式，才能持續收到通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用此<xref:System.IAsyncResult>存留期的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等到所有作業或完成任何作業。 在此案例中，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 與作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次，以便起始多項作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 您也可以將資訊傳遞到處理序執行緒使用的狀態物件。 如果在執行緒啟動，但回呼是在不同的執行緒，在非同步案例中，狀態物件會封送處理，並從事件傳遞的資訊一起傳回。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，並放在交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>窺視作業在您建立的事件處理常式方法。 您的事件處理常式可能會包含功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否可讀取 <see cref="T:System.Messaging.MessageQueue" />。</summary>
        <value>如果 <see cref="T:System.Messaging.MessageQueue" /> 存在而且應用程式可以從它讀取，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 指出應用程式是否能夠查看，或從佇列接收訊息。 如果<xref:System.Messaging.MessageQueue.CanRead%2A>已`true`，則<xref:System.Messaging.MessageQueue>可以接收或窺視佇列中的訊息。 否則，它不能。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 已`false`如果佇列已開啟且獨佔的讀取權限 (或者如果它是以非獨佔存取，而這開啟<xref:System.Messaging.MessageQueue>要求獨佔存取權)，或如果應用程式並沒有足夠的權限來存取它。 如果您的應用程式會嘗試從佇列讀取時<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，存取被拒。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.CanRead%2A>屬性。  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否可寫入 <see cref="T:System.Messaging.MessageQueue" />。</summary>
        <value>如果 <see cref="T:System.Messaging.MessageQueue" /> 存在，而且應用程式可以寫入它，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 指出應用程式是否能夠將訊息傳送至佇列。 如果<xref:System.Messaging.MessageQueue.CanWrite%2A>已`true`，則<xref:System.Messaging.MessageQueue>可以傳送訊息至佇列。 否則，它不能。  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 已`false`佇列是否已開啟以獨佔寫入存取權 (或者如果它是以非獨佔存取，而這開啟<xref:System.Messaging.MessageQueue>要求獨佔存取權)，或如果應用程式並沒有足夠的權限來存取它。 如果您的應用程式嘗試寫入至佇列時<xref:System.Messaging.MessageQueue.CanWrite%2A>是`false`，存取被拒。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.CanWrite%2A>屬性。  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列分類。</summary>
        <value>表示佇列分類 (訊息佇列型別識別項) 的 <see cref="T:System.Guid" />，可讓應用程式將它的佇列分類。 預設值為 <see langword="Guid.empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 佇列分類可讓應用程式以它的佇列分類。 例如，您也可以在一個類別目錄和所有的訂單佇列，在另一個放置計費的所有佇列。  
  
 <xref:System.Messaging.MessageQueue.Category%2A>屬性可存取訊息佇列類型 ID 屬性 （也就是讀取/寫入），可透過存取**佇列屬性** 對話方塊中 電腦管理 主控台。 您可以定義新的類別。 雖然您可以使用<xref:System.Guid.NewGuid%2A>來建立類別目錄值的所有唯一<xref:System.Guid>值，這類動作是不必要。 類別目錄值必須是相異只能從其他類別，不會從所有其他<xref:System.Guid>值。 比方說，您可以指派{00000000-0000-0000-0000-000000000001}做為<xref:System.Messaging.MessageQueue.Category%2A>的一組佇列並{00000000-0000-0000-0000-000000000002}做為<xref:System.Messaging.MessageQueue.Category%2A>另一個組。  
  
 您不需要設定<xref:System.Messaging.MessageQueue.Category%2A>。 這個值可以是 `null`。  
  
 設定這個屬性修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.Category%2A>屬性。  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">佇列分類被設定為無效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除連接快取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您呼叫<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>、 移除快取中儲存的格式名稱，並關閉控制代碼開啟和儲存在快取。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例呼叫 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>。  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Messaging.MessageQueue" /> 配置的所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> 釋出相關聯的所有資源<xref:System.Messaging.MessageQueue>，如果適用的話，包含共用資源。 系統重新取得這些資源會自動是否仍然可用，例如當您呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>方法，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 當您呼叫<xref:System.Messaging.MessageQueue.Close%2A>，則所有<xref:System.Messaging.MessageQueue>直接存取 「 訊息佇列 」 佇列的屬性會被清除。<xref:System.Messaging.MessageQueue.Path%2A>， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>， <xref:System.Messaging.MessageQueue.Formatter%2A>，和<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>所有會維持原狀。  
  
 <xref:System.Messaging.MessageQueue.Close%2A> 不會不一定會釋放讀取和寫入至佇列，控制代碼，因為它們可能會共用。 您可以採取下列步驟，以確定的任何<xref:System.Messaging.MessageQueue.Close%2A>釋出至佇列的讀取和寫入控制代碼：  
  
-   建立<xref:System.Messaging.MessageQueue>使用獨佔存取權。 若要這樣做，請呼叫<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29>或是<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>建構函式，以及組`sharedModeDenyReceive`參數來`true`。  
  
-   建立<xref:System.Messaging.MessageQueue>與停用快取的連線。 若要這樣做，請呼叫<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>建構函式和 set`enableConnectionCache`參數來`false`。  
  
-   停用連線快取。 若要這樣做，請設定<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>屬性設`false`。  
  
 您應該呼叫<xref:System.Messaging.MessageQueue.Close%2A>佇列之前刪除訊息佇列伺服器上的佇列。 否則，請傳送至佇列的訊息無法擲回例外狀況，或會出現在寄不出信件佇列。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會關閉訊息佇列 」 佇列。  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 Message Queuing 伺服器上的指定路徑建立新的佇列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要建立佇列的路徑。</param>
        <summary>在指定的路徑建立非交易的訊息佇列。</summary>
        <returns>表示新佇列的 <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載來建立非交易式的 「 訊息佇列 」 佇列。  
  
 若要建立的新執行個體<xref:System.Messaging.MessageQueue>類別在您的應用程式並將它繫結至現有的佇列，請使用<xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式。 若要建立新的佇列中訊息佇列，請呼叫<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 語法`path`參數取決於佇列類型它的參考下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用 」。 「 本機電腦。 如需詳細的語法，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會建立公用和私用佇列。 它會傳送訊息至選取的佇列。  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數為 <see langword="null" /> 或空字串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定的路徑已經有佇列存在。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要建立佇列的路徑。</param>
        <param name="transactional">
          <see langword="true" /> 表示建立交易式佇列，<see langword="false" /> 表示建立非交易式佇列。</param>
        <summary>在指定的路徑建立交易或非交易的訊息佇列。</summary>
        <returns>表示新佇列的 <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載來建立異動式佇列中訊息佇列。 您可以建立非異動式佇列，藉由設定`transactional`參數來`false`或藉由呼叫的其他多載<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 若要建立的新執行個體<xref:System.Messaging.MessageQueue>類別在您的應用程式並將它繫結至現有的佇列，請使用<xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式。 若要建立新的佇列中訊息佇列，請呼叫<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 語法`path`參數取決於佇列類型它的參考下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用 」。 「 本機電腦。 如需詳細的語法，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會建立公用和私用的交易式佇列。 它會傳送訊息至選取的佇列。  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數為 <see langword="null" /> 或空字串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定的路徑已經有佇列存在。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立目前訊息佇列的新 <see cref="T:System.Messaging.Cursor" />。</summary>
        <returns>目前訊息佇列的新 <see cref="T:System.Messaging.Cursor" />。 讀取佇列的訊息時，這個資料指標用於保持佇列中的特定位置。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得佇列在訊息佇列中建立的時間和日期。</summary>
        <value>
          <see cref="T:System.DateTime" />，表示佇列的建立日期和時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> 不是指在 Message Queuing 伺服器上，佇列<xref:System.Messaging.MessageQueue>執行個體。  
  
 如果佇列存在，則這個屬性會代表的建立佇列時，調整為佇列所在伺服器的本機時間。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.CreateTime%2A>屬性。  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式傳送訊息至佇列時，會預設採用的訊息屬性值。</summary>
        <value>
          <see cref="T:System.Messaging.DefaultPropertiesToSend" />，包含應用程式向佇列傳送 <see cref="T:System.Messaging.Message" /> 執行個體以外的物件時，使用的預設 Message Queuing 訊息屬性值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您將傳送任何物件，不是類型<xref:System.Messaging.Message>至佇列，<xref:System.Messaging.MessageQueue>將物件插入至訊息佇列的訊息。 屆時<xref:System.Messaging.MessageQueue>套用至訊息中指定的屬性值<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性。 相反地，如果您傳送<xref:System.Messaging.Message>至佇列，這些屬性已指定執行個體本身，因此<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>會忽略<xref:System.Messaging.Message>。  
  
 雖然您可以設定屬性，透過<xref:System.Messaging.MessageQueue>物件，<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>參考的訊息會傳送至佇列，不代表佇列本身的屬性。  
  
 下表顯示屬性的預設值。  
  
|屬性|預設值|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|零 (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|是長度為零的位元組的陣列|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會使用訊息的優先順序，以判斷傳送訊息的預設屬性。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">無法設定佇列的預設屬性，可能是因為其中一個屬性無效。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要刪除的佇列位置。</param>
        <summary>刪除 Message Queuing 伺服器上的佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 語法`path`參數取決於佇列的類型。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
  
 如需詳細的語法，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。  
  
 或者，您可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>來描述為佇列路徑。  
  
|參考資料|語法|  
|---------------|------------|  
|格式名稱|FormatName: [*格式名稱*]|  
|標籤|標籤: [*標籤*]|  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會刪除訊息佇列 」 佇列，若有的話。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數為 <see langword="null" /> 或空字串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <paramref name="path" /> 參數的語法無效。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出這個 <see cref="T:System.Messaging.MessageQueue" /> 是否具有從訊息佇列接收訊息的獨佔存取權。</summary>
        <value>如果這個 <see cref="T:System.Messaging.MessageQueue" /> 具有從佇列接收訊息的獨佔權限，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 指定佇列所參考的共用的模式<xref:System.Messaging.MessageQueue>。 設定<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>要`true`表示，只有這<xref:System.Messaging.MessageQueue>應該查看，或從指定的佇列接收訊息的存取<xref:System.Messaging.MessageQueue.Path%2A>。 如果另一個<xref:System.Messaging.MessageQueue>或另一個應用程式相同的佇列資源，該執行個體相關聯，或是應用程式將無法查看或接收訊息，但是它仍然可以傳送它們。  
  
 如果<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>是`false`，佇列可用於傳送、 查看，或接收訊息的多個應用程式。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>屬性。  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>處置 (Dispose) <see cref="T:System.Messaging.MessageQueue" /> 所使用的資源 (除了記憶體之外)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 使用完畢時，請呼叫 <xref:System.Messaging.MessageQueue>。 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 方法會將 <xref:System.Messaging.MessageQueue> 保留在無法使用的狀態。 之後呼叫<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>，您必須釋放所有參考<xref:System.Messaging.MessageQueue>讓它所佔用的記憶體可以回收記憶體回收。  
  
 您應該呼叫<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>您釋放最後一個參考之前<xref:System.Messaging.MessageQueue>。 否則，資源<xref:System.Messaging.MessageQueue>會使用之前，將不會釋放記憶體回收集合呼叫<xref:System.Messaging.MessageQueue>物件的解構函式。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出應用程式是否會維持連接的快取。</summary>
        <value>
          <see langword="true" /> 表示建立並使用連接快取，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 連接快取是一份結構包含讀取或寫入佇列中的控制代碼的參考。 當<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>是`true`，則<xref:System.Messaging.MessageQueue>每次呼叫會藉助從快取的控制代碼<xref:System.Messaging.MessageQueue.Send%28System.Object%29>， <xref:System.Messaging.MessageQueue.Peek%2A>，或<xref:System.Messaging.MessageQueue.Receive%2A>，而不是開啟的新控制代碼。 這可以改善效能。 使用連接快取也會隔離<xref:System.Messaging.MessageQueue>從網路拓撲中的變更。  
  
 如果您建立新的連接至佇列時的連線快取已滿，<xref:System.Messaging.MessageQueue>以新的連線覆寫至少最近存取的結構。 您可以清除快取完全是藉由呼叫<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>，比方說，如果您正在使用的佇列格式名稱已經變更，使先前的讀取和寫入控制代碼不再有效。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>屬性。  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出佇列是否只接受非私用 (不加密的) 訊息。</summary>
        <value>其中一個 <see cref="T:System.Messaging.EncryptionRequired" /> 值。 預設值為 <see langword="None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您指定需要傳送至佇列的訊息加密時，則會加密訊息內文。 其他成員 (例如<xref:System.Messaging.Message.Label%2A>和<xref:System.Messaging.Message.SenderId%2A>屬性) 無法加密。  
  
 設定這個屬性修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體。  
  
 加密的訊息讓訊息私用。 您可以指定佇列的加密需求`None`， `Body`，或`Optional`藉由設定<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>屬性適當地。 <xref:System.Messaging.Message.UseEncryption%2A>訊息的設定必須對應至佇列的加密需求。 如果訊息並未加密，但佇列指定`Body`，或如果訊息已加密，但佇列指定`None`，佇列將會拒絕訊息。 如果傳送應用程式要求負值通知訊息，在此情況下，訊息佇列會指出傳送應用程式的訊息被拒絕。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性是`true`，失敗加密的訊息，傳送至無法投遞的信件佇列。 否則，訊息就會遺失。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>屬性。  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，識別要完成的非同步窺視作業，並要從其中擷取最終結果。</param>
        <summary>完成指定的非同步窺視作業。</summary>
        <returns>與完成的非同步作業相關的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Messaging.MessageQueue.PeekCompleted>引發事件時，<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>完成作業所起始的<xref:System.Messaging.MessageQueue.BeginPeek%2A>呼叫。 若要這樣做，<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>窺視的訊息。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 可以指定逾時，這會導致<xref:System.Messaging.MessageQueue.PeekCompleted>逾時發生之前出現在佇列中的訊息時產生的事件。 當沒有訊息到達佇列的後續呼叫中發生逾時<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>會擲回例外狀況。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用來讀取訊息造成<xref:System.Messaging.MessageQueue.PeekCompleted>會引發事件。  
  
 如果您想要繼續以非同步方式查看訊息，您就可以再次呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>之後呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立名為事件處理常式`MyPeekCompleted`，將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式的委派，以及呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>起始位於路徑的佇列上的非同步窺視作業 」。 \myQueue"。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，範例窺視的訊息，並將其主體寫入螢幕。 此範例接著會呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A> 以起始新的非同步窺視作業。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 參數的語法無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，識別要完成的非同步接收作業，並要從其中擷取最終結果。</param>
        <summary>完成指定的非同步接收作業。</summary>
        <returns>與完成的非同步作業相關的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>引發事件時，<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>完成作業所起始的<xref:System.Messaging.MessageQueue.BeginReceive%2A>呼叫。 若要這樣做，<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>接收訊息。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 可以指定逾時，這會導致<xref:System.Messaging.MessageQueue.ReceiveCompleted>逾時發生之前出現在佇列中的訊息時產生的事件。 當沒有訊息到達佇列的後續呼叫中發生逾時<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>會擲回例外狀況。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用來讀取 （從佇列移除） 所造成的訊息<xref:System.Messaging.MessageQueue.ReceiveCompleted>會引發事件。  
  
 如果您想要繼續以非同步方式接收訊息時，您就可以再次呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>之後呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例鏈結非同步要求。 它會假設在稱為 「 myQueue 「 本機電腦上沒有佇列。 `Main`函式開始非同步作業所處理的`MyReceiveCompleted`常式。 `MyReceiveCompleted` 處理目前的訊息，並開始新的非同步接收作業。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 參數的語法無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要尋找的佇列位置。</param>
        <summary>判斷指定路徑上是否存在訊息佇列。</summary>
        <returns>如果指定路徑上的佇列存在則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法會判斷訊息佇列 」 佇列是否存在指定的路徑。 方法不存在，以判斷是否有指定的格式名稱的佇列存在。 如需有關格式名稱語法和其他路徑的語法形式的詳細資訊，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 是成本高昂的作業。 只需要在應用程式中時，才使用它。  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法不支援<xref:System.Messaging.MessageQueue.FormatName%2A>前置詞。  
  
 語法`path`參數類型而定的佇列下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 無法呼叫來確認遠端私用佇列存在。  
  
 如需詳細的語法，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。  
  
 或者，您可以使用<xref:System.Messaging.MessageQueue.Label%2A>來描述為佇列路徑。  
  
|參考資料|語法|  
|---------------|------------|  
|標籤|標籤: [ `label` ]|  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會確認是否 「 訊息佇列 」 佇列存在，然後將它刪除。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 語法無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。  
  
-或- 
<see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> 方法會在遠端私用佇列上呼叫。</exception>
        <exception cref="T:System.InvalidOperationException">確認佇列是否存在時，應用程式會使用格式名稱語法。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息佇列在佇列建立時產生的唯一佇列名稱。</summary>
        <value>在網路上唯一的佇列名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A>屬性包含佇列的格式名稱。 訊息佇列會使用格式名稱來識別開啟的佇列，以及如何存取它。 不同於大部分的佇列的特性，格式名稱不是訊息佇列應用程式佇列屬性，因此您無法存取它透過 「 訊息佇列的管理工具。 格式名稱是只要佇列中的唯一名稱由訊息佇列的佇列或應用程式產生稍後會在建立時產生。  
  
 如果您指定使用的路徑名稱語法的路徑 (例如`myComputer\myQueue`) 而不是您讀取或寫入至佇列時，請使用格式名稱語法，主要網域控制站 （這會使用 Active Directory） 會轉譯<xref:System.Messaging.MessageQueue.Path%2A>到相關聯<xref:System.Messaging.MessageQueue.FormatName%2A>才能存取佇列。 如果您的應用程式離線工作時，您必須使用格式名稱語法;否則，主要網域控制站將無法執行路徑轉譯。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.FormatName%2A>屬性。  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 未設定。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定對佇列寫入或讀取訊息時，用來將物件序列化成訊息主體，或者從訊息主體將物件還原序列化的格式子。</summary>
        <value>產生要對訊息主體寫入或讀取的資料流的 <see cref="T:System.Messaging.IMessageFormatter" />。 預設值為 <see cref="T:System.Messaging.XmlMessageFormatter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A>屬性包含您的應用程式讀取或寫入至佇列時，轉換訊息的格式子物件的執行個體。  
  
 當應用程式傳送訊息至佇列時，格式器會將物件序列化成資料流，並將它插入訊息內文。 格式器從佇列讀取時，會將訊息資料還原序列化<xref:System.Messaging.Message.Body%2A>屬性<xref:System.Messaging.Message>。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合的因此不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化成二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
 <xref:System.Messaging.BinaryMessageFormatter> 並<xref:System.Messaging.ActiveXMessageFormatter>提供更快速的輸送量比<xref:System.Messaging.XmlMessageFormatter>。 <xref:System.Messaging.ActiveXMessageFormatter>允許與 Visual Basic 6.0 中訊息佇列應用程式的互通性。  
  
 當您的應用程式將訊息傳送至佇列<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>只適用於使用預設的訊息屬性，這些訊息<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>。 如果您傳送<xref:System.Messaging.Message>至佇列，訊息佇列會使用中定義的格式器<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>改為序列化主體的屬性。  
  
 <xref:System.Messaging.MessageQueue>一律會使用類別<xref:System.Messaging.Message>接收或窺視佇列中的訊息。 使用還原序列化訊息<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範設定格式化的訊息內文使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下列程式碼範例示範設定格式化的訊息內文使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回佇列中的所有訊息。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 型別的陣列，表示佇列中的所有訊息，順序與出現在訊息佇列中的順序一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 這些訊息會回到佇列中的訊息，非動態連結的靜態快照集。 因此，您無法使用陣列來修改佇列中的訊息。 如果您想要即時、 動態互動 （例如，若要刪除訊息的能力） 的佇列，呼叫<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>方法，這個方法會傳回佇列中訊息的動態清單。  
  
 因為<xref:System.Messaging.MessageQueue.GetAllMessages%2A>方法呼叫傳回佇列中訊息的副本時，陣列不會反映新的訊息到達佇列或從佇列中移除的訊息。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 只有在未由篩選掉的屬性會擷取<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>屬性。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>列舉佇列中的訊息。 <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> 已被取代。 應改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" />，提供佇列中訊息的動態連接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.GetEnumerator%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">包含佇列的電腦名稱，前端沒有兩條反斜線 (\\\\)。</param>
        <summary>取得這個 <see cref="T:System.Messaging.MessageQueue" /> 參考之佇列所在位置的電腦識別項。</summary>
        <returns>
          <see cref="T:System.Guid" />，表示佇列所在之電腦的唯一識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以在兩個用途，以及其他使用電腦的識別碼： 讀取電腦日誌，並設定安全性憑證。 不過，您不能呼叫<xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>遠端電腦，當您離線工作因為應用程式必須有網域控制站上的目錄服務的存取權。  
  
 電腦識別碼 （或電腦的識別項） 是<xref:System.Guid>訊息佇列在將電腦新增至企業時所建立。 訊息佇列會結合使用的電腦識別碼`Machine`並`Journal`關鍵字來建立電腦日誌的格式名稱，其語法`Machine=<computeridentifier>;Journal`。 機器筆記本中，也就是做為日誌佇列，是系統佇列會儲存副本的應用程式產生訊息的時機<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>屬性是`true`。  
  
 建構佇列格式名稱時，日誌的這個語法才有效。 路徑名稱語法是`MachineName` \\ `Journal$`。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例呼叫 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>。  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">無法擷取電腦識別項，可能是因為目錄服務無法使用；例如，如果您是離線工作。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為佇列中的所有訊息建立列舉值物件。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> 已被取代。 應改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" />，保有在佇列中所包含的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 在佇列中建立的所有訊息的動態清單。 您可以從佇列中移除的列舉值目前位置的訊息藉由呼叫<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>for<xref:System.Messaging.MessageEnumerator>的<xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>傳回。  
  
 因為資料指標相關聯的佇列中的訊息動態清單，如果訊息超出目前游標位置列舉型別會反映您對佇列中訊息所做的任何修改。 比方說，放置游標的目前位置，之後的低優先順序訊息，而不是較高優先順序訊息，插入該位置之前，可以自動存取列舉值。 不過，您可以重設列舉型別，藉此將游標移回至清單中，開頭藉由呼叫<xref:System.Messaging.MessageEnumerator.Reset%2A>針對<xref:System.Messaging.MessageEnumerator>。  
  
 列舉訊息的順序會反映在佇列中的順序，所以較高優先順序訊息會出現在較低優先順序的項目。  
  
 如果您想要它們的訊息佇列，而不是動態連接的靜態快照時，呼叫<xref:System.Messaging.MessageQueue.GetAllMessages%2A>。 這個方法傳回的陣列<xref:System.Messaging.Message>代表訊息的時呼叫該方法的物件。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例在佇列中取得訊息的動態清單和計數的所有訊息<xref:System.Messaging.Message.Priority%2A>屬性設定為<xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>。  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為佇列中的所有訊息建立列舉值物件。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" />，保有在佇列中所包含的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 在佇列中建立的所有訊息的動態清單。 您可以從佇列中移除的列舉值目前位置的訊息藉由呼叫<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>for<xref:System.Messaging.MessageEnumerator>的<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>傳回。  
  
 因為資料指標相關聯的佇列中的訊息動態清單，如果訊息超出目前游標位置列舉型別會反映您對佇列中訊息所做的任何修改。 比方說，放置游標的目前位置，之後的低優先順序訊息，而不是較高優先順序訊息，插入該位置之前，可以自動存取列舉值。 不過，您可以重設列舉型別，藉此將游標移回至清單中，開頭藉由呼叫<xref:System.Messaging.MessageEnumerator.Reset%2A>針對<xref:System.Messaging.MessageEnumerator>。  
  
 列舉訊息的順序會反映在佇列中的順序，所以較高優先順序訊息會出現在較低優先順序的項目。  
  
 如果您想要它們的訊息佇列，而不是動態連接的靜態快照時，呼叫<xref:System.Messaging.MessageQueue.GetAllMessages%2A>。 這個方法傳回的陣列<xref:System.Messaging.Message>代表訊息的時呼叫該方法的物件。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>為網路上公用佇列的動態清單建立列舉值物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>提供順向資料指標語意，以列舉網路上的所有公用佇列。</summary>
        <returns>提供網路上所有公用訊息佇列動態清單的 <see cref="T:System.Messaging.MessageQueueEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>傳回網路上的所有公用佇列的列舉。  
  
 因為資料指標相關聯的動態清單，列舉會反映您對佇列刪除或加入到資料指標的目前位置之外的佇列清單所做的任何修改。 新增或刪除的資料指標的目前位置前面的佇列不會反映。 比方說，附加超過資料指標位置的佇列，但不是其中插入該位置之前，可以自動存取列舉值。 不過，您可以重設列舉型別，藉此將游標移回至清單中，開頭藉由呼叫<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>針對<xref:System.Messaging.MessageQueueEnumerator>。  
  
 沒有佇列的網路中未定義順序。 列舉值不會排序，例如電腦、 標籤、 公用或私用狀態，或任何其他可存取的準則。  
  
 如果您想於網路，而不是動態的連線，佇列的靜態快照集時，呼叫<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>或<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>。 這兩種方法的每個傳回的陣列<xref:System.Messaging.MessageQueue>代表佇列的時呼叫該方法的物件。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會逐一查看網路中的所有訊息佇列，並檢查每個佇列的路徑。 最後，它會在網路上顯示公用佇列的數目。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">
          <see cref="T:System.Messaging.MessageQueueCriteria" />，包含用來篩選可用訊息佇列的準則。</param>
        <summary>提供順向資料指標語意，以列舉網路上所有符合指定準則的公用佇列。</summary>
        <returns>提供網路上所有公用訊息佇列動態清單的 <see cref="T:System.Messaging.MessageQueueEnumerator" />，其符合 <paramref name="criteria" /> 參數指定的限制。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>傳回符合準則的應用程式準則中所定義的網路上的所有公用佇列的清單。 您可以指定建立或修改的時間、 電腦名稱、 標籤、 類別或上述任何組合，例如，排入佇列要包括的準則。  
  
 因為資料指標相關聯的動態清單，列舉會反映您對資料指標的目前位置之後，就會發生的佇列進行任何修改。 佇列資料指標的目前位置前面的變更不會反映。 比方說，附加超過資料指標位置的佇列，但不是其中插入該位置之前，可以自動存取列舉值。 不過，您可以重設列舉型別，藉此將游標移回至清單中，開頭藉由呼叫<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>針對<xref:System.Messaging.MessageQueueEnumerator>。  
  
 沒有佇列的網路中未定義順序。 列舉值不會排序，例如電腦、 標籤、 公用或私用狀態，或任何其他可存取的準則。  
  
 如果您想於網路，而不是動態的連線，佇列的靜態快照集時，指定的準則<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>或致電<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>。 這兩種方法的每個傳回的陣列<xref:System.Messaging.MessageQueue>代表佇列的時呼叫該方法的物件。 呼叫<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>，或<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>提供相同的結果，與呼叫<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>使用的篩選準則<xref:System.Messaging.MessageQueue.Category%2A>， <xref:System.Messaging.MessageQueue.Label%2A>，和<xref:System.Messaging.MessageQueue.MachineName%2A>分別。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會逐一查看訊息佇列，並顯示"MyComputer"的電腦上的最後一天中建立且存在於每個佇列的路徑。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">要從其中擷取私用佇列的電腦。</param>
        <summary>擷取所指定電腦上的所有私用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的私用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 擷取指定的電腦上的佇列的靜態快照集。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數為 <see langword="null" /> 或空字串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>擷取網路上所有的公用佇列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取網路上所有的公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您想在網路上的所有公用佇列的完整清單，請使用此多載。 如果您想要限制特定準則，例如<xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Category%2A>，或上次修改的時間使用這個方法的另一個多載。 (或者，您可以使用<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>，或<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>。)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 擷取佇列的靜態快照集。 若要互動的佇列動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">
          <see cref="T:System.Messaging.MessageQueueCriteria" />，包含用來篩選佇列的準則。</param>
        <summary>擷取網路上符合指定準則的所有公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您要據以篩選標籤、 類別或電腦名稱，在網路上的所有公用佇列<xref:System.Messaging.MessageQueue>類別包含提供該功能的特定方法 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>，和<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>分別)。 您可以使用此多載，取得一份所有公用佇列在網路上符合一個以上的這些準則 （例如，如果您想要指定標籤和分類）。 您也可以篩選以外的訊息準則<xref:System.Messaging.MessageQueue.Label%2A>， <xref:System.Messaging.MessageQueue.Category%2A>，和<xref:System.Messaging.MessageQueue.MachineName%2A>。 例如，您可以使用這個多載來篩選佇列的上次修改時間。 只要建立的新執行個體<xref:System.Messaging.MessageQueueCriteria>類別，請設定適當的內容中執行個體，以及傳遞做為執行個體`criteria`參數。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 擷取佇列的靜態快照集。 若要互動的佇列動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">
          <see cref="T:System.Guid" />，會將要擷取的佇列集設為群組。</param>
        <summary>擷取網路上屬於指定分類的所有公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來依類別篩選公用佇列。 <xref:System.Messaging.MessageQueue.Category%2A>屬性會提供對訊息佇列類型 ID 屬性 （也就是讀取/寫入） 的特定佇列的存取。 雖然您可以使用<xref:System.Guid.NewGuid%2A>來建立類別目錄值的所有唯一<xref:System.Guid>值，不需要。 類別目錄值必須是相異只能從其他類別，不會從所有其他<xref:System.Guid>值。 比方說，您可以指派{00000000-0000-0000-0000-000000000001}做為<xref:System.Messaging.MessageQueue.Category%2A>的一組佇列並{00000000-0000-0000-0000-000000000002}做為<xref:System.Messaging.MessageQueue.Category%2A>另一個組。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 擷取佇列的靜態快照集。 若要互動的佇列動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 您可以將類別指定為一部分<xref:System.Messaging.MessageQueueCriteria>您傳遞至方法。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">標記，該標記會將要擷取的佇列集設為群組。</param>
        <summary>擷取網路上具有指定標籤的所有公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來依標籤篩選公用佇列。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 擷取佇列的靜態快照集。 若要互動的佇列動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 您可以指定標籤的一部分<xref:System.Messaging.MessageQueueCriteria>您傳遞至方法。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">電腦的名稱，包含要擷取的公用佇列集。</param>
        <summary>擷取位於指定電腦上的所有公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考電腦上的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，以篩選電腦公用佇列。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 擷取佇列的靜態快照集。 若要互動的佇列動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 您可以指定電腦名稱的一部分<xref:System.Messaging.MessageQueueCriteria>您傳遞至方法。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數的語法不正確。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取 MSMQ 在這次呼叫時與目前使用者 (執行緒識別) 產生關聯的安全性內容。</summary>
        <returns>包含安全性內容的 <see cref="T:System.Messaging.SecurityContext" /> 物件。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得佇列的唯一訊息佇列識別項。</summary>
        <value>
          <see cref="P:System.Messaging.MessageQueue.Id" />，表示 Message Queuing 應用程式所產生的訊息識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列設定<xref:System.Messaging.MessageQueue.Id%2A>屬性時它會建立佇列。 這個屬性只適用於公用佇列。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.Id%2A>屬性。  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定佇列沒有大小限制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定時，經常會使用這個成員<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>或<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Messaging.MessageQueue.InfiniteQueueSize>成員。  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定窺視 (Peek) 或接收訊息的方法沒有逾時限制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> 支援兩種擷取訊息類型： 同步和非同步。 同步方法中，<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.Receive%2A>，使得處理序執行緒等待新訊息到達佇列中指定的時間間隔。 如果指定的時間間隔是<xref:System.Messaging.MessageQueue.InfiniteTimeout>，處理序執行緒會保持封鎖，直到新的訊息。 相反地，<xref:System.Messaging.MessageQueue.BeginPeek%2A>和<xref:System.Messaging.MessageQueue.BeginReceive%2A>（非同步的方法），允許主應用程式工作繼續在個別的執行緒，直到訊息抵達佇列中。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Messaging.MessageQueue.InfiniteTimeout>成員。  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列描述。</summary>
        <value>訊息佇列的標記。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列標籤的最大長度為 124 個字元。  
  
 <xref:System.Messaging.MessageQueue.Label%2A>屬性不需要是唯一的所有佇列。 不過，如果多個佇列都共用相同<xref:System.Messaging.MessageQueue.Label%2A>，您無法使用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>廣播到所有訊息的方法。 如果您使用的標籤語法<xref:System.Messaging.MessageQueue.Path%2A>當您傳送訊息的屬性，將會擲回例外狀況<xref:System.Messaging.MessageQueue.Label%2A>不是唯一的。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.Label%2A>屬性。  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">標籤設為無效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得上次修改佇列屬性的時間。</summary>
        <value>
          <see cref="T:System.DateTime" />，指出佇列屬性上次修改的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立佇列時，包含上次修改時間和任何<xref:System.Messaging.MessageQueue>屬性，例如修改訊息佇列 」 佇列， <xref:System.Messaging.MessageQueue.BasePriority%2A>。 值<xref:System.Messaging.MessageQueue.LastModifyTime%2A>屬性代表本機電腦的系統時間。  
  
 您必須呼叫<xref:System.Messaging.MessageQueue.Refresh%2A>才能<xref:System.Messaging.MessageQueue.LastModifyTime%2A>屬性; 否則修改相關聯的時間與這個<xref:System.Messaging.MessageQueue>可能不是最新資訊。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.LastModifyTime%2A>屬性。  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息佇列位置的電腦名稱。</summary>
        <value>佇列位置的電腦名稱。 訊息佇列預設是 "."，也就是本機電腦。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A>是不可或缺的元件之佇列的易記名稱語法<xref:System.Messaging.MessageQueue.Path%2A>。 下表顯示當您想要找出使用其易記名稱的佇列路徑時，您應該使用佇列指定之型別的語法。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
|電腦日誌佇列|`MachineName`\\`Journal$`|  
|機器無法投遞的信件佇列|`MachineName`\\`Deadletter$`|  
|電腦交易式寄不出信件佇列|`MachineName`\\`XactDeadletter$`|  
  
 使用 」。 「 本機電腦時指定<xref:System.Messaging.MessageQueue.MachineName%2A>。 比方說，辨識這個屬性中，只有電腦名稱`Server0`。 <xref:System.Messaging.MessageQueue.MachineName%2A>屬性不支援 IP 位址的格式。  
  
 如果您定義<xref:System.Messaging.MessageQueue.Path%2A>的形式<xref:System.Messaging.MessageQueue.MachineName%2A>，應用程式在離線工作，因為網域控制站是所需路徑轉譯時，會擲回例外狀況。 因此，您必須使用<xref:System.Messaging.MessageQueue.FormatName%2A>針對<xref:System.Messaging.MessageQueue.Path%2A>離線工作時的語法。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Path%2A>，和<xref:System.Messaging.MessageQueue.QueueName%2A>相關屬性。 變更<xref:System.Messaging.MessageQueue.MachineName%2A>屬性會導致<xref:System.Messaging.MessageQueue.Path%2A>来變更屬性。 它會從新的內建<xref:System.Messaging.MessageQueue.MachineName%2A>而<xref:System.Messaging.MessageQueue.QueueName%2A>。 變更<xref:System.Messaging.MessageQueue.Path%2A>（例如，若要使用的格式名稱語法） 會重設<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>屬性，以參考新的佇列。 如果<xref:System.Messaging.MessageQueue.QueueName%2A>屬性是空的<xref:System.Messaging.MessageQueue.Path%2A>設為您指定之電腦的日誌佇列。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.MachineName%2A>屬性。  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">電腦的名稱無效，可能是因為語法不正確。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定日誌佇列的最大大小。</summary>
        <value>日誌佇列大小的最大值 (以 KB 為單位)。 訊息佇列預設不指定上限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 提供訊息佇列的日誌存放區限制的存取。 它是相關時，才<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>是`true`。 設定這個屬性修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體  
  
 如果您將訊息儲存在日誌或寄不出信件佇列中時，您應該定期清除佇列，以便移除不再需要的訊息。 這類佇列中的訊息都會計入佇列所在的電腦的訊息配額。 （系統管理員將電腦配額）。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>屬性。  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">日誌佇列的最大值設定為無效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列的最大值。</summary>
        <value>佇列的最大值 (以 KB 計)。 訊息佇列預設不指定上限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>提供訊息佇列訊息存放區限制，也就是電腦的系統管理員定義的訊息配額不同的存取。 如需詳細的訊息配額的詳細資訊，請參閱<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>。  
  
 設定這個屬性修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體  
  
 如果嘗試超過佇列大小上限或電腦的訊息配額時，訊息可能會遺失。 當到達佇列配額時，訊息佇列通知，表示佇列已滿，藉由傳回負值通知訊息傳送的應用程式的管理佇列。 訊息佇列會繼續傳送負值通知，直到佇列中訊息的總大小低於限制。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>屬性。  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">佇列大小的最大值包含負值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定接收或窺視訊息的屬性篩選條件。</summary>
        <value>佇列用來為每個訊息篩選它所接收或窺視的屬性集的 <see cref="T:System.Messaging.MessagePropertyFilter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此篩選器是一組限制的訊息屬性的布林值，<xref:System.Messaging.MessageQueue>接收或窺視。 當<xref:System.Messaging.MessageQueue>接收或窺視訊息從伺服器佇列中，它會擷取只有屬性為其<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>值是`true`。  
  
 下圖顯示的初始屬性值的<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>屬性。 這些設定是相同於呼叫<xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A>上<xref:System.Messaging.MessagePropertyFilter>。  
  
|屬性|預設值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 個位元組|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 個位元組|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 個位元組|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>限制接收的訊息內容。  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">篩選條件為 <see langword="null" />。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 MSMQ 3.0 中介紹。 取得或設定與佇列相關聯的多點傳送位址。</summary>
        <value>
          <see cref="T:System.String" />，包含有效的多點傳送位址 (在下面所示的表單中)，否則為 <see langword="null" />，表示佇列未與多點傳送位址相關聯。  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A>屬性用來傳送訊息時可以使用多點傳送位址相關聯的非交易式佇列。 您無法關聯多點傳送位址的異動式佇列。 傳送應用程式會將訊息傳送至多點傳送位址，當訊息佇列將訊息的複本傳送至該位址相關聯的每個佇列。  
  
 IP 多點傳送位址必須在類別 D 範圍從 224.0.0.0 至 239.255.255.255，其對應於設定的前四個高序位位元等於 1110年。 不過，只有某些特定的這個範圍內的位址範圍會保留供傳送多點傳送的訊息。 如需保留的多點傳送位址的最新清單，請參閱[Internet Assigned 數目 Authority (IANA) 網際網路多點傳送位址](https://go.microsoft.com/fwlink/?linkid=3859)網頁。 沒有任何限制在連接埠號碼。  
  
 如果幾部來源電腦傳送多點傳送的訊息，而且您想要特定的佇列，接收來自只有一台來源電腦的訊息，每台來源電腦必須傳送訊息至不同的 IP 位址和連接埠號碼組合。  
  
 若要中斷關聯來自多點傳送位址的佇列，將<xref:System.Messaging.MessageQueue.MulticastAddress%2A>屬性設為零長度字串。 請勿將它設為`null`，因為這會導致<xref:System.ArgumentNullException>。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列路徑。 設定 <see cref="P:System.Messaging.MessageQueue.Path" /> 會使 <see cref="T:System.Messaging.MessageQueue" /> 指向新佇列。</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列。 預設值取決於您使用的 <see cref="M:System.Messaging.MessageQueue.#ctor" /> 建構函式，可以是 <see langword="null" />，或者是由建構函式的 <paramref name="path" /> 參數指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 語法<xref:System.Messaging.MessageQueue.Path%2A>屬性取決於佇列類型它點到下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
|電腦日誌佇列|`MachineName`\\`Journal$`|  
|機器無法投遞的信件佇列|`MachineName`\\`Deadletter$`|  
|電腦交易式寄不出信件佇列|`MachineName`\\`XactDeadletter$`|  
  
 使用"。"代表本機電腦。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Path%2A>，和<xref:System.Messaging.MessageQueue.QueueName%2A>相關屬性。 變更<xref:System.Messaging.MessageQueue.MachineName%2A>屬性會導致<xref:System.Messaging.MessageQueue.Path%2A>来變更屬性。 它會從新的內建<xref:System.Messaging.MessageQueue.MachineName%2A>而<xref:System.Messaging.MessageQueue.QueueName%2A>。 變更<xref:System.Messaging.MessageQueue.Path%2A>（例如，若要使用的格式名稱語法） 會重設<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>屬性，以參考新的佇列。  
  
 或者，您可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>來描述佇列路徑下, 表所示。  
  
|參考資料|語法|範例|  
|---------------|------------|-------------|  
|格式名稱|`FormatName:` [*格式名稱*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|標籤|`Label:` [*標籤*]|`Label:` TheLabel|  
  
 如果您使用的標籤語法<xref:System.Messaging.MessageQueue.Path%2A>當您傳送訊息的屬性，將會擲回例外狀況<xref:System.Messaging.MessageQueue.Label%2A>不是唯一的。  
  
 離線工作，您必須使用格式名稱語法中，而不是好記名稱語法中的第一個資料表。 否則，因為網域主控站 （Active Directory 所在） 不適用於將路徑解析成的格式名稱，便會擲回例外狀況。  
  
 設定新的路徑時，關閉訊息佇列，並釋放所有控制代碼。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|[是]|  
  
> [!NOTE]
>  工作群組模式中，您可以只使用私用佇列。 您指定的路徑使用私用佇列語法`MachineName` \\ `Private$` \\ `QueueName`。  
  
   
  
## Examples  
 下列程式碼範例，請建立新<xref:System.Messaging.MessageQueue>物件使用不同的路徑名稱語法類型。 在每個案例中，它會傳送訊息至佇列的路徑定義於建構函式。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路徑無效，可能是因為語法無效。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <summary>傳回佇列中第一個訊息的複本，但不從佇列中移除訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回而不移除 (窺視) 這個 <see cref="T:System.Messaging.MessageQueue" /> 所參考佇列中的第一個訊息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此會封鎖目前的執行緒，直到訊息可以使用為止。</summary>
        <returns>表示佇列中第一個訊息的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窺視佇列，或等候直到佇列中有一則訊息，請使用此多載。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法讀取，但不會移除，第一個訊息從佇列中。 因此，重複呼叫<xref:System.Messaging.MessageQueue.Peek%2A>傳回相同的訊息，除非較高優先權的訊息到達佇列。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，相反地，讀取和移除佇列中的第一個訊息。 重複呼叫<xref:System.Messaging.MessageQueue.Receive%2A>，因此，會傳回不同的訊息。  
  
 訊息佇列中優先權和抵達時間根據佇列的訂單訊息。 較新的訊息會放之前舊，優先順序較高的才。  
  
 當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 因為這個多載未指定逾時，應用程式可能會無限期等候。 當您需要應用程式繼續執行而不要等候，請使用非同步的 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。 或者，您可以在其中指定的逾時訊息到達佇列中所使用的多載<xref:System.Messaging.MessageQueue.Peek%2A>，指定逾時。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列範例會使用<xref:System.Messaging.MessageQueue.Peek%2A>佇列上的方法。  
  
 在第一個範例中，應用程式會等候直到佇列中訊息可用為止。 請注意第一個範例不會存取訊息抵達;此外，它只會暫停處理，直到訊息抵達。 如果佇列中已有一則訊息，它會立即傳回。  
  
 在第二個範例中，包含應用程式定義的訊息`Order`類別會傳送至佇列，並接著會從佇列查看。  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待含有訊息之佇列的最長時間。</param>
        <summary>傳回而不移除 (窺視) 這個 <see cref="T:System.Messaging.MessageQueue" /> 所參考佇列中的第一個訊息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此會封鎖目前的執行緒，直到訊息可以使用或發生指定的逾時為止。</summary>
        <returns>表示佇列中第一個訊息的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要查看佇列中，或等候一段指定的時間，直到有訊息在佇列中，請使用此多載。 如果佇列中已有一則訊息的方法會立即傳回。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法讀取，但不會移除，第一個訊息從佇列中。 因此，重複呼叫<xref:System.Messaging.MessageQueue.Peek%2A>傳回相同的訊息，除非較高優先權的訊息到達佇列。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，相反地，讀取和移除佇列中的第一個訊息。 重複呼叫<xref:System.Messaging.MessageQueue.Receive%2A>，因此，會傳回不同的訊息。  
  
 訊息佇列中優先權和抵達時間根據佇列的訂單訊息。 較新的訊息會放之前舊，優先順序較高的才。  
  
 當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 執行緒將會遭到封鎖，最多一段指定的時間，或無限期地如果指出<xref:System.Messaging.MessageQueue.InfiniteTimeout>。 當您需要應用程式繼續執行而不要等候，請使用非同步的 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Messaging.MessageQueue.Peek%2A>方法來檢查佇列是否是空的零的逾時。  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待含有訊息之佇列的最長時間。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="action">其中一個 <see cref="T:System.Messaging.PeekAction" /> 值。 指出要窺視佇列中的目前訊息，還是下一則訊息。</param>
        <summary>使用指定的游標傳回而不移除 (窺視) 佇列中的目前或下一則訊息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此會封鎖目前的執行緒，直到訊息可以使用或發生指定的逾時為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，表示佇列中的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要查看佇列中，或等候一段指定的時間，直到有訊息在佇列中，請使用此多載。 如果佇列中已有一則訊息的方法會立即傳回。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法讀取，但不會移除，將訊息從佇列。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，相反地，同時讀取，並從佇列移除訊息。  
  
 當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 最多一段指定的時間，或無限期封鎖執行緒如果指出<xref:System.Messaging.MessageQueue.InfiniteTimeout>。 當您需要應用程式繼續執行而不要等候，請使用非同步的 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">為 <paramref name="action" /> 參數指定 <see langword="PeekAction.Current" /> 或 <see langword="PeekAction.Next" /> 以外的值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。 可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>窺視符合指定關聯識別項的訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">要窺視訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>窺視符合指定關聯識別項的訊息，而且在佇列中目前沒有指定關聯識別項的訊息時，立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會查詢中參考的佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數，擲回例外狀況。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來繫結至相關聯的回應、 報表或通知訊息佇列傳送的訊息。  
  
 另外兩個方法可讓您查看佇列中的訊息。 <xref:System.Messaging.MessageQueue.Peek%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法用來擷取訊息，藉由指定的唯一識別碼。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會傳送，並收到包含訂單與佇列的訊息。 它特別要求正面確認通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">要窺視訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>窺視符合指定的關聯識別項的訊息，並且等候佇列中出現具有指定關聯識別項的訊息，或者等候直到逾時到期。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會查詢中參考的佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數，以及任何新訊息到達佇列中所指定的期間內`timeout`參數，擲回例外狀況。  
  
 `timeout`參數未指定這個方法的執行時間總計。 相反地，它會指定等待新訊息到達佇列中的時間。 每當新訊息送達時，此方法會檢查<xref:System.Messaging.Message.CorrelationId%2A>的新的訊息，以查看它是否符合`correlationId`參數。 否則，這個方法會開始逾時期限，並等候另一個新訊息到達。 因此，如果新的訊息會繼續逾時期間內抵達時，可能會此方法才能繼續無限期執行的逾時期限到期且沒有任何新的訊息抵達之前或直到訊息抵達其<xref:System.Messaging.Message.CorrelationId%2A>符合`correlationId`參數。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來繫結至相關聯的回應、 報表或通知訊息佇列傳送的訊息。  
  
 另外兩個方法可讓您查看佇列中的訊息。 <xref:System.Messaging.MessageQueue.Peek%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法用來擷取訊息，藉由指定的唯一識別碼。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.InvalidOperationException">佇列中沒有具有指定 <paramref name="correlationId" /> 的訊息，且該訊息未在逾時到期前到達。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回具有指定訊息識別項的訊息複本，但不從佇列中移除訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要窺視訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>窺視訊息識別項符合 <paramref name="id" /> 參數的訊息。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 屬性符合 <paramref name="id" /> 參數的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>讀取，但不從佇列中移除具有已知的訊息識別項的訊息。 訊息的識別碼是唯一的訊息佇列企業，，因此會有最多一個訊息在佇列中符合指定`id`參數。 如果佇列目前也不會包含訊息，則這個多載會擲回例外狀況。  
  
 兩個額外的方法可讓您查看佇列中的訊息：<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 <xref:System.Messaging.MessageQueue.Peek%2A>方法會傳回第一個訊息在佇列中;<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>傳回通知、 報表或已傳送至佇列的訊息而建立的應用程式所產生的回應訊息。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">具有指定 <paramref name="id" /> 的訊息不存在。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">要窺視訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>窺視訊息識別項符合 <paramref name="id" /> 參數的訊息。 等待直到訊息出現在佇列中，或等到發生逾時。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 屬性符合 <paramref name="id" /> 參數的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>讀取，但不從佇列中移除具有已知的訊息識別項的訊息。 訊息的識別碼是唯一的訊息佇列企業，，因此會有最多一個訊息在佇列中符合指定`id`參數。 如果佇列目前也不會包含訊息，而且發生逾時前未到達的新訊息，則這個多載會擲回例外狀況。  
  
 `timeout`參數未指定這個方法的執行時間總計。 相反地，它會指定等待新訊息到達佇列中的時間。 每當新訊息送達時，此方法會檢查<xref:System.Messaging.Message.Id%2A>的新的訊息，以查看它是否符合`id`參數。 否則，這個方法會開始逾時期限，並等候另一個新訊息到達。 因此，如果新的訊息會繼續逾時期間內抵達時，可能會此方法才能繼續無限期執行的逾時期限到期且沒有任何新的訊息抵達之前或直到訊息抵達其<xref:System.Messaging.Message.Id%2A>符合`id`參數。  
  
 兩個額外的方法可讓您查看佇列中的訊息：<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 <xref:System.Messaging.MessageQueue.Peek%2A>方法會傳回第一個訊息在佇列中;<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>傳回通知、 報表或已傳送至佇列的訊息而建立的應用程式所產生的回應訊息。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.InvalidOperationException">佇列中沒有具有指定 <paramref name="id" /> 的訊息，且該訊息未在 <paramref name="timeout" /> 參數指定的逾時到期前到達。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 MSMQ 3.0 中介紹。 窺視佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">要窺視之訊息的 <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>在 MSMQ 3.0 中介紹。 窺視符合非交易佇列之指定查詢識別項的訊息。</summary>
        <returns>傳入符合 <paramref name="lookupId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.LookupId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取已知的查詢識別項的訊息而不從佇列中移除。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，因此會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 讀取具有指定的查詢識別碼的訊息，並且從佇列中移除，請使用<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>方法。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定如何在佇列中讀取訊息。 請指定下列其中一個選項： 
 <see langword="MessageLookupAction.Current" />：窺視 <paramref name="lookupId" /> 指定的訊息。  
  
 <see langword="MessageLookupAction.Next" />：窺視 <paramref name="lookupId" /> 指定的訊息後面的訊息。  
  
 <see langword="MessageLookupAction.Previous" />：窺視 <paramref name="lookupId" /> 指定的訊息前面的訊息。  
  
 <see langword="MessageLookupAction.First" />：窺視佇列中的第一則訊息。 <paramref name="lookupId" /> 參數必須設定為 0。  
  
 <see langword="MessageLookupAction.Last" />：窺視佇列中的最後一則訊息。 <paramref name="lookupId" /> 參數必須設定為 0。</param>
        <param name="lookupId">要窺視之訊息的 <see cref="P:System.Messaging.Message.LookupId" />，或者為 0。 存取佇列中第一則或最後一則訊息時會使用 0。</param>
        <summary>在 MSMQ 3.0 中介紹。 窺視佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
        <returns>傳入之 <paramref name="action" /> 和 <paramref name="lookupId" /> 參數所指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取已知的查詢識別項的訊息而不從佇列中移除。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，因此會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 讀取具有指定識別碼的訊息，並且從佇列中移除，請使用<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>方法。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 成員。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於訊息已讀取但未從佇列中移除時。 這是非同步作業 <see cref="M:System.Messaging.MessageQueue.BeginPeek" /> 的結果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 在非同步處理用來引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件佇列中出現一則訊息時。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用來完成的呼叫所起始的作業<xref:System.Messaging.MessageQueue.BeginPeek%2A>和窺視訊息時<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件。  
  
 建立 <xref:System.Messaging.PeekCompletedEventHandler> 委派時，必須識別處理事件的方法。 若要使事件與您的事件處理常式產生關聯，請將委派的執行個體 (Instance) 加入至事件。 除非您移除委派，否則每當事件發生時就會呼叫事件處理常式。 如需有關事件處理常式委派的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立名為事件處理常式`MyPeekCompleted`，將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式的委派，以及呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>起始位於路徑的佇列上的非同步窺視作業 」。 \myQueue"。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，範例窺視的訊息，並將其主體寫入螢幕。 此範例接著會呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A> 以起始新的非同步窺視作業  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刪除佇列中所包含的所有訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 清除佇列會導致訊息佇列設定的佇列修改旗標，會影響<xref:System.Messaging.MessageQueue.LastModifyTime%2A>屬性。 從佇列中清除的訊息都會遺失。它們不會傳送到寄不出信件佇列或日誌佇列。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Purge%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定識別佇列的易記名稱。</summary>
        <value>名稱，識別這個 <see cref="T:System.Messaging.MessageQueue" /> 所參考的佇列。 這個值不能為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以結合<xref:System.Messaging.MessageQueue.QueueName%2A>具有<xref:System.Messaging.MessageQueue.MachineName%2A>建立易記<xref:System.Messaging.MessageQueue.Path%2A>佇列的名稱。 易記名稱變化的語法<xref:System.Messaging.MessageQueue.Path%2A>屬性相依於佇列的類型下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
  
 使用"."代表本機電腦。  
  
 變更<xref:System.Messaging.MessageQueue.QueueName%2A>屬性會影響<xref:System.Messaging.MessageQueue.Path%2A>屬性。 如果您設定<xref:System.Messaging.MessageQueue.QueueName%2A>未設定<xref:System.Messaging.MessageQueue.MachineName%2A>屬性，<xref:System.Messaging.MessageQueue.Path%2A>屬性會變成.\\`QueueName`。 否則，請<xref:System.Messaging.MessageQueue.Path%2A>會變成`MachineName` \\ `QueueName`。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.QueueName%2A>屬性。  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">佇列名稱是 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來從訊息佇列讀取訊息的原生控制代碼。</summary>
        <value>用來從佇列窺視或接收訊息之原生佇列物件的控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A>提供原生的 Windows 控制代碼，用於窺視或從佇列接收訊息的訊息佇列物件。 如果您變更佇列的路徑，控制代碼就會關閉，並重新開啟新的值。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <summary>接收佇列中的第一個訊息，並將它從佇列中移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 參考的第一個在佇列中可用的訊息。 這個呼叫是同步的，而且會阻礙目前執行的執行緒，直到訊息可以使用。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載，從佇列接收訊息，或等候直到佇列中有訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法是用來同步讀取一個訊息，藉此從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回依照在佇列中，或新的、 較高優先順序訊息的訊息。  
  
 若要讀取佇列中的第一個訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 因為這個多載<xref:System.Messaging.MessageQueue.Receive%2A>方法指定無限逾時，應用程式可能會無限期等候。 如果應用程式處理應該繼續進行，而不需等待訊息，請考慮使用非同步方法中， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼中，從佇列接收訊息，並輸出該訊息至螢幕的相關資訊。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 參考的第一個在交易佇列中可用的訊息。 這個呼叫是同步的，而且會阻礙目前執行的執行緒，直到訊息可以使用。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收訊息的異動式佇列，使用所定義的內部交易內容中使用此多載`transaction`參數或等候直到佇列中有訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法是用來同步讀取一個訊息，藉此從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回依照訊息在佇列中。  
  
 因為異動式佇列上呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的第一個訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會的移除任何訊息在佇列中，就是不會回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 因為這個多載<xref:System.Messaging.MessageQueue.Receive%2A>方法指定無限逾時，應用程式可能會無限期等候。 如果應用程式處理應該繼續進行，而不需等待訊息，請考慮使用非同步方法中， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會連接到本機電腦上的異動式佇列，並將訊息傳送至佇列。 然後，它會接收包含訂單的訊息。 如果發生非異動式佇列，則會擲回例外狀況並回復交易。  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。  
  
-或- 
該佇列是非交易式佇列。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 參考的第一個在佇列中可用的訊息。 這個呼叫是同步的，而且會阻礙目前執行的執行緒，直到訊息可以使用。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使用交易內容所定義的佇列中接收的訊息中使用此多載`transactionType`參數或等候直到佇列中有訊息。  
  
 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息視為單一的內部交易。 您可以指定`None`如果您想要從交易內容外的異動式佇列接收訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法是用來同步讀取一個訊息，藉此從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回依照訊息在佇列中。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的第一個訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會的移除任何訊息在佇列中，就是不會回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 因為這個多載<xref:System.Messaging.MessageQueue.Receive%2A>方法指定無限逾時，應用程式可能會無限期等候。 如果應用程式處理應該繼續進行，而不需等待訊息，請考慮使用非同步方法中， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 所參考之佇列中的第一個可用訊息，並等候直到佇列中有可用訊息，或者逾時到期。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載來接收訊息，如果佇列中沒有訊息，則在指定時間期限傳回。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法是用來同步讀取一個訊息，它從佇列中移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回依照在佇列中，或新的、 較高優先順序訊息的訊息。  
  
 若要讀取佇列中的第一個訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 執行緒會封鎖一段指定的時間，或無限期地如果指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>針對`timeout`參數。 如果應用程式處理應該繼續進行，而不需等待訊息，請考慮使用非同步方法中， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼中，從佇列接收訊息，並輸出該訊息至螢幕的相關資訊。 此範例會暫停執行五秒的時間等候訊息到達佇列中。  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <summary>使用指定的游標接收佇列中的目前訊息。 如果沒有可用的訊息，則這個方法會等到有訊息可用或逾時為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤 
使用這個多載來接收訊息，如果佇列中沒有訊息，則在指定時間期限傳回。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 所參考之交易佇列中的第一個可用訊息，並且等候直到佇列中出現可用訊息，或逾時過期為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收訊息的異動式佇列，使用所定義的內部交易內容中使用此多載`transaction`參數，並傳回指定的一段時間，如果佇列中沒有訊息內。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法是用來同步讀取一個訊息，藉此從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回依照訊息在佇列中。  
  
 因為異動式佇列上呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的第一個訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會的移除任何訊息在佇列中，就是不會回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 執行緒會封鎖一段指定的時間，或無限期地如果指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>針對`timeout`參數。 如果應用程式處理應該繼續進行，而不需等待訊息，請考慮使用非同步方法中， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個方法。  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
-或- 
該佇列是非交易式佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 參考的第一個在佇列中可用的訊息。 這個呼叫是同步的，並且會等候直到佇列中出現可用訊息，或逾時過期為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使用交易內容所定義的佇列中接收的訊息中使用此多載`transactionType`參數，並在一段指定時間，如果佇列中沒有任何訊息中的傳回。  
  
 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息視為單一的內部交易。 您可以指定`None`如果您想要從交易內容外的異動式佇列接收訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法是用來同步讀取一個訊息，藉此從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回依照訊息在佇列中。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的第一個訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會的移除任何訊息在佇列中，就是不會回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 執行緒會封鎖一段指定的時間，或無限期地如果指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>針對`timeout`參數。 如果應用程式處理應該繼續進行，而不需等待訊息，請考慮使用非同步方法中， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個方法。  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>使用指定的游標接收佇列中的目前訊息。 如果沒有可用的訊息，則這個方法會等到有訊息可用或逾時為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收訊息的異動式佇列，使用所定義的內部交易內容中使用此多載`transaction`參數，並傳回指定的一段時間，如果佇列中沒有訊息內。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法是用來同步讀取一個訊息，藉此從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>遵循的訊息傳回佇列中。  
  
 因為異動式佇列上呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會的移除任何訊息在佇列中，進行任何回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 為給定的期間內的時間，或無限期封鎖執行緒如果指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>針對`timeout`參數。 如果應用程式處理應該繼續進行，而不需等待訊息，請考慮使用非同步方法中， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。 可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
-或- 
該佇列是非交易式佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息產生關聯的交易內容類型。</param>
        <summary>使用指定的游標接收佇列中的目前訊息。 如果沒有可用的訊息，則這個方法會等到有訊息可用或逾時為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使用交易內容所定義的佇列中接收的訊息中使用此多載`transactionType`參數，並在一段指定時間，如果佇列中沒有任何訊息中的傳回。  
  
 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息視為單一的內部交易。 您可以指定`None`如果您想要從交易內容外的異動式佇列接收訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法是用來同步讀取一個訊息，藉此從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>遵循的訊息傳回佇列中。  
  
 如果從交易佇列中接收的訊息呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會的移除任何訊息在佇列中，進行任何回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 為給定的期間內的時間，或無限期封鎖執行緒如果指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>針對`timeout`參數。 如果應用程式處理應該繼續進行，而不需等待訊息，請考慮使用非同步方法中， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。 可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>此方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收符合指定關聯識別項的訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>接收符合指定關聯識別項的訊息 (從非交易佇列中)，如果佇列中目前不存在具有指定關聯識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會查詢中參考的非交易式佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數，擲回例外狀況。 否則，訊息是從佇列中移除，並傳回給應用程式。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來繫結至相關聯的回應、 報表或通知訊息佇列傳送的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法會擷取一則訊息，藉由指定的唯一識別碼。  
  
 若要讀取具有指定的關聯識別項的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會傳送，並收到包含訂單與佇列的訊息。 它特別要求正面確認通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收符合指定關聯識別項的訊息 (從交易佇列中)，如果佇列中目前不存在具有指定關聯識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會查詢中參考的交易式佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數，擲回例外狀況。 訊息會從佇列中移除並傳回應用程式使用所定義的內部交易內容，否則為`transaction`參數。  
  
 因為異動式佇列上呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來繫結至相關聯的回應、 報表或通知訊息佇列傳送的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定的唯一識別碼。  
  
 若要讀取具有指定的關聯識別項的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不會的移除任何訊息在佇列中，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">該佇列是非交易式佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收符合指定關聯識別項的訊息，如果佇列中目前不存在具有指定關聯識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會查詢中參考的佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數，擲回例外狀況。 訊息會從佇列中移除並傳回使用交易內容所定義的應用程式，否則為`transactionType`參數。  
  
 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息視為單一的內部交易。 您可以指定`None`如果您想要從交易內容外的異動式佇列接收訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來繫結至相關聯的回應、 報表或通知訊息佇列傳送的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定的唯一識別碼。  
  
 若要讀取具有指定的關聯識別項的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不會的移除任何訊息在佇列中，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>接收符合指定關聯識別項的訊息 (從非交易佇列中)，並且等待佇列中出現具有指定關聯識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會查詢中參考的非交易式佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 這個方法會立即傳回如果所指定的訊息相互關聯識別碼`correlationId`參數是在佇列中。 否則，方法會在特定的期間的新訊息到達的時間。 如果沒有收到一封新郵件，逾時到期之前，會擲回例外狀況。  
  
 `timeout`參數未指定這個方法的執行時間總計。 相反地，它會指定等待新訊息到達佇列中的時間。 每當新訊息送達時，此方法會檢查<xref:System.Messaging.Message.CorrelationId%2A>的新的訊息，以查看它是否符合`correlationId`參數。 否則，這個方法會開始逾時期限，並等候另一個新訊息到達。 因此，如果新的訊息會繼續逾時期間內抵達時，可能會此方法才能繼續無限期執行的逾時期限到期且沒有任何新的訊息抵達之前或直到訊息抵達其<xref:System.Messaging.Message.CorrelationId%2A>符合`correlationId`參數。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來繫結至相關聯的回應、 報表或通知訊息佇列傳送的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定的唯一識別碼。  
  
 若要讀取具有指定的關聯識別項的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">佇列中沒有具有指定 <paramref name="correlationId" /> 的訊息，且該訊息未在逾時到期前到達。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收符合指定關聯識別項的訊息 (從交易佇列中)，並且等待佇列中出現具有指定關聯識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會查詢中參考的交易式佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 這個方法會立即傳回如果所指定的訊息相互關聯識別碼`correlationId`參數是在佇列中，使用所定義的內部交易內容`transaction`參數。 否則，方法會在特定的期間的新訊息到達的時間。 如果沒有收到一封新郵件，逾時到期之前，會擲回例外狀況。  
  
 `timeout`參數未指定這個方法的執行時間總計。 相反地，它會指定等待新訊息到達佇列中的時間。 每當新訊息送達時，此方法會檢查<xref:System.Messaging.Message.CorrelationId%2A>的新的訊息，以查看它是否符合`correlationId`參數。 否則，這個方法會開始逾時期限，並等候另一個新訊息到達。 因此，如果新的訊息會繼續逾時期間內抵達時，可能會此方法才能繼續無限期執行的逾時期限到期且沒有任何新的訊息抵達之前或直到訊息抵達其<xref:System.Messaging.Message.CorrelationId%2A>符合`correlationId`參數。  
  
 因為異動式佇列上呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來繫結至相關聯的回應、 報表或通知訊息佇列傳送的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定的唯一識別碼。  
  
 若要讀取具有指定的關聯識別項的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不會的移除任何訊息在佇列中，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">佇列中沒有具有指定 <paramref name="correlationId" /> 的訊息，且該訊息未在逾時到期前到達。  
  
-或- 
該佇列是非交易式佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收符合指定關聯識別項的訊息，並且等待佇列中出現具有指定關聯識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會查詢中參考的佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 這個方法會立即傳回如果所指定的訊息相互關聯識別碼`correlationId`參數是在佇列中，使用所定義的交易內容`transactionType`參數。 否則，方法會在特定的期間的新訊息到達的時間。 如果沒有收到一封新郵件，逾時到期之前，會擲回例外狀況。  
  
 `timeout`參數未指定這個方法的執行時間總計。 相反地，它會指定等待新訊息到達佇列中的時間。 每當新訊息送達時，此方法會檢查<xref:System.Messaging.Message.CorrelationId%2A>的新的訊息，以查看它是否符合`correlationId`參數。 否則，這個方法會開始逾時期限，並等候另一個新訊息到達。 因此，如果新的訊息會繼續逾時期間內抵達時，可能會此方法才能繼續無限期執行的逾時期限到期且沒有任何新的訊息抵達之前或直到訊息抵達其<xref:System.Messaging.Message.CorrelationId%2A>符合`correlationId`參數。 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息視為單一的內部交易。 您可以指定`None`如果您想要從交易內容外的異動式佇列接收訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來繫結至相關聯的回應、 報表或通知訊息佇列傳送的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定的唯一識別碼。  
  
 若要讀取具有指定的關聯識別項的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不會的移除任何訊息在佇列中，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">佇列中沒有具有指定 <paramref name="correlationId" /> 的訊息，且該訊息未在逾時到期前到達。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收符合指定識別項的訊息，並將它從佇列中移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>從非交易佇列中接收符合指定識別項的訊息，如果佇列中目前不存在具有指定識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知識別碼的訊息，並將它從佇列移除使用這個方法。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是訊息佇列企業中，唯一的應該會有最多一個訊息在佇列中符合指定`id`參數。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息而建立的應用程式所產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="id" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收符合指定識別項的訊息 (從交易佇列中)，如果佇列中目前不存在具有指定識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取具有已知識別碼的訊息，並將它從佇列中，使用所定義的內部交易內容中移除`transaction`參數。 此方法擲回例外狀況的立即訊息是否不在佇列中  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是訊息佇列企業中，唯一的應該會有最多一個訊息在佇列中符合指定`id`參數。  
  
 因為異動式佇列上呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息而建立的應用程式所產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不會的移除任何訊息在佇列中，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="id" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">該佇列是非交易式佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收符合指定識別項的訊息，如果佇列中目前不存在具有指定識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知識別碼的訊息，並將它從佇列移除使用這個方法。 這個方法會擲回例外狀況立即訊息是否不在佇列中。 訊息會從佇列中移除並傳回使用交易內容所定義的應用程式，否則為`transactionType`參數。  
  
 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息視為單一的內部交易。 您可以指定`None`如果您想要從交易內容外的異動式佇列接收訊息。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是訊息佇列企業中，唯一的應該會有最多一個訊息在佇列中符合指定`id`參數。 如果具有指定識別碼的訊息是不同於與此相關聯的佇列中<xref:System.Messaging.MessageQueue>執行個體，將無法找到訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息而建立的應用程式所產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不會的移除任何訊息在佇列中，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="id" /> 的訊息。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>接收符合指定識別項的訊息 (從非交易佇列中)，並且等待佇列中出現具有指定識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知識別碼的訊息，並將它從佇列移除使用這個方法。 這個方法會立即傳回如果所指定的識別項的訊息`id`參數是在佇列中。 否則，方法會在特定的期間的新訊息到達的時間。 如果沒有收到一封新郵件，逾時到期之前，會擲回例外狀況。  
  
 `timeout`參數未指定這個方法的執行時間總計。 相反地，它會指定等待新訊息到達佇列中的時間。 每當新訊息送達時，此方法會檢查<xref:System.Messaging.Message.Id%2A>的新的訊息，以查看它是否符合`id`參數。 否則，這個方法會開始逾時期限，並等候另一個新訊息到達。 因此，如果新的訊息會繼續逾時期間內抵達時，可能會此方法才能繼續無限期執行的逾時期限到期且沒有任何新的訊息抵達之前或直到訊息抵達其<xref:System.Messaging.Message.Id%2A>符合`id`參數。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是訊息佇列企業中，唯一的應該會有最多一個訊息在佇列中符合指定`id`參數。  
  
 使用此多載<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>時，只要新訊息到達佇列所指定的逾時期限內會繼續封鎖目前的執行緒可接受`timeout`參數。 執行緒會封鎖至少在特定期間的時間，或無限期地如果指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>for`timeout`參數，則新訊息到達佇列所指定的逾時期限內會繼續`timeout`參數。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息而建立的應用程式所產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="id" /> 的訊息未在逾時到期前到達佇列中。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收符合指定識別項的訊息 (從交易佇列中)，並且等待佇列中出現具有指定識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取具有已知識別碼的訊息，並將它從佇列中，使用所定義的內部交易內容中移除`transaction`參數。 這個方法會立即傳回如果所指定的識別項的訊息`id`參數是在佇列中。 否則，方法會在特定的期間的新訊息到達的時間。 如果沒有收到一封新郵件，逾時到期之前，會擲回例外狀況。  
  
 `timeout`參數未指定這個方法的執行時間總計。 相反地，它會指定等待新訊息到達佇列中的時間。 每當新訊息送達時，此方法會檢查<xref:System.Messaging.Message.Id%2A>的新的訊息，以查看它是否符合`id`參數。 否則，這個方法會開始逾時期限，並等候另一個新訊息到達。 因此，如果新的訊息會繼續逾時期間內抵達時，可能會此方法才能繼續無限期執行的逾時期限到期且沒有任何新的訊息抵達之前或直到訊息抵達其<xref:System.Messaging.Message.Id%2A>符合`id`參數。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是訊息佇列企業中，唯一的應該會有最多一個訊息在佇列中符合指定`id`參數。  
  
 使用此多載<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>時，只要新訊息到達佇列所指定的逾時期限內會繼續封鎖目前的執行緒可接受`timeout`參數。 執行緒會封鎖至少在特定期間的時間，或無限期地如果指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>for`timeout`參數，則新訊息到達佇列所指定的逾時期限內會繼續`timeout`參數。  
  
 因為異動式佇列上呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息而建立的應用程式所產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不會的移除任何訊息在佇列中，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="id" /> 的訊息未在逾時到期前到達佇列中。  
  
-或- 
該佇列是非交易式佇列。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收符合指定識別項的訊息，並且等待佇列中出現具有指定識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知識別碼的訊息，並將它從佇列移除使用這個方法。 這個方法會立即傳回如果所指定的識別項的訊息`id`參數是在佇列中，使用所定義的交易內容`transactionType`參數。 否則，方法會在特定的期間的新訊息到達的時間。 如果沒有收到一封新郵件，逾時到期之前，會擲回例外狀況。  
  
 `timeout`參數未指定這個方法的執行時間總計。 相反地，它會指定等待新訊息到達佇列中的時間。 每當新訊息送達時，此方法會檢查<xref:System.Messaging.Message.Id%2A>的新的訊息，以查看它是否符合`id`參數。 否則，這個方法會開始逾時期限，並等候另一個新訊息到達。 因此，如果新的訊息會繼續逾時期間內抵達時，可能會此方法才能繼續無限期執行的逾時期限到期且沒有任何新的訊息抵達之前或直到訊息抵達其<xref:System.Messaging.Message.Id%2A>符合`id`參數。  
  
 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息視為單一的內部交易。 您可以指定`None`如果您想要從交易內容外的異動式佇列接收訊息。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是訊息佇列企業中，唯一的應該會有最多一個訊息在佇列中符合指定`id`參數。 如果具有指定識別碼的訊息是不同於與此相關聯的佇列中<xref:System.Messaging.MessageQueue>執行個體，將無法找到訊息。  
  
 使用此多載<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>時，只要新訊息到達佇列所指定的逾時期限內會繼續封鎖目前的執行緒可接受`timeout`參數。 執行緒會封鎖至少在特定期間的時間，或無限期地如果指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>for`timeout`參數，則新訊息到達佇列所指定的逾時期限內會繼續`timeout`參數。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息而建立的應用程式所產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息到達佇列。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不會的移除任何訊息在佇列中，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="id" /> 的訊息未在逾時到期前到達佇列中。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 MSMQ 3.0 中介紹。 接收佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">要接收訊息的 <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>在 MSMQ 3.0 中介紹。 接收符合非交易佇列之指定查詢識別項的訊息。</summary>
        <returns>傳入符合 <paramref name="lookupId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.LookupId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知的查詢識別項的訊息，並將它從佇列移除使用這個方法。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，因此會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 若要讀取具有指定的查詢識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定如何在佇列中讀取訊息。 請指定下列其中一個選項： 
 <see langword="MessageLookupAction.Current" />：接收 <paramref name="lookupId" /> 指定的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.Next" />：接收 <paramref name="lookupId" /> 指定的訊息後面的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.Previous" />：接收 <paramref name="lookupId" /> 指定的訊息前面的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.First" />：接收佇列中的第一則訊息，並且從佇列中移除。 <paramref name="lookupId" /> 參數必須設定為 0。  
  
 <see langword="MessageLookupAction.Last" />：接收佇列中的最後一則訊息，並且從佇列中移除。 <paramref name="lookupId" /> 參數必須設定為 0。</param>
        <param name="lookupId">要接收之訊息的 <see cref="P:System.Messaging.Message.LookupId" />，或者為 0。 存取佇列中第一則或最後一則訊息時會使用 0。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>在 MSMQ 3.0 中介紹。 接收交易佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
        <returns>傳入之 <paramref name="lookupId" /> 和 <paramref name="action" /> 參數所指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取已知的查詢識別項的訊息，並將它移除從佇列中，使用所定義的交易內容`transaction`參數。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，因此會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 因為異動式佇列上呼叫此方法時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 若要讀取具有指定識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>。 因為<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>不會的移除任何訊息從佇列，就是不會回復交易已中止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。  
  
-或- 
該佇列是非交易式佇列。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 成員。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定如何在佇列中讀取訊息。 請指定下列其中一個選項： 
 <see langword="MessageLookupAction.Current" />：接收 <paramref name="lookupId" /> 指定的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.Next" />：接收 <paramref name="lookupId" /> 指定的訊息後面的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.Previous" />：接收 <paramref name="lookupId" /> 指定的訊息前面的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.First" />：接收佇列中的第一則訊息，並且從佇列中移除。 <paramref name="lookupId" /> 參數必須設定為 0。  
  
 <see langword="MessageLookupAction.Last" />：接收佇列中的最後一則訊息，並且從佇列中移除。 <paramref name="lookupId" /> 參數必須設定為 0。</param>
        <param name="lookupId">要接收之訊息的 <see cref="P:System.Messaging.Message.LookupId" />，或者為 0。 存取佇列中第一則或最後一則訊息時會使用 0。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>在 MSMQ 3.0 中介紹。 使用指定的交易內容接收佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
        <returns>傳入之 <paramref name="action" /> 和 <paramref name="lookupId" /> 參數所指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取已知的查詢識別項的訊息，並將它移除從佇列中，使用所定義的交易內容`transactionType`參數。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，因此會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 若要讀取具有指定識別碼的訊息，而不從佇列中移除，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。 相關聯的呼叫所傳回的訊息沒有交易內容<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>。 因為<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>不會的移除任何訊息從佇列，就是不會回復交易已中止。  
  
 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息視為單一的內部交易。 您可以指定`None`如果您想要從交易內容外的異動式佇列接收訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，所收到的訊息會傳回至佇列，如果交易已中止。 訊息不會永久移除從佇列上，直到交易認可為止。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 成員。  
  
-或- 
<paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於從佇列移除訊息時。 這個事件是由非同步作業 <see cref="M:System.Messaging.MessageQueue.BeginReceive" /> 所引發。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在非同步處理用來引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件佇列中出現一則訊息時。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用來完成的呼叫所起始的作業<xref:System.Messaging.MessageQueue.BeginReceive%2A>和窺視訊息時<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件。  
  
 建立 <xref:System.Messaging.ReceiveCompletedEventHandler> 委派時，必須識別處理事件的方法。 若要使事件與您的事件處理常式產生關聯，請將委派的執行個體 (Instance) 加入至事件。 除非您移除委派，否則每當事件發生時就會呼叫事件處理常式。 如需有關事件處理常式委派的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立名為事件處理常式`MyReceiveCompleted`，將它附加至<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件處理常式的委派，以及呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>來起始非同步接收作業是在路徑上找到的佇列上 」。 \myQueue"。 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件，此範例接收訊息，並將其主體寫入螢幕。 此範例接著會呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A> 以起始新的非同步接收作業。  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新整理由 <see cref="T:System.Messaging.MessageQueue" /> 所表示的屬性，以反映資源的目前狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> 同步處理的屬性<xref:System.Messaging.MessageQueue>與其相關聯的訊息佇列伺服器資源。 如果任何屬性，例如<xref:System.Messaging.MessageQueue.Label%2A>或<xref:System.Messaging.MessageQueue.Category%2A>，以來已變更伺服器上<xref:System.Messaging.MessageQueue>建立<xref:System.Messaging.MessageQueue.Refresh%2A>更新<xref:System.Messaging.MessageQueue>以新的資訊。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Refresh%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將使用權限清單重設為作業系統的預設值。 移除任何附加至預設清單的佇列使用權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您呼叫<xref:System.Messaging.MessageQueue.ResetPermissions%2A>，您為其預設值傳回的權限清單。 一般而言，這所有的權限，授與佇列建立者，並提供每個使用者的群組的下列權限：  
  
-   取得佇列的屬性。  
  
-   取得佇列的權限。  
  
-   寫入至佇列。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ResetPermissions%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將物件傳送至佇列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的非交易佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要傳送訊息，其中包含使用此多載`obj`參數所參考的佇列<xref:System.Messaging.MessageQueue>。 傳送至佇列的物件可以是<xref:System.Messaging.Message>或任何 managed 的物件。 如果您傳送任何物件，而非<xref:System.Messaging.Message>，物件會序列化，並插入訊息的本文。  
  
 如果您使用這個多載，來將訊息傳送至異動式佇列，訊息會傳送至無法投遞的信件佇列中。 如果您想要包含其他訊息交易的一部分的訊息時，使用多載會採用<xref:System.Messaging.MessageQueueTransaction>或<xref:System.Messaging.MessageQueueTransactionType>做為參數。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外的其他<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序，使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 傳送時<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和 「 訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會連線到訊息佇列，並將訊息傳送至佇列。  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 下列程式碼範例會將傳送應用程式定義`Order`類別至佇列，並接著從佇列接收訊息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的交易佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要傳送訊息，其中包含使用此多載`obj`異動式佇列所參考的參數<xref:System.Messaging.MessageQueue>，使用所定義的內部交易內容`transaction`參數。 傳送至佇列的物件可以是<xref:System.Messaging.Message>或任何 managed 的物件。 如果您傳送任何物件，而非<xref:System.Messaging.Message>，物件會序列化，並插入訊息的本文。  
  
 如果您使用這個多載來傳送訊息至非異動式佇列時，可能到寄不出信件佇列傳送訊息，而不擲回例外狀況。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外的其他<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序，使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 傳送時<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和 「 訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 <xref:System.Messaging.MessageQueueTransaction> 為執行緒的 apartment 感知，因此，如果您的 apartment 狀態`STA`，您無法使用多個執行緒中的交易。 Visual Basic 會將主執行緒的狀態`STA`，因此您必須套用<xref:System.MTAThreadAttribute>在`Main`副程式。 否則，使用其他執行緒傳送交易式訊息時，會擲回 <xref:System.Messaging.MessageQueueException> 例外狀況。 您套用<xref:System.MTAThreadAttribute>使用下列的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例將字串傳送至異動式佇列，然後從該佇列接收訊息。  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
-或- 
訊息佇列應用程式指出不正確的交易用法。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要傳送訊息，其中包含使用此多載`obj`參數所參考的佇列<xref:System.Messaging.MessageQueue>，使用所定義的交易內容`transactionType`參數。 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來傳送訊息的執行緒。 指定`Single`如果您想要將訊息傳送單一的內部交易。 您可以指定`None`如果您想要傳送交易訊息到非交易式的執行緒。  
  
 傳送至佇列的物件可以是<xref:System.Messaging.Message>或任何 managed 的物件。 如果您傳送任何物件，而非<xref:System.Messaging.Message>，物件會序列化，並插入訊息的本文。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外的其他<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序，使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 傳送時<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和 「 訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="label">訊息的標記。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的非交易佇列，並指定訊息的標籤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要傳送訊息，其中包含使用此多載`obj`參數所參考的佇列<xref:System.Messaging.MessageQueue>。 您可以使用這個多載中，指定識別訊息的字串標記。 傳送至佇列的物件可以是<xref:System.Messaging.Message>、 結構、 資料物件或任何 managed 的物件。 如果您傳送任何物件，而非<xref:System.Messaging.Message>，物件會序列化，並插入訊息的本文。  
  
 訊息標籤是不同於訊息佇列的標籤，但兩者都是應用程式相依，而且不會繼承到訊息佇列的意義。  
  
 如果您使用這個多載，來將訊息傳送至異動式佇列，訊息會傳送至無法投遞的信件佇列中。 如果您想要包含其他訊息交易的一部分的訊息時，使用多載會採用<xref:System.Messaging.MessageQueueTransaction>或<xref:System.Messaging.MessageQueueTransactionType>做為參數。  
  
 <xref:System.Messaging.MessageQueue.Path%2A>屬性，這個<xref:System.Messaging.MessageQueue>必須指定執行個體，然後再傳送訊息。 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外的其他<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序，使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 傳送時<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和 「 訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="label">訊息的標記。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的交易佇列，並指定訊息的標籤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要傳送訊息，其中包含使用此多載`obj`異動式佇列所參考的參數<xref:System.Messaging.MessageQueue>，使用所定義的內部交易內容`transaction`參數。 您可以使用這個多載中，指定識別訊息的字串標記。 傳送至佇列的物件可以是<xref:System.Messaging.Message>、 結構、 資料物件或任何 managed 的物件。 如果您傳送任何物件，而非<xref:System.Messaging.Message>，物件會序列化，並插入訊息的本文。  
  
 訊息標籤是不同於訊息佇列的標籤，但兩者都是應用程式相依，而且不會繼承到訊息佇列的意義。  
  
 如果您使用這個多載來傳送訊息至非異動式佇列時，可能到寄不出信件佇列傳送訊息，而不擲回例外狀況。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外的其他<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序，使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 傳送時<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和 「 訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性  
  
 <xref:System.Messaging.MessageQueueTransaction> 為執行緒的 apartment 感知，因此，如果您的 apartment 狀態`STA`，您無法使用多個執行緒中的交易。 Visual Basic 會將主執行緒的狀態`STA`，因此您必須套用<xref:System.MTAThreadAttribute>在`Main`副程式。 否則，使用其他執行緒傳送交易式訊息時，會擲回 <xref:System.Messaging.MessageQueueException> 例外狀況。 您套用<xref:System.MTAThreadAttribute>使用下列的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
-或- 
訊息佇列應用程式指出不正確的交易使用方式。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="label">訊息的標記。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列，並指定訊息的標籤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要傳送訊息，其中包含使用此多載`obj`參數所參考的佇列<xref:System.Messaging.MessageQueue>，使用所定義的交易內容`transactionType`參數。 指定`Automatic`針對`transactionType`參數，如果已經有外部交易的內容附加至您想要用來傳送訊息的執行緒。 指定`Single`如果您想要將訊息傳送單一的內部交易。 您可以指定`None`如果您想要傳送交易訊息到非交易式的執行緒。  
  
 傳送至佇列的物件可以是<xref:System.Messaging.Message>或任何 managed 的物件。 如果您傳送任何物件，而非<xref:System.Messaging.Message>，物件會序列化，並插入訊息的本文。 您可以使用這個多載中，指定識別訊息的字串標記。  
  
 訊息標籤是不同於訊息佇列的標籤，但兩者都是應用程式相依，而且不會繼承到訊息佇列的意義。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式器預設為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外的其他<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序，使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 傳送時<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>，以及的訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">訊息佇列應用程式指出不正確的交易使用方式。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
-或- 
存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將使用權限加入至目前集合。 這控制誰有權限可存取佇列屬性和佇列中的訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">
          <see cref="T:System.Messaging.AccessControlList" />，包含指定信任項和要授與之使用權限的一個或多個存取控制項目。</param>
        <summary>根據存取控制清單的內容指派佇列的存取權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載，來授與、 拒絕或撤銷權限，利用集合的存取控制項目來指定信任項和權限資訊。 這使用，比方說，至多個使用者授與權限，在相同的時間。  
  
 當您建構指定信任項`ace`參數可以是個別使用者、 使用者、 群組或電腦。 如果信任項是選用的個人，使用格式`DOMAIN` \\ `user`。 您可以指定"。"表示本機電腦信任項。  
  
 透過您指派的權限<xref:System.Messaging.MessageQueue.SetPermissions%2A>新增到現有清單的權限。 根據預設，公用或私用佇列的建立者擁有完整控制權，而每個人都有取得佇列屬性，取得權限，並寫入至佇列的權限的網域群組。 當您呼叫<xref:System.Messaging.MessageQueue.SetPermissions%2A>，使用者和權限的資訊會附加到現有清單的底部。  
  
 系統會檢查每個<xref:System.Messaging.AccessControlEntry>順序，直到發生以下事件之一為止：  
  
-   拒絕存取時<xref:System.Messaging.AccessControlEntry>明確拒絕任何要求的存取權限，其中一個執行緒的存取權杖中所列的信任項。  
  
-   一或多個允許存取的<xref:System.Messaging.AccessControlEntry>明確列出的執行緒存取權杖中的信任者授與所有要求的存取權限的項目。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已檢查的項目，而且沒有仍在至少一個要求存取權限，不明確允許，在此情況下，會隱含拒絕存取。  
  
 當您建構`dacl`新增參數<xref:System.Messaging.AccessControlEntry>執行個體您<xref:System.Messaging.AccessControlList>集合。 當您建構每個存取控制項目時，您可以指定一般或標準存取權限。 佇列的權限可以是下列任何組合：  
  
-   刪除  
  
-   讀取安全性  
  
-   寫入安全性  
  
-   同步處理  
  
-   修改擁有者  
  
-   讀取  
  
-   Write  
  
-   執行  
  
-   必要  
  
-   全部  
  
-   無  
  
 這些權限，您可以使用位元 OR 運算子來結合的位元旗標的一組。  
  
-   完全控制  
  
-   刪除訊息  
  
-   接收訊息  
  
-   查看訊息  
  
-   接收日誌訊息  
  
-   取得佇列屬性  
  
-   設定佇列屬性  
  
-   取得權限  
  
-   設定權限  
  
-   取得佇列的擁有權  
  
-   寫入訊息  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29> 的用法。      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">指定使用者、存取類型和使用權限類型的 <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />。</param>
        <summary>根據存取控制項目的內容指派佇列的存取權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載來授與、 拒絕或撤銷權限，所使用的存取控制項目來指定信任項和權限資訊。  
  
 當您建構指定信任項`ace`參數可以是個別使用者、 使用者、 群組或電腦。 如果信任項是選用的個人，使用格式`DOMAIN` \\ `user`。 您可以指定"。"表示本機電腦信任項。  
  
 透過您指派的權限<xref:System.Messaging.MessageQueue.SetPermissions%2A>新增到現有清單的權限。 根據預設，公用或私用佇列的建立者擁有完整控制權，而每個人都有取得佇列屬性，取得權限，並寫入至佇列的權限的網域群組。 當您呼叫<xref:System.Messaging.MessageQueue.SetPermissions%2A>，使用者和權限的資訊會附加到現有清單的底部。  
  
 系統會檢查每個<xref:System.Messaging.AccessControlEntry>順序，直到發生以下事件之一為止：  
  
-   拒絕存取時<xref:System.Messaging.AccessControlEntry>明確拒絕任何要求的存取權限，其中一個執行緒的存取權杖中所列的信任項。  
  
-   一或多個允許存取的<xref:System.Messaging.AccessControlEntry>明確列出的執行緒存取權杖中的信任者授與所有要求的存取權限的項目。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已檢查的項目，而且沒有仍在至少一個要求存取權限，不明確允許，在此情況下，會隱含拒絕存取。  
  
 佇列中，您在中指定的權限`rights`參數，在建構時您<xref:System.Messaging.MessageQueueAccessControlEntry>，可以是下列的任何組合：  
  
-   完全控制  
  
-   刪除訊息  
  
-   接收訊息  
  
-   查看訊息  
  
-   接收日誌訊息  
  
-   取得佇列屬性  
  
-   設定佇列屬性  
  
-   取得權限  
  
-   設定權限  
  
-   取得佇列的擁有權  
  
-   寫入訊息  
  
 `rights`您在建構函式中指定的參數`ace`參數是旗標為<xref:System.Messaging.MessageQueueAccessRights>列舉型別。 它代表一組您可以結合使用位元運算子的位元旗標或當您建置`rights`參數。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> 的用法。  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">取得其他佇列權限的個人、群組或電腦。</param>
        <param name="rights">
          <see cref="T:System.Messaging.MessageQueueAccessRights" />，指出訊息佇列指派給 <paramref name="user" /> 傳入之佇列的一組權限。</param>
        <summary>為電腦、群組或使用者提供指定的存取權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要授與指定的權限給個別使用者使用此多載。 使用者可以是任何有效的信任者，包括個別使用者、 使用者、 群組或電腦。 如果使用者是選用的個人，使用格式`DOMAIN` \\ `user`如`user`參數。 您可以指定"。"的`user`參數來指出在本機電腦。  
  
 透過您指派的權限<xref:System.Messaging.MessageQueue.SetPermissions%2A>新增到現有清單的權限。 根據預設，公用或私用佇列的建立者擁有完整控制權，而每個人都有取得佇列屬性，取得權限，並寫入至佇列的權限的網域群組。 當您呼叫<xref:System.Messaging.MessageQueue.SetPermissions%2A>，使用者和權限的資訊會附加到現有清單的底部。  
  
 系統會檢查每個<xref:System.Messaging.AccessControlEntry>順序，直到發生以下事件之一為止：  
  
-   拒絕存取時<xref:System.Messaging.AccessControlEntry>明確拒絕任何要求的存取權限，其中一個執行緒的存取權杖中所列的信任項。  
  
-   一或多個允許存取的<xref:System.Messaging.AccessControlEntry>明確列出的執行緒存取權杖中的信任者授與所有要求的存取權限的項目。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已檢查的項目，而且沒有仍在至少一個要求存取權限，不明確允許，在此情況下，會隱含拒絕存取。  
  
 中指定佇列的權限`rights`參數，可以是下列任何組合：  
  
-   完全控制  
  
-   刪除訊息  
  
-   接收訊息  
  
-   查看訊息  
  
-   接收日誌訊息  
  
-   取得佇列屬性  
  
-   設定佇列屬性  
  
-   取得權限  
  
-   設定權限  
  
-   取得佇列的擁有權  
  
-   寫入訊息  
  
 <xref:System.Messaging.MessageQueueAccessRights>列舉型別代表一組您可以使用位元運算子來結合的位元旗標，或建置`rights`參數。  
  
 使用這個多載中，您可以只授與權限;您無法撤銷或拒絕它們。 您必須明確授與任何使用不同的多載<xref:System.Messaging.AccessControlEntryType>以外的其他`Allow`。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> 的用法。  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">取得其他佇列權限的個人、群組或電腦。</param>
        <param name="rights">
          <see cref="T:System.Messaging.MessageQueueAccessRights" />，指出訊息佇列指派給 <paramref name="user" /> 傳入之佇列的一組權限。</param>
        <param name="entryType">
          <see cref="T:System.Messaging.AccessControlEntryType" />，指定要授與、拒絕或是撤銷 <paramref name="rights" /> 參數所指定的使用權限。</param>
        <summary>以指定的存取控制類型 (允許、拒絕、撤銷或設定)，為電腦、群組或使用者提供指定的存取權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載來授與、 拒絕或撤銷指定的權限，為個別使用者。 使用者可以是任何有效的信任者，包括個別使用者、 使用者、 群組或電腦。 如果使用者是選用的個人，使用格式`DOMAIN` \\ `user`如`user`參數。 您可以指定"。"的`user`參數來指出在本機電腦。  
  
 透過您指派的權限<xref:System.Messaging.MessageQueue.SetPermissions%2A>新增到現有清單的權限。 根據預設，公用或私用佇列的建立者擁有完整控制權，而每個人都有取得佇列屬性，取得權限，並寫入至佇列的權限的網域群組。 當您呼叫<xref:System.Messaging.MessageQueue.SetPermissions%2A>，使用者和權限的資訊會附加到現有清單的底部。  
  
 系統會檢查每個<xref:System.Messaging.AccessControlEntry>順序，直到發生以下事件之一為止：  
  
-   拒絕存取時<xref:System.Messaging.AccessControlEntry>明確拒絕任何要求的存取權限，其中一個執行緒的存取權杖中所列的信任項。  
  
-   一或多個允許存取的<xref:System.Messaging.AccessControlEntry>明確列出的執行緒存取權杖中的信任者授與所有要求的存取權限的項目。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已檢查的項目，而且沒有仍在至少一個要求存取權限，不明確允許，在此情況下，會隱含拒絕存取。  
  
 中指定佇列的權限`rights`參數，可以是下列任何組合：  
  
-   完全控制  
  
-   刪除訊息  
  
-   接收訊息  
  
-   查看訊息  
  
-   接收日誌訊息  
  
-   取得佇列屬性  
  
-   設定佇列屬性  
  
-   取得權限  
  
-   設定權限  
  
-   取得佇列的擁有權  
  
-   寫入訊息  
  
 <xref:System.Messaging.MessageQueueAccessRights>列舉型別代表一組您可以使用位元運算子來結合的位元旗標，或建置`rights`參數。  
  
 下表顯示這個方法是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定封送處理從 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件產生之事件處理常式呼叫的物件。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示封送處理 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件產生之事件處理常式呼叫的物件。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Messaging.MessageQueue.ReceiveCompleted>或是<xref:System.Messaging.MessageQueue.PeekCompleted>事件產生<xref:System.Messaging.MessageQueue.BeginReceive%2A>或<xref:System.Messaging.MessageQueue.BeginPeek%2A>要求，分別在特定執行緒。 一般而言，<xref:System.Messaging.MessageQueue.SynchronizingObject%2A>設定時其相關的元件放置在控制項或表單，因為這些元件會繫結至特定執行緒。  
  
 通常，同步處理物件封送處理成單一執行緒的方法呼叫。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出佇列是否只接受交易。</summary>
        <value>如果佇列只接收做為交易一部分傳送的訊息則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 交易式訊息指的是數個相關訊息的結合程度，到單一交易。 傳送訊息，因為交易的一部分可確保訊息傳送以順序，只傳遞一次，並已順利擷取從目的地佇列。  
  
 如果佇列是交易式，它會接受交易的一部分傳送的訊息。 不過，可傳送或接收到從本機交易式佇列，而不使用明確交易式的非交易式訊息<xref:System.Messaging.MessageQueueTransaction.Begin%2A>， <xref:System.Messaging.MessageQueueTransaction.Commit%2A>，和<xref:System.Messaging.MessageQueueTransaction.Abort%2A>語法。 如果非交易式訊息傳送至異動式佇列，此元件建立單一訊息的交易，除非在參考佇列，以在遠端電腦上使用直接格式名稱的情況下。 在此情況下，如果傳送訊息時，您不會指定在交易內容，其中不會為您建立和訊息會傳送到寄不出信件佇列。  
  
 如果您將非交易式訊息傳送至異動式佇列時，您將無法回復發生例外狀況訊息。  
  
 <xref:System.Messaging.MessageQueueTransaction> 為執行緒的 apartment 感知，因此，如果您的 apartment 狀態`STA`，您無法使用多個執行緒中的交易。 Visual Basic 會將主執行緒的狀態`STA`，因此您必須套用<xref:System.MTAThreadAttribute>在`Main`副程式。 否則，使用其他執行緒傳送交易式訊息時，會擲回 <xref:System.Messaging.MessageQueueException> 例外狀況。 您套用<xref:System.MTAThreadAttribute>使用下列的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.Transactional%2A>屬性。  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否複製接收的訊息至日誌佇列。</summary>
        <value>如果將從佇列接收到的訊息複製到日誌佇列，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當訊息佇列應用程式建立新的應用程式佇列時，它會自動建立相關聯的日誌佇列中的相同位置。 日誌佇列用來追蹤訊息從佇列中移除。 設定這個屬性修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體。  
  
 日誌佇列不會追蹤訊息從佇列移除，因為其接收時間計時器到期時，也不會追蹤訊息從佇列中清除使用訊息佇列目錄服務 （Information Store 或 Active Directory）。  
  
 應用程式無法將訊息傳送至日誌佇列;僅限於這些佇列的唯讀存取權。 此外，訊息佇列永遠不會移除訊息日誌佇列。 使用佇列的應用程式必須清除這些訊息，接收它們，或清除佇列。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>屬性。  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來傳送訊息至訊息佇列的原生控制代碼。</summary>
        <value>用來傳送訊息至佇列之原生佇列物件的控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A>提供原生的 Windows 控制代碼，用於將訊息傳送至佇列的訊息佇列物件。 如果您變更佇列的路徑，控制代碼就會關閉，並重新開啟新的值。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦，並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">訊息佇列無法用來寫入。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>