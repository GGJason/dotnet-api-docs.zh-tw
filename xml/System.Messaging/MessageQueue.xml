<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f362dd97709b65574ff7b9474682818d0cb2c4b1" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038290" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供 Message Queuing 伺服器上的佇列存取。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing 技術可讓不同時間執行的應用程式跨越可能暫時離線的異質網路和系統彼此通訊。 應用程式傳送、 接收或窺視 （讀取而不移除） 來自佇列的訊息。 訊息佇列是的選用元件[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]和 Windows NT 和必須另行安裝。  
  
 <xref:System.Messaging.MessageQueue>類別是訊息佇列的包裝函式。 有多個版本的訊息佇列，並使用<xref:System.Messaging.MessageQueue>類別可能會導致稍微不同的行為，而您使用視作業系統而定。 之特定功能的每個版本的訊息佇列的資訊，請參閱 MSDN 中的平台 SDK 中的 < 什麼是訊息佇列的新 > 主題。  
  
 <xref:System.Messaging.MessageQueue>類別會提供訊息佇列 」 佇列的參考。 您可以指定的路徑<xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式來連接到現有的資源，或者您可以在伺服器上建立新的佇列。 您可以呼叫之前<xref:System.Messaging.MessageQueue.Send%28System.Object%29>， <xref:System.Messaging.MessageQueue.Peek%2A>，或<xref:System.Messaging.MessageQueue.Receive%2A>，您必須建立關聯的新執行個體<xref:System.Messaging.MessageQueue>類別與現有的佇列。 此時，您就可以操作佇列屬性例如<xref:System.Messaging.MessageQueue.Category%2A>和<xref:System.Messaging.MessageQueue.Label%2A>。  
  
 <xref:System.Messaging.MessageQueue> 支援兩種擷取訊息類型： 同步和非同步。 同步方法，<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.Receive%2A>，導致處理序執行緒等待新訊息到達佇列中的指定的時間間隔。 非同步方法，<xref:System.Messaging.MessageQueue.BeginPeek%2A>和<xref:System.Messaging.MessageQueue.BeginReceive%2A>，讓主應用程式工作在不同的執行緒中繼續，直到訊息抵達佇列中。 這些方法的運作中溝通資訊在執行緒之間使用回呼與狀態物件。  
  
 當您建立的新執行個體<xref:System.Messaging.MessageQueue>類別，您不需要建立新的 「 訊息佇列 」 佇列。 相反地，您可以使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>， <xref:System.Messaging.MessageQueue.Delete%28System.String%29>，和<xref:System.Messaging.MessageQueue.Purge%2A>方法，以管理伺服器上的佇列。  
  
 不同於<xref:System.Messaging.MessageQueue.Purge%2A>，<xref:System.Messaging.MessageQueue.Create%28System.String%29>和<xref:System.Messaging.MessageQueue.Delete%28System.String%29>是`static`成員，因此您可以呼叫它們，而不需要建立的新執行個體<xref:System.Messaging.MessageQueue>類別。  
  
 您可以設定<xref:System.Messaging.MessageQueue>物件的<xref:System.Messaging.MessageQueue.Path%2A>具有三個名稱的其中一個屬性： 易記的名稱， <xref:System.Messaging.MessageQueue.FormatName%2A>，或<xref:System.Messaging.MessageQueue.Label%2A>。 易記名稱，由佇列所定義<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>屬性，是<xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A>公用佇列，並<xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A>私用佇列。 <xref:System.Messaging.MessageQueue.FormatName%2A>屬性可讓訊息佇列離線存取。 最後，您可以使用佇列的<xref:System.Messaging.MessageQueue.Label%2A>屬性來設定佇列的<xref:System.Messaging.MessageQueue.Path%2A>。  
  
 如需執行個體的初始屬性值的清單<xref:System.Messaging.MessageQueue>，請參閱<xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式。  
  
   
  
## Examples  
 下列程式碼範例建立新<xref:System.Messaging.MessageQueue>物件，使用不同的路徑名稱語法類型。 在每個案例中，它會傳送訊息至佇列的路徑在建構函式中定義。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 下列程式碼範例將訊息傳送至佇列，並從佇列中，使用特定應用程式類別，稱為接收訊息`Order`。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>只有<see cref="M:System.Messaging.MessageQueue.GetAllMessages" />方法是安全執行緒。</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。 在預設建構函式將新執行個體初始化之後，您必須先設定執行個體的 <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性，才能夠使用執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要建立的新執行個體使用此多載<xref:System.Messaging.MessageQueue>未立即繫結至訊息佇列伺服器上的佇列的類別。 才能使用這個執行個體，您必須連接到現有的 「 訊息佇列 」 佇列設定<xref:System.Messaging.MessageQueue.Path%2A>屬性。 或者，您可以設定<xref:System.Messaging.MessageQueue>參考<xref:System.Messaging.MessageQueue.Create%28System.String%29>方法的傳回值，藉此建立新的 「 訊息佇列 」 佇列。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式具現化的新執行個體<xref:System.Messaging.MessageQueue>類別; 它不會建立新的 「 訊息佇列 」 佇列。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.MessageQueue>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|預設建構函式所設定的值<xref:System.Messaging.DefaultPropertiesToSend>類別。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|預設建構函式所設定的值<xref:System.Messaging.MessagePropertyFilter>類別。 所有篩選值都會都設為`true`。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 下列程式碼範例會建立新<xref:System.Messaging.MessageQueue>。  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 所參考的佇列位置。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體，這個執行個體會參考指定路徑的訊息佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您想要將新的繫結使用此多載<xref:System.Messaging.MessageQueue>特定訊息佇列 」 佇列，您知道的路徑，格式名稱或標籤的執行個體。 如果您想要授與獨佔存取權的第一個應用程式參考佇列，您必須設定<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>屬性`true`或使用傳遞的讀取權限限制參數的建構函式。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式具現化的新執行個體<xref:System.Messaging.MessageQueue>類別; 它不會建立新的 「 訊息佇列 」 佇列。 若要建立新的佇列中訊息佇列，使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 語法`path`參數取決於佇列類型它的參考下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
|電腦日誌佇列|`MachineName`\\`Journal$`|  
|機器寄不出信件佇列|`MachineName`\\`Deadletter$`|  
|電腦交易式寄不出信件佇列|`MachineName`\\`XactDeadletter$`|  
  
 或者，您可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>來描述為佇列路徑下, 表所示。  
  
|參考資料|語法|範例|  
|---------------|------------|-------------|  
|格式名稱|`FormatName:` [*格式名稱*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|ThisAddIn|`Label:` [*標籤*]|`Label:` TheLabel|  
  
 若要離線工作，您必須使用格式名稱語法不建構函式的路徑名稱語法。 否則，因為主要網域控制站不是可解析成格式名稱的路徑，便會擲回例外狀況。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.MessageQueue>。 這些值會與所指定的路徑時根據訊息佇列的屬性`path`參數。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|預設建構函式所設定的值<xref:System.Messaging.DefaultPropertiesToSend>類別。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`如果 「 訊息佇列 」 佇列的隱私權等級設定為"Body";否則， `false`。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|訊息佇列 」 佇列的電腦名稱屬性的值。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|預設建構函式所設定的值<xref:System.Messaging.MessagePropertyFilter>類別。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>如果未設定的建構函式。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>如果未設定的建構函式。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`如果已啟用訊息佇列物件的筆記本設定;否則， `false`。|  
  
   
  
## Examples  
 下列程式碼範例建立新<xref:System.Messaging.MessageQueue>物件，使用不同的路徑名稱語法類型。 在每個案例中，它會傳送訊息至佇列的路徑在建構函式中定義。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性無效，可能是因為尚未對其進行設定。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列位置，可能是代表本機電腦的 "."。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> 表示將獨佔讀取的存取權限授與存取佇列的第一個應用程式，否則為 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體，這個執行個體會參考指定路徑且具有指定讀取權限制的訊息佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您想要將新的繫結使用此多載<xref:System.Messaging.MessageQueue>至特定訊息佇列 」 佇列，您知道的路徑，格式名稱或標籤。 如果您想要授與獨佔存取權的第一個應用程式參考佇列，設定`sharedModeDenyReceive`參數`true`。 否則，設定`sharedModeDenyReceive`至`false`使用只具有建構函式或`path`參數。  
  
 設定`sharedModeDenyReceive`至`true`影響存取 「 訊息佇列 」 佇列，包括其他應用程式的所有物件。 參數的效果不受限制對此應用程式。  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式建立的新執行個體<xref:System.Messaging.MessageQueue>類別; 它不會建立新的 「 訊息佇列 」 佇列。 若要建立新的佇列中訊息佇列，使用<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 語法`path`參數取決於佇列的類型。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
|電腦日誌佇列|`MachineName`\\`Journal$`|  
|機器寄不出信件佇列|`MachineName`\\`Deadletter$`|  
|電腦交易式寄不出信件佇列|`MachineName`\\`XactDeadletter$`|  
  
 或者，您可以使用格式名稱或 「 訊息佇列 」 佇列的標籤，來描述為佇列路徑。  
  
|參考資料|語法|範例|  
|---------------|------------|-------------|  
|格式名稱|`FormatName:` [*格式名稱*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|ThisAddIn|`Label:` [*標籤*]|`Label:` TheLabel|  
  
 若要離線工作，您必須使用格式名稱語法，而不是易記名稱語法。 否則，因為網域主控站 （Active Directory 所在） 不是可解析成格式名稱的路徑，便會擲回例外狀況。  
  
 如果<xref:System.Messaging.MessageQueue>開啟佇列`sharedModeDenyReceive`參數設定為`true`，任何<xref:System.Messaging.MessageQueue>，後續嘗試從佇列讀取會產生<xref:System.Messaging.MessageQueueException>因為共用違規。 A<xref:System.Messaging.MessageQueueException>如果也會擲回<xref:System.Messaging.MessageQueue>嘗試存取以獨佔模式，而另一個佇列<xref:System.Messaging.MessageQueue>已佇列的非獨佔存取。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.MessageQueue>。 這些值所指定的路徑時，為內容的訊息佇列 」 佇列，`path`參數。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`。|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>。|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|預設建構函式所設定的值<xref:System.Messaging.DefaultPropertiesToSend>類別。|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`如果 「 訊息佇列 」 佇列的隱私權等級設定為"Body";否則， `false`。|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>。|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>。|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|訊息佇列 」 佇列的電腦名稱屬性的值。|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>。|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|預設建構函式所設定的值<xref:System.Messaging.MessagePropertyFilter>類別。|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>如果未設定的建構函式。|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>如果未設定的建構函式。|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` 參數的值。|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`如果已啟用訊息佇列物件的筆記本設定;否則， `false`。|  
  
   
  
## Examples  
 下列程式碼範例會建立新<xref:System.Messaging.MessageQueue>獨佔存取權與設定其路徑中，並將訊息傳送至佇列。  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性無效，可能是因為尚未對其進行設定。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列位置，可能是代表本機電腦的 "."。</param>
        <param name="accessMode">其中一個 <see cref="T:System.Messaging.QueueAccessMode" /> 值。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列位置，可能是代表本機電腦的 "."。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> 表示將獨佔讀取的存取權限授與存取佇列的第一個應用程式，否則為 <see langword="false" />。</param>
        <param name="enableCache">
          <see langword="true" /> 表示建立並使用連接快取，否則為 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立新<xref:System.Messaging.MessageQueue>具有獨佔讀取存取權與啟用快取的連接。  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列位置，可能是代表本機電腦的 "."。</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> 表示將獨佔讀取的存取權限授與存取佇列的第一個應用程式，否則為 <see langword="false" />。</param>
        <param name="enableCache">
          <see langword="true" /> 表示建立並使用連接快取，否則為 <see langword="false" />。</param>
        <param name="accessMode">其中一個 <see cref="T:System.Messaging.QueueAccessMode" /> 值。</param>
        <summary>初始化 <see cref="T:System.Messaging.MessageQueue" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示佇列的存取模式。</summary>
        <value>其中一個 <see cref="T:System.Messaging.QueueAccessMode" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 佇列的預設存取模式是`QueueAccessMode.SendAndReceive`，除非您另外指定呼叫建構函式時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出佇列是否只接受已驗證的訊息。</summary>
        <value>
          如果佇列只接受驗證過的訊息則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息驗證會提供一種方法來確保訊息完整性，以及確認誰傳送訊息。 若要要求驗證，傳送應用程式會設定訊息的驗證層級。  
  
 當您將<xref:System.Messaging.MessageQueue.Authenticate%2A>至`true`，限制在伺服器上，不只對此佇列的存取權<xref:System.Messaging.MessageQueue>執行個體。 針對相同的 「 訊息佇列 」 佇列的所有用戶端會受到影響。  
  
 只接受已驗證的訊息佇列將會拒絕未經驗證的訊息。 若要要求拒絕訊息的通知，傳送應用程式可以設定<xref:System.Messaging.Message.AcknowledgeType%2A>訊息屬性。 訊息拒絕的任何其他指示不存在，因此傳送應用程式可能會遺失訊息除非您要求它傳送到寄不出信件佇列。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.Authenticate%2A>屬性。  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息佇列用來在網路上傳送公用佇列訊息的基礎優先權 (Base Priority)。</summary>
        <value>傳送至 (公用) 佇列的所有訊息的單一基礎優先權。 預設為零 (0)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列的基底優先權會指定訊息路由至該佇列時的處理方式透過網路傳送。 您可以設定<xref:System.Messaging.MessageQueue.BasePriority%2A>來授予高或較低優先順序給所有傳送到傳送至其他佇列所指定的佇列訊息的屬性。 設定這個屬性可以修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體。  
  
 訊息佇列的<xref:System.Messaging.MessageQueue.BasePriority%2A>無關<xref:System.Messaging.Message.Priority%2A>指定內送訊息會置於佇列的順序訊息屬性。  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> 適用於為公用佇列的路徑使用指定的格式名稱。 私用佇列的基本優先順序永遠是零 (0)。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.BasePriority%2A>屬性。  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">基礎優先權設定為無效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <summary>啟始非同步窺視作業，方法是告知訊息佇列開始窺視訊息，並在完成時告知事件處理常式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟始沒有逾時的非同步窺視作業。作業要等到訊息可以在佇列中使用之後才算完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件佇列中可用的訊息時。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發在佇列中已有的訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 起始非同步窺視作業;<xref:System.Messaging.MessageQueue>通知，透過引發<xref:System.Messaging.MessageQueue.PeekCompleted>當訊息抵達佇列中時引發的事件。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或藉由擷取結果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步，您可以呼叫它來查看佇列，而不會封鎖目前的執行緒。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginPeek%2A>傳回識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，您使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，引發了完成事件時，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立名為事件處理常式`MyPeekCompleted`，將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式委派，並呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>起始位於路徑上的佇列上的非同步窺視作業 」。 \myQueue"。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，此範例窺視訊息，並將其本文寫入至螢幕。 此範例會接著呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A> 以起始新的非同步查看作業。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <summary>啟始有指定逾時的非同步窺視作業。在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引發<xref:System.Messaging.MessageQueue.PeekCompleted>時可用的訊息佇列中，或指定的時間間隔過期事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發在佇列中已有的訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 起始非同步窺視作業;<xref:System.Messaging.MessageQueue>通知，透過引發<xref:System.Messaging.MessageQueue.PeekCompleted>當訊息抵達佇列中時引發的事件。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或藉由擷取結果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步，您可以呼叫它來查看佇列，而不會封鎖目前的執行緒。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginPeek%2A>傳回識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，您使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 這個多載指定的逾時。如果指定的間隔`timeout`參數，此元件會引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件。 因為不存在，後續呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>將會擲回例外狀況。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，引發了完成事件時，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立使用的佇列路徑的非同步查看作業 」。 \myQueue"。 它會建立事件處理常式， `MyPeekCompleted`，並將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 起始非同步窺視作業，會呼叫一分鐘的時間的逾時。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件或逾時到期，如果有的話，而且其本文寫入至螢幕擷取訊息。 然後<xref:System.Messaging.MessageQueue.BeginPeek%2A>再次呼叫以起始新的非同步查看作業以相同的逾時。  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="stateObject">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <summary>啟始有指定逾時和指定狀態物件的非同步窺視作業，會在作業的整個存留期內提供相關的資訊。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>引發<xref:System.Messaging.MessageQueue.PeekCompleted>時可用的訊息佇列中，或指定的時間間隔過期事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發在佇列中已有的訊息。  
  
 您可以使用這個多載，與將在整個作業的存留期會保留作業產生關聯的資訊。 此事件處理常式可以存取此資訊，查看<xref:System.IAsyncResult.AsyncState%2A>屬性<xref:System.IAsyncResult>與作業相關聯。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginPeek%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 起始非同步窺視作業;<xref:System.Messaging.MessageQueue>通知，透過引發<xref:System.Messaging.MessageQueue.PeekCompleted>當訊息抵達佇列中時引發的事件。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>或藉由擷取結果使用<xref:System.Messaging.PeekCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步，您可以呼叫它來查看佇列，而不會封鎖目前的執行緒。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 傳回<xref:System.IAsyncResult>可識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，您使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 這個多載指定逾時和狀態的物件。 如果指定的間隔`timeout`參數，此元件會引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件。 因為不存在，後續呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>將會擲回例外狀況。  
  
 與此作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次，以便起始多個作業，您可以識別每個作業，透過您定義個別的狀態物件。 如需此案例中的圖例，請參閱 < 範例 > 一節。  
  
 您也可以將資訊傳遞多個處理序執行緒使用的狀態物件。 如果執行緒已啟動，但回呼是在不同的執行緒的非同步案例中，為狀態物件封送處理，從事件傳遞的資訊一起傳回。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，引發了完成事件時，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立使用的佇列路徑的非同步查看作業 」。 \myQueue"。 它會建立事件處理常式， `MyPeekCompleted`，並將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式委派。 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 呼叫時，搭配一分鐘的逾時。 每次呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>已識別該特定作業的唯一相關聯的整數。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，或逾時過期時，擷取訊息，如果有的話，和其主體和的特定作業的整數識別碼會寫入至螢幕。 然後<xref:System.Messaging.MessageQueue.BeginPeek%2A>會再次呼叫以起始新非同步查看具有相同的逾時和作業只完成作業的相關聯的整數。  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="stateObject">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <param name="callback">會接收非同步作業完成通知的 <see cref="T:System.AsyncCallback" />。</param>
        <summary>啟始有指定逾時和指定狀態物件的非同步窺視作業，會在作業的整個存留期內提供相關的資訊。 這個多載會透過回呼，接收作業的事件處理常式的識別通知。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用這個多載時，回呼參數中指定的回呼會直接叫用時可用的訊息佇列中，或指定的時間間隔已過期。<xref:System.Messaging.MessageQueue.PeekCompleted>不會引發事件。 其他多載的<xref:System.Messaging.MessageQueue.BeginPeek%2A>依賴此元件引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發在佇列中已有的訊息。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步，您可以呼叫它來查看佇列，而不會封鎖目前的執行緒。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 傳回<xref:System.IAsyncResult>可識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，您使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 與此作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次，以便起始多個作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立非同步窺視作業。 程式碼範例傳送訊息至本機訊息佇列，然後呼叫<xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>，並傳入： 逾時值為 10 秒; 識別該特定的訊息; 以及的新執行個體的唯一整數<xref:System.AsyncCallback>識別的事件處理常式， `MyPeekCompleted`. 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，事件處理常式窺視訊息的螢幕中寫入訊息內文和整數訊息識別項。  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="action">其中一個 <see cref="T:System.Messaging.PeekAction" /> 值。 指出要窺視佇列中的目前訊息，還是下一則訊息。</param>
        <param name="state">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" />，接收非同步作業的完成通知。</param>
        <summary>啟始非同步窺視作業，該作業具有指定的逾時，並使用指定的游標、指定的窺視動作和指定的狀態物件。 狀態物件提供整個作業存留期的相關聯資訊。 這個多載會透過回呼，接收作業的事件處理常式的識別通知。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用這個多載時，回呼參數中指定的回呼時叫用直接訊息成為可用的佇列中，或指定的時間間隔已過期。 <xref:System.Messaging.MessageQueue.PeekCompleted>不會引發事件。 其他多載的<xref:System.Messaging.MessageQueue.BeginPeek%2A>依賴此元件引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 也會引發在佇列中已有的訊息。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginPeek%2A>是非同步，您可以呼叫它來查看佇列，而不會封鎖目前的執行緒。 若要以同步方式查看佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 傳回<xref:System.IAsyncResult>可識別方法啟動非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 與此作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>多次，以便起始多個作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">為 <paramref name="action" /> 參數指定 <see langword="PeekAction.Current" /> 或 <see langword="PeekAction.Next" /> 以外的值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <summary>啟始非同步接收作業，方法是告知訊息佇列開始接收訊息，並在完成時告知事件處理常式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟始沒有逾時的非同步接收作業。作業要等到訊息可以在佇列中使用之後才算完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件時從佇列中移除訊息。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發在佇列中已有的訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業。<xref:System.Messaging.MessageQueue>通知，透過引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>當訊息抵達佇列中時引發的事件。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步，您可以呼叫它來從佇列接收訊息，而不會封鎖目前的執行緒。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，您使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，引發了完成事件時，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，且會將交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>查看作業在您建立事件處理常式方法。 事件處理常式可能包含的功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例鏈結非同步要求。 它會假設稱為 「 myQueue 「 本機電腦上沒有佇列。 `Main`函式開始非同步作業，由`MyReceiveCompleted`常式。 `MyReceiveCompleted` 處理目前的訊息，並開始新的非同步接收作業。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 下列程式碼範例會排入佇列的非同步要求。 若要呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>中它的傳回值。 `Main`常式等候結束之前完成的所有非同步作業。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <summary>啟始有指定逾時的非同步接收作業。在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>時可用的訊息佇列中，或指定的時間間隔過期事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發在佇列中已有的訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業。<xref:System.Messaging.MessageQueue>通知，透過引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>當訊息抵達佇列中時引發的事件。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或擷取結果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步，您可以呼叫它來從佇列接收訊息，而不會封鎖目前的執行緒。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，引發了完成事件時，但呼叫時，會擲回例外狀況<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，您使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 這個多載指定的逾時。如果指定的間隔`timeout`參數，此元件會引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。 因為不存在，後續呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>將會擲回例外狀況。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，且會將交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>查看作業在您建立事件處理常式方法。 事件處理常式可能包含的功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立非同步接收作業。 程式碼範例會建立事件處理常式， `MyReceiveCompleted`，並將它附加至<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件處理常式委派。 程式碼範例傳送訊息至本機訊息佇列，然後呼叫<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>，並傳入逾時值為 10 秒。 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件，事件處理常式會接收訊息，並將訊息本文寫入至螢幕。  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="timeout" /> 參數所指定的值無效，可能是因為它表示負數。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="stateObject">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <summary>啟始有指定逾時和指定狀態物件的非同步接收作業，會在作業的整個存留期內提供相關的資訊。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在非同步處理，您可以使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>時可用的訊息佇列中，或指定的時間間隔過期事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發在佇列中已有的訊息。  
  
 您可以使用這個多載，與將在整個作業的存留期會保留作業產生關聯的資訊。 此事件處理常式可以偵測到這項資訊藉由查看<xref:System.IAsyncResult.AsyncState%2A>屬性<xref:System.IAsyncResult>與作業相關聯。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業。<xref:System.Messaging.MessageQueue>通知，透過引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>當訊息抵達佇列中時引發的事件。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或擷取結果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步，您可以呼叫它來從佇列接收訊息，而不會封鎖目前的執行緒。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，您使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 這個多載指定逾時和狀態的物件。 如果指定的間隔`timeout`參數，此元件會引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。 因為不存在，後續呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>將會擲回例外狀況。  
  
 與此作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次，以便起始多個作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 您也可以將資訊傳遞多個處理序執行緒使用的狀態物件。 如果執行緒已啟動，但回呼是在不同的執行緒的非同步案例中，為狀態物件封送處理，從事件傳遞的資訊一起傳回。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，且會將交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>查看作業在您建立事件處理常式方法。 事件處理常式可能包含的功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立非同步接收作業。 程式碼範例會建立事件處理常式， `MyReceiveCompleted`，並將它附加至<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件處理常式委派。 程式碼範例傳送訊息至本機訊息佇列，然後呼叫<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>，並傳入逾時值為 10 秒，並識別該特定訊息的唯一整數。 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件，事件處理常式會接收訊息，並將訊息內文和整數訊息識別項寫入至螢幕。  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="stateObject">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <param name="callback">會接收非同步作業完成通知的 <see cref="T:System.AsyncCallback" />。</param>
        <summary>啟始有指定逾時和指定狀態物件的非同步接收作業，會在作業的整個存留期內提供相關的資訊。 這個多載會透過回呼，接收作業的事件處理常式的識別通知。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用這個多載時，回呼參數中指定的回呼會直接叫用時可用的訊息佇列中，或指定的時間間隔已過期。<xref:System.Messaging.MessageQueue.ReceiveCompleted>不會引發事件。 其他多載的<xref:System.Messaging.MessageQueue.BeginReceive%2A>依賴此元件引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發在佇列中已有的訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業。<xref:System.Messaging.MessageQueue>通知，透過引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>當訊息抵達佇列中時引發的事件。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或擷取結果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步，您可以呼叫它來從佇列接收訊息，而不會封鎖目前的執行緒。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，您使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 與此作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次，以便起始多個作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 您也可以將資訊傳遞多個處理序執行緒使用的狀態物件。 如果執行緒已啟動，但回呼是在不同的執行緒的非同步案例中，為狀態物件封送處理，從事件傳遞的資訊一起傳回。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，且會將交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>查看作業在您建立事件處理常式方法。 事件處理常式可能包含的功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立非同步接收作業。 程式碼範例傳送訊息至本機訊息佇列，然後呼叫<xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>，並傳入： 逾時值為 10 秒; 識別該特定的訊息; 以及的新執行個體的唯一整數<xref:System.AsyncCallback>識別的事件處理常式， `MyReceiveCompleted`. 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件，事件處理常式會接收訊息，並將訊息內文和整數訊息識別項寫入至螢幕。  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待訊息變成可以使用的時間間隔。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="state">應用程式指定的狀態物件，包含與非同步作業相關的資訊。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" />，接收非同步作業的完成通知。</param>
        <summary>初始化非同步接收作業，該作業具有指定的逾時，並使用指定的游標和指定的狀態物件。 狀態物件提供整個作業存留期的相關聯資訊。 這個多載會透過回呼，接收作業的事件處理常式的識別通知。 在訊息可以於佇列中使用或發生逾時之後，作業才會完成。</summary>
        <returns>識別傳送的非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用這個多載時，回呼參數中指定的回呼會直接叫用時可用的訊息佇列中，或指定的時間間隔已過期。<xref:System.Messaging.MessageQueue.ReceiveCompleted>不會引發事件。 其他多載的<xref:System.Messaging.MessageQueue.BeginReceive%2A>依賴此元件引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件。  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 也會引發在佇列中已有的訊息。  
  
 若要使用<xref:System.Messaging.MessageQueue.BeginReceive%2A>、 建立事件處理常式處理非同步作業的結果，以及其關聯事件委派。 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 啟始的非同步接收作業。<xref:System.Messaging.MessageQueue>通知，透過引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>當訊息抵達佇列中時引發的事件。 <xref:System.Messaging.MessageQueue>可以存取訊息藉由呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>或擷取結果使用<xref:System.Messaging.ReceiveCompletedEventArgs>。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>方法會立即傳回，但在呼叫事件處理常式之前未完成非同步作業。  
  
 因為<xref:System.Messaging.MessageQueue.BeginReceive%2A>是非同步，您可以呼叫它來從佇列接收訊息，而不會封鎖目前的執行緒。 若要以同步方式接收訊息，使用<xref:System.Messaging.MessageQueue.Receive%2A>方法。  
  
 非同步作業完成之後，您可以呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>或<xref:System.Messaging.MessageQueue.BeginReceive%2A>再次在事件處理常式可繼續接收通知。  
  
 <xref:System.IAsyncResult> ，<xref:System.Messaging.MessageQueue.BeginReceive%2A>傳回識別方法開始非同步作業。 您可以使用這個<xref:System.IAsyncResult>存留期中的作業，雖然您通常不會使用它之前<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>呼叫。 不過，如果您啟動數個非同步作業，您可以將其<xref:System.IAsyncResult>陣列中的值，並指定是否要等候所有作業或完成任何作業。 在此情況下，使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>屬性<xref:System.IAsyncResult>來識別已完成的作業。  
  
 與此作業的狀態物件產生關聯的狀態資訊。 例如，如果您呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>多次，以便起始多個作業，您可以識別每個作業，透過您定義個別的狀態物件。  
  
 您也可以將資訊傳遞多個處理序執行緒使用的狀態物件。 如果執行緒已啟動，但回呼是在不同的執行緒的非同步案例中，為狀態物件封送處理，從事件傳遞的資訊一起傳回。  
  
 請勿使用非同步呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>與交易。 如果您想要執行的交易式的非同步作業，呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>，且會將交易和 （同步）<xref:System.Messaging.MessageQueue.Receive%2A>查看作業在您建立事件處理常式方法。 事件處理常式可能包含的功能，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否可讀取 <see cref="T:System.Messaging.MessageQueue" />。</summary>
        <value>
          如果 <see cref="T:System.Messaging.MessageQueue" /> 存在而且應用程式可以從它讀取，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 指出應用程式是否能夠查看，或從佇列接收訊息。 如果<xref:System.Messaging.MessageQueue.CanRead%2A>是`true`、<xref:System.Messaging.MessageQueue>可以接收或窺視佇列中的訊息。 否則，不能。  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 是`false`如果佇列已經開啟具有獨佔讀取存取權 (或者如果它是以非獨佔存取，而這開啟<xref:System.Messaging.MessageQueue>要求獨佔存取權)，或如果應用程式沒有足夠的權限可以存取它。 如果您的應用程式會嘗試從佇列讀取時<xref:System.Messaging.MessageQueue.CanRead%2A>是`false`，存取被拒。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.CanRead%2A>屬性。  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否可寫入 <see cref="T:System.Messaging.MessageQueue" />。</summary>
        <value>
          如果 <see cref="T:System.Messaging.MessageQueue" /> 存在，而且應用程式可以寫入它，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 指出應用程式是否能夠將訊息傳送至佇列。 如果<xref:System.Messaging.MessageQueue.CanWrite%2A>是`true`、<xref:System.Messaging.MessageQueue>可以傳送訊息至佇列。 否則，不能。  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 是`false`如果佇列已開啟以獨佔寫入存取權 (或者如果它是以非獨佔存取，而這開啟<xref:System.Messaging.MessageQueue>要求獨佔存取權)，或如果應用程式沒有足夠的權限可以存取它。 如果您的應用程式嘗試寫入至佇列時<xref:System.Messaging.MessageQueue.CanWrite%2A>是`false`，存取被拒。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.CanWrite%2A>屬性。  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列分類。</summary>
        <value>表示佇列分類 (訊息佇列型別識別項) 的 <see cref="T:System.Guid" />，可讓應用程式將它的佇列分類。 預設值為 <see langword="Guid.empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 佇列類別目錄可讓應用程式將其佇列分類。 例如，您可以在一個類別目錄和所有的訂單佇列，在另一個放置所有計費佇列。  
  
 <xref:System.Messaging.MessageQueue.Category%2A>屬性可存取訊息佇列類型 ID 屬性 （這是讀取/寫入），可透過存取**佇列屬性** 對話方塊中 電腦管理 主控台。 您可以定義新的類別。 雖然您可以使用<xref:System.Guid.NewGuid%2A>來建立類別目錄的值，而且是唯一的所有<xref:System.Guid>值，這類動作都是不必要的。 類別目錄值必須是相異只能從其他類別，不是從所有其他<xref:System.Guid>值。 例如，您可以指派{00000000-0000-0000-0000-000000000001}做為<xref:System.Messaging.MessageQueue.Category%2A>佇列的一組和{00000000-0000-0000-0000-000000000002}為<xref:System.Messaging.MessageQueue.Category%2A>另一個集。  
  
 不需要設定<xref:System.Messaging.MessageQueue.Category%2A>。 這個值可以是 `null`。  
  
 設定這個屬性可以修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.Category%2A>屬性。  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">佇列分類被設定為無效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除連接快取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您呼叫<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>移除快取中儲存的格式名稱，開啟並儲存在快取中的控制代碼已關閉。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例呼叫 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>。  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Messaging.MessageQueue" /> 配置的所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> 釋放與相關聯的所有資源<xref:System.Messaging.MessageQueue>，如果適當的話，包含共用資源。 系統重新擷取這些資源自動是否仍然可用，例如當您呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>方法，如下列 C# 程式碼所示。  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 當您呼叫<xref:System.Messaging.MessageQueue.Close%2A>，則所有<xref:System.Messaging.MessageQueue>清除直接存取 「 訊息佇列 」 佇列的屬性。<xref:System.Messaging.MessageQueue.Path%2A>， <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>， <xref:System.Messaging.MessageQueue.Formatter%2A>，和<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>所有維持原狀。  
  
 <xref:System.Messaging.MessageQueue.Close%2A> 不會不一定會釋放讀取並寫入至佇列，控點，因為可能會共用。 您可以採取下列步驟以確保任何<xref:System.Messaging.MessageQueue.Close%2A>釋出至佇列的讀取和寫入控制代碼：  
  
-   建立<xref:System.Messaging.MessageQueue>使用獨佔存取權。 若要這樣做，請呼叫<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29>或<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>建構函式，以及組`sharedModeDenyReceive`參數`true`。  
  
-   建立<xref:System.Messaging.MessageQueue>與停用快取的連接。 若要這樣做，請呼叫<xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>建構函式和集合`enableConnectionCache`參數`false`。  
  
-   停用連線快取。 若要這樣做，請設定<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>屬性`false`。  
  
 您應該呼叫<xref:System.Messaging.MessageQueue.Close%2A>佇列，然後再刪除訊息佇列伺服器上的佇列。 否則，訊息傳送至佇列無法擲回例外狀況，或出現在寄不出信件佇列中。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會關閉訊息佇列 」 佇列。  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 Message Queuing 伺服器上的指定路徑建立新的佇列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要建立佇列的路徑。</param>
        <summary>在指定的路徑建立非交易的訊息佇列。</summary>
        <returns>表示新佇列的 <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載來建立非交易式訊息佇列 」 佇列。  
  
 若要建立的新執行個體<xref:System.Messaging.MessageQueue>應用程式中的類別和繫結到現有的佇列，請使用<xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式。 若要建立新的佇列中訊息佇列，請呼叫<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 語法`path`參數取決於佇列類型它的參考下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用 」。 「 本機電腦。 如需更多的語法，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會建立公用和私用佇列。 它會傳送訊息至所選取的佇列。  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數為 <see langword="null" /> 或空字串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定的路徑已經有佇列存在。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要建立佇列的路徑。</param>
        <param name="transactional">
          <see langword="true" /> 表示建立交易式佇列，<see langword="false" /> 表示建立非交易式佇列。</param>
        <summary>在指定的路徑建立交易或非交易的訊息佇列。</summary>
        <returns>表示新佇列的 <see cref="T:System.Messaging.MessageQueue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載來建立異動式佇列中訊息佇列。 您可以建立非交易式佇列，藉由設定`transactional`參數`false`或藉由呼叫的其他多載<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 若要建立的新執行個體<xref:System.Messaging.MessageQueue>應用程式中的類別和繫結到現有的佇列，請使用<xref:System.Messaging.MessageQueue.%23ctor%2A>建構函式。 若要建立新的佇列中訊息佇列，請呼叫<xref:System.Messaging.MessageQueue.Create%28System.String%29>。  
  
 語法`path`參數取決於佇列類型它的參考下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
  
 使用 」。 「 本機電腦。 如需更多的語法，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會建立公用和私用的交易式佇列。 它會傳送訊息至所選取的佇列。  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數為 <see langword="null" /> 或空字串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">指定的路徑已經有佇列存在。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立目前訊息佇列的新 <see cref="T:System.Messaging.Cursor" />。</summary>
        <returns>目前訊息佇列的新 <see cref="T:System.Messaging.Cursor" />。 讀取佇列的訊息時，這個資料指標用於保持佇列中的特定位置。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得佇列在訊息佇列中建立的時間和日期。</summary>
        <value>
          <see cref="T:System.DateTime" />，表示佇列的建立日期和時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> 不是指伺服器上的佇列訊息佇列，<xref:System.Messaging.MessageQueue>執行個體。  
  
 如果佇列存在，則這個屬性表示的建立佇列時，佇列所在之伺服器的本機時間調整。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.CreateTime%2A>屬性。  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定應用程式傳送訊息至佇列時，會預設採用的訊息屬性值。</summary>
        <value>
          <see cref="T:System.Messaging.DefaultPropertiesToSend" />，包含應用程式向佇列傳送 <see cref="T:System.Messaging.Message" /> 執行個體以外的物件時，使用的預設 Message Queuing 訊息屬性值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您將傳送的類型不是任何物件<xref:System.Messaging.Message>至佇列，<xref:System.Messaging.MessageQueue>將物件插入至訊息佇列的訊息。 在這段時間，<xref:System.Messaging.MessageQueue>套用至訊息中指定的屬性值<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性。 相反地，如果您傳送<xref:System.Messaging.Message>至佇列，這些屬性已指定執行個體本身，因此<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>會忽略<xref:System.Messaging.Message>。  
  
 雖然您可以設定屬性，透過<xref:System.Messaging.MessageQueue>物件<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>參考的訊息會傳送至佇列，而不佇列本身的屬性。  
  
 下表中，會顯示屬性的預設值。  
  
|屬性|預設值|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|零 (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會使用訊息的優先順序，以判斷傳送訊息的預設屬性。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">無法設定佇列的預設屬性，可能是因為其中一個屬性無效。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要刪除的佇列位置。</param>
        <summary>刪除 Message Queuing 伺服器上的佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 語法`path`參數取決於佇列的類型。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
  
 如需更多的語法，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。  
  
 或者，您可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>來描述為佇列路徑。  
  
|參考資料|語法|  
|---------------|------------|  
|格式名稱|使用 FormatName: [*格式名稱*]|  
|ThisAddIn|標籤: [*標籤*]|  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會刪除訊息佇列 」 佇列，如果存在。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數為 <see langword="null" /> 或空字串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <paramref name="path" /> 參數的語法無效。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出這個 <see cref="T:System.Messaging.MessageQueue" /> 是否具有從訊息佇列接收訊息的獨佔存取權。</summary>
        <value>
          如果這個 <see cref="T:System.Messaging.MessageQueue" /> 具有從佇列接收訊息的獨佔權限，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 指定佇列所參考的共用的模式<xref:System.Messaging.MessageQueue>。 設定<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>至`true`來表示，只有這<xref:System.Messaging.MessageQueue>應該查看，或從指定的佇列接收訊息的存取<xref:System.Messaging.MessageQueue.Path%2A>。 如果另一個<xref:System.Messaging.MessageQueue>或另一個應用程式是相同的佇列資源，該執行個體相關聯的應用程式將無法再查看或接收訊息，但它仍然可以傳送它們。  
  
 如果<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>是`false`，佇列可以使用多個應用程式傳送或其內，接收訊息。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>屬性。  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>處置 (Dispose) <see cref="T:System.Messaging.MessageQueue" /> 所使用的資源 (除了記憶體之外)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 使用完畢時，請呼叫 <xref:System.Messaging.MessageQueue>。 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 方法會將 <xref:System.Messaging.MessageQueue> 保留在無法使用的狀態。 在呼叫<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>，您必須釋放所有參考<xref:System.Messaging.MessageQueue>讓它所佔用的記憶體可由記憶體回收收回。  
  
 您應該呼叫<xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>您釋放最後一個參考之前<xref:System.Messaging.MessageQueue>。 否則，資源<xref:System.Messaging.MessageQueue>是使用之前，將不會釋放記憶體回收集合呼叫<xref:System.Messaging.MessageQueue>物件的解構函式。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出應用程式是否會維持連接的快取。</summary>
        <value>
          <see langword="true" /> 表示建立並使用連接快取，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 連接快取是一份結構包含讀取或寫入至佇列的控制代碼的參考。 當<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>是`true`、<xref:System.Messaging.MessageQueue>借用控點，從快取每次呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>， <xref:System.Messaging.MessageQueue.Peek%2A>，或<xref:System.Messaging.MessageQueue.Receive%2A>，而不是開啟新的控制代碼。 這可以改善效能。 使用連線快取也會以隔離<xref:System.Messaging.MessageQueue>網路拓撲中的變更。  
  
 如果您建立新的連接到佇列時的連線快取已滿，<xref:System.Messaging.MessageQueue>至少最近存取的結構，使用覆寫新的連接。 您可以清除快取完全是藉由呼叫<xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>，例如，如果您正在使用的佇列格式名稱已經變更，使先前的讀取和寫入控制代碼不再有效。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.EnableConnectionCache%2A>屬性。  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出佇列是否只接受非私用 (不加密的) 訊息。</summary>
        <value>其中一個 <see cref="T:System.Messaging.EncryptionRequired" /> 值。 預設值為 <see langword="None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您指定需要傳送至佇列的訊息加密時，則會加密訊息內文。 其他成員 (例如，<xref:System.Messaging.Message.Label%2A>和<xref:System.Messaging.Message.SenderId%2A>屬性) 無法加密。  
  
 設定這個屬性可以修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體。  
  
 加密的訊息，可讓訊息私用。 您可以指定佇列的加密需求是`None`， `Body`，或`Optional`藉由設定<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>屬性適當地。 <xref:System.Messaging.Message.UseEncryption%2A>訊息的設定必須對應至佇列的加密需求。 如果訊息並未加密，但佇列指定`Body`，或者如果訊息已加密，但佇列指定`None`，佇列將會拒絕訊息。 如果傳送應用程式要求在此事件的負值通知訊息，訊息佇列指出傳送應用程式的訊息被拒絕。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性是`true`，失敗加密的訊息傳送至寄不出信件佇列。 否則，訊息就會遺失。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>屬性。  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，識別要完成的非同步窺視作業，並要從其中擷取最終結果。</param>
        <summary>完成指定的非同步窺視作業。</summary>
        <returns>與完成的非同步作業相關的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Messaging.MessageQueue.PeekCompleted>引發事件時，<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>完成作業所起始的<xref:System.Messaging.MessageQueue.BeginPeek%2A>呼叫。 若要這樣做，<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>窺視訊息。  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 可以指定逾時，這會導致<xref:System.Messaging.MessageQueue.PeekCompleted>逾時發生之前佇列會出現訊息。 如果要產生的事件。 當沒有訊息抵達佇列的後續呼叫中發生逾時<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>擲回例外狀況。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用來讀取訊息造成<xref:System.Messaging.MessageQueue.PeekCompleted>會引發事件。  
  
 如果您想要繼續將以非同步方式查看訊息，可以一次呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>之後呼叫<xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會建立名為事件處理常式`MyPeekCompleted`，將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式委派，並呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>起始位於路徑上的佇列上的非同步窺視作業 」。 \myQueue"。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，此範例窺視訊息，並將其本文寫入至螢幕。 此範例會接著呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A> 以起始新的非同步查看作業。  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 參數的語法無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，識別要完成的非同步接收作業，並要從其中擷取最終結果。</param>
        <summary>完成指定的非同步接收作業。</summary>
        <returns>與完成的非同步作業相關的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>引發事件時，<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>完成作業所起始的<xref:System.Messaging.MessageQueue.BeginReceive%2A>呼叫。 若要這樣做，<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>接收訊息。  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 可以指定逾時，這會導致<xref:System.Messaging.MessageQueue.ReceiveCompleted>逾時發生之前佇列會出現訊息。 如果要產生的事件。 當沒有訊息抵達佇列的後續呼叫中發生逾時<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>擲回例外狀況。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用來讀取 （從佇列移除） 所造成的訊息<xref:System.Messaging.MessageQueue.ReceiveCompleted>會引發事件。  
  
 如果您想要繼續以非同步方式接收訊息，可以一次呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>之後呼叫<xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例鏈結非同步要求。 它會假設稱為 「 myQueue 「 本機電腦上沒有佇列。 `Main`函式開始非同步作業，由`MyReceiveCompleted`常式。 `MyReceiveCompleted` 處理目前的訊息，並開始新的非同步接收作業。  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 參數的語法無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要尋找的佇列位置。</param>
        <summary>判斷指定路徑上是否存在訊息佇列。</summary>
        <returns>
          如果指定路徑上的佇列存在則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法來判斷訊息佇列 」 佇列是否存在指定的路徑。 沒有方法可用來判斷具有指定的格式名稱的佇列是否存在。 如需有關格式名稱語法和其他路徑語法形式的詳細資訊，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 是昂貴的作業。 只有在必要時在應用程式中，請使用它。  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29>方法不支援<xref:System.Messaging.MessageQueue.FormatName%2A>前置詞。  
  
 語法`path`參數類型而定的佇列下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 無法呼叫來確認遠端私用佇列存在。  
  
 如需更多的語法，請參閱<xref:System.Messaging.MessageQueue.Path%2A>屬性。  
  
 或者，您可以使用<xref:System.Messaging.MessageQueue.Label%2A>來描述為佇列路徑。  
  
|參考資料|語法|  
|---------------|------------|  
|ThisAddIn|標籤: [ `label` ]|  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會確認是否 「 訊息佇列 」 佇列存在，然後將它刪除。  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 語法無效。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。  
  
 -或-  
  
 <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> 方法會在遠端私用佇列上呼叫。</exception>
        <exception cref="T:System.InvalidOperationException">確認佇列是否存在時，應用程式會使用格式名稱語法。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得訊息佇列在佇列建立時產生的唯一佇列名稱。</summary>
        <value>在網路上唯一的佇列名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A>屬性包含佇列的格式名稱。 訊息佇列使用的格式名稱來識別開啟的佇列，以及如何存取它。 不同於大部分的佇列的特性，格式名稱不是訊息佇列應用程式佇列屬性，因此您無法透過訊息佇列的管理工具存取它。 格式名稱是在佇列中，只是唯一的名稱建立佇列，或稍後再產生應用程式時，訊息佇列產生的。  
  
 如果您指定使用的路徑名稱語法的路徑 (例如`myComputer\myQueue`) 而不是您讀取或寫入至佇列時，請使用格式名稱語法，在網域主控站 （這會使用 Active Directory） 將轉譯<xref:System.Messaging.MessageQueue.Path%2A>到相關聯的<xref:System.Messaging.MessageQueue.FormatName%2A>之前存取佇列。 如果您的應用程式離線工作時，您必須使用格式名稱語法。否則，主要網域控制站將無法執行路徑轉譯。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.FormatName%2A>屬性。  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 未設定。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定對佇列寫入或讀取訊息時，用來將物件序列化成訊息主體，或者從訊息主體將物件還原序列化的格式子。</summary>
        <value>產生要對訊息主體寫入或讀取的資料流的 <see cref="T:System.Messaging.IMessageFormatter" />。 預設值為 <see cref="T:System.Messaging.XmlMessageFormatter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A>屬性包含格式子物件，您的應用程式讀取或寫入至佇列時，轉換訊息的執行個體。  
  
 當應用程式傳送訊息至佇列時，格式器會將物件序列化成資料流，並將它插入訊息內文。 格式器時從佇列讀取時，會將訊息資料還原序列化<xref:System.Messaging.Message.Body%2A>屬性<xref:System.Messaging.Message>。  
  
 <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。 <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。  
  
 <xref:System.Messaging.BinaryMessageFormatter> 和<xref:System.Messaging.ActiveXMessageFormatter>提供更快速的輸送量比<xref:System.Messaging.XmlMessageFormatter>。 <xref:System.Messaging.ActiveXMessageFormatter>允許與 Visual Basic 6.0 訊息佇列應用程式的互通性。  
  
 當您的應用程式會將訊息傳送至佇列，<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>只適用於使用預設的訊息屬性，這些訊息<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>。 如果您傳送<xref:System.Messaging.Message>至佇列，訊息佇列使用中定義的格式器<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性改為序列化內文。  
  
 <xref:System.Messaging.MessageQueue>類別一律會使用<xref:System.Messaging.Message>接收或窺視佇列中的訊息。 使用還原序列化訊息<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範的格式化訊息本文會使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下列程式碼範例示範的格式化訊息本文會使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回佇列中的所有訊息。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 型別的陣列，表示佇列中的所有訊息，順序與出現在訊息佇列中的順序一樣。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 這些訊息傳回佇列中的訊息、 非動態連結的靜態快照集。 因此，您無法使用陣列，若要修改佇列中的訊息。 如果您想即時、 動態互動 （例如，若要刪除訊息的能力） 佇列時，呼叫<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>方法，這個方法會傳回佇列中訊息的動態清單。  
  
 因為<xref:System.Messaging.MessageQueue.GetAllMessages%2A>呼叫此方法傳回佇列中訊息的複本時，陣列不會反映新的訊息到達佇列或從佇列中移除的訊息。  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 擷取尚未經過篩選的屬性<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>屬性。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>列舉佇列中的訊息。 <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> 已被取代。 應改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" />，提供佇列中訊息的動態連接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.GetEnumerator%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">包含佇列的電腦名稱，前端沒有兩條反斜線 (\\\\)。</param>
        <summary>取得這個 <see cref="T:System.Messaging.MessageQueue" /> 參考之佇列所在位置的電腦識別項。</summary>
        <returns>
          <see cref="T:System.Guid" />，表示佇列所在之電腦的唯一識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用電腦的識別碼有兩種用途，和其他項目： 讀取電腦日誌，並設定安全性憑證。 不過，您不能呼叫<xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>遠端電腦，當您離線工作因為應用程式必須具有網域控制站上的目錄服務的存取權。  
  
 電腦識別元 （或電腦的識別項） 是<xref:System.Guid>訊息佇列時，會建立將電腦新增至企業。 訊息佇列的結合電腦識別項與`Machine`和`Journal`關鍵字來建立電腦日誌的格式名稱，其語法`Machine=<computeridentifier>;Journal`。 機器筆記本中，也稱為日誌佇列中，為已儲存之系統佇列應用程式所產生的訊息時<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>屬性是`true`。  
  
 建構佇列格式名稱時，此語法日誌才有效。 路徑名稱語法不`MachineName` \\ `Journal$`。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例呼叫 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>。  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">無法擷取電腦識別項，可能是因為目錄服務無法使用；例如，如果您是離線工作。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為佇列中的所有訊息建立列舉值物件。 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> 已被取代。 應改用 <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" />，保有在佇列中所包含的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 建立佇列中的所有訊息的動態清單。 您可以從佇列中移除位於列舉值的目前位置的訊息藉由呼叫<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>如<xref:System.Messaging.MessageEnumerator>，<xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>傳回。  
  
 因為資料指標相關聯的訊息佇列中的動態清單，列舉型別會反映您對佇列中的訊息進行任何修改，如果訊息超出目前的游標位置。 比方說，放置游標的目前位置，超出的低優先權訊息但不是插入該位置之前較高優先權的訊息，可以自動存取列舉值。 不過，您可以重設列舉型別，藉此將游標移回至清單中，開頭藉由呼叫<xref:System.Messaging.MessageEnumerator.Reset%2A>如<xref:System.Messaging.MessageEnumerator>。  
  
 列舉中訊息的順序會反映在佇列中，其順序，所以較高優先權的訊息會出現在優先順序較低的。  
  
 如果您想將它們之訊息佇列，而不是動態的連接靜態快照集時，呼叫<xref:System.Messaging.MessageQueue.GetAllMessages%2A>。 這個方法傳回的陣列<xref:System.Messaging.Message>代表訊息的時呼叫此方法的物件。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例在佇列取得訊息的動態清單和計數的所有訊息<xref:System.Messaging.Message.Priority%2A>屬性設定為<xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>。  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為佇列中的所有訊息建立列舉值物件。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" />，保有在佇列中所包含的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 建立佇列中的所有訊息的動態清單。 您可以從佇列中移除位於列舉值的目前位置的訊息藉由呼叫<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>如<xref:System.Messaging.MessageEnumerator>，<xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>傳回。  
  
 因為資料指標相關聯的訊息佇列中的動態清單，列舉型別會反映您對佇列中的訊息進行任何修改，如果訊息超出目前的游標位置。 比方說，放置游標的目前位置，超出的低優先權訊息但不是插入該位置之前較高優先權的訊息，可以自動存取列舉值。 不過，您可以重設列舉型別，藉此將游標移回至清單中，開頭藉由呼叫<xref:System.Messaging.MessageEnumerator.Reset%2A>如<xref:System.Messaging.MessageEnumerator>。  
  
 列舉中訊息的順序會反映在佇列中，其順序，所以較高優先權的訊息會出現在優先順序較低的。  
  
 如果您想將它們之訊息佇列，而不是動態的連接靜態快照集時，呼叫<xref:System.Messaging.MessageQueue.GetAllMessages%2A>。 這個方法傳回的陣列<xref:System.Messaging.Message>代表訊息的時呼叫此方法的物件。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>為網路上公用佇列的動態清單建立列舉值物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>提供順向資料指標語意，以列舉網路上的所有公用佇列。</summary>
        <returns>提供網路上所有公用訊息佇列動態清單的 <see cref="T:System.Messaging.MessageQueueEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>傳回位於網路的所有公用佇列的列舉。  
  
 因為資料指標相關聯的動態清單，列舉型別會反映您對刪除或資料指標的目前位置之後加入佇列的佇列清單所做的任何修改。 不會反映加入或刪除的資料指標的目前位置前面的佇列。 比方說，佇列，附加到資料指標位置之外，但不是其中插入該位置之前，可以自動存取列舉值。 不過，您可以重設列舉型別，藉此將游標移回至清單中，開頭藉由呼叫<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>如<xref:System.Messaging.MessageQueueEnumerator>。  
  
 沒有佇列的網路中未定義順序。 列舉值不會排序，例如電腦、 標籤、 公用或私用狀態，或任何其他可存取的準則。  
  
 如果您想在網路，而不是動態的連線，佇列的靜態快照集時，呼叫<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>或<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>。 這兩種方法的每個傳回的陣列<xref:System.Messaging.MessageQueue>代表佇列的時呼叫此方法的物件。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會逐一查看網路中的所有訊息佇列，並檢查每個佇列的路徑。 最後，它會在網路上顯示公用佇列的數目。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">
          <see cref="T:System.Messaging.MessageQueueCriteria" />，包含用來篩選可用訊息佇列的準則。</param>
        <summary>提供順向資料指標語意，以列舉網路上所有符合指定準則的公用佇列。</summary>
        <returns>提供網路上所有公用訊息佇列動態清單的 <see cref="T:System.Messaging.MessageQueueEnumerator" />，其符合 <paramref name="criteria" /> 參數指定的限制。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>傳回符合準則的應用程式準則中所定義的網路上的所有公用佇列的清單。 您可以指定建立或修改時間、 電腦名稱、 標籤、 類別目錄或上述任何組合，例如，排入佇列要包括的準則。  
  
 因為資料指標相關聯的動態清單，列舉型別會反映您對資料指標的目前位置之後，就會發生的佇列進行任何修改。 不會反映佇列資料指標的目前位置前面的變更。 比方說，佇列，附加到資料指標位置之外，但不是其中插入該位置之前，可以自動存取列舉值。 不過，您可以重設列舉型別，藉此將游標移回至清單中，開頭藉由呼叫<xref:System.Messaging.MessageQueueEnumerator.Reset%2A>如<xref:System.Messaging.MessageQueueEnumerator>。  
  
 沒有佇列的網路中未定義順序。 列舉值不會排序，例如電腦、 標籤、 公用或私用狀態，或任何其他可存取的準則。  
  
 如果您想在網路，而不是動態的連線，佇列的靜態快照集時，指定的準則<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>或呼叫<xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>。 這兩種方法的每個傳回的陣列<xref:System.Messaging.MessageQueue>代表佇列的時呼叫此方法的物件。 呼叫<xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>，或<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>提供相同的結果，與呼叫<xref:System.Messaging.MessageQueue.GetPublicQueues%2A>的篩選條件與<xref:System.Messaging.MessageQueue.Category%2A>， <xref:System.Messaging.MessageQueue.Label%2A>，和<xref:System.Messaging.MessageQueue.MachineName%2A>分別。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會逐一訊息佇列，並顯示最後一天中建立且存在於每個佇列的路徑在電腦"MyComputer"。  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">要從其中擷取私用佇列的電腦。</param>
        <summary>擷取所指定電腦上的所有私用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的私用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 擷取指定的電腦上之佇列的靜態快照集。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數為 <see langword="null" /> 或空字串 ("")。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>擷取網路上所有的公用佇列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取網路上所有的公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您想在網路上的所有公用佇列的完整清單，請使用此多載。 如果您想要限制特定準則，例如<xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Category%2A>，或上次修改的時間使用這個方法的另一個多載。 (或者，您可以使用<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>，或<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>。)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 擷取佇列的靜態快照集。 若要互動之佇列的動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">
          <see cref="T:System.Messaging.MessageQueueCriteria" />，包含用來篩選佇列的準則。</param>
        <summary>擷取網路上符合指定準則的所有公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您想要依標籤、 類別或電腦名稱，篩選網路上的所有公用佇列<xref:System.Messaging.MessageQueue>類別包含可提供該功能的特定方法 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>， <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>，和<xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>分別)。 使用此多載以取得所有公用佇列的網路上 （例如，如果您想要指定標籤和分類） 符合一個以上的這些準則的清單。 您也可以根據篩選準則訊息以外<xref:System.Messaging.MessageQueue.Label%2A>， <xref:System.Messaging.MessageQueue.Category%2A>，和<xref:System.Messaging.MessageQueue.MachineName%2A>。 例如，您可以使用這個多載以篩選出的佇列的上次修改時間。 只要建立的新執行個體<xref:System.Messaging.MessageQueueCriteria>類別、 執行個體中，設定適當的屬性，並傳遞做為執行個體`criteria`參數。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 擷取佇列的靜態快照集。 若要互動之佇列的動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">
          <see cref="T:System.Guid" />，會將要擷取的佇列集設為群組。</param>
        <summary>擷取網路上屬於指定分類的所有公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法依類別篩選公用佇列。 <xref:System.Messaging.MessageQueue.Category%2A>屬性提供的訊息佇列類型 ID 屬性 （這是讀取/寫入） 的特定佇列的存取。 雖然您可以使用<xref:System.Guid.NewGuid%2A>來建立類別目錄的值，而且是唯一的所有<xref:System.Guid>值，都則不需要。 類別目錄值必須是相異只能從其他類別，不是從所有其他<xref:System.Guid>值。 例如，您可以指派{00000000-0000-0000-0000-000000000001}做為<xref:System.Messaging.MessageQueue.Category%2A>佇列的一組和{00000000-0000-0000-0000-000000000002}為<xref:System.Messaging.MessageQueue.Category%2A>另一個集。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 擷取佇列的靜態快照集。 若要互動之佇列的動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 您可以指定類別的一部分<xref:System.Messaging.MessageQueueCriteria>您傳遞至方法。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">標記，該標記會將要擷取的佇列集設為群組。</param>
        <summary>擷取網路上具有指定標籤的所有公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考擷取的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要依標籤篩選公用佇列，使用這個方法。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 擷取佇列的靜態快照集。 若要互動之佇列的動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 您可以指定標籤的一部分<xref:System.Messaging.MessageQueueCriteria>您傳遞至方法。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">電腦的名稱，包含要擷取的公用佇列集。</param>
        <summary>擷取位於指定電腦上的所有公用佇列。</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> 物件的陣列，會參考電腦上的公用佇列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法依電腦篩選公用佇列。  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 擷取佇列的靜態快照集。 若要互動之佇列的動態清單，請使用<xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>。 您可以指定電腦名稱的一部分<xref:System.Messaging.MessageQueueCriteria>您傳遞至方法。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|否|  
|本機電腦，並直接格式名稱|否|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會擷取佇列的清單。  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數的語法不正確。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取 MSMQ 在這次呼叫時與目前使用者 (執行緒識別) 產生關聯的安全性內容。</summary>
        <returns>包含安全性內容的 <see cref="T:System.Messaging.SecurityContext" /> 物件。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得佇列的唯一訊息佇列識別項。</summary>
        <value>
          <see cref="P:System.Messaging.MessageQueue.Id" />，表示 Message Queuing 應用程式所產生的訊息識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列設定<xref:System.Messaging.MessageQueue.Id%2A>屬性會在建立佇列時。 這個屬性只適用於公用佇列。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.Id%2A>屬性。  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定佇列沒有大小限制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定時，經常會使用這個成員<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>或<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Messaging.MessageQueue.InfiniteQueueSize>成員。  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定窺視 (Peek) 或接收訊息的方法沒有逾時限制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> 支援兩種擷取訊息類型： 同步和非同步。 同步方法，<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.Receive%2A>，導致處理序執行緒等待新訊息到達佇列中的指定的時間間隔。 如果指定的時間間隔為<xref:System.Messaging.MessageQueue.InfiniteTimeout>，處理序執行緒會保持封鎖，直到新訊息。 相反地，<xref:System.Messaging.MessageQueue.BeginPeek%2A>和<xref:System.Messaging.MessageQueue.BeginReceive%2A>（非同步方法），允許不同的執行緒中繼續，直到訊息抵達佇列中的主應用程式工作。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Messaging.MessageQueue.InfiniteTimeout>成員。  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列描述。</summary>
        <value>訊息佇列的標記。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息佇列標籤的最大長度為 124 個字元。  
  
 <xref:System.Messaging.MessageQueue.Label%2A>屬性不需要是唯一的所有佇列。 不過，如果多個佇列都共用相同<xref:System.Messaging.MessageQueue.Label%2A>，您不能使用<xref:System.Messaging.MessageQueue.Send%28System.Object%29>廣播到所有的這些訊息的方法。 如果您使用的標籤語法<xref:System.Messaging.MessageQueue.Path%2A>屬性傳送訊息時，發生例外狀況會擲回<xref:System.Messaging.MessageQueue.Label%2A>不是唯一的。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.Label%2A>屬性。  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">標籤設為無效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得上次修改佇列屬性的時間。</summary>
        <value>
          <see cref="T:System.DateTime" />，指出佇列屬性上次修改的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立佇列時，包含上次修改時間和任何<xref:System.Messaging.MessageQueue>屬性，例如修改 「 訊息佇列 」 佇列， <xref:System.Messaging.MessageQueue.BasePriority%2A>。 值<xref:System.Messaging.MessageQueue.LastModifyTime%2A>屬性代表本機電腦的系統時間。  
  
 您必須呼叫<xref:System.Messaging.MessageQueue.Refresh%2A>再取得<xref:System.Messaging.MessageQueue.LastModifyTime%2A>屬性; 否則修改相關聯的時間與這個<xref:System.Messaging.MessageQueue>可能不是最新資訊。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.LastModifyTime%2A>屬性。  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息佇列位置的電腦名稱。</summary>
        <value>佇列位置的電腦名稱。 訊息佇列預設是 "."，也就是本機電腦。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A>是不可或缺的元件之佇列的易記名稱語法<xref:System.Messaging.MessageQueue.Path%2A>。 下表顯示當您想要識別使用其易記名稱的佇列路徑，您應該使用佇列的指定類型的語法。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
|電腦日誌佇列|`MachineName`\\`Journal$`|  
|機器寄不出信件佇列|`MachineName`\\`Deadletter$`|  
|電腦交易式寄不出信件佇列|`MachineName`\\`XactDeadletter$`|  
  
 使用 」。 「 本機電腦時指定<xref:System.Messaging.MessageQueue.MachineName%2A>。 例如，只有電腦名稱辨識這個屬性， `Server0`。 <xref:System.Messaging.MessageQueue.MachineName%2A>屬性不支援 IP 位址的格式。  
  
 如果您定義<xref:System.Messaging.MessageQueue.Path%2A>的<xref:System.Messaging.MessageQueue.MachineName%2A>，應用程式在離線工作，因為網域控制站是所需路徑轉譯時，會擲回例外狀況。 因此，您必須使用<xref:System.Messaging.MessageQueue.FormatName%2A>如<xref:System.Messaging.MessageQueue.Path%2A>離線工作時的語法。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Path%2A>，和<xref:System.Messaging.MessageQueue.QueueName%2A>相關屬性。 變更<xref:System.Messaging.MessageQueue.MachineName%2A>屬性原因<xref:System.Messaging.MessageQueue.Path%2A>来變更屬性。 建置在新<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>。 變更<xref:System.Messaging.MessageQueue.Path%2A>（例如，若要使用的格式名稱語法） 會重設<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>屬性來參考新的佇列。 如果<xref:System.Messaging.MessageQueue.QueueName%2A>屬性是空的<xref:System.Messaging.MessageQueue.Path%2A>設為您指定之電腦的日誌佇列。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.MachineName%2A>屬性。  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">電腦的名稱無效，可能是因為語法不正確。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定日誌佇列的最大大小。</summary>
        <value>日誌佇列大小的最大值 (以 KB 為單位)。 訊息佇列預設不指定上限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 提供存取訊息佇列的日誌存放區限制。 它是相關時，才<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>是`true`。 設定這個屬性可以修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體  
  
 如果您將訊息儲存在日誌或寄不出的信件佇列，您應該定期清除佇列，以便移除不再需要的訊息。 這類佇列中的訊息都會計佇列所在的電腦的訊息配額。 （系統管理員設定電腦配額）。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>屬性。  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">日誌佇列的最大值設定為無效值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列的最大值。</summary>
        <value>佇列的最大值 (以 KB 計)。 訊息佇列預設不指定上限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>存取訊息佇列訊息存放區限制，從電腦的系統管理員定義的訊息配額分開的。 如需訊息配額的詳細資訊，請參閱<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>。  
  
 設定這個屬性可以修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體  
  
 如果嘗試超過佇列大小上限或電腦訊息配額時，訊息可能會遺失。 當到達佇列配額時，訊息佇列通知，表示傳回負值通知訊息的佇列已滿，傳送應用程式的管理佇列。 訊息佇列會繼續傳送負值通知，直到佇列中的訊息總大小低於限制。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>屬性。  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">佇列大小的最大值包含負值。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定接收或窺視訊息的屬性篩選條件。</summary>
        <value>佇列用來為每個訊息篩選它所接收或窺視的屬性集的 <see cref="T:System.Messaging.MessagePropertyFilter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此篩選器是一組限制的訊息屬性的布林值，<xref:System.Messaging.MessageQueue>接收或窺視。 當<xref:System.Messaging.MessageQueue>接收或窺視訊息從伺服器佇列中，它會擷取只有這些屬性的<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>值是`true`。  
  
 下圖顯示的初始屬性值的<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>屬性。 這些設定是相同於呼叫<xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A>上<xref:System.Messaging.MessagePropertyFilter>。  
  
|屬性|預設值|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 個位元組|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 個位元組|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 個位元組|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>限制接收的訊息內容。  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">篩選條件為 <see langword="null" />。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 MSMQ 3.0 中介紹。 取得或設定與佇列相關聯的多點傳送位址。</summary>
        <value>
          <see cref="T:System.String" />，包含有效的多點傳送位址 (在下面所示的表單中)，否則為 <see langword="null" />，表示佇列未與多點傳送位址相關聯。  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A>屬性用來將非交易式佇列與傳送訊息時可以使用多點傳送位址產生關聯。 您無法將交易式佇列與多點傳送位址。 當傳送應用程式會將訊息傳送至多點傳送位址時，訊息佇列傳送至該位址相關聯的每個佇列的訊息的複本。  
  
 IP 多點傳送位址必須在類別 D 範圍從 224.0.0.0 到 239.255.255.255，對應到前四個高序位位元等於 1110年的設定。 不過，只有某些特定範圍的位址範圍中都未保留，可用於傳送多點傳送的訊息。 如需保留的多點傳送位址的最新清單，請參閱[網際網路指定編號 Authority (IANA) 網際網路多點傳送位址](http://go.microsoft.com/fwlink/?linkid=3859)網頁。 沒有任何通訊埠編號上的限制。  
  
 如果數個來源電腦傳送多點傳送的訊息，而且您想要特定的佇列接收訊息從一個來源電腦，每台來源電腦必須將訊息傳送至不同的 IP 位址和連接埠號碼組合。  
  
 若要中斷關聯的佇列，從多點傳送位址，設定<xref:System.Messaging.MessageQueue.MulticastAddress%2A>屬性設為零長度字串。 請勿將它設為`null`，因為這會導致<xref:System.ArgumentNullException>。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定佇列路徑。 設定 <see cref="P:System.Messaging.MessageQueue.Path" /> 會使 <see cref="T:System.Messaging.MessageQueue" /> 指向新佇列。</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列。 預設值取決於您使用的 <see cref="M:System.Messaging.MessageQueue.#ctor" /> 建構函式，可以是 <see langword="null" />，或者是由建構函式的 <paramref name="path" /> 參數指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 語法<xref:System.Messaging.MessageQueue.Path%2A>屬性取決於佇列類型它點至下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
|電腦日誌佇列|`MachineName`\\`Journal$`|  
|機器寄不出信件佇列|`MachineName`\\`Deadletter$`|  
|電腦交易式寄不出信件佇列|`MachineName`\\`XactDeadletter$`|  
  
 使用"。"代表本機電腦。  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>， <xref:System.Messaging.MessageQueue.Path%2A>，和<xref:System.Messaging.MessageQueue.QueueName%2A>相關屬性。 變更<xref:System.Messaging.MessageQueue.MachineName%2A>屬性原因<xref:System.Messaging.MessageQueue.Path%2A>来變更屬性。 建置在新<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>。 變更<xref:System.Messaging.MessageQueue.Path%2A>（例如，若要使用的格式名稱語法） 會重設<xref:System.Messaging.MessageQueue.MachineName%2A>和<xref:System.Messaging.MessageQueue.QueueName%2A>屬性來參考新的佇列。  
  
 或者，您可以使用<xref:System.Messaging.MessageQueue.FormatName%2A>或<xref:System.Messaging.MessageQueue.Label%2A>來描述為佇列路徑下, 表所示。  
  
|參考資料|語法|範例|  
|---------------|------------|-------------|  
|格式名稱|`FormatName:` [*格式名稱*]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|ThisAddIn|`Label:` [*標籤*]|`Label:` TheLabel|  
  
 如果您使用的標籤語法<xref:System.Messaging.MessageQueue.Path%2A>屬性傳送訊息時，發生例外狀況會擲回<xref:System.Messaging.MessageQueue.Label%2A>不是唯一的。  
  
 若要設為離線工作，您必須使用第一個資料表中的格式名稱語法，而不是易記名稱語法。 否則，因為網域主控站 （Active Directory 所在） 不是可解析成格式名稱的路徑，便會擲回例外狀況。  
  
 設定新的路徑時，關閉訊息佇列，並釋放所有控制代碼。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|[是]|  
  
> [!NOTE]
>  工作群組模式中，您可以只使用私用佇列。 您指定的路徑，使用私用佇列語法`MachineName` \\ `Private$` \\ `QueueName`。  
  
   
  
## Examples  
 下列程式碼範例建立新<xref:System.Messaging.MessageQueue>物件，使用不同的路徑名稱語法類型。 在每個案例中，它會傳送訊息至佇列的路徑在建構函式中定義。  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路徑無效，可能是因為語法無效。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <summary>傳回佇列中第一個訊息的複本，但不從佇列中移除訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回而不移除 (窺視) 這個 <see cref="T:System.Messaging.MessageQueue" /> 所參考佇列中的第一個訊息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此會封鎖目前的執行緒，直到訊息可以使用為止。</summary>
        <returns>表示佇列中第一個訊息的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要查看佇列中，或等候直到有訊息佇列中，請使用此多載。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法讀取，但不會移除，從佇列的第一個訊息。 因此，重複呼叫<xref:System.Messaging.MessageQueue.Peek%2A>傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，相反地，同時讀取，並從佇列中移除第一個訊息。 重複呼叫<xref:System.Messaging.MessageQueue.Receive%2A>，因此，會傳回不同的訊息。  
  
 訊息佇列會根據優先權和抵達時間在佇列中排序訊息。 只有在優先順序較高的舊之前放置較新的訊息。  
  
 當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 這個多載不會指定逾時，應用程式可能會無限期等候。 當您需要應用程式繼續執行而不要等候，請使用非同步的 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。 或者，您可以指定的逾時訊息到達佇列中所使用的多載<xref:System.Messaging.MessageQueue.Peek%2A>所指定的逾時。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列範例會使用<xref:System.Messaging.MessageQueue.Peek%2A>佇列上的方法。  
  
 在第一個範例中，應用程式會等到訊息成為佇列中可用。 請注意第一個範例不會存取訊息到達。它只會暫停處理，直到訊息抵達。 如果佇列中已有一則訊息，它會立即傳回。  
  
 在第二個範例中，包含應用程式定義的訊息`Order`類別傳送至佇列，並接著會從佇列查看。  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待含有訊息之佇列的最長時間。</param>
        <summary>傳回而不移除 (窺視) 這個 <see cref="T:System.Messaging.MessageQueue" /> 所參考佇列中的第一個訊息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此會封鎖目前的執行緒，直到訊息可以使用或發生指定的逾時為止。</summary>
        <returns>表示佇列中第一個訊息的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要查看佇列中，或等候一段指定的時間，直到有訊息佇列中，請使用此多載。 如果佇列中已有一則訊息的方法會立即傳回。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法讀取，但不會移除，從佇列的第一個訊息。 因此，重複呼叫<xref:System.Messaging.MessageQueue.Peek%2A>傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，相反地，同時讀取，並從佇列中移除第一個訊息。 重複呼叫<xref:System.Messaging.MessageQueue.Receive%2A>，因此，會傳回不同的訊息。  
  
 訊息佇列會根據優先權和抵達時間在佇列中排序訊息。 只有在優先順序較高的舊之前放置較新的訊息。  
  
 當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 執行緒會封鎖到指定的期間內的時間或無限期如果指出<xref:System.Messaging.MessageQueue.InfiniteTimeout>。 當您需要應用程式繼續執行而不要等候，請使用非同步的 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Messaging.MessageQueue.Peek%2A>方法，檢查佇列是否是空的零的逾時。  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待含有訊息之佇列的最長時間。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="action">其中一個 <see cref="T:System.Messaging.PeekAction" /> 值。 指出要窺視佇列中的目前訊息，還是下一則訊息。</param>
        <summary>使用指定的游標傳回而不移除 (窺視) 佇列中的目前或下一則訊息。 <see cref="M:System.Messaging.MessageQueue.Peek" /> 方法是同步的，因此會封鎖目前的執行緒，直到訊息可以使用或發生指定的逾時為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，表示佇列中的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要查看佇列中，或等候一段指定的時間，直到有訊息佇列中，請使用此多載。 如果佇列中已有一則訊息的方法會立即傳回。  
  
 <xref:System.Messaging.MessageQueue.Peek%2A>方法讀取，但不會移除，將訊息從佇列。 <xref:System.Messaging.MessageQueue.Receive%2A>方法，相反地，同時讀取，並從佇列移除訊息。  
  
 當目前的執行緒可接受進行封鎖並同時等候訊息到達佇列時，請使用 <xref:System.Messaging.MessageQueue.Peek%2A>。 最多指定的期間內的時間或無限期地封鎖執行緒如果指出<xref:System.Messaging.MessageQueue.InfiniteTimeout>。 當您需要應用程式繼續執行而不要等候，請使用非同步的 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 方法。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">為 <paramref name="action" /> 參數指定 <see langword="PeekAction.Current" /> 或 <see langword="PeekAction.Next" /> 以外的值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。 可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>窺視符合指定關聯識別項的訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">要窺視訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>窺視符合指定關聯識別項的訊息，而且在佇列中目前沒有指定關聯識別項的訊息時，立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會在所參照的佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數時，擲回例外狀況。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來將繫結傳送至相關聯的回應、 報表或通知訊息至佇列的訊息。  
  
 另外兩個方法可讓您查看佇列中的訊息。 <xref:System.Messaging.MessageQueue.Peek%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法用來擷取訊息，藉由指定其唯一識別碼。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會將傳送和接收包含訂單與佇列的訊息。 它特別要求正值通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">要窺視訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>窺視符合指定的關聯識別項的訊息，並且等候佇列中出現具有指定關聯識別項的訊息，或者等候直到逾時到期。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會在所參照的佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數，以及任何新訊息到達佇列中所指定的期間內`timeout`參數時，擲回例外狀況。  
  
 `timeout`參數未指定此方法的執行時間總計。 相反地，它會指定新訊息到達佇列中等候的時間。 每次新的訊息抵達時，這個方法會檢查<xref:System.Messaging.Message.CorrelationId%2A>新訊息是否符合`correlationId`參數。 否則，這個方法的逾時期間的開始，並等候另一個新訊息到達。 因此，如果新的訊息持續逾時期間內抵達時，可能會此方法才能繼續執行，直到逾時期間過期且沒有任何新的訊息抵達，或是在訊息抵達其之前<xref:System.Messaging.Message.CorrelationId%2A>符合`correlationId`參數。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來將繫結傳送至相關聯的回應、 報表或通知訊息至佇列的訊息。  
  
 另外兩個方法可讓您查看佇列中的訊息。 <xref:System.Messaging.MessageQueue.Peek%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法用來擷取訊息，藉由指定其唯一識別碼。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.InvalidOperationException">佇列中沒有具有指定 <paramref name="correlationId" /> 的訊息，且該訊息未在逾時到期前到達。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回具有指定訊息識別項的訊息複本，但不從佇列中移除訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要窺視訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>窺視訊息識別項符合 <paramref name="id" /> 參數的訊息。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 屬性符合 <paramref name="id" /> 參數的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>讀取，但不會從佇列移除訊息具有已知的訊息識別項。 訊息的識別項是唯一的訊息佇列企業中，因此中會有最多一個訊息佇列符合給定`id`參數。 如果佇列目前也不會包含訊息，則這個多載會擲回例外狀況。  
  
 兩個額外的方法可讓您查看佇列中的訊息：<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 <xref:System.Messaging.MessageQueue.Peek%2A>方法會傳回第一個訊息在佇列中。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>傳回通知、 報表或已傳送至佇列的訊息後建立的應用程式產生的回應訊息。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">具有指定 <paramref name="id" /> 的訊息不存在。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">要窺視訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>窺視訊息識別項符合 <paramref name="id" /> 參數的訊息。 等待直到訊息出現在佇列中，或等到發生逾時。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> 屬性符合 <paramref name="id" /> 參數的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>讀取，但不會從佇列移除訊息具有已知的訊息識別項。 訊息的識別項是唯一的訊息佇列企業中，因此中會有最多一個訊息佇列符合給定`id`參數。 如果佇列目前也不會包含訊息，而且發生逾時前未到達新訊息，則這個多載會擲回例外狀況。  
  
 `timeout`參數未指定此方法的執行時間總計。 相反地，它會指定新訊息到達佇列中等候的時間。 每次新的訊息抵達時，這個方法會檢查<xref:System.Messaging.Message.Id%2A>新訊息是否符合`id`參數。 否則，這個方法的逾時期間的開始，並等候另一個新訊息到達。 因此，如果新的訊息持續逾時期間內抵達時，可能會此方法才能繼續執行，直到逾時期間過期且沒有任何新的訊息抵達，或是在訊息抵達其之前<xref:System.Messaging.Message.Id%2A>符合`id`參數。  
  
 兩個額外的方法可讓您查看佇列中的訊息：<xref:System.Messaging.MessageQueue.Peek%2A>和<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 <xref:System.Messaging.MessageQueue.Peek%2A>方法會傳回第一個訊息在佇列中。<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>傳回通知、 報表或已傳送至佇列的訊息後建立的應用程式產生的回應訊息。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.InvalidOperationException">佇列中沒有具有指定 <paramref name="id" /> 的訊息，且該訊息未在 <paramref name="timeout" /> 參數指定的逾時到期前到達。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 MSMQ 3.0 中介紹。 窺視佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">要窺視之訊息的 <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>在 MSMQ 3.0 中介紹。 窺視符合非交易佇列之指定查詢識別項的訊息。</summary>
        <returns>傳入符合 <paramref name="lookupId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.LookupId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法，而不移除它從佇列讀取具有已知的查閱識別項。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，應該會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 讀取具有指定的查詢識別碼的訊息，並將它從佇列移除，請使用<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>方法。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定如何在佇列中讀取訊息。 請指定下列其中一個選項：  
  
 <see langword="MessageLookupAction.Current" />：窺視 <c>lookupId</c> 指定的訊息。  
  
 <see langword="MessageLookupAction.Next" />：窺視 <c>lookupId</c> 指定的訊息後面的訊息。  
  
 <see langword="MessageLookupAction.Previous" />：窺視 <c>lookupId</c> 指定的訊息前面的訊息。  
  
 <see langword="MessageLookupAction.First" />：窺視佇列中的第一則訊息。 <c>lookupId</c> 參數必須設定為 0。  
  
 <see langword="MessageLookupAction.Last" />：窺視佇列中的最後一則訊息。 <c>lookupId</c> 參數必須設定為 0。</param>
        <param name="lookupId">要窺視之訊息的 <see cref="P:System.Messaging.Message.LookupId" />，或者為 0。 存取佇列中第一則或最後一則訊息時會使用 0。</param>
        <summary>在 MSMQ 3.0 中介紹。 窺視佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
        <returns>傳入之 <paramref name="action" /> 和 <paramref name="lookupId" /> 參數所指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法，而不移除它從佇列讀取具有已知的查閱識別項。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，應該會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 讀取具有指定識別碼的訊息，並將它從佇列移除，請使用<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>方法。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 成員。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於訊息已讀取但未從佇列中移除時。 這是非同步作業 <see cref="M:System.Messaging.MessageQueue.BeginPeek" /> 的結果。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 在非同步處理用來引發<xref:System.Messaging.MessageQueue.PeekCompleted>事件佇列中出現一則訊息時。  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 用來完成作業的呼叫所初始化<xref:System.Messaging.MessageQueue.BeginPeek%2A>和窺視訊息時<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件。  
  
 建立 <xref:System.Messaging.PeekCompletedEventHandler> 委派時，必須識別處理事件的方法。 若要使事件與您的事件處理常式產生關聯，請將委派的執行個體 (Instance) 加入至事件。 除非您移除委派，否則每當事件發生時就會呼叫事件處理常式。 如需事件處理常式委派的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立名為事件處理常式`MyPeekCompleted`，將它附加至<xref:System.Messaging.MessageQueue.PeekCompleted>事件處理常式委派，並呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A>起始位於路徑上的佇列上的非同步窺視作業 」。 \myQueue"。 當<xref:System.Messaging.MessageQueue.PeekCompleted>就會引發事件，此範例窺視訊息，並將其本文寫入至螢幕。 此範例會接著呼叫<xref:System.Messaging.MessageQueue.BeginPeek%2A> 以起始新的非同步查看作業  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刪除佇列中所包含的所有訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 清除佇列會導致訊息佇列設定的佇列修改旗標，會影響<xref:System.Messaging.MessageQueue.LastModifyTime%2A>屬性。 從佇列中清除的訊息都會遺失。它們不會傳送到寄不出信件佇列或日誌佇列。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Purge%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定識別佇列的易記名稱。</summary>
        <value>名稱，識別這個 <see cref="T:System.Messaging.MessageQueue" /> 所參考的佇列。 這個值不能為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以結合<xref:System.Messaging.MessageQueue.QueueName%2A>與<xref:System.Messaging.MessageQueue.MachineName%2A>建立易記<xref:System.Messaging.MessageQueue.Path%2A>佇列的名稱。 易記名稱變化的語法<xref:System.Messaging.MessageQueue.Path%2A>屬性取決於佇列類型下, 表所示。  
  
|佇列類型|語法|  
|----------------|------------|  
|公用佇列|`MachineName`\\`QueueName`|  
|私用佇列|`MachineName`\\`Private$`\\`QueueName`|  
|日誌佇列|`MachineName`\\`QueueName`\\`Journal$`|  
  
 使用"。"代表本機電腦。  
  
 變更<xref:System.Messaging.MessageQueue.QueueName%2A>屬性會影響<xref:System.Messaging.MessageQueue.Path%2A>屬性。 如果您設定<xref:System.Messaging.MessageQueue.QueueName%2A>未設定<xref:System.Messaging.MessageQueue.MachineName%2A>屬性，<xref:System.Messaging.MessageQueue.Path%2A>屬性變成。\\`QueueName`. 否則，<xref:System.Messaging.MessageQueue.Path%2A>變成`MachineName` \\ `QueueName`。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|[是]|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.QueueName%2A>屬性。  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">佇列名稱是 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來從訊息佇列讀取訊息的原生控制代碼。</summary>
        <value>用來從佇列窺視或接收訊息之原生佇列物件的控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A>提供用於窺視或從佇列接收訊息的訊息佇列物件的原生 Windows 控制代碼。 如果您變更佇列的路徑，控制代碼關閉並重新開啟新的值。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <summary>接收佇列中的第一個訊息，並將它從佇列中移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 參考的第一個在佇列中可用的訊息。 這個呼叫是同步的，而且會阻礙目前執行的執行緒，直到訊息可以使用。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載會收到訊息從佇列中，或等到有訊息佇列中。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允許同步讀取一個訊息，因而從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回跟在佇列中，或新的、 高優先權的訊息的訊息。  
  
 若要讀取佇列中的第一個訊息，而不需移除佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 因為此多載的<xref:System.Messaging.MessageQueue.Receive%2A>方法會指定無限逾時、 應用程式可能會無限期等候。 如果應用程式處理應該不需等到訊息繼續，請考慮使用非同步的方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例從佇列接收訊息，並輸出至畫面的訊息的相關資訊。  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 參考的第一個在交易佇列中可用的訊息。 這個呼叫是同步的，而且會阻礙目前執行的執行緒，直到訊息可以使用。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要從使用內部交易內容所定義的交易式佇列接收訊息中使用此多載`transaction`參數或等到有訊息佇列中。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允許同步讀取一個訊息，因而從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回佇列中遵循的訊息。  
  
 因為在交易式佇列上呼叫此方法時，收到的訊息會傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的第一個訊息，而不需移除佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會移除任何訊息佇列中，會是 nothing 回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 因為此多載的<xref:System.Messaging.MessageQueue.Receive%2A>方法會指定無限逾時、 應用程式可能會無限期等候。 如果應用程式處理應該不需等到訊息繼續，請考慮使用非同步的方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會連接到本機電腦上的交易式佇列，並將訊息傳送至佇列。 然後會收到含有訂單的訊息。 如果遇到非交易式佇列，則會擲回例外狀況並回復交易。  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。  
  
 -或-  
  
 該佇列是非交易式佇列。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 參考的第一個在佇列中可用的訊息。 這個呼叫是同步的，而且會阻礙目前執行的執行緒，直到訊息可以使用。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要從使用異動內容所定義的佇列接收訊息中使用此多載`transactionType`參數或等到有訊息佇列中。  
  
 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息當做單一的內部異動。 您可以指定`None`如果您想要從交易內容外部異動式佇列接收訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允許同步讀取一個訊息，因而從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回佇列中遵循的訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，收到的訊息將傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的第一個訊息，而不需移除佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會移除任何訊息佇列中，會是 nothing 回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 因為此多載的<xref:System.Messaging.MessageQueue.Receive%2A>方法會指定無限逾時、 應用程式可能會無限期等候。 如果應用程式處理應該不需等到訊息繼續，請考慮使用非同步的方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 所參考之佇列中的第一個可用訊息，並等候直到佇列中有可用訊息，或者逾時到期。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載來接收訊息，如果佇列中沒有訊息，則在指定時間期限傳回。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允許同步讀取一個訊息，它從佇列中移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回跟在佇列中，或新的、 高優先權的訊息的訊息。  
  
 若要讀取佇列中的第一個訊息，而不需移除佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 執行緒將給定的期間內的時間或無限期地封鎖您指定的值如果<xref:System.Messaging.MessageQueue.InfiniteTimeout>如`timeout`參數。 如果應用程式處理應該繼續而不等待的訊息，請考慮使用非同步的方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例從佇列接收訊息，並輸出至畫面的訊息的相關資訊。 此範例會暫停執行五秒，等待訊息到達佇列中。  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <summary>使用指定的游標接收佇列中的目前訊息。 如果沒有可用的訊息，則這個方法會等到有訊息可用或逾時為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤  
  
 使用這個多載來接收訊息，如果佇列中沒有訊息，則在指定時間期限傳回。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收 <see cref="T:System.Messaging.MessageQueue" /> 所參考之交易佇列中的第一個可用訊息，並且等候直到佇列中出現可用訊息，或逾時過期為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要從使用內部交易內容所定義的交易式佇列接收訊息中使用此多載`transaction`參數，並傳回指定期間內的時間，如果佇列中沒有其他訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允許同步讀取一個訊息，因而從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回佇列中遵循的訊息。  
  
 因為在交易式佇列上呼叫此方法時，收到的訊息會傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的第一個訊息，而不需移除佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會移除任何訊息佇列中，會是 nothing 回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 執行緒將給定的期間內的時間或無限期地封鎖您指定的值如果<xref:System.Messaging.MessageQueue.InfiniteTimeout>如`timeout`參數。 如果應用程式處理應該繼續而不等待的訊息，請考慮使用非同步的方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個方法。  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
 -或-  
  
 該佇列是非交易式佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收由 <see cref="T:System.Messaging.MessageQueue" /> 參考的第一個在佇列中可用的訊息。 這個呼叫是同步的，並且會等候直到佇列中出現可用訊息，或逾時過期為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的第一個可用訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要從使用異動內容所定義的佇列接收訊息中使用此多載`transactionType`參數，並傳回在指定的一段時間，如果佇列中沒有其他訊息。  
  
 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息當做單一的內部異動。 您可以指定`None`如果您想要從交易內容外部異動式佇列接收訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允許同步讀取一個訊息，因而從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>會傳回佇列中遵循的訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，收到的訊息將傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的第一個訊息，而不需移除佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 <xref:System.Messaging.MessageQueue.Peek%2A>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會移除任何訊息佇列中，會是 nothing 回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 執行緒將給定的期間內的時間或無限期地封鎖您指定的值如果<xref:System.Messaging.MessageQueue.InfiniteTimeout>如`timeout`參數。 如果應用程式處理應該繼續而不等待的訊息，請考慮使用非同步的方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個方法。  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>使用指定的游標接收佇列中的目前訊息。 如果沒有可用的訊息，則這個方法會等到有訊息可用或逾時為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要從使用內部交易內容所定義的交易式佇列接收訊息中使用此多載`transaction`參數，並傳回指定期間內的時間，如果佇列中沒有其他訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允許同步讀取一個訊息，因而從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>遵循的訊息傳回佇列中。  
  
 因為這個方法呼叫交易式佇列，如果交易已中止所收到的訊息會傳回至佇列。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會移除任何訊息佇列中，沒有要回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 給定的期間內的時間或無限期地封鎖執行緒如果您指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>如`timeout`參數。 如果應用程式處理應該繼續而不等待的訊息，請考慮使用非同步的方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。 可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
 -或-  
  
 該佇列是非交易式佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" />，保留訊息佇列中的特定位置。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息產生關聯的交易內容類型。</param>
        <summary>使用指定的游標接收佇列中的目前訊息。 如果沒有可用的訊息，則這個方法會等到有訊息可用或逾時為止。</summary>
        <returns>
          <see cref="T:System.Messaging.Message" />，參考佇列中的訊息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要從使用異動內容所定義的佇列接收訊息中使用此多載`transactionType`參數，並傳回在指定的一段時間，如果佇列中沒有其他訊息。  
  
 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息當做單一的內部異動。 您可以指定`None`如果您想要從交易內容外部異動式佇列接收訊息。  
  
 <xref:System.Messaging.MessageQueue.Receive%2A>方法允許同步讀取一個訊息，因而從佇列移除。 後續呼叫<xref:System.Messaging.MessageQueue.Receive%2A>遵循的訊息傳回佇列中。  
  
 如果呼叫這個方法會從異動式佇列接收訊息，會收到的訊息會傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 若要讀取佇列中的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.Peek%2A>方法。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.Peek%2A>。 因為<xref:System.Messaging.MessageQueue.Peek%2A>不會移除任何訊息佇列中，沒有要回復呼叫<xref:System.Messaging.MessageQueueTransaction.Abort%2A>。  
  
 使用呼叫<xref:System.Messaging.MessageQueue.Receive%2A>時可接受進行封鎖並同時等候訊息到達佇列中目前的執行緒。 給定的期間內的時間或無限期地封鎖執行緒如果您指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>如`timeout`參數。 如果應用程式處理應該繼續而不等待的訊息，請考慮使用非同步的方法， <xref:System.Messaging.MessageQueue.BeginReceive%2A>。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">指定給 <paramref name="timeout" /> 參數的值無效。 可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">訊息沒有在逾時到期前到達佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <threadsafe>這個方法不是安全執行緒。</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收符合指定關聯識別項的訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <summary>接收符合指定關聯識別項的訊息 (從非交易佇列中)，如果佇列中目前不存在具有指定關聯識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會在所參照的非交易式佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數時，擲回例外狀況。 否則，訊息會從佇列中移除，並傳回到應用程式。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來將繫結傳送至相關聯的回應、 報表或通知訊息至佇列的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法擷取一則訊息，藉由指定其唯一識別碼。  
  
 若要讀取具有指定的相互關聯識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會將傳送和接收包含訂單與佇列的訊息。 它特別要求正值通知，當原始訊息抵達或已從佇列擷取。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收符合指定關聯識別項的訊息 (從交易佇列中)，如果佇列中目前不存在具有指定關聯識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會在所參照的交易式佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數時，擲回例外狀況。 否則，訊息是從佇列中移除並傳回應用程式使用所定義的內部交易內容`transaction`參數。  
  
 因為在交易式佇列上呼叫此方法時，收到的訊息會傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來將繫結傳送至相關聯的回應、 報表或通知訊息至佇列的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定其唯一識別碼。  
  
 若要讀取具有指定的相互關聯識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不會移除任何訊息佇列中，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">該佇列是非交易式佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收符合指定關聯識別項的訊息，如果佇列中目前不存在具有指定關聯識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會在所參照的佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 如果不找到任何訊息符合`correlationID`參數時，擲回例外狀況。 否則，訊息是從佇列中移除，並傳回到應用程式使用所定義的交易內容`transactionType`參數。  
  
 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息當做單一的內部異動。 您可以指定`None`如果您想要從交易內容外部異動式佇列接收訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，收到的訊息將傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來將繫結傳送至相關聯的回應、 報表或通知訊息至佇列的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定其唯一識別碼。  
  
 若要讀取具有指定的相互關聯識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不會移除任何訊息佇列中，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>接收符合指定關聯識別項的訊息 (從非交易佇列中)，並且等待佇列中出現具有指定關聯識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會在所參照的非交易式佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 這個方法會立即傳回如果所指定的訊息相互關聯識別項`correlationId`參數是在佇列中。 否則，方法會等候指定的一段時間的新訊息到達。 如果逾時到期前未到達新訊息，則會擲回例外狀況。  
  
 `timeout`參數未指定此方法的執行時間總計。 相反地，它會指定新訊息到達佇列中等候的時間。 每次新的訊息抵達時，這個方法會檢查<xref:System.Messaging.Message.CorrelationId%2A>新訊息是否符合`correlationId`參數。 否則，這個方法的逾時期間的開始，並等候另一個新訊息到達。 因此，如果新的訊息持續逾時期間內抵達時，可能會此方法才能繼續執行，直到逾時期間過期且沒有任何新的訊息抵達，或是在訊息抵達其之前<xref:System.Messaging.Message.CorrelationId%2A>符合`correlationId`參數。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來將繫結傳送至相關聯的回應、 報表或通知訊息至佇列的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定其唯一識別碼。  
  
 若要讀取具有指定的相互關聯識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">佇列中沒有具有指定 <paramref name="correlationId" /> 的訊息，且該訊息未在逾時到期前到達。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收符合指定關聯識別項的訊息 (從交易佇列中)，並且等待佇列中出現具有指定關聯識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會在所參照的交易式佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 這個方法會立即傳回如果所指定的訊息相互關聯識別項`correlationId`參數是在佇列中，使用所定義的內部異動內容`transaction`參數。 否則，方法會等候指定的一段時間的新訊息到達。 如果逾時到期前未到達新訊息，則會擲回例外狀況。  
  
 `timeout`參數未指定此方法的執行時間總計。 相反地，它會指定新訊息到達佇列中等候的時間。 每次新的訊息抵達時，這個方法會檢查<xref:System.Messaging.Message.CorrelationId%2A>新訊息是否符合`correlationId`參數。 否則，這個方法的逾時期間的開始，並等候另一個新訊息到達。 因此，如果新的訊息持續逾時期間內抵達時，可能會此方法才能繼續執行，直到逾時期間過期且沒有任何新的訊息抵達，或是在訊息抵達其之前<xref:System.Messaging.Message.CorrelationId%2A>符合`correlationId`參數。  
  
 因為在交易式佇列上呼叫此方法時，收到的訊息會傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來將繫結傳送至相關聯的回應、 報表或通知訊息至佇列的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定其唯一識別碼。  
  
 若要讀取具有指定的相互關聯識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不會移除任何訊息佇列中，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">佇列中沒有具有指定 <paramref name="correlationId" /> 的訊息，且該訊息未在逾時到期前到達。  
  
 -或-  
  
 該佇列是非交易式佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">要接收訊息的 <see cref="P:System.Messaging.Message.CorrelationId" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收符合指定關聯識別項的訊息，並且等待佇列中出現具有指定關聯識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="correlationId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.CorrelationId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會在所參照的佇列<xref:System.Messaging.MessageQueue>訊息其<xref:System.Messaging.Message.CorrelationId%2A>符合指定`correlationId`參數。 這個方法會立即傳回如果所指定的訊息相互關聯識別項`correlationId`參數是在佇列中，使用所定義的交易內容`transactionType`參數。 否則，方法會等候指定的一段時間的新訊息到達。 如果逾時到期前未到達新訊息，則會擲回例外狀況。  
  
 `timeout`參數未指定此方法的執行時間總計。 相反地，它會指定新訊息到達佇列中等候的時間。 每次新的訊息抵達時，這個方法會檢查<xref:System.Messaging.Message.CorrelationId%2A>新訊息是否符合`correlationId`參數。 否則，這個方法的逾時期間的開始，並等候另一個新訊息到達。 因此，如果新的訊息持續逾時期間內抵達時，可能會此方法才能繼續執行，直到逾時期間過期且沒有任何新的訊息抵達，或是在訊息抵達其之前<xref:System.Messaging.Message.CorrelationId%2A>符合`correlationId`參數。 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息當做單一的內部異動。 您可以指定`None`如果您想要從交易內容外部異動式佇列接收訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，收到的訊息將傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 <xref:System.Messaging.Message.CorrelationId%2A>屬性用來將繫結傳送至相關聯的回應、 報表或通知訊息至佇列的訊息。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>方法用來擷取訊息，藉由指定其唯一識別碼。  
  
 若要讀取具有指定的相互關聯識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>不會移除任何訊息佇列中，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="correlationId" /> 的訊息。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">佇列中沒有具有指定 <paramref name="correlationId" /> 的訊息，且該訊息未在逾時到期前到達。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收符合指定識別項的訊息，並將它從佇列中移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <summary>從非交易佇列中接收符合指定識別項的訊息，如果佇列中目前不存在具有指定識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知識別碼的訊息，並將它從佇列移除使用這個方法。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是唯一的訊息佇列企業中，因此會有最多一個訊息符合的佇列中給定`id`參數。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息後建立的應用程式產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="id" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收符合指定識別項的訊息 (從交易佇列中)，如果佇列中目前不存在具有指定識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取具有已知識別碼的訊息，並將它移除從佇列中，使用所定義的內部異動內容`transaction`參數。 這個方法擲回例外狀況的立即訊息是否不在佇列中  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是唯一的訊息佇列企業中，因此會有最多一個訊息符合的佇列中給定`id`參數。  
  
 因為在交易式佇列上呼叫此方法時，收到的訊息會傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息後建立的應用程式產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不會移除任何訊息佇列中，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="id" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">該佇列是非交易式佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收符合指定識別項的訊息，如果佇列中目前不存在具有指定識別項的訊息，則立即引發例外狀況。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知識別碼的訊息，並將它從佇列移除使用這個方法。 這個方法會擲回例外狀況立即訊息是否不在佇列中。 否則，訊息是從佇列中移除，並傳回到應用程式使用所定義的交易內容`transactionType`參數。  
  
 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息當做單一的內部異動。 您可以指定`None`如果您想要從交易內容外部異動式佇列接收訊息。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是唯一的訊息佇列企業中，因此會有最多一個訊息符合的佇列中給定`id`參數。 如果具有指定識別碼的訊息是以外與此相關聯的佇列中<xref:System.Messaging.MessageQueue>執行個體，將無法找到訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，收到的訊息將傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息後建立的應用程式產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不會移除任何訊息佇列中，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="id" /> 的訊息。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <summary>接收符合指定識別項的訊息 (從非交易佇列中)，並且等待佇列中出現具有指定識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知識別碼的訊息，並將它從佇列移除使用這個方法。 這個方法會立即傳回如果所指定的訊息識別項`id`參數是在佇列中。 否則，方法會等候指定的一段時間的新訊息到達。 如果逾時到期前未到達新訊息，則會擲回例外狀況。  
  
 `timeout`參數未指定此方法的執行時間總計。 相反地，它會指定新訊息到達佇列中等候的時間。 每次新的訊息抵達時，這個方法會檢查<xref:System.Messaging.Message.Id%2A>新訊息是否符合`id`參數。 否則，這個方法的逾時期間的開始，並等候另一個新訊息到達。 因此，如果新的訊息持續逾時期間內抵達時，可能會此方法才能繼續執行，直到逾時期間過期且沒有任何新的訊息抵達，或是在訊息抵達其之前<xref:System.Messaging.Message.Id%2A>符合`id`參數。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是唯一的訊息佇列企業中，因此會有最多一個訊息符合的佇列中給定`id`參數。  
  
 使用此多載的<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>時，只要新訊息到達佇列所指定的逾時期間內會繼續封鎖目前的執行緒可接受`timeout`參數。 執行緒會為封鎖至少在特定期間的時間或無限期如果您指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>如`timeout`參數，或如果新訊息到達佇列所指定的逾時期間內繼續`timeout`參數。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息後建立的應用程式產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29> 的用法。  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="id" /> 的訊息未在逾時到期前到達佇列中。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>接收符合指定識別項的訊息 (從交易佇列中)，並且等待佇列中出現具有指定識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取具有已知識別碼的訊息，並將它移除從佇列中，使用所定義的內部異動內容`transaction`參數。 這個方法會立即傳回如果所指定的訊息識別項`id`參數是在佇列中。 否則，方法會等候指定的一段時間的新訊息到達。 如果逾時到期前未到達新訊息，則會擲回例外狀況。  
  
 `timeout`參數未指定此方法的執行時間總計。 相反地，它會指定新訊息到達佇列中等候的時間。 每次新的訊息抵達時，這個方法會檢查<xref:System.Messaging.Message.Id%2A>新訊息是否符合`id`參數。 否則，這個方法的逾時期間的開始，並等候另一個新訊息到達。 因此，如果新的訊息持續逾時期間內抵達時，可能會此方法才能繼續執行，直到逾時期間過期且沒有任何新的訊息抵達，或是在訊息抵達其之前<xref:System.Messaging.Message.Id%2A>符合`id`參數。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是唯一的訊息佇列企業中，因此會有最多一個訊息符合的佇列中給定`id`參數。  
  
 使用此多載的<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>時，只要新訊息到達佇列所指定的逾時期間內會繼續封鎖目前的執行緒可接受`timeout`參數。 執行緒會為封鎖至少在特定期間的時間或無限期如果您指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>如`timeout`參數，或如果新訊息到達佇列所指定的逾時期間內繼續`timeout`參數。  
  
 因為在交易式佇列上呼叫此方法時，收到的訊息會傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息後建立的應用程式產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不會移除任何訊息佇列中，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="id" /> 的訊息未在逾時到期前到達佇列中。  
  
 -或-  
  
 該佇列是非交易式佇列。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">要接收訊息的 <see cref="P:System.Messaging.Message.Id" />。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，指出等待新訊息可以進行檢查的時間。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>接收符合指定識別項的訊息，並且等待佇列中出現具有指定識別項的訊息，或者逾時到期。</summary>
        <returns>傳入符合 <paramref name="id" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.Id" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 讀取具有已知識別碼的訊息，並將它從佇列移除使用這個方法。 這個方法會立即傳回如果所指定的訊息識別項`id`參數是在佇列中，使用所定義的交易內容`transactionType`參數。 否則，方法會等候指定的一段時間的新訊息到達。 如果逾時到期前未到達新訊息，則會擲回例外狀況。  
  
 `timeout`參數未指定此方法的執行時間總計。 相反地，它會指定新訊息到達佇列中等候的時間。 每次新的訊息抵達時，這個方法會檢查<xref:System.Messaging.Message.Id%2A>新訊息是否符合`id`參數。 否則，這個方法的逾時期間的開始，並等候另一個新訊息到達。 因此，如果新的訊息持續逾時期間內抵達時，可能會此方法才能繼續執行，直到逾時期間過期且沒有任何新的訊息抵達，或是在訊息抵達其之前<xref:System.Messaging.Message.Id%2A>符合`id`參數。  
  
 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息當做單一的內部異動。 您可以指定`None`如果您想要從交易內容外部異動式佇列接收訊息。  
  
 <xref:System.Messaging.Message.Id%2A>訊息屬性是唯一的訊息佇列企業中，因此會有最多一個訊息符合的佇列中給定`id`參數。 如果具有指定識別碼的訊息是以外與此相關聯的佇列中<xref:System.Messaging.MessageQueue>執行個體，將無法找到訊息。  
  
 使用此多載的<xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>時，只要新訊息到達佇列所指定的逾時期間內會繼續封鎖目前的執行緒可接受`timeout`參數。 執行緒會為封鎖至少在特定期間的時間或無限期如果您指定的值<xref:System.Messaging.MessageQueue.InfiniteTimeout>如`timeout`參數，或如果新訊息到達佇列所指定的逾時期間內繼續`timeout`參數。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，收到的訊息將傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 另外兩個方法可讓您從佇列接收訊息。 <xref:System.Messaging.MessageQueue.Receive%2A>方法會傳回第一個訊息在佇列中，而<xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29>方法用來擷取通知、 報表或已傳送至佇列的訊息後建立的應用程式產生的回應訊息。  
  
 若要讀取具有指定識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法。 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>方法一律會傳回第一個訊息在佇列中，因此方法的後續呼叫會傳回相同的訊息，除非較高優先權的訊息抵達佇列中。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>。 因為<xref:System.Messaging.MessageQueue.PeekById%28System.String%29>不會移除任何訊息佇列中，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為 <paramref name="timeout" /> 參數指定的值無效，可能是 <paramref name="timeout" /> 小於 <see cref="F:System.TimeSpan.Zero" /> 或大於 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">具有指定 <paramref name="id" /> 的訊息未在逾時到期前到達佇列中。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 MSMQ 3.0 中介紹。 接收佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">要接收訊息的 <see cref="P:System.Messaging.Message.LookupId" />。</param>
        <summary>在 MSMQ 3.0 中介紹。 接收符合非交易佇列之指定查詢識別項的訊息。</summary>
        <returns>傳入符合 <paramref name="lookupId" /> 參數的 <see cref="T:System.Messaging.Message" /> 的 <see cref="P:System.Messaging.Message.LookupId" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來讀取訊息與已知的查閱識別項，並從佇列中移除。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，應該會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 若要讀取具有指定的查詢識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定如何在佇列中讀取訊息。 請指定下列其中一個選項：  
  
 <see langword="MessageLookupAction.Current" />：接收 <c>lookupId</c> 指定的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.Next" />：接收 <c>lookupId</c> 指定的訊息後面的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.Previous" />：接收 <c>lookupId</c> 指定的訊息前面的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.First" />：接收佇列中的第一則訊息，並且從佇列中移除。 <c>lookupId</c> 參數必須設定為 0。  
  
 <see langword="MessageLookupAction.Last" />：接收佇列中的最後一則訊息，並且從佇列中移除。 <c>lookupId</c> 參數必須設定為 0。</param>
        <param name="lookupId">要接收之訊息的 <see cref="P:System.Messaging.Message.LookupId" />，或者為 0。 存取佇列中第一則或最後一則訊息時會使用 0。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>在 MSMQ 3.0 中介紹。 接收交易佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
        <returns>傳入之 <paramref name="lookupId" /> 和 <paramref name="action" /> 參數所指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取具有已知的查閱識別項，並將它移除從佇列中，使用所定義的交易內容`transaction`參數。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，應該會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 因為在交易式佇列上呼叫此方法時，收到的訊息會傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 若要讀取具有指定識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>。 因為<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>不會移除任何佇列的訊息，就是如果中止的交易已回復並無關聯。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。  
  
 -或-  
  
 該佇列是非交易式佇列。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 成員。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 值，指定如何在佇列中讀取訊息。 請指定下列其中一個選項：  
  
 <see langword="MessageLookupAction.Current" />：接收 <c>lookupId</c> 指定的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.Next" />：接收 <c>lookupId</c> 指定的訊息後面的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.Previous" />：接收 <c>lookupId</c> 指定的訊息前面的訊息，並且從佇列中移除。  
  
 <see langword="MessageLookupAction.First" />：接收佇列中的第一則訊息，並且從佇列中移除。 <c>lookupId</c> 參數必須設定為 0。  
  
 <see langword="MessageLookupAction.Last" />：接收佇列中的最後一則訊息，並且從佇列中移除。 <c>lookupId</c> 參數必須設定為 0。</param>
        <param name="lookupId">要接收之訊息的 <see cref="P:System.Messaging.Message.LookupId" />，或者為 0。 存取佇列中第一則或最後一則訊息時會使用 0。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>在 MSMQ 3.0 中介紹。 使用指定的交易內容接收佇列中的特定訊息。 訊息可以由查閱識別項指定，或由訊息在佇列前面或結尾的位置來指定。</summary>
        <returns>傳入之 <paramref name="action" /> 和 <paramref name="lookupId" /> 參數所指定的 <see cref="T:System.Messaging.Message" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來讀取具有已知的查閱識別項，並將它移除從佇列中，使用所定義的交易內容`transactionType`參數。 這個方法會擲回例外狀況立即訊息是否不在佇列中。  
  
 <xref:System.Messaging.Message.LookupId%2A>訊息屬性是唯一的佇列訊息所在的位置，應該會有最多一個訊息在佇列中符合指定`lookupId`參數。  
  
 若要讀取具有指定識別碼的訊息而不需移除佇列，使用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>方法。 沒有與呼叫所傳回的訊息相關聯交易內容<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>。 因為<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>不會移除任何佇列的訊息，就是如果中止的交易已回復並無關聯。  
  
 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來接收訊息的執行緒。 指定`Single`如果您想要接收的訊息當做單一的內部異動。 您可以指定`None`如果您想要從交易內容外部異動式佇列接收訊息。  
  
 如果這個方法呼叫從異動式佇列接收訊息時，收到的訊息將傳回至佇列，如果交易已中止。 訊息不是永久移除從佇列上，直到交易認可為止。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安裝 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">找不到具有指定 <paramref name="lookupId" /> 的訊息。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageLookupAction" /> 成員。  
  
 -或-  
  
 <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於從佇列移除訊息時。 這個事件是由非同步作業 <see cref="M:System.Messaging.MessageQueue.BeginReceive" /> 所引發。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 在非同步處理用來引發<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件佇列中出現一則訊息時。  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 用來完成作業的呼叫所初始化<xref:System.Messaging.MessageQueue.BeginReceive%2A>和窺視訊息時<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件。  
  
 建立 <xref:System.Messaging.ReceiveCompletedEventHandler> 委派時，必須識別處理事件的方法。 若要使事件與您的事件處理常式產生關聯，請將委派的執行個體 (Instance) 加入至事件。 除非您移除委派，否則每當事件發生時就會呼叫事件處理常式。 如需事件處理常式委派的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立名為事件處理常式`MyReceiveCompleted`，將它附加至<xref:System.Messaging.MessageQueue.ReceiveCompleted>事件處理常式委派，並呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A>啟始的非同步接收作業是位於路徑的佇列上 「。 \myQueue"。 當<xref:System.Messaging.MessageQueue.ReceiveCompleted>就會引發事件，範例接收訊息，並將其本文寫入至螢幕。 此範例會接著呼叫<xref:System.Messaging.MessageQueue.BeginReceive%2A> 以起始新的非同步接收作業。  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新整理由 <see cref="T:System.Messaging.MessageQueue" /> 所表示的屬性，以反映資源的目前狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> 同步處理的屬性<xref:System.Messaging.MessageQueue>與其相關聯的訊息佇列伺服器資源。 如果任何內容，例如<xref:System.Messaging.MessageQueue.Label%2A>或<xref:System.Messaging.MessageQueue.Category%2A>，已經在伺服器上變更以來<xref:System.Messaging.MessageQueue>已建立，<xref:System.Messaging.MessageQueue.Refresh%2A>更新<xref:System.Messaging.MessageQueue>以新的資訊。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Refresh%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將使用權限清單重設為作業系統的預設值。 移除任何附加至預設清單的佇列使用權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您呼叫<xref:System.Messaging.MessageQueue.ResetPermissions%2A>，權限清單返回其預設值。 一般而言，這所有使用權限，授與佇列建立者，並提供每個使用者群組的下列權限：  
  
-   取得佇列的屬性。  
  
-   取得佇列的權限。  
  
-   寫入至佇列。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.ResetPermissions%2A> 的用法。  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將物件傳送至佇列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的非交易佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳送訊息，其中包含使用此多載`obj`參數所參照的佇列<xref:System.Messaging.MessageQueue>。 傳送至佇列的物件可以是<xref:System.Messaging.Message>或任何 managed 的物件。 如果您不是傳送任何物件<xref:System.Messaging.Message>，物件會序列化並插入至訊息的本文。  
  
 如果您使用這個多載，將訊息傳送至異動式佇列，訊息會傳送到寄不出信件佇列。 如果您想要包含其他訊息是交易的一部分的訊息時，使用多載採用<xref:System.Messaging.MessageQueueTransaction>或<xref:System.Messaging.MessageQueueTransactionType>做為參數。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式子的預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 當傳送<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會連接到訊息佇列，並將訊息傳送至佇列。  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 下列程式碼範例會將傳送應用程式定義`Order`類別至佇列，然後從該佇列接收訊息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的交易佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳送訊息，其中包含使用此多載`obj`異動式佇列所參考的參數<xref:System.Messaging.MessageQueue>，使用內部交易內容所定義`transaction`參數。 傳送至佇列的物件可以是<xref:System.Messaging.Message>或任何 managed 的物件。 如果您不是傳送任何物件<xref:System.Messaging.Message>，物件會序列化並插入至訊息的本文。  
  
 如果您使用這個多載，將訊息傳送至非交易式佇列，訊息可以傳送到寄不出信件佇列而不擲回例外狀況。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式子的預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 當傳送<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 <xref:System.Messaging.MessageQueueTransaction> 為執行緒的 apartment 感知的功能，因此，如果已 apartment 狀態`STA`，您無法使用多個執行緒中的交易。 Visual Basic 會將主執行緒的狀態`STA`，因此您必須先套用<xref:System.MTAThreadAttribute>中`Main`副程式。 否則，使用其他執行緒傳送交易式訊息時，會擲回 <xref:System.Messaging.MessageQueueException> 例外狀況。 您套用<xref:System.MTAThreadAttribute>使用下列的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例會將字串傳送至異動式佇列，然後從該佇列接收訊息。  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
 -或-  
  
 訊息佇列應用程式指出不正確的交易用法。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳送訊息，其中包含使用此多載`obj`參數所參照的佇列<xref:System.Messaging.MessageQueue>，使用所定義的交易內容`transactionType`參數。 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來傳送訊息的執行緒。 指定`Single`如果您想要以單一的內部交易傳送訊息。 您可以指定`None`如果您想要將交易式訊息傳送至非交易式的執行緒。  
  
 傳送至佇列的物件可以是<xref:System.Messaging.Message>或任何 managed 的物件。 如果您不是傳送任何物件<xref:System.Messaging.Message>，物件會序列化並插入至訊息的本文。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式子的預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 當傳送<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="label">訊息的標記。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的非交易佇列，並指定訊息的標籤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳送訊息，其中包含使用此多載`obj`參數所參照的佇列<xref:System.Messaging.MessageQueue>。 您可以使用這個多載，指定識別訊息的字串標記。 傳送至佇列的物件可以是<xref:System.Messaging.Message>、 結構、 資料物件或任何 managed 的物件。 如果您不是傳送任何物件<xref:System.Messaging.Message>，物件會序列化並插入至訊息的本文。  
  
 訊息標籤是不同於訊息佇列的標籤，但兩者都是應用程式相依，而且不會繼承到訊息佇列的意義。  
  
 如果您使用這個多載，將訊息傳送至異動式佇列，訊息會傳送到寄不出信件佇列。 如果您想要包含其他訊息是交易的一部分的訊息時，使用多載採用<xref:System.Messaging.MessageQueueTransaction>或<xref:System.Messaging.MessageQueueTransactionType>做為參數。  
  
 <xref:System.Messaging.MessageQueue.Path%2A>屬性這<xref:System.Messaging.MessageQueue>傳送訊息之前，必須指定執行個體。 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式子的預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 當傳送<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29> 的用法。  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="label">訊息的標記。</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> 物件。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的交易佇列，並指定訊息的標籤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳送訊息，其中包含使用此多載`obj`異動式佇列所參考的參數<xref:System.Messaging.MessageQueue>，使用內部交易內容所定義`transaction`參數。 您可以使用這個多載，指定識別訊息的字串標記。 傳送至佇列的物件可以是<xref:System.Messaging.Message>、 結構、 資料物件或任何 managed 的物件。 如果您不是傳送任何物件<xref:System.Messaging.Message>，物件會序列化並插入至訊息的本文。  
  
 訊息標籤是不同於訊息佇列的標籤，但兩者都是應用程式相依，而且不會繼承到訊息佇列的意義。  
  
 如果您使用這個多載，將訊息傳送至非交易式佇列，訊息可以傳送到寄不出信件佇列而不擲回例外狀況。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式子的預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 當傳送<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>和訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性  
  
 <xref:System.Messaging.MessageQueueTransaction> 為執行緒的 apartment 感知的功能，因此，如果已 apartment 狀態`STA`，您無法使用多個執行緒中的交易。 Visual Basic 會將主執行緒的狀態`STA`，因此您必須先套用<xref:System.MTAThreadAttribute>中`Main`副程式。 否則，使用其他執行緒傳送交易式訊息時，會擲回 <xref:System.Messaging.MessageQueueException> 例外狀況。 您套用<xref:System.MTAThreadAttribute>使用下列的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29> 的用法。  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 參數為 <see langword="null" />。  
  
 -或-  
  
 <paramref name="transaction" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
 -或-  
  
 訊息佇列應用程式指出不正確的交易使用方式。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">要傳送至佇列的物件。</param>
        <param name="label">訊息的標記。</param>
        <param name="transactionType">其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 值，描述要與訊息相關聯的異動內容的類型。</param>
        <summary>將物件傳送至這個 <see cref="T:System.Messaging.MessageQueue" /> 參考的佇列，並指定訊息的標籤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳送訊息，其中包含使用此多載`obj`參數所參照的佇列<xref:System.Messaging.MessageQueue>，使用所定義的交易內容`transactionType`參數。 指定`Automatic`如`transactionType`參數，如果已經有外部交易內容附加到您要用來傳送訊息的執行緒。 指定`Single`如果您想要以單一的內部交易傳送訊息。 您可以指定`None`如果您想要將交易式訊息傳送至非交易式的執行緒。  
  
 傳送至佇列的物件可以是<xref:System.Messaging.Message>或任何 managed 的物件。 如果您不是傳送任何物件<xref:System.Messaging.Message>，物件會序列化並插入至訊息的本文。 您可以使用這個多載，指定識別訊息的字串標記。  
  
 訊息標籤是不同於訊息佇列的標籤，但兩者都是應用程式相依，而且不會繼承到訊息佇列的意義。  
  
 如果您未設定<xref:System.Messaging.MessageQueue.Formatter%2A>屬性，然後再呼叫<xref:System.Messaging.MessageQueue.Send%28System.Object%29>，格式子的預設值為<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性會套用至任何物件以外<xref:System.Messaging.Message>。 如果您指定，例如，標籤或優先順序使用<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成員，這些值套用到包含的類型不是物件的任何訊息<xref:System.Messaging.Message>當您的應用程式將它傳送至佇列。 當傳送<xref:System.Messaging.Message>，屬性值設定為<xref:System.Messaging.Message>優先於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>，和訊息<xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>屬性會優先於佇列的<xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>屬性。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">訊息佇列應用程式指出不正確的交易使用方式。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> 參數不是其中一個 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 成員。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> 屬性尚未設定。  
  
 -或-  
  
 存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將使用權限加入至目前集合。 這控制誰有權限可存取佇列屬性和佇列中的訊息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">
          <see cref="T:System.Messaging.AccessControlList" />，包含指定信任項和要授與之使用權限的一個或多個存取控制項目。</param>
        <summary>根據存取控制清單的內容指派佇列的存取權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載來授與、 拒絕或撤銷權限使用集合的存取控制項目指定信任者和權限資訊。 這會使用，例如，同時授與權限給多個使用者。  
  
 您指定當您建構的信任者`ace`參數可以是個別使用者、 使用者、 群組或電腦。 如果個別之信任項目，使用格式`DOMAIN` \\ `user`。 您可以指定"。"表示本機電腦信任項。  
  
 您透過指派權限<xref:System.Messaging.MessageQueue.SetPermissions%2A>新增至現有清單的權限。 根據預設，公用或私用佇列的建立者擁有完整控制權，而且每個人都已取得佇列屬性，取得權限，然後再寫入佇列的權限的網域群組。 當您呼叫<xref:System.Messaging.MessageQueue.SetPermissions%2A>，使用者和權限的資訊會附加至現有清單的底部。  
  
 系統會檢查每個<xref:System.Messaging.AccessControlEntry>順序，直到發生下列事件之一為止：  
  
-   拒絕存取時<xref:System.Messaging.AccessControlEntry>明確拒絕任何要求的存取權限，其中一個執行緒的存取權杖中所列的信任。  
  
-   一或多個允許存取的<xref:System.Messaging.AccessControlEntry>明確列出的執行緒存取權杖中的信任者授與所有要求的存取權限的項目。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已檢查的項目，而且沒有仍在至少一個要求的存取權限未明確允許，在此情況下，會隱含拒絕存取。  
  
 當您建構`dacl`新增參數，<xref:System.Messaging.AccessControlEntry>執行個體來您<xref:System.Messaging.AccessControlList>集合。 當您建構每個存取控制項目時，您可以指定一般或標準存取權限。 佇列的權限可以是下列任何組合：  
  
-   刪除  
  
-   讀取安全性  
  
-   寫入安全性  
  
-   同步處理  
  
-   修改擁有者  
  
-   讀取  
  
-   Write  
  
-   執行  
  
-   必要  
  
-   全部  
  
-   無  
  
 這些權限，您可以使用位元 OR 運算子來結合的位元旗標組。  
  
-   完全控制  
  
-   刪除訊息  
  
-   接收訊息  
  
-   查看訊息  
  
-   接收日誌訊息  
  
-   取得佇列屬性  
  
-   設定佇列屬性  
  
-   取得權限  
  
-   設定權限  
  
-   取得佇列的擁有權  
  
-   寫入訊息  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29> 的用法。      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">指定使用者、存取類型和使用權限類型的 <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />。</param>
        <summary>根據存取控制項目的內容指派佇列的存取權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載來授與、 拒絕或撤銷權限所使用的存取控制項目指定信任者和權限資訊。  
  
 您指定當您建構的信任者`ace`參數可以是個別使用者、 使用者、 群組或電腦。 如果個別之信任項目，使用格式`DOMAIN` \\ `user`。 您可以指定"。"表示本機電腦信任項。  
  
 您透過指派權限<xref:System.Messaging.MessageQueue.SetPermissions%2A>新增至現有清單的權限。 根據預設，公用或私用佇列的建立者擁有完整控制權，而且每個人都已取得佇列屬性，取得權限，然後再寫入佇列的權限的網域群組。 當您呼叫<xref:System.Messaging.MessageQueue.SetPermissions%2A>，使用者和權限的資訊會附加至現有清單的底部。  
  
 系統會檢查每個<xref:System.Messaging.AccessControlEntry>順序，直到發生下列事件之一為止：  
  
-   拒絕存取時<xref:System.Messaging.AccessControlEntry>明確拒絕任何要求的存取權限，其中一個執行緒的存取權杖中所列的信任。  
  
-   一或多個允許存取的<xref:System.Messaging.AccessControlEntry>明確列出的執行緒存取權杖中的信任者授與所有要求的存取權限的項目。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已檢查的項目，而且沒有仍在至少一個要求的存取權限未明確允許，在此情況下，會隱含拒絕存取。  
  
 佇列中，您在中指定的權限`rights`參數在建構時您<xref:System.Messaging.MessageQueueAccessControlEntry>，可以是下列任何組合：  
  
-   完全控制  
  
-   刪除訊息  
  
-   接收訊息  
  
-   查看訊息  
  
-   接收日誌訊息  
  
-   取得佇列屬性  
  
-   設定佇列屬性  
  
-   取得權限  
  
-   設定權限  
  
-   取得佇列的擁有權  
  
-   寫入訊息  
  
 `rights`您指定的參數的建構函式`ace`參數是旗標為<xref:System.Messaging.MessageQueueAccessRights>列舉型別。 它代表一組您可以使用位元運算子來結合的位元旗標或當您建置`rights`參數。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29> 的用法。  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">取得其他佇列權限的個人、群組或電腦。</param>
        <param name="rights">
          <see cref="T:System.Messaging.MessageQueueAccessRights" />，指出訊息佇列指派給 <c>user</c> 傳入之佇列的一組權限。</param>
        <summary>為電腦、群組或使用者提供指定的存取權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要授與指定權限給個別使用者使用這個多載。 使用者可以是任何有效的信任者，包括個別使用者、 使用者、 群組或電腦。 如果是個別的使用者，使用格式`DOMAIN` \\ `user`如`user`參數。 您可以指定"。"的`user`參數，以指定本機電腦。  
  
 您透過指派權限<xref:System.Messaging.MessageQueue.SetPermissions%2A>新增至現有清單的權限。 根據預設，公用或私用佇列的建立者擁有完整控制權，而且每個人都已取得佇列屬性，取得權限，然後再寫入佇列的權限的網域群組。 當您呼叫<xref:System.Messaging.MessageQueue.SetPermissions%2A>，使用者和權限的資訊會附加至現有清單的底部。  
  
 系統會檢查每個<xref:System.Messaging.AccessControlEntry>順序，直到發生下列事件之一為止：  
  
-   拒絕存取時<xref:System.Messaging.AccessControlEntry>明確拒絕任何要求的存取權限，其中一個執行緒的存取權杖中所列的信任。  
  
-   一或多個允許存取的<xref:System.Messaging.AccessControlEntry>明確列出的執行緒存取權杖中的信任者授與所有要求的存取權限的項目。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已檢查的項目，而且沒有仍在至少一個要求的存取權限未明確允許，在此情況下，會隱含拒絕存取。  
  
 中指定佇列的權限`rights`參數，可以是下列任何組合：  
  
-   完全控制  
  
-   刪除訊息  
  
-   接收訊息  
  
-   查看訊息  
  
-   接收日誌訊息  
  
-   取得佇列屬性  
  
-   設定佇列屬性  
  
-   取得權限  
  
-   設定權限  
  
-   取得佇列的擁有權  
  
-   寫入訊息  
  
 <xref:System.Messaging.MessageQueueAccessRights>列舉，代表一組您可以使用位元運算子來結合的位元旗標，或建置`rights`參數。  
  
 使用這個多載中，您可以只授與權限。您無法撤銷或拒絕它們。 您必須使用不同的多載來明確地授與任何<xref:System.Messaging.AccessControlEntryType>以外`Allow`。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29> 的用法。  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">取得其他佇列權限的個人、群組或電腦。</param>
        <param name="rights">
          <see cref="T:System.Messaging.MessageQueueAccessRights" />，指出訊息佇列指派給 <c>user</c> 傳入之佇列的一組權限。</param>
        <param name="entryType">
          <see cref="T:System.Messaging.AccessControlEntryType" />，指定要授與、拒絕或是撤銷 <c>rights</c> 參數所指定的使用權限。</param>
        <summary>以指定的存取控制類型 (允許、拒絕、撤銷或設定)，為電腦、群組或使用者提供指定的存取權限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載來授與、 拒絕或撤銷個別使用者的指定權限。 使用者可以是任何有效的信任者，包括個別使用者、 使用者、 群組或電腦。 如果是個別的使用者，使用格式`DOMAIN` \\ `user`如`user`參數。 您可以指定"。"的`user`參數，以指定本機電腦。  
  
 您透過指派權限<xref:System.Messaging.MessageQueue.SetPermissions%2A>新增至現有清單的權限。 根據預設，公用或私用佇列的建立者擁有完整控制權，而且每個人都已取得佇列屬性，取得權限，然後再寫入佇列的權限的網域群組。 當您呼叫<xref:System.Messaging.MessageQueue.SetPermissions%2A>，使用者和權限的資訊會附加至現有清單的底部。  
  
 系統會檢查每個<xref:System.Messaging.AccessControlEntry>順序，直到發生下列事件之一為止：  
  
-   拒絕存取時<xref:System.Messaging.AccessControlEntry>明確拒絕任何要求的存取權限，其中一個執行緒的存取權杖中所列的信任。  
  
-   一或多個允許存取的<xref:System.Messaging.AccessControlEntry>明確列出的執行緒存取權杖中的信任者授與所有要求的存取權限的項目。  
  
-   所有<xref:System.Messaging.AccessControlEntry>已檢查的項目，而且沒有仍在至少一個要求的存取權限未明確允許，在此情況下，會隱含拒絕存取。  
  
 中指定佇列的權限`rights`參數，可以是下列任何組合：  
  
-   完全控制  
  
-   刪除訊息  
  
-   接收訊息  
  
-   查看訊息  
  
-   接收日誌訊息  
  
-   取得佇列屬性  
  
-   設定佇列屬性  
  
-   取得權限  
  
-   設定權限  
  
-   取得佇列的擁有權  
  
-   寫入訊息  
  
 <xref:System.Messaging.MessageQueueAccessRights>列舉，代表一組您可以使用位元運算子來結合的位元旗標，或建置`rights`參數。  
  
 下表顯示這個方法中是否有提供各種不同的工作群組模式。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例示範 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29> 的用法。  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定封送處理從 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件產生之事件處理常式呼叫的物件。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示封送處理 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 或 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 事件產生之事件處理常式呼叫的物件。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Messaging.MessageQueue.ReceiveCompleted>或<xref:System.Messaging.MessageQueue.PeekCompleted>事件產生<xref:System.Messaging.MessageQueue.BeginReceive%2A>或<xref:System.Messaging.MessageQueue.BeginPeek%2A>分別要求特定執行緒。 一般而言，<xref:System.Messaging.MessageQueue.SynchronizingObject%2A>時設定其相關的元件放置於控制項或表單，因為這些元件會繫結至特定執行緒。  
  
 通常，同步處理物件封送處理成單一執行緒的方法呼叫。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出佇列是否只接受交易。</summary>
        <value>
          如果佇列只接收做為交易一部分傳送的訊息則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 交易式訊息參考到單一異動結合數個相關訊息。 傳送訊息，因為在交易期間可確保訊息傳送順序，只傳遞一次，並從其目的地佇列成功擷取。  
  
 如果佇列是交易式，它會接受會當做交易之一部分傳送的訊息。 不過，非交易式訊息可以傳送或從本機交易佇列接收，而不使用明確交易式<xref:System.Messaging.MessageQueueTransaction.Begin%2A>， <xref:System.Messaging.MessageQueueTransaction.Commit%2A>，和<xref:System.Messaging.MessageQueueTransaction.Abort%2A>語法。 如果非交易式訊息傳送至異動式佇列，這個元件會建立單一訊息交易，除了在參考上使用直接格式名稱的遠端電腦的佇列。 在此情況下，傳送訊息時，您不會指定在交易內容，如果不為您建立一個，訊息會傳送到寄不出信件佇列。  
  
 如果您的非交易式訊息傳送至異動式佇列時，您將無法復原期間發生例外狀況訊息。  
  
 <xref:System.Messaging.MessageQueueTransaction> 為執行緒的 apartment 感知的功能，因此，如果已 apartment 狀態`STA`，您無法使用多個執行緒中的交易。 Visual Basic 會將主執行緒的狀態`STA`，因此您必須先套用<xref:System.MTAThreadAttribute>中`Main`副程式。 否則，使用其他執行緒傳送交易式訊息時，會擲回 <xref:System.Messaging.MessageQueueException> 例外狀況。 您套用<xref:System.MTAThreadAttribute>使用下列的片段。  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例顯示的訊息佇列的值<xref:System.Messaging.MessageQueue.Transactional%2A>屬性。  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否複製接收的訊息至日誌佇列。</summary>
        <value>
          如果將從佇列接收到的訊息複製到日誌佇列，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當訊息佇列應用程式建立新的應用程式佇列時，它會自動建立相關的日誌佇列中的相同位置。 日誌佇列用來追蹤從佇列移除的訊息。 設定這個屬性可以修改 「 訊息佇列 」 佇列。 因此，任何其他<xref:System.Messaging.MessageQueue>變更會影響執行個體。  
  
 日誌佇列不會追蹤訊息從佇列移除，因為其接收時間計時器過期時，也不會追蹤訊息從佇列中清除使用訊息佇列目錄服務 （資訊儲存區或 Active Directory）。  
  
 應用程式無法傳送訊息至日誌佇列。它們會限制為這些佇列的唯讀存取權。 此外，訊息佇列永遠不會移除訊息日誌佇列。 使用佇列的應用程式必須清除這些訊息，以接收或清除佇列的方式。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|否|  
  
   
  
## Examples  
 下列程式碼範例會取得並設定訊息佇列的值<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>屬性。  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">存取訊息佇列方法時發生錯誤。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來傳送訊息至訊息佇列的原生控制代碼。</summary>
        <value>用來傳送訊息至佇列之原生佇列物件的控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A>提供原生的 Windows 控制代碼用於將訊息傳送至佇列的訊息佇列物件。 如果您變更佇列的路徑，控制代碼關閉並重新開啟新的值。  
  
 下表顯示此屬性是否可以使用各種不同的工作群組模式中。  
  
|工作群組模式|可用|  
|--------------------|---------------|  
|本機電腦|[是]|  
|本機電腦，並直接格式名稱|[是]|  
|遠端電腦|否|  
|遠端電腦並直接格式名稱|[是]|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">訊息佇列無法用來寫入。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>