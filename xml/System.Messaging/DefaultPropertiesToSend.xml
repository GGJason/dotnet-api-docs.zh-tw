<Type Name="DefaultPropertiesToSend" FullName="System.Messaging.DefaultPropertiesToSend">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1de27b1a67d05f78b04bbb5ab0355aca953652da" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36477351" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DefaultPropertiesToSend" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DefaultPropertiesToSend extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.DefaultPropertiesToSend" />
  <TypeSignature Language="VB.NET" Value="Public Class DefaultPropertiesToSend" />
  <TypeSignature Language="C++ CLI" Value="public ref class DefaultPropertiesToSend" />
  <TypeSignature Language="F#" Value="type DefaultPropertiesToSend = class" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>指定傳送 <see cref="T:System.Messaging.Message" /> 執行個體 (Instance) 以外的物件至訊息佇列時將使用的預設屬性值。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以設定上訊息傳送至所選屬性的預設值<xref:System.Messaging.MessageQueue>。 <xref:System.Messaging.DefaultPropertiesToSend> 用來指定預設屬性值時要傳送的訊息物件以外的<xref:System.Messaging.Message>執行個體傳送至佇列，例如，字串引數傳遞至<xref:System.Messaging.MessageQueue.Send%2A>方法中的程式碼片段， `myMessageQueue.Send("hello")`。 <xref:System.Messaging.Message>類別具有對應的相同的內容中的已命名<xref:System.Messaging.DefaultPropertiesToSend>傳送時，提供了值<xref:System.Messaging.Message>特別是執行個體。 即使您已指定<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType>佇列，傳送<xref:System.Messaging.Message>至該佇列的物件會導致相同具名的值<xref:System.Messaging.Message>屬性，以覆寫佇列<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>值。  
  
 您未明確設定的屬性預設建構函式，所指定的值為<xref:System.Messaging.DefaultPropertiesToSend.%23ctor%2A>。  
  
 如需執行個體的初始屬性值的清單<xref:System.Messaging.DefaultPropertiesToSend>，請參閱<xref:System.Messaging.DefaultPropertiesToSend>建構函式。  
  
   
  
## Examples  
 下列程式碼範例會使用訊息的優先順序，以判斷傳送訊息的預設屬性。  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DefaultPropertiesToSend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.DefaultPropertiesToSend.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DefaultPropertiesToSend();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.DefaultPropertiesToSend" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以建立的新執行個體<xref:System.Messaging.DefaultPropertiesToSend>來定義要包含的物件傳送至佇列不是型別產生關聯的預設屬性值<xref:System.Messaging.Message>。 當使用<xref:System.Messaging.MessageQueue>物件，<xref:System.Messaging.DefaultPropertiesToSend>為您建立並與相關聯執行個體<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType>隸屬<xref:System.Messaging.MessageQueue>。  
  
 有兩種方式可定義佇列的預設屬性，若要傳送，如下列 C# 程式碼所示。 您可以設定值，這個執行個體的<xref:System.Messaging.DefaultPropertiesToSend>並將它與佇列關聯<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType>屬性：  
  
```  
DefaultPropertiesToSend myDefaultProperties = new DefaultPropertiesToSend();  
  // Set default values for the properties.  
  myDefaultProperties.Label = "myLabel";  
  myDefaultProperties.Recoverable = false;  
 ...  
  myMessageQueue.DefaultPropertiesToSend = myDefaultProperties;  
  myMessageQueue.Send("hello");  
```  
  
 或者，您可以個別地將值指派給<xref:System.Messaging.MessageQueue>執行個體的<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>直接屬性：  
  
```  
myMessageQueue.DefaultPropertiesToSend.Label = "myLabel";  
  myMessageQueue.DefaultPropertiesToSend.Recoverable = false;  
...  
  myMessageQueue.Send("hello");  
```  
  
 如果您選擇的第二個這些選項，您不需要呼叫<xref:System.Messaging.DefaultPropertiesToSend.%23ctor%2A>建構函式明確。 您可能想要建立的執行個體<xref:System.Messaging.DefaultPropertiesToSend>，例如，如果屬性的預設值取決於一些準則所傳送的訊息。 您可以建立多個<xref:System.Messaging.DefaultPropertiesToSend>執行個體，並指派給佇列的<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType>屬性，才能將訊息傳送至佇列。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Messaging.DefaultPropertiesToSend>。  
  
|屬性|Initial value|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeTypes.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|0|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|為零長度的位元組的陣列|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|空字串 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.DefaultPropertiesToSend.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要傳回至傳送的應用程式的認可訊息類型。</summary>
        <value>其中一個 <see cref="T:System.Messaging.AcknowledgeTypes" /> 列舉值。 這個值是用來決定系統張貼在管理佇列的認可訊息類型，以及認可傳回至傳送的應用程式的時間。 預設值為 <see langword="AcknowledgeTypes.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>屬性會指定要傳回給傳送應用程式的認可訊息的類型。 例如，設定<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>屬性要求通知時在訊息抵達其目的地，擷取時，或是否逾時使訊息無法到達，或從目的地佇列中擷取。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.DefaultPropertiesToSend.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定接收由訊息佇列所產生的認可訊息的佇列。</summary>
        <value>指定用於系統產生認可訊息之管理佇列的 <see cref="T:System.Messaging.MessageQueue" />。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中指定的佇列<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>屬性可以是任何非交易式佇列。 傳送至管理佇列的認可訊息可以指示原始訊息已到達其目的地佇列，以及已從佇列中移除。  
  
 當<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>屬性有任何值以外`None`，傳送應用程式必須指定要做為管理佇列的佇列。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.DefaultPropertiesToSend.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定額外的應用程式特定資訊。</summary>
        <value>應用程式的特定資訊。 預設值為 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>屬性包含特定應用程式之其他資訊可以用來組織不同類型的訊息，例如，使用應用程式特有的索引。 要解譯的應用程式負責<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>資訊。  
  
 可能的話，訊息資料應包含的訊息，而不是在主體中<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>屬性。  
  
 當使用外部佇列，使用<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>屬性來指定非訊息佇列訊息屬性。 如同<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>，要了解的內容的應用程式負責<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.Extension" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.DefaultPropertiesToSend.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否應該將傳送者識別碼附加至訊息。</summary>
        <value>如果傳送者識別碼應該附加至訊息則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 寄件者識別碼是位元組陣列，代表傳送使用者的識別項。 寄件者識別碼由訊息佇列設定，並由接收佇列管理員用來驗證寄件者是否有佇列的存取權限。 只有可信任，如果訊息在到達目的端佇列已驗證寄件者識別碼。  
  
 寄件者識別碼未附加到訊息，這，訊息佇列不應該驗證訊息的寄件者傳送到目的地佇列訊息時，表示傳送應用程式。 如果目的地佇列只接受已驗證的訊息，然後<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>或<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>是`false`，到達佇列時，將會拒絕訊息。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseAuthentication" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來加密私用訊息主體的加密演算法。</summary>
        <value>其中一個 <see cref="T:System.Messaging.EncryptionAlgorithm" /> 列舉值。 預設值為 <see langword="RC2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果訊息是私人的它會加密再傳送並接收時，會解密。 <xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>屬性會指定用來加密私用訊息之訊息主體的演算法。  
  
 佇列可以要求傳入訊息加密。 如果非加密的 （非私用） 訊息已傳送至只接受私用的訊息佇列或私用訊息已傳送至只接受非私用訊息佇列，佇列會拒絕訊息。 傳送應用程式可以要求負認可訊息傳回給傳送應用程式如果訊息已被拒絕。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.DefaultPropertiesToSend.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.ArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與訊息關聯的其他資訊。</summary>
        <value>提供與訊息關聯的額外的應用程式定義資訊的位元組陣列。 預設值是長度為零的陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>屬性提供的訊息，例如大型二進位物件相關聯的其他應用程式定義的資訊。 它是解譯的內容接收的應用程式的責任<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>。  
  
 可能的話，訊息資料應該包含在訊息本文，而不是延伸模組中。  
  
 當使用外部佇列，使用<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>屬性來指定非訊息佇列訊息屬性。  
  
 非 Microsoft Message Queuing 的佇列系統中存在的外部索引的佇列。 Microsoft Message Queuing 與透過連接器應用程式的這類佇列通訊。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.DefaultPropertiesToSend.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定當驗證訊息或建立訊息的數位簽章時所使用的雜湊演算法。</summary>
        <value>其中一個 <see cref="T:System.Messaging.HashAlgorithm" /> 列舉值。 預設值為 <see langword="MD5" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>屬性會識別訊息佇列會使用驗證訊息時，或建立一則訊息的數位簽章的雜湊演算法。  
  
 來源電腦上的訊息佇列會在建立訊息的數位簽章時使用的雜湊演算法。 目標佇列管理員再使用相同的雜湊演算法，來驗證訊息接收時。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseAuthentication" />
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.DefaultPropertiesToSend.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定描述訊息的應用程式定義字串。</summary>
        <value>訊息的標記。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 訊息標籤可以用於顯示用途，例如，或選擇性地處理訊息，根據標籤值。 訊息標籤的最大長度為 249 個 Unicode 字元。 標籤並不需要是唯一的訊息。  
  
 訊息佇列和訊息標籤表示應用程式定義的值，可協助識別佇列或訊息的人類看得懂的條款。 它負責解譯標籤內容，應用程式它們不具有實質意義至訊息佇列應用程式。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.DefaultPropertiesToSend.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息的優先權，用來決定訊息放置在佇列中的位置。</summary>
        <value>其中一個 <see cref="T:System.Messaging.MessagePriority" /> 列舉值，表示非異動性訊息的優先權層級。 預設值為 <see langword="Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>屬性會影響訊息佇列處理訊息，而路由，方式與在到達其目的地時，將會放在佇列的訊息。 高優先權的訊息會在路由期間授與喜好設定，且插入佇列的前端。 優先權相同的訊息會根據抵達時間放置在佇列中。  
  
 非交易式訊息只能設定有意義地加以訊息優先順序。 交易式訊息的優先順序會自動設定為`Lowest`，因而導致交易式訊息的優先權會被忽略。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
        <altmember cref="P:System.Messaging.Message.Priority" />
        <altmember cref="T:System.Messaging.MessagePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.DefaultPropertiesToSend.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出當發生電腦故障或網路問題時是否保證傳遞訊息。</summary>
        <value>如果在路由時會將訊息儲存至磁碟以保證訊息傳遞則為 <see langword="true" />；如果不確保傳遞，則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>屬性會指出是否保證訊息的傳遞，即使目的地佇列來路由訊息時電腦當機。  
  
 如果訊息的傳遞保證，訊息儲存在本機的路由上的每一個步驟，直到訊息成功轉送至下一部電腦。 設定<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>至`true`上<xref:System.Messaging.DefaultPropertiesToSend>可能會影響輸送量。  
  
 如果交易式訊息，訊息佇列會自動將訊息視為可復原，而不論是否<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>設`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseTracing" />
        <altmember cref="P:System.Messaging.Message.Recoverable" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.DefaultPropertiesToSend.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定接收應用程式產生的回應訊息的佇列。</summary>
        <value>傳回應用程式產生的回應訊息的 <see cref="T:System.Messaging.MessageQueue" />。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>屬性會識別接收會傳回到傳送應用程式所接收的應用程式的應用程式產生的回應訊息的佇列。 應用程式傳送其訊息時所傳送的應用程式指定回應佇列。 任何可用的佇列都可以指定為回應佇列。  
  
 傳回至回應佇列的訊息是應用程式指定的。 應用程式必須定義什麼是訊息中以及執行接收到訊息的動作。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.DefaultPropertiesToSend.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定從目的端佇列擷取訊息的時間限制。</summary>
        <value>從目的佇列接收已傳送訊息的總秒數。 預設值為 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>屬性指定的總時間 （秒） 傳送到從目的地佇列等候接收訊息。 這個時間限制包括到達目的地佇列，花費的時間，加上應用程式擷取訊息之前的佇列中等候所花費的時間。  
  
> [!CAUTION]
>  當使用依存性用戶端電腦時，同步用戶端電腦上的時鐘與執行訊息佇列的伺服器上的時鐘。 如果兩個時鐘未同步處理，當傳送訊息時，您可能會看到非預期的行為<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>不<xref:System.Messaging.Message.InfiniteTimeout>。  
  
 如果<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>間隔到期之前從佇列移除訊息，訊息佇列應用程式會捨棄訊息。 訊息是 傳送到寄不出信件佇列，如果訊息的<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>屬性設定為`true`，或忽略，如果<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>是`false`。 如果<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>是小於<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>，<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>優先。  
  
 訊息的<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>屬性可以設定為要求的訊息佇列傳送負認可訊息傳回給傳送應用程式如果計時器終止之前，不會擷取訊息。  
  
> [!CAUTION]
>  如果您已經指定要接收<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>負值通知，您將無法接收通知時的值<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>的值少於<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>。  
  
 在交易中傳送數個訊息，訊息佇列會使用值的第一個訊息<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.DefaultPropertiesToSend.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定訊息到達佇列的時間限制。</summary>
        <value>從傳送訊息的時間至訊息到達目的端佇列的時間限制 (以秒為單位)。 預設值為 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>間隔到期之前訊息抵達其目的端，訊息佇列應用程式會捨棄訊息。 訊息是 傳送到寄不出信件佇列，如果訊息的<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>屬性設定為`true`，或忽略，如果<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>是`false`。 如果<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>大於<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>，<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>優先。  
  
 訊息的<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>屬性可以設定為要求的訊息佇列傳送負認可訊息傳回給傳送應用程式如果計時器終止之前未到達的訊息。  
  
 如果<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>為 0 秒，訊息佇列一次嘗試傳送訊息至其目的地佇列等候訊息。 如果本機佇列，訊息永遠會到達佇列。  
  
 在交易中傳送數個訊息，訊息佇列會使用值的第一個訊息<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得來源電腦上的異動狀態佇列。</summary>
        <value>來源電腦上的異動狀態佇列，用來傳回認可訊息至傳送的應用程式。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>屬性會識別來源電腦上的交易狀態佇列。 屬性由訊息佇列、 設定和擷取交易式訊息傳送至外部的佇列時，會使用連接器應用程式。  
  
 非 Microsoft Message Queuing 的佇列系統中存在的外部索引的佇列。 Microsoft Message Queuing 與透過連接器應用程式的這類佇列通訊。  
  
 連接器應用程式可以傳送認可訊息傳回給傳送應用程式使用的交易狀態佇列。 即使傳送應用程式不會要求其他認可的交易狀態應該會收到這些通知。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.DefaultPropertiesToSend.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出訊息在傳送之前是否必須通過驗證。</summary>
        <value>如果傳送的應用程式要求訊息的驗證則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>屬性會指定是否需要驗證訊息。 如果傳送應用程式要求驗證，訊息佇列建立數位簽章，並使用簽章訊息傳送時，並收到它時，驗證訊息。  
  
 如果到達佇列時，如果訊息已傳送至只接受已驗證的訊息佇列中，將拒絕訊息<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>設`false`。  
  
 您不可能以查看訊息的屬性並判斷訊息是否驗證失敗。 驗證失敗的訊息會予以捨棄，而且不會傳遞至佇列。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.AcknowledgeType" />
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否應該將無法傳遞的訊息複本傳送至無法投遞的信件佇列。</summary>
        <value>如果訊息傳遞錯誤會導致將訊息複本傳送至無法投遞的信件佇列，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A> 和<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>指定訊息佇列將會如何追蹤訊息。 如果<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>是`true`，則發生 （適用於非交易式訊息） 的傳遞失敗，訊息傳送至非交易式寄不出信件佇列無法傳送訊息 （例如，如果郵件計時器過期） 的電腦上。  
  
 在交易式訊息的傳遞失敗，訊息會傳送至異動式寄不出信件佇列中所有負數且不確定的情況下在來源電腦上。  
  
 當您將訊息儲存在寄不出信件佇列時，空的定期以移除不再需要的訊息佇列。 計算儲存在寄不出信件佇列對佇列所在的電腦的大小配額的訊息。 電腦配額由系統管理員所設定，並指的是配置來儲存訊息的電腦上，不只是在單一佇列的總大小。  
  
 您不會建立日誌或寄不出的信件佇列。 這些是由訊息佇列會產生這兩個系統佇列。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseJournalQueue" />
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseTracing" />
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.DefaultPropertiesToSend.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否將訊息設成私用。</summary>
        <value>如果要求訊息佇列為訊息加密則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果訊息是私人的其主體已加密，然後再傳送和接收時，會解密。 若要傳送的私用訊息，傳送應用程式必須指定用於加密和 （選擇性） 若要套用何種加密演算法。  
  
 傳送私用的訊息時，則不需要您的應用程式執行訊息加密。 訊息佇列時，可以加密訊息本文為您應用程式會傳送 Microsoft Windows 2000 企業中的訊息沒有目錄服務的存取權。 接收私用的訊息時，它一律是接收佇列管理員來解密訊息內文。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.DefaultPropertiesToSend.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出訊息複本是否應保留在原始電腦上的電腦日誌中。</summary>
        <value>
          <see langword="true" /> 表示訊息成功地從原始電腦傳輸至下一個步驟後，要求在原始電腦的電腦日誌中保留訊息的複本，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A> 和<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>指定訊息佇列將會如何追蹤訊息。 如果<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>是`true`，然後在每個步驟中，訊息會傳輸，複本保留在原始電腦上電腦日誌中。  
  
 如果目的地佇列是在遠端電腦上，傳送的訊息只複製到日誌佇列。 如果目的地是本機電腦上，訊息會直接傳送至佇列。沒有任何需要日誌的中間步驟。  
  
 當您將訊息儲存在日誌佇列中時，清除定期以移除不再需要的訊息佇列。 計算儲存在日誌佇列的佇列所在的電腦配額的訊息 （由系統管理員設定電腦配額）。  
  
 您不會建立日誌或寄不出的信件佇列。 這些是由訊息佇列會產生這兩個系統佇列。  
  
 訊息與佇列可以指定日誌。 當<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A?displayProperty=nameWithType>是`true`，日誌型的訊息是傳送時。 當<xref:System.Messaging.MessageQueue.UseJournalQueue%2A?displayProperty=nameWithType>是`true`，日誌型的訊息是接收時。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.DefaultPropertiesToSend.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.DefaultPropertiesToSend.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出當訊息向其目的佇列移動時是否要追蹤訊息。</summary>
        <value>如果原始訊息路由至目的佇列的每個中間步驟都會產生要傳送至系統報告佇列的報告，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>屬性會指定是否要向其目的地佇列為時加以追蹤訊息的路由。 如果`true`，每次訊息通過訊息佇列路由伺服器傳送的訊息佇列所產生的報告訊息至報告佇列。 來源佇列管理員所指定的報告佇列。 報告佇列不限於訊息佇列所產生的報告訊息。 您應用程式所產生的訊息可以傳送至報告佇列。  
  
 使用追蹤牽涉到設定 Active Directory，並指定訊息佇列企業報告佇列。 系統管理員可以設定這些設定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.DefaultPropertiesToSend.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
  </Members>
</Type>