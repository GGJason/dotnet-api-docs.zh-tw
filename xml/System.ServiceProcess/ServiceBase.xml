<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e2912243db0e29abdb2e744262f17e23e80bfbe8" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39829237" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供將會屬於服務應用程之服務的基底類別。 當建立新的服務類別時，必須衍生自 <see cref="T:System.ServiceProcess.ServiceBase" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自<xref:System.ServiceProcess.ServiceBase>服務應用程式中定義您的服務類別時。 實用的服務中的任何覆寫<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法。 如需其他功能，您可以覆寫<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>以回應服務狀態變更的特定行為。  
  
 服務是長時間執行可執行檔不支援使用者介面，以及不可能在登入的使用者帳戶下執行。 服務可以執行而不需要任何使用者的身分登入電腦。  
  
 根據預設，服務會執行系統帳戶不是系統管理員帳戶相同。 您無法變更系統帳戶的權限。 或者，您可以使用<xref:System.ServiceProcess.ServiceProcessInstaller>來指定服務執行的使用者帳戶。  
  
 可執行檔可以包含多個服務，但必須包含個別<xref:System.ServiceProcess.ServiceInstaller>針對每個服務。 <xref:System.ServiceProcess.ServiceInstaller>執行個體向系統註冊服務。 安裝程式也會將事件記錄檔，您可以使用它來記錄服務命令關聯的每個服務。 `main()`函式，可執行檔會定義應執行哪些服務。 服務的目前工作目錄是系統目錄，而不是可執行檔所在的目錄。  
  
 當您啟動服務時，系統會找出可執行檔，並執行<xref:System.ServiceProcess.ServiceBase.OnStart%2A>該服務，可執行檔中包含的方法。 不過，執行服務不是可執行檔相同。 可執行檔只會載入服務。 透過服務控制管理員中存取服務 （例如，啟動和停止）。  
  
 可執行檔呼叫<xref:System.ServiceProcess.ServiceBase>衍生類別的建構函式的第一次呼叫服務上的啟動。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>命令處理方法在只有在建構函式執行之後立即呼叫。 建構函式就不會執行一次之後第一次載入之後，服務，因此必須將從執行的建構函式所執行之處理<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 可以釋放任何資源<xref:System.ServiceProcess.ServiceBase.OnStop%2A>應該會在建立<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 在建構函式中建立資源防止服務之後，再次啟動時，如果正確建立<xref:System.ServiceProcess.ServiceBase.OnStop%2A>已釋放資源。  
  
 服務控制管理員 (SCM) 可用來與服務互動。 您可以使用 SCM 將啟動、 停止、 暫停、 繼續或自訂命令至服務。 SCM 會使用值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>和<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>來判斷服務是否接受停止、 暫停或繼續命令。 停止、 暫停和繼續啟用 SCM 的操作功能表才會在中對應的屬性<xref:System.ServiceProcess.ServiceBase.CanStop%2A>或是<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`服務類別中。 如果啟用，要將命令傳遞至服務，並<xref:System.ServiceProcess.ServiceBase.OnStop%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>呼叫。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>， <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>，或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`，對應的命令處理方法 (例如<xref:System.ServiceProcess.ServiceBase.OnStop%2A>) 將不會處理，即使您已實作的方法。  
  
 您可以使用<xref:System.ServiceProcess.ServiceController>類別來以程式設計方式執行何種 SCM 未使用的使用者介面。 您可以自動化在主控台中可用的工作。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>， <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>，或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`但尚未實作對應的命令處理方法 (例如<xref:System.ServiceProcess.ServiceBase.OnStop%2A>) 系統就會擲回例外狀況，並忽略命令。  
  
 您不必實作<xref:System.ServiceProcess.ServiceBase.OnStart%2A>， <xref:System.ServiceProcess.ServiceBase.OnStop%2A>，或任何其他方法在<xref:System.ServiceProcess.ServiceBase>。 不過中, 所述的服務行為<xref:System.ServiceProcess.ServiceBase.OnStart%2A>，因此最小值，這個成員應該覆寫。 `main()`函式的可執行檔可執行檔和服務控制管理員中註冊服務，藉由呼叫<xref:System.ServiceProcess.ServiceBase.Run%2A>方法。 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>的屬性<xref:System.ServiceProcess.ServiceBase>物件傳遞給<xref:System.ServiceProcess.ServiceBase.Run%2A>方法必須符合<xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A>該服務之服務安裝程式的屬性。  
  
 您可以使用`InstallUtil.exe`在您的系統上安裝服務。  
  
> [!NOTE]
>  您可以指定應用程式事件記錄檔，以接收通知的服務呼叫，但兩者皆非的記錄檔<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>和<xref:System.ServiceProcess.ServiceBase.EventLog%2A>屬性可以寫入自訂記錄檔。 設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`false`如果不想使用自動記錄。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>建立 <see cref="T:System.ServiceProcess.ServiceBase" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 無法建立的執行個體<xref:System.ServiceProcess.ServiceBase>類別。 相反地，衍生自<xref:System.ServiceProcess.ServiceBase>和具現化衍生的類別。 您需要實作建構函式的類別繼承自最小<xref:System.ServiceProcess.ServiceBase>是設定<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>在您的元件。 沒有其他處理程序特別需要建構函式。 您應該處理中的大部分初始化<xref:System.ServiceProcess.ServiceBase.OnStart%2A>而不是在建構函式。 否則，就無法保證當您重新啟動服務已停止後，將重新初始化的物件。  
  
 如果衍生類別中覆寫建構函式，請在您的程式碼中呼叫基底類別建構函式。  
  
 <xref:System.ServiceProcess.ServiceBase>建構函式<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`true`。 如果您不想自動登入服務呼叫從服務控制管理員 (SCM)，設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`false`。  
  
 如果可執行檔包含單一服務，系統就會呼叫服務的建構函式時開始選取 scm，和呼叫停止，則會執行解構函式。  
  
 如果可執行檔包含多個服務，呼叫開始於一項服務會導致所要呼叫的可執行檔中的所有服務的建構函式，但指定的服務已啟動。 當所有的服務已停止，不個別停止每個服務時，會一起執行解構函式的服務。  
  
> [!NOTE]
>  如果您覆寫基底類別建構函式，您應該在您的衍生類別的建構函式中明確呼叫它。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示是否在事件記錄檔中報告啟動、停止、暫停和繼續等命令。</summary>
        <value>若要在事件記錄檔中報告資訊，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`true`指示要用於報表的命令失敗，以及狀態變更資訊的應用程式事件記錄檔開始、 停止、 暫停和繼續事件，在服務上的服務。 服務的名稱做為記錄檔的<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>。  
  
 若要報告自訂事件記錄檔，而不是應用程式記錄檔的資訊，請設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>來`false`和寫入命令處理方法中的指示<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>張貼至適當的記錄檔。  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>，提供事件記錄檔的來源字串之前，必須設定服務會嘗試寫入事件記錄檔。 嘗試存取事件記錄檔，就會設定來源的名稱，就會擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出服務是否可以處理電腦電源狀態變更時發生的告知。</summary>
        <value>如果服務處理 <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> 類別中所指示的電腦電源狀態變更，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當電腦的電源狀態變更，服務控制管理員 (SCM) 確認服務是否接受電源事件的命令使用的值<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>是`true`，此命令傳遞至服務和<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>如果定義會呼叫方法。 如果<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>未實作在衍生類別中，SCM 處理電源事件，透過空的基底類別<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個屬性在服務啟動之後被修改。</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出服務是否可以處理從 Terminal Server 工作階段所擷取的工作階段變更事件。</summary>
        <value>如果服務可以處理 Terminal Server 工作階段的變更事件則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">這個屬性在服務啟動之後被修改。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出服務是否可以暫停和繼續。</summary>
        <value>如果服務可以暫停，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值設定<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>服務建構函式中的屬性。  
  
 服務暫停時，它會中止它正在進行。 當您繼續執行服務 （無論是透過服務控制管理員中或以程式設計的方式），<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>執行。  
  
 暫停要求傳送至服務，可以節省系統資源。 暫停可能不會發行所有系統資源，但停止。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 並<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>通常會實作來執行較少處理會比<xref:System.ServiceProcess.ServiceBase.OnStop%2A>和<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。  
  
 當<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`，覆寫<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>來指定應該在服務控制管理員 (SCM) 傳送暫停或繼續要求到您的服務時所發生的處理。 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 若要復原中的處理應該實作<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>已`false`、 SCM 將無法通過暫停或繼續服務要求，因此<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使它們在實作時，就不會呼叫方法。 SCM 中,`Pause`並`Continue`已停用控制項時<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經啟動服務。 一旦已經啟動服務，就無法變更 <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> 屬性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出當系統關閉時是否應該通知服務。</summary>
        <value>如果當系統關閉時應該通知服務，則為 <see langword="true" />，否則為 <see langword="false" />。  預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>是`true`，當系統關閉時，通知服務。 在關機，<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>如果衍生類別中實作會呼叫方法。  
  
> [!NOTE]
>  只有系統應該會造成<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>方法來執行; 服務可以呼叫它，但不是建議這麼做。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經啟動服務。 一旦已經啟動服務，就無法變更 <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> 屬性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出一旦服務已經啟動是否可以停止它。</summary>
        <value>如果可以停止服務並且呼叫 <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> 方法，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在服務上呼叫時停止，服務控制管理員 (SCM) 會確認服務是否接受停止命令，使用值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>。 大部分的服務，windows 7<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`true`，但某些作業系統服務，例如，不允許使用者停止它們。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>已`true`，[停止] 命令傳遞至服務和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>如果已定義，會呼叫方法。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>未實作在衍生類別中，透過空的基底類別的 Stop 命令的 SCM 控點<xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經啟動服務。 一旦已經啟動服務，就無法變更 <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> 屬性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>處置 (Dispose) <see cref="T:System.ServiceProcess.ServiceBase" /> 所使用的資源 (除了記憶體之外)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.ServiceProcess.ServiceBase.Dispose%2A>衍生類別中 (並透過它在<xref:System.ServiceProcess.ServiceBase>類別) 當您完成使用衍生的類別。 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>方法讓衍生的類別中無法使用的狀態。 之後呼叫<xref:System.ServiceProcess.ServiceBase.Dispose%2A>，您必須釋放所有參考衍生的類別和<xref:System.ServiceProcess.ServiceBase>讓它們所佔用的記憶體可以回收記憶體回收。  
  
> [!NOTE]
>  請務必呼叫<xref:System.ServiceProcess.ServiceBase.Dispose%2A>發行類別衍生自您最後一個參考之前<xref:System.ServiceProcess.ServiceBase>。 否則，資源<xref:System.ServiceProcess.ServiceBase>而衍生的類別使用會不會釋放記憶體回收會呼叫物件的解構函式之前。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 通常實作處理中的程式碼<xref:System.ServiceProcess.ServiceBase.OnPause%2A>呼叫合併<xref:System.ServiceProcess.ServiceBase.Dispose%2A>。 如果您選擇在您的衍生類別中這麼做，是實作慣用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>配置任何<xref:System.ServiceProcess.ServiceBase.Dispose%2A>發行。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得事件記錄檔，您可以利用該事件記錄將服務命令呼叫 (例如啟動和停止) 通知寫入應用程式事件記錄檔。</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLog" /> 執行個體，其來源是登錄到應用程式記錄檔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建構函式初始化<xref:System.ServiceProcess.ServiceBase.EventLog%2A>屬性的執行個體，但<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType>屬性集。 來源是<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>的服務，並已在電腦的應用程式記錄檔的記錄檔。 這些值會自動設定，而且不能變更自動記錄服務命令。  
  
 當<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>是`true`，啟動、 停止、 暫停、 繼續、 和自訂命令會自動記錄應用程式事件記錄檔中。 您可以使用<xref:System.ServiceProcess.ServiceBase.EventLog%2A>屬性，以寫入該記錄檔中的其他訊息。 此元件會呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType>使用此<xref:System.ServiceProcess.ServiceBase.EventLog%2A>成員。  
  
 若要報告自訂事件記錄檔，而不是應用程式記錄檔的資訊，請設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>來`false`和寫入命令處理方法中的指示<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>張貼至適當的記錄檔。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定服務的結束代碼 (Exit Code)。</summary>
        <value>服務的結束代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.ServiceProcess.ServiceBase.ExitCode%2A>屬性設為非零值之前停止服務，以指出服務控制管理員發生錯誤。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>指示服務名稱的最大值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName 和 DisplayName 兩者都有您的服務類別上設定屬性時，必須遵守的大小限制。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳送繼續命令給服務時，將執行 <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" />。 指定暫停服務後要繼續正常運作所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>來鏡像您的應用程式回應<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。 當您繼續執行服務 （無論是透過 [服務] 主控台或以程式設計方式），<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>處理執行時，與服務再次變成作用中。  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 應該覆寫，當<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>屬性是`true`。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>已`false`、 SCM 將無法通過暫停或繼續服務要求，因此<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使它們在實作時，就不會呼叫方法。 SCM 中,`Pause`並`Continue`已停用控制項時<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">傳送至服務的命令訊息。</param>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳遞自訂命令給服務時，將執行 <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />。 指定在具有指定參數值的命令發生時所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 可讓您指定啟動、 停止、 暫停和繼續服務以外的其他功能。  
  
 SCM 不會檢查以確認服務是否支援自訂命令`command`傳入參數。 它的自訂命令直接傳送至服務。 如果服務無法辨識`command`參數，它不執行任何動作。  
  
 自訂命令會引發<xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>中的陳述式<xref:System.ServiceProcess.ServiceController>元件。 使用 switch 陳述式或 if...然後條件，以處理您在您的服務定義的自訂命令。  
  
 您可以在您的應用程式中定義，或使用中的自訂命令的唯一值<xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A>是 128 到 255 之間。 以下 128 的整數會對應至系統保留的值。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>屬性是`true`，自訂的命令，例如所有其他命令，將項目寫入事件記錄檔，以報告方法執行成功還是失敗。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳送暫停命令至服務時執行。 指定在服務暫停時所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnPause%2A>來指定當服務接收到縸懫暀硉時發生的處理。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 應該覆寫，當<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>屬性是`true`。  
  
 當您繼續已暫停的服務 （無論是透過 [服務] 主控台或以程式設計方式），<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>執行處理，以及服務再次變為無法使用。  
  
 縸懫暀硉只允許您的應用程式，以回應特定事件。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 沒有任何未定義其執行的服務。  
  
 暫停要求傳送至服務可以節省系統資源，因為暫停必須釋放所有的系統資源。 例如，如果執行緒已開啟的處理程序，暫停服務，而不是將其停止，可以讓執行緒保持開啟，因此不需要時，服務會繼續重新配置。 如果您定義要釋放所有系統資源的暫停時，它就停止命令。  
  
 設定<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>要`true`，並覆寫<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>來指定當 SCM 將暫停或繼續要求傳遞至您的服務時，應該會發生的處理。 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 若要復原中的處理應該實作<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>已`false`、 SCM 將無法通過暫停或繼續服務要求，因此<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使實作，就不會呼叫方法。 SCM 中,`Pause`並`Continue`已停用控制項時<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">
          <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />，表示來自系統關於電源狀態的通知。</param>
        <summary>在衍生類別中實作時，當電腦的電源狀態已經變更時執行。 這適用於攜帶型電腦，當它們進入暫停模式的時候，不同於系統關閉。</summary>
        <returns>當在衍生類別中實作時，您的應用程式之需求會決定將傳回什麼值。 例如，如果傳遞 <see langword="QuerySuspend" /> 廣播狀態，您可能會導致您的應用程式傳回 <see langword="false" /> 來拒絕查詢。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>指定的處理序時的系統事件中指出<xref:System.ServiceProcess.PowerBroadcastStatus>列舉型別，就會發生-例如，在電腦放在暫停模式，或指出電力偏低時。  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 應該覆寫，當<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>屬性是`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">識別變更類型的結構。</param>
        <summary>當從 Terminal Server 工作階段接收到變更事件時執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須設定<xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>屬性設`true`才能執行此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，當系統正在關閉時執行。 指定緊接在系統關閉之前應該發生的處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>指定發生於系統關閉時的處理。  
  
 只有在作業系統關機，不會在關閉電腦時，才，就會發生此事件。  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 應該覆寫，當<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>屬性是`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">啟動命令所傳遞的資料。</param>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳送啟動命令至服務或當作業系統啟動 (自動啟動服務) 時執行。 指定在服務啟動時所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>來指定當服務收到 Start 命令，就會發生的處理。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 是您可以在其中指定服務行為的方法。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 可以接受引數來傳遞資料，但這種使用方式很少見。  
  
> [!CAUTION]
>  請勿使用建構函式來執行處理，應為<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 使用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>來處理您的服務的所有初始設定。 應用程式的可執行檔時，會呼叫建構函式執行時，不在執行服務時。 可執行檔執行之前<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 當您要繼續，比方說，建構函式不會再次呼叫因為 SCM 已存有物件在記憶體中。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>釋放配置的建構函式而不是在資源<xref:System.ServiceProcess.ServiceBase.OnStart%2A>，所需的資源不會建立一次呼叫服務時的第二個時間。  
  
 服務可以設定為自動啟動時重新啟動電腦藉由設定<xref:System.ServiceProcess.ServiceInstaller.StartType%2A>服務的安裝程式，以在<xref:System.ServiceProcess.ServiceStartMode.Automatic>。 在這種情況下，<xref:System.ServiceProcess.ServiceBase.OnStart%2A>會在系統啟動時呼叫。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 要在衍生類別中被覆寫。 服務會很實用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>應該兩者在實作您的服務類別。  
  
 處理初始化引數中的服務<xref:System.ServiceProcess.ServiceBase.OnStart%2A>方法中的，Main 方法中找不到。 中的引數`args`可以手動設定參數陣列，在 [屬性] 視窗的 [服務] 主控台中的服務。 此外，不會儲存在主控台中輸入的引數;它們會傳遞至服務一次從控制台啟動服務時。 必須的存在，服務會自動啟動的引數可以放在服務的登錄機碼的 ImagePath 字串值 (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\ * \<服務名稱 >*)。 您可以從登錄使用來取得引數<xref:System.Environment.GetCommandLineArgs%2A>方法，例如： `string[] imagePathArgs = Environment.GetCommandLineArgs();`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳送停止命令至服務時執行。 指定在服務停止執行時所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnStop%2A>來指定當服務收到 Stop 命令，就會發生的處理。  
  
 當 SCM 收到 Stop 命令時，它會使用值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>若要確認服務是否接受停止命令。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`true`，[停止] 命令傳遞至服務，而<xref:System.ServiceProcess.ServiceBase.OnStop%2A>如果已定義，會呼叫方法。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>未實作在服務中，SCM 處理 [停止] 命令。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`false`，SCM 會忽略 [停止] 命令。 它不會傳遞給服務。 [停止] 命令會傳回，則擲回例外狀況。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 要在衍生類別中被覆寫。 服務會很實用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>應該兩者在實作您的服務類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">以毫秒為單位的要求時間。</param>
        <summary>要求額外時間進行暫止的運算。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A>方法是呼叫所覆寫<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>， <xref:System.ServiceProcess.ServiceBase.OnStart%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法來要求更多的時間暫止的作業，以防止標記中的服務控制管理員 (SCM)為沒有回應的服務。  如果暫止的作業不是繼續、 暫停、 啟動或停止<xref:System.InvalidOperationException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服務不在暫止狀態。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提供服務可執行檔的主要進入點。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.ServiceProcess.ServiceBase" />，表示要啟動的服務。</param>
        <summary>使用服務控制管理員 (SCM) 登錄服務的可執行檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個多載`main()`函式可註冊服務和服務控制管理員中執行的服務。 在您呼叫後<xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>，服務控制管理員發出啟動命令，會導致呼叫<xref:System.ServiceProcess.ServiceBase.OnStart%2A>服務中的方法。 Start 命令執行之前，不會啟動服務。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>方法會呼叫在相同的方式為<xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType>Windows Form 應用程式。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>已`true`，將項目寫入事件記錄檔所指定的服務如果`service`參數無法啟動。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">ServiceBase 執行個體的陣列，表示要啟動的服務。</param>
        <summary>使用服務控制管理員 (SCM) 登錄多個服務的可執行檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個多載`main()`服務可執行檔，註冊服務和服務控制管理員中的功能。 在您呼叫後<xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>，服務控制管理員，以發出啟動命令，呼叫會導致<xref:System.ServiceProcess.ServiceBase.OnStart%2A>服務中的方法。 服務無法啟動之前啟動命令會執行。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>方法會呼叫在相同的方式為<xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType>Windows Form 應用程式的方法。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>是`true`，項目寫入事件記錄檔，如果陣列中的任何服務無法啟動。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">您不提供要啟動的服務。 陣列可能為 <see langword="null" /> 或空白。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得服務的服務控制處理。</summary>
        <value>包含服務之服務控制處理的 <see cref="T:System.IntPtr" /> 結構。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 服務控制處理用來通訊的服務控制管理員 (SCM)。  控制代碼可用來更新使用未受管理的呼叫服務的服務控制管理員的狀態資訊`SetServiceStatus`函式。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用於存取 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">引數陣列中的引數數目。</param>
        <param name="argPointer">指向引數陣列的 <see cref="T:System.IntPtr" /> 結構。</param>
        <summary>登錄命令處理常式 (Command Handler) 並啟動服務。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來識別系統服務的簡短名稱。</summary>
        <value>服務的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>識別到服務控制管理員中的服務。 這個屬性的值必須是記錄中的服務的名稱與相同<xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType>相對應的安裝程式類別的屬性。 程式碼中，<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>的服務通常會設定`main()`函式的可執行檔。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>也用來指定<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>聯<xref:System.ServiceProcess.ServiceBase.EventLog%2A>屬性。 這<xref:System.ServiceProcess.ServiceBase.EventLog%2A>是服務命令資訊寫入應用程式記錄檔的執行個體。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>，提供事件記錄檔的來源字串必須設為服務寫入事件記錄檔。 嘗試存取事件記錄檔，就會設定來源的名稱，會導致擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經啟動服務。 一旦已經啟動服務，就無法變更 <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">指定的名稱是零長度字串或比 <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" /> 更長，或者指定的名稱包含斜線或反斜線字元。</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止執行中的服務。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.Stop%2A>方法會設定服務狀態，以指出停止暫止和呼叫<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法。  停止應用程式之後，服務的狀態設定為停止。 如果裝載的服務應用程式，應用程式定義域會卸載。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>