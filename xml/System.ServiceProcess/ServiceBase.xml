<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d659a5675f8e308404ab56d663607e4230bf1530" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530902" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供將會屬於服務應用程之服務的基底類別。 當建立新的服務類別時，必須衍生自 <see cref="T:System.ServiceProcess.ServiceBase" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自<xref:System.ServiceProcess.ServiceBase>服務應用程式中定義您的服務類別時。 任何服務很實用覆寫<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法。 如需其他功能，您可以覆寫<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>具有特定行為，以回應服務狀態的變更。  
  
 服務是長時間執行可執行檔不支援使用者介面，以及可能不在登入的使用者帳戶下執行。 服務可以執行不需任何使用者的身分登入電腦。  
  
 根據預設，服務會執行系統帳戶不是系統管理員帳戶相同。 您無法變更系統帳戶的權限。 或者，您可以使用<xref:System.ServiceProcess.ServiceProcessInstaller>來指定服務執行所在的使用者帳戶。  
  
 可執行檔可以包含多個服務，但必須包含個別<xref:System.ServiceProcess.ServiceInstaller>每個服務。 <xref:System.ServiceProcess.ServiceInstaller>執行個體向系統註冊服務。 安裝程式也會將每個服務與事件記錄檔可讓您記錄服務命令產生關聯。 `main()`函式可執行檔中的定義應執行哪些服務。 服務的目前工作目錄是系統目錄，而非可執行檔所在的目錄。  
  
 當您啟動服務時，系統會找出可執行檔，並執行<xref:System.ServiceProcess.ServiceBase.OnStart%2A>該服務，可執行檔中包含的方法。 不過，執行服務並不相同的可執行檔。 可執行檔只會載入服務。 透過服務控制管理員中存取服務 （例如，啟動和停止）。  
  
 可執行檔呼叫<xref:System.ServiceProcess.ServiceBase>衍生類別的建構函式的第一次呼叫服務上的啟動。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>建構函式執行後立即呼叫命令處理方法。 因此需要分隔中執行的建構函式所執行的處理建構函式不已載入該服務，在第一次之後，再次執行<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 可以釋放任何資源<xref:System.ServiceProcess.ServiceBase.OnStop%2A>應該建立在<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 在建構函式中建立資源防止後再啟動服務，如果正確建立<xref:System.ServiceProcess.ServiceBase.OnStop%2A>已釋放資源。  
  
 服務控制管理員 (SCM) 可用來與服務互動。 您可以使用 SCM 傳遞到服務的啟動、 停止、 暫停、 繼續 」 或自訂的命令。 SCM 會使用值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>和<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>來判斷服務是否接受停止、 暫停或繼續命令。 停止、 暫停和繼續已啟用的 SCM 內容功能表才會在中的對應屬性<xref:System.ServiceProcess.ServiceBase.CanStop%2A>或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`服務類別中。 啟用時，要將命令傳遞至服務，以及<xref:System.ServiceProcess.ServiceBase.OnStop%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>呼叫。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>， <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>，或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`，對應的命令處理方法 (例如<xref:System.ServiceProcess.ServiceBase.OnStop%2A>) 將不會處理，即使您已實作的方法。  
  
 您可以使用<xref:System.ServiceProcess.ServiceController>類別以程式設計方式進行何種 SCM 未使用的使用者介面。 您可以自動化主控台中可用的工作。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>， <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>，或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`但未實作對應的命令處理方法 (例如<xref:System.ServiceProcess.ServiceBase.OnStop%2A>) 系統擲回例外狀況，並忽略命令。  
  
 您不需要實作<xref:System.ServiceProcess.ServiceBase.OnStart%2A>， <xref:System.ServiceProcess.ServiceBase.OnStop%2A>，或在任何其他方法<xref:System.ServiceProcess.ServiceBase>。 不過中, 所述的服務行為<xref:System.ServiceProcess.ServiceBase.OnStart%2A>，因此最小值，這個成員應該覆寫。 `main()`函式可執行檔的可執行檔和服務控制管理員中註冊服務，藉由呼叫<xref:System.ServiceProcess.ServiceBase.Run%2A>方法。 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>屬性<xref:System.ServiceProcess.ServiceBase>物件傳遞至<xref:System.ServiceProcess.ServiceBase.Run%2A>方法必須符合<xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A>該服務之服務安裝程式的屬性。  
  
 您可以使用`InstallUtil.exe`您系統上安裝服務。  
  
> [!NOTE]
>  您可以指定的記錄檔的應用程式事件記錄檔，以接收通知服務呼叫，但是這兩者不<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>和<xref:System.ServiceProcess.ServiceBase.EventLog%2A>屬性可以寫入自訂的記錄檔。 設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`false`如果不想使用自動記錄。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>建立 <see cref="T:System.ServiceProcess.ServiceBase" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 無法建立的執行個體<xref:System.ServiceProcess.ServiceBase>類別。 相反地，衍生自<xref:System.ServiceProcess.ServiceBase>並具現化您的衍生的類別。 您需要實作建構函式類別繼承自至少<xref:System.ServiceProcess.ServiceBase>設定<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>上您的元件。 建構函式中特別不需要任何其他處理。 您應該處理中的大部分初始化<xref:System.ServiceProcess.ServiceBase.OnStart%2A>而不是在建構函式。 否則，便不保證已停止後重新啟動服務時，將重新初始化的物件。  
  
 如果衍生類別中覆寫建構函式，請在程式碼中呼叫基底類別建構函式。  
  
 <xref:System.ServiceProcess.ServiceBase>建構函式<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`true`。 如果您不想自動登入服務呼叫從服務控制管理員 (SCM)，設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`false`。  
  
 如果可執行檔會包含單一服務，系統會呼叫服務的建構函式時開始從 SCM 中，選取與呼叫停止，則會執行解構函式。  
  
 如果可執行檔包含多個服務，呼叫開始於一項服務會導致針對可執行檔中的所有服務呼叫的建構函式，但指定的服務已啟動。 當所有的服務已經停止，不個別停止每個服務時，解構函式的服務會一起執行。  
  
> [!NOTE]
>  如果您覆寫基底類別建構函式，您應該在衍生類別的建構函式中明確呼叫它。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示是否在事件記錄檔中報告啟動、停止、暫停和繼續等命令。</summary>
        <value>
          若要在事件記錄檔中報告資訊，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`true`指示服務應用程式事件日誌中報表的命令失敗，因為狀態變更資訊用於啟動、 停止、 暫停和繼續服務上的事件。 服務名稱做記錄檔的<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>。  
  
 若要報告自訂事件記錄檔，而不是應用程式記錄檔的資訊，請設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`false`和寫入命令處理方法中的指示<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>張貼到適當的記錄檔。  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>，它提供事件記錄檔的來源字串之前，必須設定服務會嘗試寫入事件記錄檔。 嘗試存取事件記錄檔之前設定的來源名稱，就會擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出服務是否可以處理電腦電源狀態變更時發生的告知。</summary>
        <value>
          如果服務處理 <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> 類別中所指示的電腦電源狀態變更，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當電腦的電源狀態變更，服務控制管理員 (SCM) 會驗證服務是否接受電源事件的命令使用的值<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>是`true`，傳遞至服務的命令和<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>如果定義會呼叫方法。 如果<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>未實作在衍生類別中，SCM 處理空的基底類別透過電源事件<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個屬性在服務啟動之後被修改。</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出服務是否可以處理從 Terminal Server 工作階段所擷取的工作階段變更事件。</summary>
        <value>
          如果服務可以處理 Terminal Server 工作階段的變更事件則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">這個屬性在服務啟動之後被修改。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出服務是否可以暫停和繼續。</summary>
        <value>
          如果服務可以暫停，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值設定<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>服務建構函式中的屬性。  
  
 服務已暫停，當它暫停它正在進行。 當您繼續執行服務 （無論是透過服務控制管理員中或以程式設計的方式），<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>執行。  
  
 暫停要求傳送至服務，可以節省系統資源。 暫停可能不會發行所有系統資源，但停止。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>，通常會執行較少處理比實作<xref:System.ServiceProcess.ServiceBase.OnStop%2A>和<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。  
  
 當<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`，覆寫<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>來指定服務控制管理員 (SCM) 將暫停或繼續要求傳遞至您的服務時所採取的處理。 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 復原中的處理應該實作<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`、 SCM 將不會傳遞暫停或繼續對服務要求，因此<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使它們實作，將不會呼叫方法。 SCM 中`Pause`和`Continue`已停用控制項時<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經啟動服務。 一旦已經啟動服務，就無法變更 <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> 屬性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出當系統關閉時是否應該通知服務。</summary>
        <value>
          如果當系統關閉時應該通知服務，則為 <see langword="true" />，否則為 <see langword="false" />。  預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>是`true`，當系統關閉時，通知服務。 在關機，<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>呼叫方法時若已在您的衍生類別中實作。  
  
> [!NOTE]
>  只有系統應該會造成<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>方法才可執行，服務可以呼叫它，但不是建議這樣。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經啟動服務。 一旦已經啟動服務，就無法變更 <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> 屬性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出一旦服務已經啟動是否可以停止它。</summary>
        <value>
          如果可以停止服務並且呼叫 <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> 方法，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在服務上呼叫時停止，服務控制管理員 (SCM) 會驗證服務是否接受 Stop 命令使用的值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>。 對於大部分的服務，值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`true`，但某些作業系統服務，例如，不允許使用者停止它們。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`true`，傳遞至服務的停止命令而<xref:System.ServiceProcess.ServiceBase.OnStop%2A>呼叫方法時若其定義。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>未實作在衍生類別中，透過空的基底類別的 Stop 命令的 SCM 控點<xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經啟動服務。 一旦已經啟動服務，就無法變更 <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> 屬性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>處置 (Dispose) <see cref="T:System.ServiceProcess.ServiceBase" /> 所使用的資源 (除了記憶體之外)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.ServiceProcess.ServiceBase.Dispose%2A>衍生類別中 (並透過它在<xref:System.ServiceProcess.ServiceBase>類別) 當您完成使用衍生的類別。 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>方法讓衍生的類別中無法使用的狀態。 在呼叫<xref:System.ServiceProcess.ServiceBase.Dispose%2A>，您必須釋放所有參考衍生的類別和<xref:System.ServiceProcess.ServiceBase>讓它們所佔用的記憶體可由記憶體回收收回。  
  
> [!NOTE]
>  請務必呼叫<xref:System.ServiceProcess.ServiceBase.Dispose%2A>釋放類別衍生自您最後一個參考之前<xref:System.ServiceProcess.ServiceBase>。 否則，資源<xref:System.ServiceProcess.ServiceBase>和衍生的類別會使用將不會釋放回收呼叫物件的解構函式之前。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 通常處理中的程式碼實作<xref:System.ServiceProcess.ServiceBase.OnPause%2A>呼叫合併<xref:System.ServiceProcess.ServiceBase.Dispose%2A>。 如果您選擇在您的衍生類別中這麼做，它是慣用實作<xref:System.ServiceProcess.ServiceBase.OnStart%2A>配置任何<xref:System.ServiceProcess.ServiceBase.Dispose%2A>釋出。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得事件記錄檔，您可以利用該事件記錄將服務命令呼叫 (例如啟動和停止) 通知寫入應用程式事件記錄檔。</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLog" /> 執行個體，其來源是登錄到應用程式記錄檔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建構函式初始化<xref:System.ServiceProcess.ServiceBase.EventLog%2A>與執行個體的內容<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType>屬性集。 來源是<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>的服務，並在記錄檔已在電腦的應用程式記錄檔。 這些值會自動設定並不能自動記錄服務命令的變更。  
  
 當<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>是`true`，啟動、 停止、 暫停、 繼續和自訂的命令會自動記錄應用程式事件記錄檔中。 您可以使用<xref:System.ServiceProcess.ServiceBase.EventLog%2A>將額外的訊息寫入該記錄檔的屬性。 元件呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType>使用這個<xref:System.ServiceProcess.ServiceBase.EventLog%2A>成員。  
  
 若要報告自訂事件記錄檔，而不是應用程式記錄檔的資訊，請設定<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>至`false`和寫入命令處理方法中的指示<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>張貼到適當的記錄檔。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定服務的結束代碼 (Exit Code)。</summary>
        <value>服務的結束代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.ServiceProcess.ServiceBase.ExitCode%2A>屬性設為非零值，之後才能停止服務，以指出服務控制管理員發生錯誤。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>指示服務名稱的最大值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName 或 DisplayName 兩者都有您的服務類別上設定屬性時，必須遵守的大小限制。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳送繼續命令給服務時，將執行 <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" />。 指定暫停服務後要繼續正常運作所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>鏡像，您的應用程式回應<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。 當您繼續執行服務 （無論是透過 [服務] 主控台或以程式設計方式），<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>處理執行，然後服務再次變成作用中。  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 應該覆寫，當<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>屬性是`true`。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`、 SCM 將不會傳遞暫停或繼續對服務要求，因此<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使它們實作，將不會呼叫方法。 SCM 中`Pause`和`Continue`已停用控制項時<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">傳送至服務的命令訊息。</param>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳遞自訂命令給服務時，將執行 <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />。 指定在具有指定參數值的命令發生時所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 可讓您指定啟動、 停止、 暫停和繼續服務之外的其他功能。  
  
 SCM 不會檢查以確認服務是否支援自訂的命令`command`參數傳入。 它的自訂命令直接傳送至服務。 如果服務無法辨識`command`參數，它不做任何動作。  
  
 所引發的自訂命令<xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>陳述式中的<xref:System.ServiceProcess.ServiceController>元件。 使用 switch 陳述式或 if...然後條件來處理您在服務定義的自訂命令。  
  
 您可以在您的應用程式中定義，或使用中的自訂命令的唯一值<xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A>則 128 到 255 之間。 128 以下的整數會對應至系統保留的值。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>屬性是`true`，自訂的命令，像其他命令，將項目寫入事件記錄檔以報告是否方法執行成功或失敗。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳送暫停命令至服務時執行。 指定在服務暫停時所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnPause%2A>來指定服務收到縸懫暀硉時，就會發生的處理。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 應該覆寫，當<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>屬性是`true`。  
  
 當您繼續已暫停的服務 （無論是透過 [服務] 主控台或以程式設計方式），<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>處理，並再次變成作用中的服務。  
  
 [暫停] 命令只允許您的應用程式，以回應特定事件。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 沒有任何您沒有定義動作的服務。  
  
 服務傳送暫停要求可以節省系統資源，因為暫停不需要釋放所有系統資源。 例如，如果執行緒已開啟的程序，暫停服務，而不是停止它可以讓執行緒保持開啟，因此不需要服務繼續時重新配置。 如果您定義釋放所有系統資源的暫停時，它的行為類似停止命令。  
  
 設定<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>至`true`，並覆寫<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>指定 SCM 將暫停或繼續要求傳遞至您的服務時所採取的處理。 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 復原中的處理應該實作<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`、 SCM 將不會傳遞暫停或繼續對服務要求，因此<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使實作，將不會呼叫方法。 SCM 中`Pause`和`Continue`已停用控制項時<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">
          <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />，表示來自系統關於電源狀態的通知。</param>
        <summary>在衍生類別中實作時，當電腦的電源狀態已經變更時執行。 這適用於攜帶型電腦，當它們進入暫停模式的時候，不同於系統關閉。</summary>
        <returns>當在衍生類別中實作時，您的應用程式之需求會決定將傳回什麼值。 例如，如果傳遞 <see langword="QuerySuspend" /> 廣播狀態，您可能會導致您的應用程式傳回 <see langword="false" /> 來拒絕查詢。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>指定發生於系統事件中指出處理<xref:System.ServiceProcess.PowerBroadcastStatus>列舉型別，就會發生-例如，電腦會置於已暫停模式，或指出電力偏低時。  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 應該覆寫，當<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>屬性是`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">識別變更類型的結構。</param>
        <summary>當從 Terminal Server 工作階段接收到變更事件時執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須設定<xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>屬性`true`以便執行此方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，當系統正在關閉時執行。 指定緊接在系統關閉之前應該發生的處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>來指定系統關機時所發生的處理。  
  
 只有當作業系統關機，不會在關閉電腦時，就會發生這個事件。  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 應該覆寫，當<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>屬性是`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">啟動命令所傳遞的資料。</param>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳送啟動命令至服務或當作業系統啟動 (自動啟動服務) 時執行。 指定在服務啟動時所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>來指定在服務接收啟動命令時，就會發生的處理。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 是您可以在其中指定服務行為的方法。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 可以接受引數，用來傳送資料，但這種使用方式很少發生。  
  
> [!CAUTION]
>  請勿使用建構函式來執行處理應該在<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 使用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>來處理您的服務的所有初始設定。 應用程式的可執行檔時，會呼叫建構函式執行時，不會在執行此服務。 可執行檔執行之前<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 當您要繼續，例如，建構函式不會再次呼叫因為 SCM 已經保留在記憶體中的物件。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>建構函式，而非在配置的資源釋出<xref:System.ServiceProcess.ServiceBase.OnStart%2A>，所需的資源並不會建立一次呼叫服務時的第二個時間。  
  
 服務可以設定為自動啟動時重新啟動電腦藉由設定<xref:System.ServiceProcess.ServiceInstaller.StartType%2A>上服務的安裝程式<xref:System.ServiceProcess.ServiceStartMode.Automatic>。 在這種情況下，<xref:System.ServiceProcess.ServiceBase.OnStart%2A>會在系統啟動時呼叫。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 必須在衍生類別中覆寫。 服務才能發揮作用，<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>應該同時在實作您的服務類別。  
  
 處理初始化引數中的服務<xref:System.ServiceProcess.ServiceBase.OnStart%2A>方法，不會在 Main 方法。 中的引數`args`可以手動設定參數陣列，在 [屬性] 視窗的 [服務] 主控台中的服務。 在主控台輸入的引數不會儲存。它們會傳遞至服務一次從控制台啟動服務時。 必須是服務自動啟動時存在的引數可以放在服務的登錄機碼的 ImagePath 字串值 (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\ * \<服務名稱 >*)。 您可以從登錄使用來取得引數<xref:System.Environment.GetCommandLineArgs%2A>方法，例如： `string[] imagePathArgs = Environment.GetCommandLineArgs();`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，當服務控制管理員 (SCM) 傳送停止命令至服務時執行。 指定在服務停止執行時所要執行的動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnStop%2A>來指定服務收到 Stop 命令時，就會發生的處理。  
  
 SCM 收到 Stop 命令時，它會使用值的<xref:System.ServiceProcess.ServiceBase.CanStop%2A>以確認服務是否接受停止命令。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`true`，停止命令傳遞至服務，而<xref:System.ServiceProcess.ServiceBase.OnStop%2A>呼叫方法時若其定義。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>未實作在服務中，SCM 處理停止命令。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`false`，SCM 會略過停止命令。 它不會傳遞至服務。 停止命令傳回，則擲回例外狀況。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 必須在衍生類別中覆寫。 服務才能發揮作用，<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>應該同時在實作您的服務類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">以毫秒為單位的要求時間。</param>
        <summary>要求額外時間進行暫止的運算。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A>方法用於呼叫所覆寫<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>， <xref:System.ServiceProcess.ServiceBase.OnStart%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法來要求更多的時間暫止的作業，以防止標示的服務控制管理員 (SCM)為沒有回應的服務。  如果暫止的作業不會繼續、 暫停、 啟動或停止，<xref:System.InvalidOperationException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服務不在暫止狀態。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提供服務可執行檔的主要進入點。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.ServiceProcess.ServiceBase" />，表示要啟動的服務。</param>
        <summary>使用服務控制管理員 (SCM) 登錄服務的可執行檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個多載`main()`函式可註冊服務和服務控制管理員中執行的服務。 在您呼叫後<xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>，服務控制管理員發出的呼叫會導致啟動命令<xref:System.ServiceProcess.ServiceBase.OnStart%2A>服務中的方法。 服務未啟動，直到執行啟動命令為止。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>相同方式為呼叫方法<xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType>Windows Forms 應用程式。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>是`true`，項目寫入事件記錄檔，如果所指定的服務`service`參數無法啟動。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">ServiceBase 執行個體的陣列，表示要啟動的服務。</param>
        <summary>使用服務控制管理員 (SCM) 登錄多個服務的可執行檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個多載`main()`函式可註冊服務和服務控制管理員中執行的服務。 在您呼叫後<xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>，服務控制管理員發出開始命令，這會導致呼叫<xref:System.ServiceProcess.ServiceBase.OnStart%2A>服務中的方法。 直到開始執行的命令會將無法啟動服務。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>相同方式為呼叫方法<xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType>Windows Forms 應用程式的方法。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>是`true`，項目寫入事件記錄檔，如果陣列中的任何服務無法啟動。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">您不提供要啟動的服務。 陣列可能為 <see langword="null" /> 或空白。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得服務的服務控制處理。</summary>
        <value>包含服務之服務控制處理的 <see cref="T:System.IntPtr" /> 結構。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 服務控制代碼用來通訊的服務控制管理員 (SCM)。  控制代碼可用來更新使用 unmanaged 呼叫服務的服務控制管理員的狀態資訊`SetServiceStatus`函式。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用於存取 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">引數陣列中的引數數目。</param>
        <param name="argPointer">指向引數陣列的 <see cref="T:System.IntPtr" /> 結構。</param>
        <summary>登錄命令處理常式 (Command Handler) 並啟動服務。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來識別系統服務的簡短名稱。</summary>
        <value>服務的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>識別到服務控制管理員中的服務。 這個屬性的值必須是相同的服務所記錄的名稱<xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType>相對應的安裝程式類別的屬性。 在程式碼，<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>通常設定服務的`main()`函式的可執行檔。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>也用來指定<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>聯<xref:System.ServiceProcess.ServiceBase.EventLog%2A>屬性。 這<xref:System.ServiceProcess.ServiceBase.EventLog%2A>是將服務命令資訊寫入至應用程式記錄檔的執行個體。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>，它提供事件記錄檔的來源字串之前，必須設定服務會寫入事件記錄檔。 嘗試存取事件記錄檔之前設定的來源名稱會導致擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已經啟動服務。 一旦已經啟動服務，就無法變更 <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> 屬性。</exception>
        <exception cref="T:System.ArgumentException">指定的名稱是零長度字串或比 <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" /> 更長，或者指定的名稱包含斜線或反斜線字元。</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止執行中的服務。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.Stop%2A>方法設定的服務狀態，以指出停止暫止 」 和 「 呼叫<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法。  停止應用程式之後，服務的狀態設定為停止。 如果應用程式是託管的服務，應用程式定義域已卸載。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>