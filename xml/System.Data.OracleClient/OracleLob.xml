<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="69379b993f96f3e6579fc6f1fe9d4d03c40dd835" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36684334" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a large object binary (<see langword="LOB" />) data type stored on an Oracle server. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob>不同於<xref:System.Data.OracleClient.OracleBFile>，資料會儲存於作業系統中的實體檔案而不是伺服器上。 它也可以是讀寫物件不同於<xref:System.Data.OracleClient.OracleBFile>，這一律是唯讀的。  
  
 <xref:System.Data.OracleClient.OracleLob>可能是下列其中一種<xref:System.Data.OracleClient.OracleType>資料型別。  
  
|OracleType 資料類型|描述|  
|--------------------------|-----------------|  
|`Blob`|Oracle`BLOB`包含最大值 4 gb 之二進位資料的資料類型。 這會對應到<xref:System.Array>型別的<xref:System.Byte>。|  
|`Clob`|Oracle`CLOB`設定在伺服器上，最大值 4 gb 的資料類型包含字元資料，根據預設字元。 這會對應到<xref:System.String>。|  
|`NClob`|Oracle`NCLOB`包含字元資料的資料型別會根據最大值 4 GB 的伺服器上的國家字元集。 這會對應到<xref:System.String>。|  
  
 .NET 應用程式開發人員可以擷取 Oracle`LOB`值為基本的.NET 資料類型，例如<xref:System.Array>型別的<xref:System.Byte>和<xref:System.String>，或特殊<xref:System.Data.OracleClient.OracleLob>資料型別。 <xref:System.Data.OracleClient.OracleLob>類別支援讀取資料來源和 Oracle 寫入`LOB`Oracle 資料庫中。  
  
 以下是主要特性<xref:System.Data.OracleClient.OracleLob>區別基本的.NET 資料類型的資料類型：  
  
-   擷取 Oracle 之後`LOB`值從 Oracle 資料庫<xref:System.Data.OracleClient.OracleLob>類別，您可以變更`LOB`開啟的交易和您的變更中的資料會直接反映至資料庫。 如果您擷取 Oracle`LOB`值放入<xref:System.Array>型別的<xref:System.Byte>或<xref:System.String>及更新這些陣列中，您的變更不會反映到資料庫。  
  
-   當您使用<xref:System.Data.OracleClient.OracleLob>類別來存取的區塊`LOB`值，只有該區塊會傳遞從 Oracle 資料庫給用戶端。 當您使用<xref:System.Data.OracleClient.OracleDataReader.GetChars%2A>方法來存取的區塊`LOB`值，該值的整個內容會從 Oracle 資料庫給用戶端。  
  
 若要取得<xref:System.Data.OracleClient.OracleLob>物件，呼叫<xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A>方法。  
  
 您可以建構<xref:System.Data.OracleClient.OracleLob>這是 NULL，使用下列格式：  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 這項技術主要用來測試是否`LOB`從伺服器傳回為 NULL，如這個範例所示：  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL`LOB`同樣的運作方式會與零位元組`LOB`在於<xref:System.Data.OracleClient.OracleLob.Read%2A>成功，而且一律會傳回零個位元組。  
  
 選取`LOB`包含 null 值的資料行會傳回<xref:System.Data.OracleClient.OracleLob.Null>。  
  
 您必須開始之前取得暫存交易`LOB`。 否則，<xref:System.Data.OracleClient.OracleDataReader>稍後取得資料可能會失敗。  
  
 您也可以開啟暫存`LOB`Oracle 藉由呼叫 DBMS_LOB 中。CREATETEMPORARY 系統預存程序和繫結`LOB`輸出參數。 在用戶端，暫存`LOB`行為類似資料表為基礎`LOB`。 例如，若要更新暫存`LOB`，就必須括在交易。  
  
 下列 C# 範例示範如何開啟暫存`LOB`。  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  繼承<xref:System.IO.Stream.WriteByte%2A>方法失敗時，如果搭配字元資料和<xref:System.InvalidOperationException>就會擲回。 請改用 <xref:System.Data.OracleClient.OracleLob.Write%2A> 方法。  
>   
>  暫存`LOB`是只關閉連接關閉時，但與集區，並在負載下，暫時`LOB`s，請勿關閉。 這可以透過處置暫存解決`LOB`，藉由叫用`tempLob.Dispose()`。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">The <see langword="LOB" /> from which to append data.</param>
        <summary>Appends data from the specified <see langword="LOB" /> to the current <see langword="LOB" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
 所有資料來源的`LOB`附加至目前結尾`LOB`。 兩者皆非的位置`LOB`評估或變更在此程序。  
  
 基礎資料類型必須相同。 例如，如果您從附加<xref:System.Data.OracleClient.OracleType.NClob>，目的地<xref:System.Data.OracleClient.OracleLob>也必須是<xref:System.Data.OracleClient.OracleType.NClob>。  
  
> [!NOTE]
>  在此版本中，唯讀的寫入作業`LOB`可能會成功，但不會更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null.</exception>
        <exception cref="T:System.InvalidOperationException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple write operations.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple read operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開啟`LOB`中<xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly>模式; 因此，`LOB`只能讀取，不會寫入，直到的對應呼叫<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>。 若要執行批次寫入`LOB`，呼叫<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>與<xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>。  
  
 呼叫<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>超過一次在相同交易內目前擲回 Oracle"或 22293: LOB 已經開啟與相同交易中 」 錯誤。 此外，如果您取得`LOB`使用另一個<xref:System.Data.OracleClient.OracleDataReader>，和原始呼叫端未呼叫<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>方法，相同的錯誤會產生。 因此，您必須呼叫<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>方法，當您完成使用<xref:System.Data.OracleClient.OracleLob>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Mode (one of the <see cref="T:System.Data.OracleClient.OracleLobOpenMode" /> values) in which the <see langword="LOB" /> can be accessed between this <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> call and the corresponding <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" /> call.</param>
        <summary>Prevents server-side triggers from firing while performing multiple read and write operations in the specified access mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
 呼叫<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>超過一次在相同交易內目前擲回 Oracle"或 22293: LOB 已經開啟與相同交易中 」 錯誤。 此外，如果您取得`LOB`使用另一個<xref:System.Data.OracleClient.OracleDataReader>，和原始呼叫端未呼叫<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>方法，相同的錯誤會產生。 因此，您必須呼叫<xref:System.Data.OracleClient.OracleLob.EndBatch%2A>方法，當您完成使用<xref:System.Data.OracleClient.OracleLob>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see langword="LOB" /> stream can be read.</summary>
        <value>
          <see langword="true" /> 如果<see langword="LOB" />資料流支援讀取，否則<see langword="false" />如果<see langword="LOB" />已關閉或處置。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether forward and backward seek operations can be performed.</summary>
        <value>
          <see langword="false" /> 如果<see langword="LOB" />已關閉或處置，否則<see langword="true" />。 一律<see langword="true" />如<see cref="F:System.Data.OracleClient.OracleLob.Null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Always returns true, regardless of whether the <see langword="LOB" /> supports writing or not.</summary>
        <value>一律傳回<see langword="true" />，無論是否已開啟或未處置的<see langword="LOB" />支援寫入，<see langword="false" />如果<see langword="LOB" />已關閉或處置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須先啟動本機交易。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating the minimum number of bytes to retrieve from or send to the server during a read/write operation.</summary>
        <value>要擷取或傳送的位元組數目下限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所傳回的值<xref:System.Data.OracleClient.OracleLob.ChunkSize%2A>屬性不是 Oracle 的.NET Framework 資料提供者的設定。 相反地，它是與伺服器通訊時，會使用 Oracle Call Interface (OCI) 的值。 使用<xref:System.Data.OracleClient.OracleLob.ChunkSize%2A>以確保用戶端區塊都是相同的大小。 讀取或寫入較小的區塊不會快取資料，並會造成無最佳化往返伺服器，因為未接收或傳送完整的封包。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <returns>A new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新的屬性<xref:System.Data.OracleClient.OracleLob>物件一開始會有相同的值與原始物件。 不過之後,<xref:System.Data.OracleClient.OracleLob.Clone%2A>已完成，每個<xref:System.Data.OracleClient.OracleLob>與其他物件無關。 例如，變更值的<xref:System.Data.OracleClient.OracleLob.Position%2A>原始屬性<xref:System.Data.OracleClient.OracleLob>不會變更的值<xref:System.Data.OracleClient.OracleLob.Position%2A>副本上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Data.OracleClient.OracleConnection" /> used by this instance of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>資料來源的連接。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基礎資料類型必須相同。 例如，如果您要從複製<xref:System.Data.OracleClient.OracleType.NClob>，目的地<xref:System.Data.OracleClient.OracleLob>也必須是<xref:System.Data.OracleClient.OracleType.NClob>。  
  
 如果目的地位移超出目的地結尾`LOB`、`LOB`要複製資料的擴充。 結尾之間的間距`LOB`和結尾之外的目的位移會以零填補`BLOB`資料型別和空間`CLOB`和`NCLOB`資料型別。  
  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
> [!NOTE]
>  在此版本中，唯讀的寫入作業`LOB`可能成功，但不是更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`將會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
>   
>  `CopyTo`方法不會清除目的地的內容`OracleLob`之前執行複製作業。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is null.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" /></param>
        <param name="destinationOffset">The offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number of bytes.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基礎資料類型必須相同。 例如，如果您要從複製<xref:System.Data.OracleClient.OracleType.NClob>，目的地<xref:System.Data.OracleClient.OracleLob>也必須是<xref:System.Data.OracleClient.OracleType.NClob>。  
  
 如果目的地位移超出目的地結尾`LOB`、`LOB`要複製資料的擴充。 結尾之間的間距`LOB`和目的地超過結尾的位移會以零填補`BLOB`資料型別和空間`CLOB`和`NCLOB`資料型別。  
  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
> [!NOTE]
>  在此版本中，唯讀的寫入作業`LOB`可能會成功，但不會更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
>   
>  `CopyTo`方法不會清除目的地的內容`OracleLob`之前執行複製作業。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">The offset from which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="destination">The destination <see langword="OracleLob" /><see cref="N:System.Data.OracleClient" />.</param>
        <param name="destinationOffset">The destination offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data, and the source offset.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基礎資料類型必須相同。 例如，如果您要從複製<xref:System.Data.OracleClient.OracleType.NClob>，目的地<xref:System.Data.OracleClient.OracleLob>也必須是<xref:System.Data.OracleClient.OracleType.NClob>。  
  
 如果目的地位移超出目的地結尾`LOB`、`LOB`要複製資料的擴充。 結尾之間的間距`LOB`和目的地超過結尾的位移會以零填補`BLOB`資料型別和空間`CLOB`和`NCLOB`資料型別。  
  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
> [!NOTE]
>  在此版本中，唯讀的寫入作業`LOB`可能會成功，但不會更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
>   
>  `CopyTo`方法不會清除目的地的內容`OracleLob`之前執行複製作業。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows server-side triggers to resume firing after performing multiple write operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Data.OracleClient.OracleLob.BeginBatch%2A>方法之前執行寫入作業上<xref:System.Data.OracleClient.OracleLob>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erases data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erases all data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> 不會截斷資料。 `LOB`長度將維持不相同的`BLOB`資料型別，並清除的資料取代為 0x00 處截斷。 `CLOB` 和`NCLOB`以空格取代資料型別。  
  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
> [!NOTE]
>  在此版本中，唯讀的寫入作業`LOB`可能會成功，但不會更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">The offset from which to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Erases the specified amount of data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中值的總和`offset`和`amount`參數可以是大於大小<xref:System.Data.OracleClient.OracleLob>。 因此，指定的值大於傳回<xref:System.Data.OracleClient.OracleLob.Length%2A>屬性會成功; 但是<xref:System.Data.OracleClient.OracleLob.Erase%2A>只清除結尾<xref:System.Data.OracleClient.OracleLob>。 (同樣地，如果負數的值會傳遞至`offset`，<xref:System.Data.OracleClient.OracleLob.Erase%2A>會成功，但只清除 從開頭開始<xref:System.Data.OracleClient.OracleLob>。)此行為是不同的<xref:System.Data.OracleClient.OracleLob.Read%2A>和<xref:System.Data.OracleClient.OracleLob.Write%2A>方法，與提供的優點是能夠清除所有資料值所指定項目`offset`而不需要進行額外的往返到伺服器，以確認實際大小。  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> 不會截斷資料。 `LOB`長度將維持不相同的`BLOB`資料型別，並清除的資料取代為 0x00 處截斷。 `CLOB` 和`NCLOB`以空格取代資料型別。  
  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
> [!NOTE]
>  在此版本中，唯讀的寫入作業`LOB`可能會成功，但不會更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Not currently supported.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此版本中，這個方法沒有作用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether an application called the <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> method.</summary>
        <value>
          <see langword="true" /> 如果應用程式呼叫<see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />方法，否則為<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用 Oracle 8.0.5 server、 Oracle"或 00600： 內部錯誤碼"擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> stream.</summary>
        <value>
          <see langword="true" /> 如果<see cref="T:System.Data.OracleClient.OracleLob" />是<see cref="F:System.Data.OracleClient.OracleBFile.Null" />資料流，否則為<see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a temporary <see langword="LOB" />.</summary>
        <value>
          <see langword="true" /> 如果<see cref="T:System.Data.OracleClient.OracleLob" />是暫存<see langword="LOB" />，否則為<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列範例示範如何建立暫存`LOB`。  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the size of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>大小<see cref="T:System.Data.OracleClient.OracleLob" />以位元組為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大小<xref:System.Data.OracleClient.OracleLob>一律會傳回以位元組為單位的所有資料型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the <see langword="LOB" /> data type.</summary>
        <value>其中一個<see cref="T:System.Data.OracleClient.OracleType" /><see langword="LOB" />資料型別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob>可能是下列其中一種<xref:System.Data.OracleClient.OracleType>資料型別。  
  
|OracleType 資料類型|描述|  
|--------------------------|-----------------|  
|`Blob`|Oracle`BLOB`包含最大值 4 gb 之二進位資料的資料類型。 這會對應到<xref:System.Array>型別的<xref:System.Byte>。|  
|`Clob`|Oracle`CLOB`設定在伺服器上，最大值 4 gb 的資料類型包含字元資料，根據預設字元。 這會對應到<xref:System.String>。|  
|`NClob`|Oracle`NCLOB`包含字元資料的資料型別會根據最大值 4 gb 之伺服器上的國家字元集。 這會對應到<xref:System.String>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents a null <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以建構<xref:System.Data.OracleClient.OracleLob>這是 NULL，使用下列格式：  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 這項技術主要用來測試是否`LOB`從伺服器傳回為 NULL，如這個範例所示：  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL`LOB`同樣的運作方式會與零位元組`LOB`在於<xref:System.Data.OracleClient.OracleLob.Read%2A>成功，而且一律會傳回零個位元組。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current read position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <value>中的目前位置<see cref="T:System.Data.OracleClient.OracleLob" />資料流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資料流必須支援搜尋要取得或設定位置。 使用<xref:System.Data.OracleClient.OracleLob.CanSeek%2A>屬性來判斷資料流是否支援搜尋。  
  
 支援搜尋到的任何位置超出資料流的長度。 奇數位置搜尋`CLOB`和`NCLOB`也支援的資料類型。 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Data.OracleClient.OracleLob.Read%2A>屬性。  
  
 <xref:System.Data.OracleClient.OracleLob.Position%2A>屬性不會不追蹤的已耗用，略過，資料流，或兩者中的位元組數目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c>) replaced by the bytes read from the current source.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The maximum number of bytes to be read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Reads a sequence of bytes from the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream and advances the position within the stream by the number of bytes read.</summary>
        <returns>The total number of bytes read into the buffer. This may be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Read%2A>方法讀取的數目上限`count`位元組從目前資料流，且將其儲存在`buffer`開始`offset`。 資料流的目前位置前移讀取位元組數。不過，如果發生例外狀況，則資料流中目前的位置維持不變。 <xref:System.Data.OracleClient.OracleLob.Read%2A> 傳回讀取的位元組數目。 只有位置是目前資料流結尾，傳回的值為零。 <xref:System.Data.OracleClient.OracleLob.Read%2A> 會阻擋，直到可以讀取至少一個位元組的資料，確認沒有資料可供使用。<xref:System.Data.OracleClient.OracleLob.Read%2A> 如果您嘗試讀取會傳回 0`LOB`目前位置的結尾時`LOB`。 <xref:System.Data.OracleClient.OracleLob.Read%2A> 可傳回比要求的位元組更少，即使尚未達到資料流結尾。  
  
 .NET Framework Data Provider for Oracle 會處理所有`CLOB`和`NCLOB`以 unicode 格式的資料。 因此，當存取`CLOB`和`NCLOB`資料類型，您永遠都在處理其中每一個字元是 2 個位元組的位元組數目。 例如，如果文字包含三個字元的字串會儲存為`NCLOB`其中的字元集是 4 個位元組，每個字元，而您執行 Oracle 伺服器上`Read`作業，您將指定字串的長度為 6 個位元組，雖然它是儲存在伺服器上的 12 個位元組。  
  
 下列 C# 範例示範如何讀取<xref:System.Data.OracleClient.OracleLob>物件。  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 您可以建構<xref:System.Data.OracleClient.OracleLob>這是 NULL，使用下列格式：  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 這項技術主要用來測試是否`LOB`從伺服器傳回為 NULL，如下列範例所示。  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 NULL`LOB`同樣的運作方式會與零位元組`LOB`在於<xref:System.Data.OracleClient.OracleLob.Read%2A>成功，而且一律會傳回零個位元組。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the offset and count parameters is larger than the buffer length.  -or-  A value specified in the <paramref name="amount" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">A byte offset relative to origin. If <c>offset</c> is negative, the new position precedes the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>. If <c>offset</c> is zero, the new position is the position specified by <c>origin</c>. If <c>offset</c> is positive, the new position follows the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>.</param>
        <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</param>
        <summary>Sets the position on the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <returns>The new position within the current stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`offset`是負數，新的位置必須優先於所指定的位置`origin`所指定的位元組數`offset`。 如果`offset`為零，新的位置必須是所指定的位置`origin`。 如果`offset`是正數，新的位置必須遵循所指定的位置`origin`所指定的位元組數`offset`。  
  
 支援搜尋到的任何位置超出資料流的長度。 奇數位置搜尋`CLOB`和`NCLOB`也支援的資料類型。 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Data.OracleClient.OracleLob.Read%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="origin" /> parameter does not contain a valid value.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting position is beyond the length of the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The desired length of the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream in bytes. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Sets the length of the <see cref="T:System.Data.OracleClient.OracleLob" /> stream to a value less than the current length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘗試增加的長度<xref:System.Data.OracleClient.OracleLob>資料流失敗，並傳回 「 郵件： ORA-TUT1-LESSON1-STEP2 22926： 指定修剪的長度大於目前 LOB 值的長度 」 從 Oracle 伺服器。  
  
 資料流必須支援寫入和搜尋的<xref:System.Data.OracleClient.OracleLob.SetLength%2A>函式。  
  
 .NET Framework Data Provider for Oracle 會處理所有`CLOB`和`NCLOB`以 unicode 格式的資料。 因此，當存取`CLOB`和`NCLOB`資料類型，您永遠都在處理其中每一個字元是 2 個位元組的位元組數目。 例如，如果文字包含三個字元的字串會儲存為`NCLOB`其中的字元集是 4 個位元組，每個字元，而您執行 Oracle 伺服器上`SetLength`作業，您將指定字串的長度為 6 個位元組，雖然它是儲存在伺服器上的 12 個位元組。  
  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
> [!NOTE]
>  寫入作業的唯讀`LOB`可能會成功，但不會更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="value" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  A value specified in the <paramref name="value" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the common language runtime stream value equivalent of the underlying value.</summary>
        <value>如<see cref="F:System.Data.OracleClient.OracleType.Blob" />，類型的陣列<see langword="Byte[]" />。 如<see cref="F:System.Data.OracleClient.OracleType.Clob" />和<see cref="F:System.Data.OracleClient.OracleType.NClob" />、 <see langword="String" />。 對於 null 的資料， <see cref="T:System.DBNull" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如<xref:System.Data.OracleClient.OracleType.Blob>資料型別，<xref:System.Data.OracleClient.OracleLob.Value%2A>傳回整個基礎資料當做連續陣列型別的`Byte[]`。 如<xref:System.Data.OracleClient.OracleType.Clob>和<xref:System.Data.OracleClient.OracleType.NClob>資料型別，<xref:System.Data.OracleClient.OracleLob.Value%2A>傳回的資料作為`String`資料型別。 對於 null 的資料，<xref:System.Data.OracleClient.OracleLob.Value%2A>傳回<xref:System.DBNull>。 藉由比較傳回的值，您可以分辨空白資料、 null、 資料和資料。  
  
> [!NOTE]
>  使用的好處`LOB`資料型別就是能夠擷取大量的用戶端區塊中的資料。 不過，當您使用<xref:System.Data.OracleClient.OracleLob.Value%2A>，取得所有的資料`LOB`資料行做為一個連續的區塊，可能會大幅增加應用程式的額外負荷。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. This method copies the number of bytes specified in <c>count</c> from <c>buffer</c> to the current stream.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The number of bytes to be written to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Writes a sequence of bytes to the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the current position within this stream by the number of bytes written.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果作業成功時，寫入的位元組數目進階資料流的位置。 如果發生例外狀況，資料流的位置維持不變。  
  
 寫入結尾之外`LOB`允許，且會放大`LOB`所寫入的位元組數目。  
  
 .NET Framework Data Provider for Oracle 會處理所有`CLOB`和`NCLOB`以 unicode 格式的資料。 因此，當存取`CLOB`和`NCLOB`資料類型，您永遠都在處理其中每一個字元是 2 個位元組的位元組數目。 例如，如果文字包含三個字元的字串會儲存為`NCLOB`其中的字元集是 4 個位元組，每個字元，而您執行 Oracle 伺服器上`Write`作業，您將指定字串的長度為 6 個位元組，雖然它是儲存在伺服器上的 12 個位元組。  
  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
 下列 C# 範例示範如何寫入<xref:System.Data.OracleClient.OracleLob>物件。  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  寫入作業的唯讀`LOB`可能會成功，但不會更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the <paramref name="offset" /> and <paramref name="count" /> parameters is larger than the <paramref name="buffer" /> length.  -or-  A value specified in the <paramref name="count" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The byte to write to the stream.</param>
        <summary>Writes a byte to the current position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the position within the stream by one byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果作業成功，資料流位置推進一個位元組。 如果發生例外狀況，資料流的位置維持不變。  
  
 寫入結尾之外`LOB`允許，且會放大`LOB`由 1 個位元組。  
  
 要寫入`LOB`，您必須擷取`LOB`使用 FOR UPDATE 子句中的 SQL SELECT 陳述式，而且您必須啟動的本機交易。  
  
> [!NOTE]
>  寫入作業的唯讀`LOB`可能會成功，但不會更新`LOB`在伺服器上。 在此情況下，不過，本機副本`LOB`會更新。 因此，稍後在讀取作業<xref:System.Data.OracleClient.OracleLob>物件可能會傳回寫入作業的結果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>