<Type Name="WorkflowRuntime" FullName="System.Workflow.Runtime.WorkflowRuntime">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d60c0d25dac7d842579bcc965536195478c702ea" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39776483" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WorkflowRuntime : IDisposable, IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi WorkflowRuntime extends System.Object implements class System.IDisposable, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowRuntime" />
  <TypeSignature Language="VB.NET" Value="Public Class WorkflowRuntime&#xA;Implements IDisposable, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowRuntime : IDisposable, IServiceProvider" />
  <TypeSignature Language="F#" Value="type WorkflowRuntime = class&#xA;    interface IServiceProvider&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表工作流程的工作流程執行階段引擎提供的可設定執行環境。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 <xref:System.Workflow.Runtime.WorkflowRuntime> 會公開主應用程式和服務需要的功能以設定和控制工作流程執行階段引擎，以及收到變更工作流程執行階段引擎與其任何工作流程執行個體的通知。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 它提供如何使用 <xref:System.Workflow.Runtime.WorkflowRuntime.%23ctor%2A> 建構函式 (Constructor)、<xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A>、<xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 和 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A> 方法的範例。 程式碼也會顯示在工作流程主機中使用 <xref:System.Workflow.Runtime.WorkflowInstance> 方法建立 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> 物件的建議方法。 同時也會顯示如何設定 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted>、<xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 和 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> 事件的事件處理常式。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkID=157346)範例。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowRuntime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowRuntime();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime> 是以預設的屬性值初始化，而且包含預設的核心服務。 若要額外設定工作流程執行階段引擎，您可以使用 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> 和 <xref:System.Workflow.Runtime.WorkflowRuntime.RemoveService%2A> 來加入或移除服務，而且您可以設定 <xref:System.Workflow.Runtime.WorkflowRuntime.Name%2A>。 設定 <xref:System.Workflow.Runtime.WorkflowRuntime> 後，呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 以啟動工作流程執行階段引擎及其服務。  
  
 下表顯示 <xref:System.Workflow.Runtime.WorkflowRuntime> 類別執行個體的初始屬性值。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Workflow.Runtime.WorkflowRuntime.Name%2A>|"WorkflowRuntime"|  
|<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A>|`false`|  
  
 預設的核心服務有：<xref:System.Workflow.Runtime.Hosting.DefaultWorkflowCommitWorkBatchService> 和 <xref:System.Workflow.Runtime.Hosting.DefaultWorkflowSchedulerService>。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 它提供如何使用 <xref:System.Workflow.Runtime.WorkflowRuntime.%23ctor%2A> 建構函式建立 <xref:System.Workflow.Runtime.WorkflowRuntime> 的執行個體，以及存取它的方法和事件的範例。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkID=157346)範例。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowRuntime (string configSectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string configSectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (configSectionName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowRuntime(System::String ^ configSectionName);" />
      <MemberSignature Language="F#" Value="new System.Workflow.Runtime.WorkflowRuntime : string -&gt; System.Workflow.Runtime.WorkflowRuntime" Usage="new System.Workflow.Runtime.WorkflowRuntime configSectionName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="configSectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configSectionName">應用程式組態檔中有效 <see langword="workflowSettings" /> 區段的名稱。</param>
        <summary>使用指定的應用程式組態檔區段，初始化 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據 <xref:System.Workflow.Runtime.WorkflowRuntime> 在應用程式組態檔中指定之區段中的設定初始化 `configSectionName`。 `configSectionName` 必須對應至有效`workflowSettings`組態檔區段。  
  
 當工作流程執行階段引擎設定使用應用程式組態檔時，它會載入並具現化中所列之類型的類別`Services`組態檔區段。 工作流程執行階段引擎建構這些類別時，會依序使用下列特徵標記尋找類別建構函式：  
  
1.  Service(WorkflowRuntime runtime, NameValueCollection parameters)  
  
2.  Service(WorkflowRuntime runtime)  
  
3.  Service(NameValueCollection parameters)  
  
4.  Service()  
  
 所有自組態檔載入的服務類別必須至少實作這些建構函式簽章中的其中一個。  
  
 如需詳細資訊，請參閱<xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="configSectionName" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentException">在應用程式組態檔中找不到有效的 <see langword="workflowSettings" /> 區段。</exception>
        <exception cref="T:System.InvalidOperationException">已存在此應用程式定義域的 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowRuntime (System.Workflow.Runtime.Configuration.WorkflowRuntimeSection settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Workflow.Runtime.Configuration.WorkflowRuntimeSection settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.#ctor(System.Workflow.Runtime.Configuration.WorkflowRuntimeSection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (settings As WorkflowRuntimeSection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowRuntime(System::Workflow::Runtime::Configuration::WorkflowRuntimeSection ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Workflow.Runtime.WorkflowRuntime : System.Workflow.Runtime.Configuration.WorkflowRuntimeSection -&gt; System.Workflow.Runtime.WorkflowRuntime" Usage="new System.Workflow.Runtime.WorkflowRuntime settings" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settings" Type="System.Workflow.Runtime.Configuration.WorkflowRuntimeSection" />
      </Parameters>
      <Docs>
        <param name="settings">
          <see cref="T:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection" />。</param>
        <summary>使用指定的 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 中的設定，初始化 <see cref="T:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式為不使用應用程式組態檔的主機提供了一個機制，可使用單一呼叫方法來設定工作流程執行階段引擎。 不使用應用程式組態檔的原因很多。 主機可能在不允許使用組態檔的環境中執行，例如，基於安全因素而不允許從應用程式組態檔中讀取的受信任環境。 此外，主機可能想要使用專屬的組態機制，例如，主機可能將工作流程執行階段引擎組態設定儲存在 SQL 資料庫中。  
  
 工作流程執行階段引擎會載入 <xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.Services%2A?displayProperty=nameWithType> 包含型別的類別，並將這些類別個體化。 工作流程執行階段引擎建構這些類別時，會依序使用下列特徵標記尋找類別建構函式：  
  
1.  Service(WorkflowRuntime runtime, NameValueCollection parameters)  
  
2.  Service(WorkflowRuntime runtime)  
  
3.  Service(NameValueCollection parameters)  
  
4.  Service()  
  
 所有在 `settings` 中指定的服務類別必須至少實作這些建構函式簽章中的其中一個。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="settings" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.InvalidOperationException">已存在此應用程式定義域的 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddService">
      <MemberSignature Language="C#" Value="public void AddService (object service);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddService(object service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.AddService(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddService (service As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddService(System::Object ^ service);" />
      <MemberSignature Language="F#" Value="member this.AddService : obj -&gt; unit" Usage="workflowRuntime.AddService service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="service">物件，表示要新增的服務。</param>
        <summary>加入指定的服務至工作流程執行階段引擎。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以透過加入核心服務來設定工作流程執行階段引擎。 核心服務是衍生自下列任一服務基底類別 (Base Class) 的服務：<xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 類別、<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 類別、<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 類別和 <xref:System.Workflow.Runtime.Tracking.TrackingService> 類別。  核心服務只能加入，當工作流程執行階段引擎未在執行中;也就是說，當<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A>是`false`。 <xref:System.Workflow.Runtime.WorkflowRuntime> 也可以當做其他服務的儲存容器使用，其他工作流程或主機上執行的應用程式也可以使用。 如果您在工作流程執行階段引擎啟動後，加入衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 類別的非核心服務，則 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> 會呼叫該服務實作的 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Start%2A> 方法。  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> 會強制限制不能有兩個屬於相同 <xref:System.Type> 的服務加入至 <xref:System.Workflow.Runtime.WorkflowRuntime>。 然而，您可以加入衍生自相同基底類別的多個服務。  <xref:System.Workflow.Runtime.WorkflowRuntime> 中，只能加入各一個衍生自下列服務基底類別的服務：<xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 類別、<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 類別和 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 類別。  如果加入多個衍生自這些類別其中之一的服務 (例如兩個持續性服務)，<xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 會擲回 <xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 提供如何使用 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> 方法，將 <xref:System.Workflow.Activities.ExternalDataExchangeService> 與 <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> 加入工作流程執行階段引擎的範例。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkId=157346)範例。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="service" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已處置。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="service" /> 已向工作流程執行階段引擎註冊。  
  
-或- 
 <paramref name="service" /> 是核心服務，而且工作流程執行階段引擎已經在執行中 (<see cref="P:System.Workflow.Runtime.WorkflowRuntime.IsStarted" /> 是 <see langword="true" />)。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateWorkflow">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用指定的參數建立工作流程執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果工作流程執行階段引擎尚未啟動，<xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> 方法會呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>。 如需可能的例外狀況清單，請參閱 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>。 建立工作流程執行個體後，呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A?displayProperty=nameWithType> 方法傳回之 <xref:System.Workflow.Runtime.WorkflowInstance> 物件上的 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> 以開始其執行。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (Type workflowType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Type workflowType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowType As Type) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(Type ^ workflowType);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : Type -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow workflowType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="workflowType">要建立之工作流程的 <see cref="T:System.Type" />。</param>
        <summary>使用指定的工作流程 <see cref="T:System.Type" /> 建立新的工作流程執行個體。</summary>
        <returns>建立的工作流程執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，系統會針對它執行驗證。 如果發生任何驗證錯誤，就會擲回 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 這對於簡單案例很有用，但是在伺服器環境中，針對每一個啟動過程重新驗證工作流程可能是不必要的額外負荷。  
  
 如需有關如何停用驗證的詳細資訊，請參閱<xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
   
  
## Examples  
 下列程式碼範例將示範如何在使用 <xref:System.Workflow.Runtime.WorkflowInstance> 方法的工作流程主機中，以建議的方法建立 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> 物件。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkID=157346)範例。  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="workflowType" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (System.Xml.XmlReader workflowDefinitionReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Xml.XmlReader workflowDefinitionReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowDefinitionReader As XmlReader) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(System::Xml::XmlReader ^ workflowDefinitionReader);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : System.Xml.XmlReader -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow workflowDefinitionReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowDefinitionReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="workflowDefinitionReader">包含工作流程定義的 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 建立工作流程執行個體。</summary>
        <returns>建立的工作流程執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行個體是從 <xref:System.Xml.XmlReader> 參考的 XAML 工作流程定義檔建立。  
  
 建立 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，系統會針對它執行驗證。 如果發生任何驗證錯誤，就會擲回 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 這對於簡單案例很有用，但是在伺服器環境中，針對每一個啟動過程重新驗證工作流程可能是不必要的額外負荷。  
  
 如需有關如何停用驗證的詳細資訊，請參閱<xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
   
  
## Examples  
 下列程式碼範例將示範如何使用指定的 XAML 工作流程定義來建立工作流程。  
  
```  
static void Main(string[] args)  
{  
    using (WorkflowRuntime workflowRuntime = new WorkflowRuntime())  
    {  
        AutoResetEvent waitHandle = new AutoResetEvent(false);  
        workflowRuntime.WorkflowCompleted += delegate(object sender, WorkflowCompletedEventArgs e)  
        {  
            waitHandle.Set();  
        };  
        workflowRuntime.WorkflowTerminated += delegate(object sender, WorkflowTerminatedEventArgs e)  
        {  
            Console.WriteLine(e.Exception.Message);  
            waitHandle.Set();  
        };  
  
        TypeProvider typeProvider = new TypeProvider(null);  
        // Add referenced assemblies, if needed  
        // typeProvider.AddAssembly(...);  
        workflowRuntime.AddService(typeProvider);  
  
        using (XmlReader reader = XmlReader.Create("Workflow1.xoml"))  
        {  
            WorkflowInstance instance = workflowRuntime.CreateWorkflow(reader);  
            instance.Start();  
        }  
  
        waitHandle.WaitOne();  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="workflowDefinitionReader" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (Type workflowType, System.Collections.Generic.Dictionary&lt;string,object&gt; namedArgumentValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Type workflowType, class System.Collections.Generic.Dictionary`2&lt;string, object&gt; namedArgumentValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowType As Type, namedArgumentValues As Dictionary(Of String, Object)) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(Type ^ workflowType, System::Collections::Generic::Dictionary&lt;System::String ^, System::Object ^&gt; ^ namedArgumentValues);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : Type * System.Collections.Generic.Dictionary&lt;string, obj&gt; -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow (workflowType, namedArgumentValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowType" Type="System.Type" />
        <Parameter Name="namedArgumentValues" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowType">要建立之工作流程的 <see cref="T:System.Type" />。</param>
        <param name="namedArgumentValues">由字串建立索引鍵之物件的 <see cref="T:System.Collections.Generic.Dictionary`2" />，代表工作流程的引數。</param>
        <summary>使用指定的工作流程 <see cref="T:System.Type" /> 和指定之 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的工作流程之引數來建立工作流程執行個體。</summary>
        <returns>建立的工作流程執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，系統會針對它執行驗證。 如果發生任何驗證錯誤，就會擲回 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 這對於簡單案例很有用，但是在伺服器環境中，針對每一個啟動過程重新驗證工作流程可能是不必要的額外負荷。  
  
 如需有關如何停用驗證的詳細資訊，請參閱<xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
 如需範例的參數傳入`CreateWorkflow`，請參閱 <<c2> [ 搭配工作流程參數範例](http://go.microsoft.com/fwlink/?LinkId=157403)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="workflowType" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (Type workflowType, System.Collections.Generic.Dictionary&lt;string,object&gt; namedArgumentValues, Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Type workflowType, class System.Collections.Generic.Dictionary`2&lt;string, object&gt; namedArgumentValues, valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object},System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowType As Type, namedArgumentValues As Dictionary(Of String, Object), instanceId As Guid) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(Type ^ workflowType, System::Collections::Generic::Dictionary&lt;System::String ^, System::Object ^&gt; ^ namedArgumentValues, Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : Type * System.Collections.Generic.Dictionary&lt;string, obj&gt; * Guid -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow (workflowType, namedArgumentValues, instanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowType" Type="System.Type" />
        <Parameter Name="namedArgumentValues" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="workflowType">要建立之工作流程的 <see cref="T:System.Type" />。</param>
        <param name="namedArgumentValues">由字串建立索引鍵之物件的 <see cref="T:System.Collections.Generic.Dictionary`2" />，代表工作流程的引數。</param>
        <param name="instanceId">要建立之特定 <see cref="T:System.Guid" /> 的 <see cref="T:System.Workflow.Runtime.WorkflowInstance" />。</param>
        <summary>使用指定的參數建立工作流程執行個體。</summary>
        <returns>建立的工作流程執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，系統會針對它執行驗證。 如果發生任何驗證錯誤，就會擲回 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 這對於簡單案例很有用，但是在伺服器環境中，針對每一個啟動過程重新驗證工作流程可能是不必要的額外負荷。  
  
 如需有關如何停用驗證的詳細資訊，請參閱<xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
 `instanceId` 載入的任何執行中工作流程的工作流程 <xref:System.Workflow.Runtime.WorkflowRuntime> 必須是唯一的。 如果傳遞 `instanceId` 以建立工作流程，而且某個執行中的工作流程已在使用該 `instanceId`，則會擲回 <xref:System.InvalidOperationException>。  
  
 如需範例的參數傳入`CreateWorkflow`，請參閱 <<c2> [ 搭配工作流程參數範例](http://go.microsoft.com/fwlink/?LinkID=157403)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="workflowType" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (System.Xml.XmlReader workflowDefinitionReader, System.Xml.XmlReader rulesReader, System.Collections.Generic.Dictionary&lt;string,object&gt; namedArgumentValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Xml.XmlReader workflowDefinitionReader, class System.Xml.XmlReader rulesReader, class System.Collections.Generic.Dictionary`2&lt;string, object&gt; namedArgumentValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Xml.XmlReader,System.Xml.XmlReader,System.Collections.Generic.Dictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowDefinitionReader As XmlReader, rulesReader As XmlReader, namedArgumentValues As Dictionary(Of String, Object)) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(System::Xml::XmlReader ^ workflowDefinitionReader, System::Xml::XmlReader ^ rulesReader, System::Collections::Generic::Dictionary&lt;System::String ^, System::Object ^&gt; ^ namedArgumentValues);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : System.Xml.XmlReader * System.Xml.XmlReader * System.Collections.Generic.Dictionary&lt;string, obj&gt; -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow (workflowDefinitionReader, rulesReader, namedArgumentValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowDefinitionReader" Type="System.Xml.XmlReader" />
        <Parameter Name="rulesReader" Type="System.Xml.XmlReader" />
        <Parameter Name="namedArgumentValues" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowDefinitionReader">包含工作流程定義的 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="rulesReader">
          <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="namedArgumentValues">由字串建立索引鍵之物件的 <see cref="T:System.Collections.Generic.Dictionary`2" />，代表工作流程的引數。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 物件和包含在指定之 <see cref="T:System.Collections.Generic.Dictionary`2" /> 中的引數建立工作流程執行個體。</summary>
        <returns>建立的工作流程執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行個體是從 <xref:System.Xml.XmlReader> 參考的工作流程定義和 `namedArgumentValues` 提供的引數來建立。  
  
 建立 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，系統會針對它執行驗證。 如果發生任何驗證錯誤，就會擲回 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 這對於簡單案例很有用，但是在伺服器環境中，針對每一個啟動過程重新驗證工作流程可能是不必要的額外負荷。  
  
 如需有關如何停用驗證的詳細資訊，請參閱<xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
 如需範例的參數傳入`CreateWorkflow`，請參閱 <<c2> [ 搭配工作流程參數範例](http://go.microsoft.com/fwlink/?LinkID=157403)。  
  
 如需使用在 XML 中定義的規則的範例，請參閱 < [IfElse 規則範例](http://go.microsoft.com/fwlink/?LinkId=157404)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="workflowDefinitionReader" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance CreateWorkflow (System.Xml.XmlReader workflowDefinitionReader, System.Xml.XmlReader rulesReader, System.Collections.Generic.Dictionary&lt;string,object&gt; namedArgumentValues, Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance CreateWorkflow(class System.Xml.XmlReader workflowDefinitionReader, class System.Xml.XmlReader rulesReader, class System.Collections.Generic.Dictionary`2&lt;string, object&gt; namedArgumentValues, valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow(System.Xml.XmlReader,System.Xml.XmlReader,System.Collections.Generic.Dictionary{System.String,System.Object},System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWorkflow (workflowDefinitionReader As XmlReader, rulesReader As XmlReader, namedArgumentValues As Dictionary(Of String, Object), instanceId As Guid) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ CreateWorkflow(System::Xml::XmlReader ^ workflowDefinitionReader, System::Xml::XmlReader ^ rulesReader, System::Collections::Generic::Dictionary&lt;System::String ^, System::Object ^&gt; ^ namedArgumentValues, Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.CreateWorkflow : System.Xml.XmlReader * System.Xml.XmlReader * System.Collections.Generic.Dictionary&lt;string, obj&gt; * Guid -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.CreateWorkflow (workflowDefinitionReader, rulesReader, namedArgumentValues, instanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowDefinitionReader" Type="System.Xml.XmlReader" />
        <Parameter Name="rulesReader" Type="System.Xml.XmlReader" />
        <Parameter Name="namedArgumentValues" Type="System.Collections.Generic.Dictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="workflowDefinitionReader">包含工作流程定義的 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="rulesReader">
          <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="namedArgumentValues">由字串建立索引鍵之物件的 <see cref="T:System.Collections.Generic.Dictionary`2" />，代表工作流程的引數。</param>
        <param name="instanceId">要建立之特定 <see cref="T:System.Guid" /> 的 <see cref="T:System.Workflow.Runtime.WorkflowInstance" />。</param>
        <summary>使用指定的參數建立工作流程執行個體。</summary>
        <returns>建立的工作流程執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立 <xref:System.Workflow.Runtime.WorkflowInstance> 之前，系統會針對它執行驗證。 如果發生任何驗證錯誤，就會擲回 <xref:System.Workflow.ComponentModel.Compiler.WorkflowValidationFailedException>。 這對於簡單案例很有用，但是在伺服器環境中，針對每一個啟動過程重新驗證工作流程可能是不必要的額外負荷。  
  
 如需有關如何停用驗證的詳細資訊，請參閱<xref:System.Workflow.Runtime.Configuration.WorkflowRuntimeSection.ValidateOnCreate%2A>。  
  
 `instanceId` 載入的任何執行中工作流程的工作流程 <xref:System.Workflow.Runtime.WorkflowRuntime> 必須是唯一的。 如果傳遞 `instanceId` 以建立工作流程，而且某個執行中的工作流程已在使用該 `instanceId`，則會擲回 <xref:System.InvalidOperationException>。  
  
 如需範例的參數傳入`CreateWorkflow`，請參閱 <<c2> [ 搭配工作流程參數範例](http://go.microsoft.com/fwlink/?LinkID=157403)。  
  
 如需使用在 XML 中定義的規則的範例，請參閱 < [IfElse 規則範例](http://go.microsoft.com/fwlink/?LinkID=157404)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="workflowType" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="workflowRuntime.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 使用的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要正常關閉 <xref:System.Workflow.Runtime.WorkflowRuntime>，您應該在呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 之後呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A>。 這是因為，單獨呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 方法，會使 <xref:System.Workflow.Runtime.WorkflowRuntime> 變成無法使用的狀態。 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 會透過關閉開啟的檔案控制代碼、資料庫連接等方法釋放執行階段使用的資源，但不會卸載工作流程執行個體、停止服務，或執行 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A> 所做的任何其他動作。  
  
 只有當主應用程式必須在記憶體回收行程自動釋放 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 使用的資源之前進行釋放時，才應該呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime>。 如需一般資訊<xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A>，請參閱 <<c2> [ 清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)並[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
   
  
## Examples  
 下列範例示範如何呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 物件上的 <xref:System.Workflow.Runtime.WorkflowRuntime>。 在這個範例中，會從應用程式主要表單的 FormClosing 事件處理常式呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 方法。這樣可確保應用程式關閉時，會適當地清理執行階段建立的物件。 這個範例是來自[語音應用程式範例](http://go.microsoft.com/fwlink/?LinkId=157405)。  
  
 [!code-csharp[WF_Samples#108](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#108)]
 [!code-vb[WF_Samples#108](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllServices">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;object&gt; GetAllServices (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;object&gt; GetAllServices(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetAllServices(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllServices (serviceType As Type) As ReadOnlyCollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Object ^&gt; ^ GetAllServices(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="member this.GetAllServices : Type -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;obj&gt;" Usage="workflowRuntime.GetAllServices serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">服務必須實作才能傳回的 <see cref="T:System.Type" />。</param>
        <summary>擷取已加入工作流程執行階段引擎的所有服務，這些服務實作或衍生自指定的 <see cref="T:System.Type" />。</summary>
        <returns>實作或衍生自指定 <see cref="T:System.Type" /> 的服務。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 空的 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 表示沒有任何實作或衍生自指定之 <xref:System.Type> 的服務加入工作流程執行階段引擎中。  
  
   
  
## Examples  
 下列範例示範如何從 <xref:System.Workflow.Runtime.WorkflowRuntime> 物件擷取指定類型的所有服務。  
  
 [!code-csharp[WF_Samples#19](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#19)]
 [!code-vb[WF_Samples#19](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serviceType" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAllServices&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; GetAllServices&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; GetAllServices&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetAllServices``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllServices(Of T) () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ GetAllServices();" />
      <MemberSignature Language="F#" Value="member this.GetAllServices : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="workflowRuntime.GetAllServices " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">服務類型。</typeparam>
        <summary>擷取已加入工作流程執行階段引擎的所有服務，這些服務實作或衍生自指定的泛型型別。</summary>
        <returns>實作或衍生自指定泛型型別的服務。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 空的 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 表示沒有任何實作或衍生自指定之泛型型別的服務加入工作流程執行階段引擎中。  
  
   
  
## Examples  
 下列範例示範如何從 <xref:System.Workflow.Runtime.WorkflowRuntime> 物件擷取指定類型的所有服務。  
  
 [!code-csharp[WF_Samples#6](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#6)]
 [!code-vb[WF_Samples#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedWorkflows">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowInstance&gt; GetLoadedWorkflows ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowInstance&gt; GetLoadedWorkflows() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetLoadedWorkflows" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedWorkflows () As ReadOnlyCollection(Of WorkflowInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowInstance ^&gt; ^ GetLoadedWorkflows();" />
      <MemberSignature Language="F#" Value="member this.GetLoadedWorkflows : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowInstance&gt;" Usage="workflowRuntime.GetLoadedWorkflows " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowInstance&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得集合，其中包含目前載入記憶體內的所有工作流程執行個體。</summary>
        <returns>目前載入記憶體中之每個工作流程執行個體的 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，與 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> 不同的是，如果執行階段未啟動，這個方法不會擲回 <xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下列範例示範如何從 <xref:System.Workflow.Runtime.WorkflowRuntime> 物件擷取已載入之工作流程的集合。  
  
 [!code-csharp[WF_Samples#18](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#18)]
 [!code-vb[WF_Samples#18](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="workflowRuntime.GetService serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">要擷取之服務的 <see cref="T:System.Type" />。</param>
        <summary>從工作流程執行階段引擎中擷取屬於指定 <see cref="T:System.Type" /> 的服務。</summary>
        <returns>屬於指定 <see cref="T:System.Type" /> 的服務。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果存在一個以上屬於指定之 <xref:System.Workflow.Runtime.WorkflowRuntime.GetService%2A> 的服務，<xref:System.InvalidOperationException> 會擲回 <xref:System.Type>。 因此，如果 <xref:System.Workflow.Runtime.WorkflowRuntime.GetAllServices%2A> 有多個屬於指定型別的服務，您應該使用其中一個 <xref:System.Workflow.Runtime.WorkflowRuntime> 的多載方法。 例如，工作流程執行階段引擎可能有多個追蹤服務。 如果利用指定 <xref:System.Workflow.Runtime.Tracking.TrackingService> 基底類別的方式要求追蹤服務，可能會擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serviceType" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.ObjectDisposedException">已經處置 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
        <exception cref="T:System.InvalidOperationException">找到一個以上的 <paramref name="serviceType" /> 類型的服務。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetService&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetService&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetService&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetService``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T GetService();" />
      <MemberSignature Language="F#" Value="member this.GetService : unit -&gt; 'T" Usage="workflowRuntime.GetService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">服務類型。</typeparam>
        <summary>從工作流程執行階段引擎中擷取指定之泛型型別的服務。</summary>
        <returns>屬於指定泛型型別的單一服務。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果存在一個以上屬於指定之泛型型別的服務，<xref:System.Workflow.Runtime.WorkflowRuntime.GetService%2A> 會擲回 <xref:System.InvalidOperationException>。 因此，如果 <xref:System.Workflow.Runtime.WorkflowRuntime.GetAllServices%2A> 中有多個屬於泛型型別的服務，您應該使用其中一個 <xref:System.Workflow.Runtime.WorkflowRuntime> 的多載方法。 例如，工作流程執行階段引擎可能有多個追蹤服務。 如果利用指定 <xref:System.Workflow.Runtime.Tracking.TrackingService> 基底類別的方式要求追蹤服務，可能會擲回例外狀況。  
  
   
  
## Examples  
 下列範例示範如何從 <xref:System.Workflow.Runtime.WorkflowRuntime> 物件擷取單一服務 (在這個案例中是 <xref:System.Workflow.Runtime.Hosting.ManualWorkflowSchedulerService> 類型的服務)。 這個範例取自[工作流程執行緒範例](http://go.microsoft.com/fwlink/?LinkId=157350)。  
  
 [!code-csharp[WF_Samples#28](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#28)]
 [!code-vb[WF_Samples#28](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已經過處置。</exception>
        <exception cref="T:System.InvalidOperationException">找到一個以上泛型型別的服務。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflow">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowInstance GetWorkflow (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.Runtime.WorkflowInstance GetWorkflow(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflow (instanceId As Guid) As WorkflowInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::Runtime::WorkflowInstance ^ GetWorkflow(Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.GetWorkflow : Guid -&gt; System.Workflow.Runtime.WorkflowInstance" Usage="workflowRuntime.GetWorkflow instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">工作流程執行個體的 <see cref="T:System.Guid" />。</param>
        <summary>擷取有指定之 <see cref="T:System.Guid" /> 的工作流程執行個體。</summary>
        <returns>有指定之 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 的 <see cref="T:System.Guid" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `instanceId` 指定目前不在記憶體中的工作流程執行個體，工作流程執行個體會載入記憶體中並排程執行。 例如，在中止工作流程執行個體後，您可以呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A>，將工作流程執行個體載回記憶體中。 在此情況中，持續性服務會將工作流程執行個體的上次保存狀態載入記憶體中。  
  
   
  
## Examples  
 下列程式碼範例會示範呼叫 `ReloadWorkflow` 方法的 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> 方法。 `ReloadWorkflow` 方法屬於一個較大的類別，該類別的 `Runtime` 屬性可以存取 <xref:System.Workflow.Runtime.WorkflowRuntime> 類別的所有方法、屬性和事件。  
  
 此程式碼範例是一部分[自訂持續性服務範例](http://go.microsoft.com/fwlink/?LinkId=157351)範例。  
  
> [!NOTE]
>  在範例中，呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> 是多餘的，因為 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> 和 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> 方法使用相同的內部 Helper 方法將工作流程執行個體載入記憶體中。  
  
 [!code-csharp[WF_Samples#265](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#265)]
 [!code-vb[WF_Samples#265](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#265)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未啟動工作流程執行階段。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStarted">
      <MemberSignature Language="C#" Value="public bool IsStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStarted" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowRuntime.IsStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStarted : bool" Usage="System.Workflow.Runtime.WorkflowRuntime.IsStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得指出工作流程執行階段引擎是否已啟動的值。</summary>
        <value>如果工作流程執行階段引擎已啟動則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 表示工作流程執行階段引擎服務正在執行中。 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 已`false`直到主機呼叫<xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>。 在主機呼叫 `true` 之前，它都會保持為 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A>。  
  
> [!NOTE]
>  工作流程執行階段引擎正在執行時，無法將核心服務加入到引擎中。 核心服務是衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 類別、<xref:System.Workflow.Runtime.Hosting.DefaultWorkflowCommitWorkBatchService> 類別、<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 類別和 <xref:System.Workflow.Runtime.Tracking.TrackingService> 類別的服務。  
  
   
  
## Examples  
 下列範例示範如何存取 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 物件的 <xref:System.Workflow.Runtime.WorkflowRuntime> 屬性。 在這個範例中，如果執行階段已啟動，則訊息會列印到主控台中。  
  
 [!code-csharp[WF_Samples#21](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#21)]
 [!code-vb[WF_Samples#21](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowRuntime.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Workflow.Runtime.WorkflowRuntime.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 關聯的名稱。</summary>
        <value>與此 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 關聯的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法設定<xref:System.Workflow.Runtime.WorkflowRuntime.Name%2A>工作流程執行階段引擎正在執行 (<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A>是`true`)。  
  
   
  
## Examples  
 下列範例示範如何存取 <xref:System.Workflow.Runtime.WorkflowRuntime.Name%2A> 物件的 <xref:System.Workflow.Runtime.WorkflowRuntime> 屬性。 在此範例中，執行階段的名稱設定為 "Main Runtime"。  
  
 [!code-csharp[WF_Samples#20](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#20)]
 [!code-vb[WF_Samples#20](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">嘗試在已處置 (Dispose) 的 <see cref="P:System.Workflow.Runtime.WorkflowRuntime.Name" /> 上設定 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
        <exception cref="T:System.InvalidOperationException">在工作流程執行階段引擎執行時，嘗試設定 <see cref="P:System.Workflow.Runtime.WorkflowRuntime.Name" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveService">
      <MemberSignature Language="C#" Value="public void RemoveService (object service);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveService(object service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.RemoveService(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveService (service As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveService(System::Object ^ service);" />
      <MemberSignature Language="F#" Value="member this.RemoveService : obj -&gt; unit" Usage="workflowRuntime.RemoveService service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="service">物件，表示要移除的服務。</param>
        <summary>從工作流程執行階段引擎中移除指定的服務。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行階段引擎執行時，不能移除核心服務 (<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A>是`true`)。 核心服務是衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 類別、<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 類別、<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 類別和 <xref:System.Workflow.Runtime.Tracking.TrackingService> 類別的服務。  如果 `service` 衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 類別，<xref:System.Workflow.Runtime.WorkflowRuntime.RemoveService%2A> 會呼叫由 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Stop%2A> 實作的 `service` 方法。  
  
   
  
## Examples  
 在下列範例中，將在 <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> 中加入並移除 <xref:System.Workflow.Runtime.WorkflowRuntime>。  
  
 [!code-csharp[WF_Samples#16](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#16)]
 [!code-vb[WF_Samples#16](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="service" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.ObjectDisposedException">已經處置 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎已啟動 (<see cref="P:System.Workflow.Runtime.WorkflowRuntime.IsStarted" /> 為<see langword="true" /> )，而且 <paramref name="service" /> 是核心服務。  
  
\-或- 
 <paramref name="service" /> 尚未向工作流程執行階段引擎註冊。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServicesExceptionNotHandled">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt; ServicesExceptionNotHandled;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt; ServicesExceptionNotHandled" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.ServicesExceptionNotHandled" />
      <MemberSignature Language="VB.NET" Value="Public Event ServicesExceptionNotHandled As EventHandler(Of ServicesExceptionNotHandledEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::ServicesExceptionNotHandledEventArgs ^&gt; ^ ServicesExceptionNotHandled;" />
      <MemberSignature Language="F#" Value="member this.ServicesExceptionNotHandled : EventHandler&lt;System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt; " Usage="member this.ServicesExceptionNotHandled : System.EventHandler&lt;System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.ServicesExceptionNotHandledEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生自 <see cref="T:System.Workflow.Runtime.Hosting.WorkflowRuntimeService" /> 類別的服務呼叫 <see cref="M:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.RaiseServicesExceptionNotHandledEvent(System.Exception,System.Guid)" /> 時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 類別的服務可以呼叫 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.RaiseServicesExceptionNotHandledEvent%2A> 方法，以便通知 <xref:System.Workflow.Runtime.WorkflowRuntime.ServicesExceptionNotHandled> 事件的訂閱者，在服務的執行期間發生了無法處理的例外狀況。 您可以訂閱此事件以實作復原機制。  
  
 在工作流程執行階段引擎尚未建立工作流程執行個體且發生例外狀況時，會引發此事件。 在此案例中，通知主應用程式發生例外狀況的唯一方法就是引發此事件。 然而，工作流程執行階段引擎不會直接加以呼叫。 相反的，工作流程執行階段引擎會傳遞例外狀況到工作流程執行個體，如果沒有執行個體則擲回給呼叫者，在這種情況中，呼叫者實際上是引發此事件的服務。 如果建立自己的持續性服務或排程器服務，您必須透過基底 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.RaiseServicesExceptionNotHandledEvent%2A> 方法。  
  
 若為 <xref:System.Workflow.Runtime.WorkflowRuntime.ServicesExceptionNotHandled> 事件，寄件者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則會包含使用服務的工作流程執行個體 <xref:System.Guid> 和無法處理的 <xref:System.Exception>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.ServicesExceptionNotHandled> 與事件處理常式 (名稱為 `OnExceptionNotHandled` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[自訂持續性服務範例](http://go.microsoft.com/fwlink/?LinkID=157351)。  
  
 [!code-csharp[WF_Samples#271](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#271)]
 [!code-vb[WF_Samples#271](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#271)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Started">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; Started;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; Started" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.Started" />
      <MemberSignature Language="VB.NET" Value="Public Event Started As EventHandler(Of WorkflowRuntimeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowRuntimeEventArgs ^&gt; ^ Started;" />
      <MemberSignature Language="F#" Value="member this.Started : EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; " Usage="member this.Started : System.EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在工作流程執行階段引擎啟動時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>方法會引發<xref:System.Workflow.Runtime.WorkflowRuntime.Started>叫用事件驗證的工作流程執行階段引擎的核心服務組態之後<xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Start%2A>衍生自其服務的每個實作的方法<xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService>類別而且已設定<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A>至`true`。 工作流程執行階段引擎啟動衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 類別的服務時，無法保證其順序。而且這些工作流程執行階段引擎服務的其中一些服務，可能需要依賴其中的其他服務所提供的功能，來完成各自的啟動工作。 工作流程執行階段引擎服務可以覆寫 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.OnStarted%2A?displayProperty=nameWithType> 方法，以便在 <xref:System.Workflow.Runtime.WorkflowRuntime.Started> 事件引發時，執行需要其他工作流程執行階段引擎服務支援的任何最後啟動工作。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 在下列範例中，會將事件處理常式加入至 <xref:System.Workflow.Runtime.WorkflowRuntime.Started> 的 <xref:System.Workflow.Runtime.WorkflowRuntime> 事件中。 在這個範例中，處理常式是列印簡易訊息至主控台的匿名方法。  
  
 [!code-csharp[WF_Samples#15](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#15)]
 [!code-vb[WF_Samples#15](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartRuntime">
      <MemberSignature Language="C#" Value="public void StartRuntime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartRuntime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.StartRuntime" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartRuntime ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartRuntime();" />
      <MemberSignature Language="F#" Value="member this.StartRuntime : unit -&gt; unit" Usage="workflowRuntime.StartRuntime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟動工作流程執行階段引擎和工作流程執行階段引擎服務。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會確認有一組有效的核心服務存在，然後啟動任何衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 類別的服務。  必須是其中之一的每個下列的核心服務： 工作流程`CommitWorkBatch`服務衍生自<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService>基底類別和排程器服務衍生自<xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService>基底類別。  如果遺漏一個或兩個這些核心服務，工作流程執行階段引擎會提供適當的預設服務：<xref:System.Workflow.Runtime.Hosting.DefaultWorkflowCommitWorkBatchService>工作流程`CommitWorkBatch`服務和<xref:System.Workflow.Runtime.Hosting.DefaultWorkflowSchedulerService>排程器服務。 持續性服務是選用的服務，而且最多只能有一個持續性服務。 驗證服務組態後，<xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 會呼叫所有衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Start%2A> 類別之服務上的 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService>。  最後，工作流程執行階段引擎會設定 <xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A> 並引發 <xref:System.Workflow.Runtime.WorkflowRuntime.Started> 事件。  
  
 工作流程執行階段引擎啟動後，無法加入或移除核心服務。 核心服務是衍生自 <xref:System.Workflow.Runtime.Hosting.WorkflowSchedulerService> 類別、<xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> 類別、<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> 類別和 <xref:System.Workflow.Runtime.Tracking.TrackingService> 類別的服務。  如果您在工作流程執行階段引擎執行時呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>，則不會執行任何動作。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 程式碼在 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A> 建立 <xref:System.Workflow.Runtime.WorkflowRuntime.%23ctor%2A> 執行個體，並且在它呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime> 以加入服務到執行階段中後呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A>。 它也會在發生任何其他處理之前呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.StartRuntime%2A>。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkId=157346)範例。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 已處置。</exception>
        <exception cref="T:System.InvalidOperationException">有一個以上的服務工作流程 <see langword="CommitWorkBatch" /> 服務已向此 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 註冊。  
  
-或- 
有一個以上的排程器服務已向此 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 註冊。  
  
-或- 
有一個以上的持續性服務已向此 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> 註冊。</exception>
      </Docs>
    </Member>
    <Member MemberName="Stopped">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; Stopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; Stopped" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.Stopped" />
      <MemberSignature Language="VB.NET" Value="Public Event Stopped As EventHandler(Of WorkflowRuntimeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowRuntimeEventArgs ^&gt; ^ Stopped;" />
      <MemberSignature Language="F#" Value="member this.Stopped : EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; " Usage="member this.Stopped : System.EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowRuntimeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在工作流程執行階段引擎停止時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A> 方法會在叫用以其衍生自 <xref:System.Workflow.Runtime.WorkflowRuntime.Stopped> 類別的每個服務實作的 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.Stop%2A> 方法後，引發 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService> 事件。  這些工作流程執行階段引擎服務的停止順序不一定，而且這些服務的其中一些服務可能需要保留一些其他服務所依賴的功能，直到其他服務停止為止。 這類服務可以覆寫 <xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService.OnStopped%2A?displayProperty=nameWithType> 方法，以在引發 <xref:System.Workflow.Runtime.WorkflowRuntime.Stopped> 事件時執行任何剩餘的關閉邏輯。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 在下列範例中，會將事件處理常式加入至 <xref:System.Workflow.Runtime.WorkflowRuntime.Stopped> 的 <xref:System.Workflow.Runtime.WorkflowRuntime> 事件中。 在這個範例中，處理常式是列印簡易訊息至主控台的匿名方法。  
  
 [!code-csharp[WF_Samples#14](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#14)]
 [!code-vb[WF_Samples#14](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopRuntime">
      <MemberSignature Language="C#" Value="public void StopRuntime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopRuntime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowRuntime.StopRuntime" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopRuntime ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopRuntime();" />
      <MemberSignature Language="F#" Value="member this.StopRuntime : unit -&gt; unit" Usage="workflowRuntime.StopRuntime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止工作流程執行階段引擎和執行階段服務。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會導致工作流程執行階段引擎卸載其工作流程執行個體的每個、 停止其所有的服務是衍生自<xref:System.Workflow.Runtime.Hosting.WorkflowRuntimeService>類別中，將<xref:System.Workflow.Runtime.WorkflowRuntime.IsStarted%2A>要`false`，並引發<xref:System.Workflow.Runtime.WorkflowRuntime.Stopped>事件。  
  
 若要正常關閉 <xref:System.Workflow.Runtime.WorkflowRuntime>，請先呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A>，再呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A>。  
  
 如需詳細資訊，請參閱 <xref:System.Workflow.Runtime.WorkflowRuntime.Dispose%2A> 方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 在主機完成所有與執行階段相關聯的其他處理後，會呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.StopRuntime%2A>。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkId=157346)範例。  
  
 [!code-csharp[WF_Samples#259](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#259)]
 [!code-vb[WF_Samples#259](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#259)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已經處置 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowAborted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowAborted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowAborted" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowAborted As EventHandler(Of WorkflowEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowAborted;" />
      <MemberSignature Language="F#" Value="member this.WorkflowAborted : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowAborted : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在中止工作流程執行個體時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted> 會發生在工作流程執行個體的所有暫止工作都已清除之後，但在工作流程執行個體於記憶體中失效之前。 您可以透過呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A?displayProperty=nameWithType> 來中止工作流程執行個體。  
  
 對於這個事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則包含事件關聯的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkId=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted> 與事件處理常式 (名稱為 `OnWorkflowAborted` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkID=157346)範例。  
  
 [!code-csharp[WF_Samples#141](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#141)]
 [!code-vb[WF_Samples#141](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#141)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowCompletedEventArgs&gt; WorkflowCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowCompletedEventArgs&gt; WorkflowCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowCompleted As EventHandler(Of WorkflowCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowCompletedEventArgs ^&gt; ^ WorkflowCompleted;" />
      <MemberSignature Language="F#" Value="member this.WorkflowCompleted : EventHandler&lt;System.Workflow.Runtime.WorkflowCompletedEventArgs&gt; " Usage="member this.WorkflowCompleted : System.EventHandler&lt;System.Workflow.Runtime.WorkflowCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在完成工作流程執行個體時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> 會在工作流程執行個體完成後，但在執行個體失效之前引發。  
  
 針對 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowCompletedEventArgs> 則包含 <xref:System.Workflow.Runtime.WorkflowInstance> 及其輸出參數。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkId=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> 與事件處理常式 (名稱為 `OnWorkflowCompleted` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkId=157346)範例。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowCreated" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowCreated" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowCreated As EventHandler(Of WorkflowEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowCreated;" />
      <MemberSignature Language="F#" Value="member this.WorkflowCreated : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowCreated : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在建立工作流程執行個體時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行階段引擎會在工作流程執行個體完成建構後，但在處理活動之前引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCreated> 事件。 對於這個事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則包含事件關聯的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkId=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCreated> 與事件處理常式 (名稱為 `OnWorkflowCreated` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[自訂持續性服務範例](http://go.microsoft.com/fwlink/?LinkID=15735)。  
  
 [!code-csharp[WF_Samples#271](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#271)]
 [!code-vb[WF_Samples#271](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#271)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowIdled">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowIdled;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowIdled" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowIdled As EventHandler(Of WorkflowEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowIdled;" />
      <MemberSignature Language="F#" Value="member this.WorkflowIdled : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowIdled : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在工作流程執行個體進入閒置 (Idle) 狀態時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行階段引擎會在工作流程執行個體進入閒置狀態時引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 事件。例如，在工作流程等待 <xref:System.Workflow.Activities.DelayActivity> 活動完成時。  
  
 對於這個事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則包含事件關聯的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](https://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67(v=vs.100))。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 與事件處理常式 (名稱為 `OnWorkflowIdled` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkID=157346)範例。  
  
 [!code-csharp[WF_Samples#258](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#258)]
 [!code-vb[WF_Samples#258](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#258)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowLoaded">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowLoaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowLoaded" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowLoaded As EventHandler(Of WorkflowEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowLoaded;" />
      <MemberSignature Language="F#" Value="member this.WorkflowLoaded : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowLoaded : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在工作流程執行個體載入記憶體中時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> 會發生在持續性服務已還原工作流程執行個體之後，但在工作流程執行階段引擎開始執行任何活動之前。  
  
 對於 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> 事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則包含事件關聯的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> 與事件處理常式 (名稱為 `OnWorkflowLoad` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[自訂持續性服務](http://go.microsoft.com/fwlink/?LinkID=157351)範例。  
  
 [!code-csharp[WF_Samples#271](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#271)]
 [!code-vb[WF_Samples#271](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#271)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowPersisted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowPersisted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowPersisted" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowPersisted As EventHandler(Of WorkflowEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowPersisted;" />
      <MemberSignature Language="F#" Value="member this.WorkflowPersisted : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowPersisted : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在工作流程執行個體的狀態被保存時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行個體可能基於多個原因而保存。 例如，主機可能呼叫工作流程執行個體上的 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A?displayProperty=nameWithType>。或者已完成不可部分完成的範圍，或執行個體已成為閒置狀態時，工作流程執行階段引擎可能會保存工作流程執行個體。 如果 <xref:System.Workflow.Runtime.WorkflowRuntime> 中有持續性服務，則在工作流程執行個體的狀態儲存到記憶體之後，執行階段會引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted>。 如果沒有持續性服務存在，仍然會引發事件，但不會儲存執行個體狀態。 如果因為正在卸載工作流程執行個體而發生 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件，接著會發生 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件。  
  
 對於 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則包含事件關聯的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 與事件處理常式 (名稱為 `OnWorkflowPersisted` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[自訂持續性服務範例](http://go.microsoft.com/fwlink/?LinkID=15735)。  
  
 [!code-csharp[WF_Samples#279](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#279)]
 [!code-vb[WF_Samples#279](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#279)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowResumed">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowResumed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowResumed" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowResumed As EventHandler(Of WorkflowEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowResumed;" />
      <MemberSignature Language="F#" Value="member this.WorkflowResumed : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowResumed : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在暫止後繼續執行工作流程執行個體時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行階段引擎會在正要排程工作流程執行個體之前引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件。 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件常因明確呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType> 而引發。 然而，工作流程執行階段引擎可能暫時停止執行個體，以便執行作業，例如套用工作流程變更。 若是如此，在作業完成後，作業階段繼續執行工作流程執行個體時，就會引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件。  
  
 對於 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則包含事件關聯的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 與事件處理常式 (名稱為 `OnWorkflowResume` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[暫止與終止範例](http://go.microsoft.com/fwlink/?LinkId=157402)。  
  
 [!code-csharp[WF_Samples#171](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#171)]
 [!code-vb[WF_Samples#171](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#171)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowStarted" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowStarted As EventHandler(Of WorkflowEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowStarted;" />
      <MemberSignature Language="F#" Value="member this.WorkflowStarted : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowStarted : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在啟動工作流程執行個體時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由排程執行的根活動啟動工作流程執行個體後，工作流程執行階段引擎會引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowStarted> 事件。 對於這個事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則包含事件關聯的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowStarted> 與事件處理常式 (名稱為 `OnWorkflowStarted` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[主機通訊範例](http://go.microsoft.com/fwlink/?LinkId=157406)。  
  
 [!code-csharp[WF_Samples#297](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets38.cs#297)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowSuspended">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt; WorkflowSuspended;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt; WorkflowSuspended" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowSuspended As EventHandler(Of WorkflowSuspendedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowSuspendedEventArgs ^&gt; ^ WorkflowSuspended;" />
      <MemberSignature Language="F#" Value="member this.WorkflowSuspended : EventHandler&lt;System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt; " Usage="member this.WorkflowSuspended : System.EventHandler&lt;System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowSuspendedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在暫止工作流程執行個體時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行個體可以由主機呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> 方法、藉由 <xref:System.Workflow.ComponentModel.SuspendActivity> 活動，或由工作流程執行階段引擎隱含地暫止。 例如，當工作流程執行階段引擎要套用動態變更至執行個體時，它會暫時停止執行個體。  
  
 若為 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> 事件，寄件人會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而且 <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs> 會包含 <xref:System.Workflow.Runtime.WorkflowInstance> 與說明暫止執行個體之原因的字串。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> 與事件處理常式 (名稱為 `OnWorkflowSuspended` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[暫止與終止範例](http://go.microsoft.com/fwlink/?LinkID=157402)。  
  
 [!code-csharp[WF_Samples#170](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#170)]
 [!code-vb[WF_Samples#170](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#170)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowTerminated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt; WorkflowTerminated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt; WorkflowTerminated" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowTerminated As EventHandler(Of WorkflowTerminatedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowTerminatedEventArgs ^&gt; ^ WorkflowTerminated;" />
      <MemberSignature Language="F#" Value="member this.WorkflowTerminated : EventHandler&lt;System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt; " Usage="member this.WorkflowTerminated : System.EventHandler&lt;System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowTerminatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在結束工作流程執行個體時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 發生未處理的例外狀況時，工作流程可以由主機呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> 方法、藉由 <xref:System.Workflow.ComponentModel.TerminateActivity> 活動，或由工作流程執行階段引擎加以結束。 工作流程執行階段會在工作流程執行個體結束後，但是在它於記憶體中失效之前引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> 事件。  
  
 若為 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件，寄件者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而且 <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs> 會包含 <xref:System.Workflow.Runtime.WorkflowInstance> 和 <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs.Exception%2A?displayProperty=nameWithType> 屬性中執行個體結束原因的相關資訊。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> 與事件處理常式 (名稱為 `OnWorkflowCompleted` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[取消工作流程](http://go.microsoft.com/fwlink/?LinkID=157346)範例。  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkflowUnloaded">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowUnloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.Runtime.WorkflowEventArgs&gt; WorkflowUnloaded" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded" />
      <MemberSignature Language="VB.NET" Value="Public Event WorkflowUnloaded As EventHandler(Of WorkflowEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::Runtime::WorkflowEventArgs ^&gt; ^ WorkflowUnloaded;" />
      <MemberSignature Language="F#" Value="member this.WorkflowUnloaded : EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " Usage="member this.WorkflowUnloaded : System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.Runtime.WorkflowEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在工作流程執行個體從記憶體中卸載時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 透過明確呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 或工作流程執行階段引擎根據本身語意的隱含呼叫，可從記憶體中卸載工作流程執行個體。 例如，工作流程執行階段引擎卸載工作流程執行個體時如果執行個體變成閒置，而且此執行階段具有<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService>新增為其<xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnloadOnIdle%2A>是`true`。  
  
 在成功保存工作流程執行個體的狀態後，但在執行個體於記憶體中失效之前，工作流程執行階段引擎會引發   
  
 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件。 因此，<xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowPersisted> 事件會發生在 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件之前。  
  
 對於 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件，傳送者會包含 <xref:System.Workflow.Runtime.WorkflowRuntime>，而 <xref:System.Workflow.Runtime.WorkflowEventArgs> 則包含事件關聯的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 耗用事件](http://go.microsoft.com/fwlink/?LinkID=157352)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從工作流程主機使用 <xref:System.Workflow.Runtime.WorkflowRuntime> 功能。 此程式碼會使 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 與事件處理常式 (名稱為 `OnWorkflowUnload` 的方法) 產生關聯。  
  
 此程式碼範例是一部分[自訂持續性服務範例](http://go.microsoft.com/fwlink/?LinkID=157351)。  
  
 [!code-csharp[WF_Samples#271](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#271)]
 [!code-vb[WF_Samples#271](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#271)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>