<Type Name="WorkflowInstance" FullName="System.Workflow.Runtime.WorkflowInstance">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="181673212b57e524c54cc9851648ca01d7c1e21c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30720902" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表工作流程執行個體。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 <xref:System.Workflow.Runtime.WorkflowInstance> 類別會公開可用於控制工作流程執行個體之執行的方法和屬性，它基本上是工作流程執行階段引擎使用的實際工作流程執行個體的 Proxy。 主機或服務可以呼叫包含在 <xref:System.Workflow.Runtime.WorkflowInstance> 類別中的適當方法，來指示工作流程執行階段引擎在工作流程執行個體上執行動作。  如果要求的動作無效，例如，如果主機呼叫已完成的工作流程執行個體上的 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A>，則工作流程執行階段引擎會引發適當的例外狀況。  
  
> [!NOTE]
>  如果工作流程執行個體因為主應用程式 (Host Application) 上的呼叫沒有傳回而變得沒有回應，復原執行個體的唯一方法就是重新啟動執行階段。 不過，如果已強制卸載、中止或暫停執行個體，則透過呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType> 方法可以繼續該執行個體。  
  
   
  
## Examples  
 下列程式碼範例將示範如何在工作流程主機中建立和啟動 <xref:System.Workflow.Runtime.WorkflowInstance>。 下列程式碼會建立 <xref:System.Workflow.Runtime.WorkflowRuntime> 的執行個體、加入服務至執行階段，然後示範建立 <xref:System.Workflow.Runtime.WorkflowInstance> 物件的建議方式。 程式碼藉由呼叫 <xref:System.Workflow.Runtime.WorkflowInstance> 方法和傳遞之前建立的類型給它來初始化 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A>。 <xref:System.Workflow.Runtime.WorkflowInstance> 由 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> 方法呼叫啟動。  
  
 這個程式碼範例是 Program.cs 檔案中＜取消工作流程 SDK＞範例的一部分。 如需詳細資訊，請參閱[取消工作流程](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb)。  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中止工作流程執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行個體是以同步方式中止，也就是這個方法會在中止工作流程執行個體後返回。 工作流程執行階段引擎會使記憶體中的工作流程執行個體失效，並且清除 <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>。 如果您的工作流程執行個體使用持續性 (Persistence) 服務，自上次保存點開始執行的所有工作都會被丟棄。 中止工作流程執行個體後，工作流程執行階段引擎會引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted> 事件。 您可以呼叫 <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> 以重新載入工作流程執行個體，然後從它的上一個保存點啟動。  
  
 `Abort` 與 <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> 不同，因為 `Abort` 僅清除記憶體內的工作流程執行個體，而且可以從上次保存點重新啟動，終止 (Terminate) 會清除記憶體內的工作流程執行個體，並通知持續性服務該執行個體已自記憶體中清除。 對 <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> 而言，這表示發生終止時，所有該工作流程執行個體的狀態資訊都會從資料庫中刪除。 您將無法從之前儲存的保存點重新載入工作流程執行個體。  
  
   
  
## Examples  
 下列程式碼範例將示範呼叫 Workflow1 類型之工作流程執行個體上的 Abort。  
  
 [!code-csharp[WF_Samples#13](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#13)]
 [!code-vb[WF_Samples#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyWorkflowChanges">
      <MemberSignature Language="C#" Value="public void ApplyWorkflowChanges (System.Workflow.ComponentModel.WorkflowChanges workflowChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyWorkflowChanges(class System.Workflow.ComponentModel.WorkflowChanges workflowChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ApplyWorkflowChanges(System.Workflow.ComponentModel.WorkflowChanges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyWorkflowChanges(System::Workflow::ComponentModel::WorkflowChanges ^ workflowChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowChanges" Type="System.Workflow.ComponentModel.WorkflowChanges" />
      </Parameters>
      <Docs>
        <param name="workflowChanges">指定工作流程執行個體之動態更新的 <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" />。</param>
        <summary>將變更套用到 <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> 物件指定的工作流程執行個體中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果工作流程執行個體尚未暫止，在套用變更之前，工作流程執行階段引擎會暫時停止執行個體。  
  
   
  
## Examples  
 下列範例將示範如何呼叫 <xref:System.Workflow.Runtime.WorkflowInstance> 物件的 ApplyWorkflowChanges。  這個範例是 Mainform.cs 的檔案中＜訂購狀態機器 SDK＞範例的一部分。  如需詳細資訊，請參閱[訂購狀態機器範例](http://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c)。  
  
 [!code-csharp[WF_Samples#89](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#89)]
 [!code-vb[WF_Samples#89](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItem">
      <MemberSignature Language="C#" Value="public void EnqueueItem (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItem(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItem(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItem (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItem(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">
          <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 的名稱。</param>
        <param name="item">要加入佇列的物件。</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" />，可讓寄件者在傳遞 <c>item</c> 時收到通知。</param>
        <param name="workItem">要傳遞給 <see cref="T:System.Workflow.Runtime.IPendingWork" /> 方法的物件。</param>
        <summary>同步公佈訊息至指定的工作流程佇列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將 `item` 傳送至指定的 <xref:System.Workflow.Runtime.WorkflowQueue>。 如果想要在傳遞訊息時得到通知，您可以在您的服務中實作 <xref:System.Workflow.Runtime.IPendingWork>，並且傳遞 `workItem` 和 <xref:System.Workflow.Runtime.IPendingWork> 物件至 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>。 如果不想要這類通知，您可以傳遞 `Nothing` 和 `pendingWork` 的 null 參考 (在 Visual Basic 中為 `workItem`)。  
  
 使用此方法搭配狀態機器工作流程時，您可能會取得帶有「未啟用佇列 '{0}'」訊息的例外狀況。 這種情況發生在狀態機器的目前狀態不知道如何處理特定事件時。 例如，當目前狀態以外的某種狀態包含 <xref:System.Workflow.Activities.EventDrivenActivity>，而且其中包含由佇列 '{0}' 所代表的 <xref:System.Workflow.Activities.HandleExternalEventActivity> 時。  
  
> [!NOTE]
>  工作流程執行個體接收訊息的順序，不一定會與訊息的傳送順序相同。 例如，如果在現有佇列 (佇列 A) 中接收訊息導致工作流程建立另一個佇列 (佇列 B)，後者接著接聽在第一個訊息後傳送的另一個訊息，第二個訊息可能會先到達，而且因為它的佇列尚未建立而無法被接收。 若要避免這個問題，應該先確認 (使用 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>) 第二個佇列存在後，再傳送第二個訊息。  
  
   
  
## Examples  
 下列程式碼範例將示範如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>。 當 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 事件發生時，會呼叫此範例中定義的 `OnWorkflowIdled` 方法。 它會使用 <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> 屬性判斷閒置的工作流程，然後呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> 方法取得工作流程執行個體之佇列項目的集合。 此程式碼會在集合上反覆查看，以判斷是哪個活動正在等候閒置工作流程的事件。 然後，它會使用 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> 方法以及事件佇列項目的名稱，將例外狀況傳送到工作流程佇列中。  
  
 這個程式碼範例是 Program.cs 檔案中＜取消工作流程 SDK＞範例的一部分。 如需詳細資訊，請參閱[取消工作流程](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb)。  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。  
  
 -或-  
  
 由 <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 指定的 <paramref name="queueName" /> 並不存在。  
  
 -或-  
  
 <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 指定的 <paramref name="queueName" /> 未啟用。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItemOnIdle">
      <MemberSignature Language="C#" Value="public void EnqueueItemOnIdle (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItemOnIdle(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItemOnIdle (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItemOnIdle(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">
          <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 的名稱。</param>
        <param name="item">要加入佇列的物件。</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" />，可讓寄件者在傳遞 <c>item</c> 時收到通知。</param>
        <param name="workItem">要傳遞給 <see cref="T:System.Workflow.Runtime.IPendingWork" /> 方法的物件。</param>
        <summary>工作流程閒置時，將訊息張貼至指定的工作流程佇列。 <see cref="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" /> 會等到工作流程到達閒置點，並在確認工作流程排程器閒置後 (也就是沒有任何正在執行的作用中操作時) 加入佇列中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 等待工作流程執行個體變成閒置，然後將 `item` 傳送到指定的 <xref:System.Workflow.Runtime.WorkflowQueue>。 如果您在工作流程執行個體暫止時呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle%2A>，工作流程執行階段引擎將擲回 <xref:System.InvalidOperationException>。 如果想要在傳遞訊息時得到通知，您可以在您的服務中實作 <xref:System.Workflow.Runtime.IPendingWork>，並且傳遞 `workItem` 和 <xref:System.Workflow.Runtime.IPendingWork> 物件至 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>。 如果不想要這類通知，您可以傳遞 `Nothing` 和 `pendingWork` 的 null 參考 (在 Visual Basic 中為 `workItem`)。  
  
 使用此方法搭配狀態機器工作流程時，您可能會取得帶有「未啟用佇列 '{0}'」訊息的例外狀況。 這種情況發生在狀態機器的目前狀態不知道如何處理特定事件時。 例如，當目前狀態以外的某種狀態包含 <xref:System.Workflow.Activities.EventDrivenActivity>，而且其中包含由佇列 '{0}' 所代表的 <xref:System.Workflow.Activities.HandleExternalEventActivity> 時。  
  
   
  
## Examples  
 下列程式碼範例將示範使用 `EnqueueItemOnIdle` 方法，將資訊傳送到工作流程執行個體。 首先會建立並啟動 WorkflowInstance 物件，接下來則會建立實作 <xref:System.Workflow.Runtime.IPendingWork> 介面的物件。 `EnqueueItemOnIdle` 然後，呼叫傳入佇列名稱、 加入佇列項目和工作項目，要傳遞給 pendingWork 物件之方法的字串值。  
  
 [!code-csharp[WF_Samples#12](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#12)]
 [!code-vb[WF_Samples#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> 為 null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。  
  
 -或-  
  
 工作流程執行個體已暫停。  
  
 -或-  
  
 由 <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 指定的 <paramref name="queueName" /> 並不存在。  
  
 -或-  
  
 <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> 指定的 <paramref name="queueName" /> 未啟用。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要比較的物件。</param>
        <summary>傳回指出指定的物件是否和 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 相等的值。</summary>
        <returns>
          如果指定的物件和這個 <see langword="true" /> 相等，則為 <see cref="T:System.Workflow.Runtime.WorkflowInstance" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 物件必須是 <xref:System.Workflow.Runtime.WorkflowInstance> 類別的執行個體，而且擁有和此 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 相同的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個工作流程執行個體的雜湊程式碼。</summary>
        <returns>這個 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 的雜湊碼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetHashCode%2A><xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>會傳回以  的值為基礎的雜湊程式碼。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity GetWorkflowDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.ComponentModel.Activity GetWorkflowDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowDefinition () As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::ComponentModel::Activity ^ GetWorkflowDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取此工作流程執行個體的根活動。</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用根活動巡覽工作流程的活動階層。  
  
 這個方法不具備執行緒安全，因此主機應該同步其對此方法的呼叫。  
  
   
  
## Examples  
 下列程式碼範例將示範如何從工作流程執行個體中擷取工作流程定義。  這個範例是 Mainform.cs 的檔案中＜訂購狀態機器 SDK＞範例的一部分。  如需詳細資訊，請參閱[訂購狀態機器範例](http://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c)。  
  
 [!code-csharp[WF_Samples#86](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#86)]
 [!code-vb[WF_Samples#86](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#86)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowNextTimerExpiration">
      <MemberSignature Language="C#" Value="public DateTime GetWorkflowNextTimerExpiration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetWorkflowNextTimerExpiration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowNextTimerExpiration () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetWorkflowNextTimerExpiration();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回計時器訊息將會傳遞至此 <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> 的下一個時間點。</summary>
        <returns>DateTime 值，表示在下一個 <see cref="P:System.Workflow.Runtime.TimerEventSubscription.ExpiresAt" /> 時間，將傳遞計時器訊息至此 <see cref="T:System.Workflow.Runtime.WorkflowInstance" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範使用 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration%2A> 方法，判斷是否有更多工作流程計時器訊息加入佇列中。 這個範例是 Program.cs 檔案中＜工作流程執行緒 SDK＞範例的一部分。 如需詳細資訊，請參閱[工作流程執行緒範例](http://msdn.microsoft.com/library/5b650be7-09fa-47db-a2f6-523dc8ea5ee9)。  
  
 [!code-csharp[WF_Samples#284](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#284)]
 [!code-vb[WF_Samples#284](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#284)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Workflow.Runtime.TimerEventSubscription" />
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowQueueData">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowQueueData () As ReadOnlyCollection(Of WorkflowQueueInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowQueueInfo ^&gt; ^ GetWorkflowQueueData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> 物件的集合，其中包含此工作流程執行個體關聯的工作流程佇列之暫止項目 (Pending Item) 與訂閱的活動。</summary>
        <returns>
          <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 物件的 <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> 會傳回 <xref:System.Workflow.Runtime.WorkflowQueueInfo> 物件的集合，每一個物件都包含與此工作流程執行個體關聯的其中一個工作流程佇列狀態的資訊。 <xref:System.Workflow.Runtime.WorkflowQueueInfo.Items%2A?displayProperty=nameWithType> 包含 <xref:System.Workflow.Runtime.WorkflowQueue> 的暫止項目，而 <xref:System.Workflow.Runtime.WorkflowQueueInfo.SubscribedActivityNames%2A?displayProperty=nameWithType> 則包含在 <xref:System.Workflow.Runtime.WorkflowQueue> 上傳遞項目的訂閱活動清單。  
  
   
  
## Examples  
 下列程式碼範例將示範如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> 方法，以取得與 <xref:System.Workflow.Runtime.WorkflowInstance> 物件關聯的所有工作流程佇列的狀態資訊。 當 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 事件發生時，會呼叫此範例中定義的 `OnWorkflowIdled` 方法。 它會使用 <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> 屬性判斷閒置的工作流程，然後呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> 方法取得工作流程執行個體之佇列項目的集合。 此程式碼會在集合上反覆查看，以判斷是哪個活動正在等候閒置工作流程的事件。 然後，它會使用 <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> 方法以及事件佇列項目的名稱，將例外狀況傳送到工作流程佇列中。  
  
 這個程式碼範例是 Program.cs 檔案中＜取消工作流程 SDK＞範例的一部分。 如需詳細資訊，請參閱[取消工作流程](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb)。  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid InstanceId { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得工作流程執行個體的唯一識別碼。</summary>
        <value>工作流程執行個體的 <see cref="T:System.Guid" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 參考工作流程執行個體。  
  
   
  
## Examples  
 下列程式碼範例將示範如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 屬性取得關於 <xref:System.Workflow.Runtime.WorkflowInstance> 物件的資訊。 第一個程式碼片段會建立名為 <xref:System.Workflow.Runtime.WorkflowInstance> 的 `instanceId` 變數。  
  
 [!code-csharp[WF_Samples#210](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#210)]
 [!code-vb[WF_Samples#210](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#210)]  
  
 第二個片段使用 <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> 屬性做為呼叫 `OrderEventArgs` 方法時，在 `CallBackForApproval` 建構函式 (Constructor) 呼叫中的第一個物件。  
  
 這個程式碼範例是 OrderServiceImple.cs 檔案中＜接聽 SDK＞範例的一部分。 如需詳細資訊，請參閱[接聽範例](http://msdn.microsoft.com/library/1cec0e82-7544-429f-b717-0fc25eb42b7f)。  
  
 [!code-csharp[WF_Samples#211](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#211)]
 [!code-vb[WF_Samples#211](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#211)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Load" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>載入之前卸載的工作流程執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> 是同步的，如果可以載入工作流程執行個體，<xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> 將在工作流程執行個體載入記憶體並由工作流程執行階段引擎排程後傳回。 執行階段會在持續性服務還原記憶體中的工作流程執行個體後，但是在工作流程執行階段引擎排程執行個體之前引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> 事件。  
  
   
  
## Examples  
 下列程式碼範例將示範如何載入之前卸載的 <xref:System.Workflow.Runtime.WorkflowInstance>物件。  
  
 [!code-csharp[WF_Samples#10](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#10)]
 [!code-vb[WF_Samples#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReloadTrackingProfiles">
      <MemberSignature Language="C#" Value="public void ReloadTrackingProfiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReloadTrackingProfiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ReloadTrackingProfiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReloadTrackingProfiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReloadTrackingProfiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新載入此工作流程執行個體的追蹤設定檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行階段追蹤基礎結構將為這個與其追蹤通道關聯的工作流程執行個體，重新載入每個 <xref:System.Workflow.Runtime.Tracking.TrackingProfile>。 如果尚未在暫止狀態中，工作流程會在追蹤設定檔重新載入時由執行階段追蹤基礎結構暫時停止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>繼續執行之前暫止的工作流程執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主機可以呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A> 以繼續執行之前暫止的工作流程執行個體。 如果工作流程執行個體不在暫停狀態中，則不採取任何行動。 執行階段會在正要繼續執行工作流程執行個體之前引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> 事件。  
  
   
  
## Examples  
 下列程式碼範例將示範如何呼叫之前暫止的工作流程執行個體上的 Resume。  這個範例來自＜暫止與結束 SDK＞範例。  如需詳細資訊，請參閱[暫止與終止範例](http://msdn.microsoft.com/library/f4dffa58-d01e-44fb-b5a1-3b283d2c4517)。  
  
 [!code-csharp[WF_Samples#172](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#172)]
 [!code-vb[WF_Samples#172](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#172)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始執行工作流程執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> 會呼叫此工作流程執行個體根活動上的 <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ExecuteActivity%2A>。 如果 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> 遇到例外狀況，它會呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> 並傳遞例外狀況的 <xref:System.Exception.Message%2A> 屬性當做結束原因，以結束工作流程執行個體。  
  
   
  
## Examples  
 下列程式碼範例將示範如何使用 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> 方法在工作流程主機中啟動 <xref:System.Workflow.Runtime.WorkflowInstance>。 下列程式碼會建立 <xref:System.Workflow.Runtime.WorkflowRuntime> 的執行個體、加入服務至執行階段，然後示範建立 <xref:System.Workflow.Runtime.WorkflowInstance> 物件的建議方式。 它會建立 <xref:System.Type> 物件，並將它轉換成其中一個與主機關聯的工作流程物件。 程式碼接著藉由呼叫 <xref:System.Workflow.Runtime.WorkflowInstance> 方法和傳遞之前建立的類型給它來初始化 <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A>。 <xref:System.Workflow.Runtime.WorkflowInstance> 由 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> 方法呼叫啟動。  
  
 這個程式碼範例是 Program.cs 檔案中＜取消工作流程 SDK＞範例的一部分。 如需詳細資訊，請參閱[取消工作流程](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb)。  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。  
  
 -或-  
  
 工作流程執行個體已啟動。</exception>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Suspend(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend(System::String ^ error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">暫止工作流程執行個體的原因描述。</param>
        <summary>暫止工作流程執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行個體是以同步方式暫止。 如果工作流程執行個體已經暫停，則不採取任何行動，否則工作流程執行階段引擎會暫止工作流程執行個體、引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> 事件，並在 `reason` 中傳遞 <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs>。  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> 不會卸載工作流程執行個體。  
  
   
  
## Examples  
 下列程式碼範例將示範如何呼叫 <xref:System.Workflow.Runtime.WorkflowInstance> 物件上的 Suspend。  
  
 [!code-csharp[WF_Samples#9](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#9)]
 [!code-vb[WF_Samples#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。</exception>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">結束工作流程執行個體的原因描述。</param>
        <summary>以同步方式結束工作流程執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作流程執行個體是以同步方式結束。 主機會呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> 以結束工作流程執行個體。 工作流程執行階段引擎會清除記憶體中的工作流程執行個體，並通知持續性服務已清除記憶體中的執行個體。 對 <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> 而言，這表示發生終止時，所有該工作流程執行個體的狀態資訊都會從資料庫中刪除。 您將無法從之前儲存的保存點重新載入工作流程執行個體。  
  
 清除記憶體內的工作流程執行個體，而且通知持續性服務已終止執行個體後，`Terminate` 方法會引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> 事件，並且在包含於 `reason` 中的 <xref:System.Exception.Message%2A> 之 <xref:System.Workflow.ComponentModel.WorkflowTerminatedException> 屬性中傳遞 <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs>。  
  
 `Terminate` 與 <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A> 不同，因為 Terminate 會清除記憶體內的工作流程執行個體並通知持續性服務時，`Abort` 僅清除可以從上次保存點重新啟動之記憶體內的工作流程執行個體。  
  
   
  
## Examples  
 下列程式碼範例將示範如何呼叫 <xref:System.Workflow.Runtime.WorkflowInstance> 物件上的 Terminate。  
  
 [!code-csharp[WF_Samples#8](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#8)]
 [!code-vb[WF_Samples#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作流程執行階段引擎不在執行中。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryUnload">
      <MemberSignature Language="C#" Value="public bool TryUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.TryUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnload();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>執行個體暫止或閒置時，將工作流程執行個體從記憶體卸載到持續性存放區中。</summary>
        <returns>
          如果工作流程執行個體已卸載則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果工作流程執行個體閒置或暫停，<xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> 會使用持續性服務移除記憶體中的工作流程執行個體，然後將它保存在資料存放區中。 如果沒有已向 <xref:System.Workflow.Runtime.WorkflowRuntime> 註冊的持續性服務，<xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> 會擲回 <xref:System.InvalidOperationException>。 如果成功保存工作流程執行個體，就會引發執行階段<xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded>事件，並傳回`true`。 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 傳回`false`工作流程執行個體已卸載，如果已終止，已中止，或已完成。  
  
 主機可以使用 <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> 從閒置的工作流程中回收系統資源。  
  
   
  
## Examples  
 下列程式碼範例將示範如何使用 TryUnload 方法在 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled> 事件引發時卸載工作流程。 這個範例是 Program.cs 檔案中＜使用持續性服務 SDK＞範例的一部分。 如需詳細資訊，請參閱[使用持續性服務範例](http://msdn.microsoft.com/library/3176b7e7-ae49-4d5c-802b-85032d6ebde6)。  
  
 [!code-csharp[WF_Samples#280](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#280)]
 [!code-vb[WF_Samples#280](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#280)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有已經向工作流程執行階段引擎註冊的持續性服務。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將工作流程執行個體從記憶體卸載到持續性存放區中。 此呼叫會封鎖到完成目前排程的工作後，或到異動範圍結束為止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 是同步的，也就是說，它會在完成其執行的任何動作後傳回。 如果工作流程執行個體未閒置，則執行階段會等到執行個體可以被中斷為止。 只有在目前排程的工作項目完成後，才能中斷執行個體。這通常發生在目前執行的 Activity 從執行個體的 <xref:System.Workflow.ComponentModel.Activity.Execute%2A> 方法傳回時。 但如果執行個體正在執行 <xref:System.Workflow.ComponentModel.TransactionScopeActivity>，則執行個體必須等到交易範圍完成執行後才能被中斷。 請先卸載，然後使用持續性服務移除記憶體中的工作流程執行個體，然後將它保存在資料存放區中。 如果沒有已向 <xref:System.Workflow.Runtime.WorkflowRuntime> 註冊的持續性服務，<xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 會擲回 <xref:System.InvalidOperationException>。 如果成功保存工作流程執行個體，執行階段會引發 <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> 事件。  
  
 主機可以使用 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 從閒置的工作流程中回收系統資源。  
  
   
  
## Examples  
 下列範例示範呼叫 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> 物件上的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 [!code-csharp[WF_Samples#11](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#11)]
 [!code-vb[WF_Samples#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有已經向工作流程執行階段引擎註冊的持續性服務。</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowRuntime">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowRuntime As WorkflowRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::Runtime::WorkflowRuntime ^ WorkflowRuntime { System::Workflow::Runtime::WorkflowRuntime ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此工作流程執行個體的 <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />。</summary>
        <value>
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />，表示此工作流程執行個體執行時所在的執行環境。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例將示範如何存取 <xref:System.Workflow.Runtime.WorkflowRuntime> 物件之執行中的 <xref:System.Workflow.Runtime.WorkflowInstance>。  
  
 [!code-csharp[WF_Samples#7](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#7)]
 [!code-vb[WF_Samples#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>