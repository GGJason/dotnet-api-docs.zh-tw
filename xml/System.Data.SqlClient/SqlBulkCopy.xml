<Type Name="SqlBulkCopy" FullName="System.Data.SqlClient.SqlBulkCopy">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="913de004f355c8ec72b363a3a33c142db5cfa36d" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038034" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlBulkCopy : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlBulkCopy extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlClient.SqlBulkCopy" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlBulkCopy&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlBulkCopy sealed : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.SqlClient</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>可讓您有效率地大量載入具有另一個來源的資料之 SQL Server 資料表。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 包含名為常用的命令提示字元公用程式**bcp**如之間移動資料從一個資料表，在單一伺服器或伺服器之間。 <xref:System.Data.SqlClient.SqlBulkCopy>類別可讓您撰寫 managed 程式碼解決方案，以提供類似的功能。 還有其他方式將資料載入 SQL Server 資料表 （INSERT 陳述式，例如），但<xref:System.Data.SqlClient.SqlBulkCopy>提供顯著的效能優勢。  
  
 <xref:System.Data.SqlClient.SqlBulkCopy> 類別可用於僅將資料寫入 SQL Server 資料表。 不過，資料來源不限於 SQL Server;任何資料來源可以使用，因為可以將資料載入至<xref:System.Data.DataTable>執行個體，或是讀取<xref:System.Data.IDataReader>執行個體。  
  
 <xref:System.Data.SqlClient.SqlBulkCopy> 將會失敗時大量載入<xref:System.Data.DataTable>類型的資料行<xref:System.Data.SqlTypes.SqlDateTime>在 SQL Server 型別是日期/時間類型的其中一個資料行加入 SQL Server 2008 中。  
  
   
  
## Examples  
 下列主控台應用程式示範如何使用 <xref:System.Data.SqlClient.SqlBulkCopy> 類別來載入資料。 在此範例中，<xref:System.Data.SqlClient.SqlDataReader>用來將資料從複製**Production.Product** SQL Server 中的資料表**AdventureWorks**相同資料庫中的類似資料表的資料庫。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks BulkCopy.Single#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks BulkCopy.Single/CS/source.cs#1)]
 [!code-vb[DataWorks BulkCopy.Single#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks BulkCopy.Single/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlBulkCopy (System.Data.SqlClient.SqlConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.SqlClient.SqlConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As SqlConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlBulkCopy(System::Data::SqlClient::SqlConnection ^ connection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.SqlClient.SqlConnection" />
      </Parameters>
      <Docs>
        <param name="connection">已開啟的 <see cref="T:System.Data.SqlClient.SqlConnection" /> 執行個體，用於執行大量複製作業。 如果您的連接字串不使用 <see langword="Integrated Security = true" />，您可以使用 <see cref="T:System.Data.SqlClient.SqlCredential" /> 傳遞使用者 ID 和密碼，比起在連接字串中將使用者 ID 和密碼指定為文字更安全。</param>
        <summary>使用指定開啟之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 的執行個體，初始化 <see cref="T:System.Data.SqlClient.SqlConnection" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為連線已經開啟時<xref:System.Data.SqlClient.SqlBulkCopy>初始化執行個體，連接會保持開啟之後<xref:System.Data.SqlClient.SqlBulkCopy>執行個體已關閉。  
  
 如果`connection`引數為 null，<xref:System.ArgumentNullException>就會擲回。  
  
   
  
## Examples  
 下列主控台應用程式示範如何將資料大量載入使用已開啟的連接。 在此範例中，<xref:System.Data.SqlClient.SqlDataReader>用來將資料從複製**Production.Product** SQL Server 中的資料表**AdventureWorks**相同資料庫中的類似資料表的資料庫。 此範例僅供示範之用。 您不會將`SqlBulkCopy`將資料從一個資料表移動到另一個相同資料庫中的實際執行應用程式。 請注意，來源資料不需要位於 SQL Server;您可以使用任何可讀取的資料來源<xref:System.Data.IDataReader>或載入<xref:System.Data.DataTable>。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks BulkCopy.Single#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks BulkCopy.Single/CS/source.cs#1)]
 [!code-vb[DataWorks BulkCopy.Single#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks BulkCopy.Single/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlBulkCopy (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlBulkCopy(System::String ^ connectionString);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">字串，定義為 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 執行個體使用而開啟的連接。 如果您的連接字串不使用 <see langword="Integrated Security = true" />，您可以使用 <see cref="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection)" /> 或 <see cref="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlBulkCopyOptions,System.Data.SqlClient.SqlTransaction)" /> 和 <see cref="T:System.Data.SqlClient.SqlCredential" /> 傳遞使用者 ID 和密碼，比起在連接字串中將使用者 ID 和密碼指定為文字更安全。</param>
        <summary>基於已提供的 <paramref name="connectionString" />，初始化和開啟 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的新執行個體。 建構函式 (Constructor) 會使用 <see cref="T:System.Data.SqlClient.SqlConnection" />，初始化 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 結尾的大量複製作業會自動關閉連接。  
  
 如果`connectionString`為 null，<xref:System.ArgumentNullException>就會擲回。 如果`connectionString`為空字串，<xref:System.ArgumentException>就會擲回。  
  
   
  
## Examples  
 下列主控台應用程式示範如何使用連線字串形式指定大量載入資料。 自動關閉連線時<xref:System.Data.SqlClient.SqlBulkCopy>執行個體已關閉。  
  
 在此範例中，來源資料第一次讀取 SQL Server 資料表，以從<xref:System.Data.SqlClient.SqlDataReader>執行個體。 來源資料不需要位於 SQL Server;您可以使用任何可讀取的資料來源<xref:System.Data.IDataReader>或載入<xref:System.Data.DataTable>。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.ConnectionString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.ConnectionString/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.ConnectionString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.ConnectionString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlBulkCopy (string connectionString, System.Data.SqlClient.SqlBulkCopyOptions copyOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString, valuetype System.Data.SqlClient.SqlBulkCopyOptions copyOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.String,System.Data.SqlClient.SqlBulkCopyOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String, copyOptions As SqlBulkCopyOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlBulkCopy(System::String ^ connectionString, System::Data::SqlClient::SqlBulkCopyOptions copyOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="copyOptions" Type="System.Data.SqlClient.SqlBulkCopyOptions" />
      </Parameters>
      <Docs>
        <param name="connectionString">字串，定義為 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 執行個體使用而開啟的連接。 如果您的連接字串不使用 <see langword="Integrated Security = true" />，您可以使用 <see cref="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection)" /> 或 <see cref="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlBulkCopyOptions,System.Data.SqlClient.SqlTransaction)" /> 和 <see cref="T:System.Data.SqlClient.SqlCredential" /> 傳遞使用者 ID 和密碼，比起在連接字串中將使用者 ID 和密碼指定為文字更安全。</param>
        <param name="copyOptions">
          <see cref="T:System.Data.SqlClient.SqlBulkCopyOptions" /> 列舉的值組合，會決定要將哪些資料來源資料列複製到目的地資料表。</param>
        <summary>基於已提供的 <paramref name="connectionString" />，初始化和開啟 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的新執行個體。 建構函式會使用 <see cref="T:System.Data.SqlClient.SqlConnection" />，初始化 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 類別的新執行個體。 <see cref="T:System.Data.SqlClient.SqlConnection" /> 執行個體會根據 <paramref name="copyOptions" /> 參數中提供的選項進行運作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以取得詳細的資訊中的所有大量複製選項<xref:System.Data.SqlClient.SqlBulkCopyOptions>主題。  
  
   
  
## Examples  
 下列主控台應用程式示範如何使用指定為字串的連接來執行大量載入。 選項設定為使用來源資料表的 identity 資料行中的值，當您載入目的地資料表。 在此範例中，來源資料第一次讀取 SQL Server 資料表，以從<xref:System.Data.SqlClient.SqlDataReader>執行個體。 來源資料表及目標資料表都包含識別資料行。 根據預設，新值**識別**會產生每個資料列加入目的地資料表中的資料行。 在此範例中，選項會設定開啟連接時，會強制大量載入處理序使用**識別**改為來源資料表中的值。 若要查看如何選項變更運作的方式大量負載，以執行此範例**dbo。BulkCopyDemoMatchingColumns**空的資料表。 從來源載入的所有資料列。 然後範例再次執行無需空白資料表。 擲回例外狀況，程式碼會將訊息寫入主控台，告知您未能加入資料列，因為主索引鍵條件約束違規。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.KeepIdentity#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.KeepIdentity/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.KeepIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.KeepIdentity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlBulkCopy (System.Data.SqlClient.SqlConnection connection, System.Data.SqlClient.SqlBulkCopyOptions copyOptions, System.Data.SqlClient.SqlTransaction externalTransaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.SqlClient.SqlConnection connection, valuetype System.Data.SqlClient.SqlBulkCopyOptions copyOptions, class System.Data.SqlClient.SqlTransaction externalTransaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlBulkCopyOptions,System.Data.SqlClient.SqlTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As SqlConnection, copyOptions As SqlBulkCopyOptions, externalTransaction As SqlTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlBulkCopy(System::Data::SqlClient::SqlConnection ^ connection, System::Data::SqlClient::SqlBulkCopyOptions copyOptions, System::Data::SqlClient::SqlTransaction ^ externalTransaction);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.SqlClient.SqlConnection" />
        <Parameter Name="copyOptions" Type="System.Data.SqlClient.SqlBulkCopyOptions" />
        <Parameter Name="externalTransaction" Type="System.Data.SqlClient.SqlTransaction" />
      </Parameters>
      <Docs>
        <param name="connection">已開啟的 <see cref="T:System.Data.SqlClient.SqlConnection" /> 執行個體，用於執行大量複製作業。 如果您的連接字串不使用 <see langword="Integrated Security = true" />，您可以使用 <see cref="T:System.Data.SqlClient.SqlCredential" /> 傳遞使用者 ID 和密碼，比起在連接字串中將使用者 ID 和密碼指定為文字更安全。</param>
        <param name="copyOptions">
          <see cref="T:System.Data.SqlClient.SqlBulkCopyOptions" /> 列舉的值組合，會決定要將哪些資料來源資料列複製到目的地資料表。</param>
        <param name="externalTransaction">現有的 <see cref="T:System.Data.SqlClient.SqlTransaction" /> 執行個體，其下會發生大量複製。</param>
        <summary>使用已提供之現有開啟的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 執行個體，初始化 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的新執行個體。 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 執行個體會根據 <paramref name="copyOptions" /> 參數中提供的選項進行運作。 如果提供非 null <see cref="T:System.Data.SqlClient.SqlTransaction" />，則會在交易中執行複製作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果選項包括`UseInternalTransaction`和`externalTransaction`引數不是 null， **InvalidArgumentException**就會擲回。  
  
 如需範例示範如何使用`SqlBulkCopy`在交易中，請參閱[異動和大量複製作業](~/docs/framework/data/adonet/sql/transaction-and-bulk-copy-operations.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatchSize">
      <MemberSignature Language="C#" Value="public int BatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlBulkCopy.BatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Property BatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BatchSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>每個批次中的資料列數目。 每個批次結束時，批次中的資料列會傳送到伺服器。</summary>
        <value>
          <see cref="P:System.Data.SqlClient.SqlBulkCopy.BatchSize" /> 屬性的整數值；如果未設定任何值，則為零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 批次時，即完成<xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A>資料列都已處理或傳送到目的地資料來源沒有多個資料列。  
  
 零 （預設值） 表示，每個<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>作業是在單一批次。  
  
 如果<xref:System.Data.SqlClient.SqlBulkCopy>執行個體已宣告但<xref:System.Data.SqlClient.SqlBulkCopyOptions.UseInternalTransaction>選項作用中，資料列會傳送到伺服器<xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A>會從資料列在一段期間，但沒有交易相關的動作。 如果<xref:System.Data.SqlClient.SqlBulkCopyOptions.UseInternalTransaction>作用中，是以個別的交易插入的資料列的每個批次。  
  
 <xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A>屬性可以在任何時間設定。 如果大量複製已在進行中，目前的批次的大小調整為根據上一個批次大小。 後續的批次使用新的大小。 如果<xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A>一開始是零和已變更時<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>作業正在進行中，作業會當做單一批次的資料載入。 任何後續<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>上相同的作業<xref:System.Data.SqlClient.SqlBulkCopy>使用新的執行個體<xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A>。  
  
   
  
## Examples  
 下列主控台應用程式示範如何將資料大量載入的 50 個資料列批次。 如範例說明如何<xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A>適用於交易，請參閱[異動和大量複製作業](~/docs/framework/data/adonet/sql/transaction-and-bulk-copy-operations.md)。  
  
 在此範例中，來源資料第一次讀取 SQL Server 資料表，以從<xref:System.Data.SqlClient.SqlDataReader>執行個體。 來源資料不需要位於 SQL Server;您可以使用任何可讀取的資料來源<xref:System.Data.IDataReader>或載入<xref:System.Data.DataTable>。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.BatchSize#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.BatchSize/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.BatchSize#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.BatchSize/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulkCopyTimeout">
      <MemberSignature Language="C#" Value="public int BulkCopyTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulkCopyTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlBulkCopy.BulkCopyTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property BulkCopyTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulkCopyTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成作業的秒數，在這之後作業會逾時。</summary>
        <value>
          <see cref="P:System.Data.SqlClient.SqlBulkCopy.BulkCopyTimeout" /> 屬性的整數值。 預設為 30 秒。 值為 0 表示沒有限制；大量複製會無限期等候。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果作業逾時時間，也不會認可交易，並複製的所有資料列會移除從目的地資料表。  
  
   
  
## Examples  
 下列主控台應用程式示範如何修改逾時為 60 秒大量載入資料時。  
  
 在此範例中，來源資料第一次讀取 SQL Server 資料表，以從<xref:System.Data.SqlClient.SqlDataReader>執行個體。 來源資料不需要位於 SQL Server;您可以使用任何可讀取的資料來源<xref:System.Data.IDataReader>或載入<xref:System.Data.DataTable>。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用[!INCLUDE[tsql](~/includes/tsql-md.md)]`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.Timeout#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.Timeout/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.Timeout/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在您呼叫後<xref:System.Data.SqlClient.SqlBulkCopy.Close%2A>上<xref:System.Data.SqlClient.SqlBulkCopy>物件沒有其他作業將會成功。 呼叫<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>方法會擲回<xref:System.InvalidOperationException>。  
  
 呼叫<xref:System.Data.SqlClient.SqlBulkCopy.Close%2A>方法從<xref:System.Data.SqlClient.SqlBulkCopy.SqlRowsCopied>事件導致<xref:System.InvalidOperationException>擲回。  
  
 請注意開啟<xref:System.Data.SqlClient.SqlBulkCopy>執行個體視為封閉式隱含結尾`using`區塊。  
  
   
  
## Examples  
 下列範例會使用相同<xref:System.Data.SqlClient.SqlBulkCopy>將銷售訂單和其關聯的詳細資料加入至兩個目的地資料表的執行個體。 因為**AdventureWorks**銷售訂單資料表很大，範例會讀取只有某些帳戶號碼所下的訂單和大量複製到目的地資料表的那些訂單和明細。 <xref:System.Data.SqlClient.SqlBulkCopy.Close%2A>只有這兩個大量複製作業完成之後，會使用方法。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.OrdersDetails#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.OrdersDetails/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.OrdersDetails#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.OrdersDetails/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnMappings">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlBulkCopyColumnMappingCollection ColumnMappings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlBulkCopyColumnMappingCollection ColumnMappings" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlBulkCopy.ColumnMappings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ColumnMappings As SqlBulkCopyColumnMappingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlBulkCopyColumnMappingCollection ^ ColumnMappings { System::Data::SqlClient::SqlBulkCopyColumnMappingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlBulkCopyColumnMappingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回 <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" /> 項目的集合。 資料行對應會定義資料來源中資料行和目的地中資料行之間的關聯性。</summary>
        <value>資料行對應的集合。 根據預設，它可以是空的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果資料來源和目的地資料表有相同數目的資料行，而且資料來源中的每個來源資料行的序數位置中符合相對應的目的地資料行的序數位置<xref:System.Data.SqlClient.SqlBulkCopy.ColumnMappings%2A>是不必要的集合。 不過，如果資料行計數不同，或不一致的序數位置，您必須使用<xref:System.Data.SqlClient.SqlBulkCopy.ColumnMappings%2A>以確定資料會複製到正確的資料行。  
  
 在執行大量複製作業時，此集合可供存取，但無法變更。 若要變更它的任何嘗試將會擲回<xref:System.InvalidOperationException>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
      </Docs>
    </Member>
    <Member MemberName="DestinationTableName">
      <MemberSignature Language="C#" Value="public string DestinationTableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DestinationTableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationTableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DestinationTableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>伺服器上的目的資料表名稱。</summary>
        <value>
          <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 屬性的字串值；如果未提供任何值，則為 null。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Data.SqlClient.SqlBulkCopy.DestinationTableName%2A>尚未設定時<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>呼叫時，<xref:System.ArgumentNullException>就會擲回。  
  
 如果<xref:System.Data.SqlClient.SqlBulkCopy.DestinationTableName%2A>遭到修改時<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>作業正在執行，變更不會影響目前的作業。 新<xref:System.Data.SqlClient.SqlBulkCopy.DestinationTableName%2A>使用下一次的值<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>方法呼叫。  
  
 <xref:System.Data.SqlClient.SqlBulkCopy.DestinationTableName%2A> 這是三部分名稱 (`<database>.<owningschema>.<name>`)。 如果您選擇，您可以限定資料表名稱的資料庫和主控結構描述。 不過，如果資料表名稱使用底線 ("_") 或任何其他特殊字元，您必須逸出名稱使用周圍的方括號中 (`[<database>.<owningschema>.<name_01>]`)。 如需詳細資訊，請參閱 SQL Server 線上叢書 》 中的 < 識別碼 >。  
  
 您可以將資料大量複製到暫存資料表使用的值，例如`tempdb..#table`或`tempdb.<owner>.#table`如<xref:System.Data.SqlClient.SqlBulkCopy.DestinationTableName%2A>屬性。  
  
   
  
## Examples  
 下列主控台應用程式示範如何將資料大量載入使用已開啟的連接。 目的地資料表是中的資料表**AdventureWorks**資料庫。  
  
 在此範例中，連接第一次使用的 SQL Server 資料表中讀取資料<xref:System.Data.SqlClient.SqlDataReader>執行個體。 來源資料不需要位於 SQL Server;您可以使用任何可讀取的資料來源<xref:System.Data.IDataReader>或載入<xref:System.Data.DataTable>。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.Single#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.Single/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.Single#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.Single/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableStreaming">
      <MemberSignature Language="C#" Value="public bool EnableStreaming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableStreaming" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlBulkCopy.EnableStreaming" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableStreaming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableStreaming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>啟用或停用 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 物件，從 <see cref="T:System.Data.IDataReader" /> 物件串流資料。</summary>
        <value>
          如果 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 物件可從 <see cref="T:System.Data.IDataReader" /> 物件串流資料，則為 <see langword="true" />，否則為 false。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Data.SqlClient.SqlBulkCopy.EnableStreaming%2A>是`true`，<xref:System.Data.SqlClient.SqlBulkCopy>讀取<xref:System.Data.IDataReader>物件使用<xref:System.Data.CommandBehavior.SequentialAccess>，記憶體使用量最佳化使用<xref:System.Data.IDataReader>串流處理功能。 當設定為 false，<xref:System.Data.SqlClient.SqlBulkCopy>類別會載入所傳回的資料<xref:System.Data.IDataReader>到記憶體，再將它傳送到 SQL Server 或 SQL Azure 的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyAfter">
      <MemberSignature Language="C#" Value="public int NotifyAfter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NotifyAfter" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlBulkCopy.NotifyAfter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyAfter As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NotifyAfter { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定義產生通知事件之前要處理的資料列數目。</summary>
        <value>
          <see cref="P:System.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> 屬性的整數值，如果尚未設定屬性，則為零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性被設計用於使用者介面元件，以說明大量複製作業的進度。 表示產生通知事件之前要處理的資料列數目。 <xref:System.Data.SqlClient.SqlBulkCopy.NotifyAfter%2A>即使在大量複製作業正在進行中時，可以在任何時間，設定屬性。 大量複製作業期間所做的變更在下一個通知之後才會生效。 新的設定套用到相同的執行個體上的所有後續作業。  
  
 如果<xref:System.Data.SqlClient.SqlBulkCopy.NotifyAfter%2A>是設定為數目小於零，則<xref:System.ArgumentOutOfRangeException>就會擲回。  
  
   
  
## Examples  
 下列主控台應用程式示範如何將資料大量載入使用已開啟的連接。 <xref:System.Data.SqlClient.SqlBulkCopy.NotifyAfter%2A>屬性設定，讓每個 50 個資料列複製到資料表之後，事件處理常式的呼叫。  
  
 在此範例中，連接第一次使用的 SQL Server 資料表中讀取資料<xref:System.Data.SqlClient.SqlDataReader>執行個體。 然後第二個連接被開啟的資料大量複製。 請注意，來源資料不需要位於 SQL Server;您可以使用任何可讀取的資料來源<xref:System.Data.IDataReader>或載入<xref:System.Data.DataTable>。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.NotifyAfter#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.NotifyAfter/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.NotifyAfter#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.NotifyAfter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SqlRowsCopied">
      <MemberSignature Language="C#" Value="public event System.Data.SqlClient.SqlRowsCopiedEventHandler SqlRowsCopied;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.SqlClient.SqlRowsCopiedEventHandler SqlRowsCopied" />
      <MemberSignature Language="DocId" Value="E:System.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SqlRowsCopied As SqlRowsCopiedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::SqlClient::SqlRowsCopiedEventHandler ^ SqlRowsCopied;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlRowsCopiedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於每次處理 <see cref="P:System.Data.SqlClient.SqlBulkCopy.NotifyAfter" /> 屬性所指定的資料列數目時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，設定<xref:System.Data.SqlClient.SqlBulkCopy.NotifyAfter%2A>和<xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A>無關。 收到<xref:System.Data.SqlClient.SqlBulkCopy.SqlRowsCopied>事件並不代表任何資料列已傳送到伺服器或認可。  
  
 您不能呼叫 SqlBulkCopy.Close (<xref:System.Data.SqlClient.SqlBulkCopy.Close%2A>) 或 SqlConnection.Close (<xref:System.Data.SqlClient.SqlConnection.Close%2A>) 從這個事件。 如此一來，這會導致<xref:System.InvalidOperationException>擲回，而<xref:System.Data.SqlClient.SqlBulkCopy>不會變更物件狀態。 如果使用者想要取消事件，從作業<xref:System.Data.SqlClient.SqlRowsCopiedEventArgs.Abort%2A>屬性<xref:System.Data.SqlClient.SqlRowsCopiedEventArgs>可用。 (請參閱[異動和大量複製作業](~/docs/framework/data/adonet/sql/transaction-and-bulk-copy-operations.md)如需範例，使用<xref:System.Data.SqlClient.SqlRowsCopiedEventArgs.Abort%2A>屬性。)  
  
 任何動作，例如交易活動，支援大量複製作業，在執行期間的連線，而且建議您不要使用相同的連接期間使用<xref:System.Data.SqlClient.SqlBulkCopy.SqlRowsCopied>事件。 不過，您可以開啟不同的連接。  
  
   
  
## Examples  
 下列主控台應用程式示範如何將資料大量載入使用已開啟的連接。 <xref:System.Data.SqlClient.SqlBulkCopy.NotifyAfter%2A>屬性設定，讓每個 50 個資料列複製到資料表之後，事件處理常式的呼叫。  
  
 在此範例中，連接第一次使用的 SQL Server 資料表中讀取資料<xref:System.Data.SqlClient.SqlDataReader>執行個體。 請注意，來源資料不需要位於 SQL Server;您可以使用任何可讀取的資料來源<xref:System.Data.IDataReader>或載入<xref:System.Data.DataTable>。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.NotifyAfter#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.NotifyAfter/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.NotifyAfter#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.NotifyAfter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 類別目前的執行個體所使用的資源全部釋出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` 使用完畢時，請呼叫 <xref:System.Data.SqlClient.SqlBulkCopy>。 `Dispose` 方法會將 <xref:System.Data.SqlClient.SqlBulkCopy> 保留在無法使用的狀態。 在呼叫`Dispose`，您必須釋放所有參考<xref:System.Data.SqlClient.SqlBulkCopy>讓記憶體回收行程可以回收記憶體的<xref:System.Data.SqlClient.SqlBulkCopy>所佔用。  
  
 如需詳細資訊，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  在您釋放最後一個 `Dispose` 參考之前，請務必呼叫 <xref:System.Data.SqlClient.SqlBulkCopy>。 否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Data.SqlClient.SqlBulkCopy> 物件的 `Finalize` 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToServer">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將所有資料列從資料來源複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 multiple active result set (MARS) 停用，<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>忙碌中 」 建立的連接。 如果啟用 MARS 時，您可以交錯使用呼叫<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>與相同的連接中的其他命令。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToServer">
      <MemberSignature Language="C#" Value="public void WriteToServer (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteToServer(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteToServer (reader As DbDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteToServer(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" />，其資料列會複製到目的資料表。</param>
        <summary>將所有資料列從已提供的 <see cref="T:System.Data.Common.DbDataReader" /> 陣列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToServer">
      <MemberSignature Language="C#" Value="public void WriteToServer (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteToServer(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteToServer (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteToServer(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">要複製至目的資料表之 <see cref="T:System.Data.DataRow" /> 物件的陣列。</param>
        <summary>將所有資料列從已提供的 <see cref="T:System.Data.DataRow" /> 陣列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大量複製作業正在進行時，相關聯的目的地<xref:System.Data.SqlClient.SqlConnection>忙碌處理，而且可以在連接上執行任何其他的作業。  
  
 <xref:System.Data.SqlClient.SqlBulkCopy.ColumnMappings%2A>集合對應從<xref:System.Data.DataRow>目的地資料庫的資料表資料行。  
  
   
  
## Examples  
 下列主控台應用程式示範如何在大量載入資料，從<xref:System.Data.DataRow>陣列。 目的地資料表是中的資料表**AdventureWorks**資料庫。  
  
 在此範例中，<xref:System.Data.DataTable>建立在執行階段。 從選取的單一資料列<xref:System.Data.DataTable>複製到目的資料表。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.RowArray#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.RowArray/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.RowArray#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.RowArray/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToServer">
      <MemberSignature Language="C#" Value="public void WriteToServer (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteToServer(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteToServer (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteToServer(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" />，其資料列會複製到目的資料表。</param>
        <summary>將已提供之 <see cref="T:System.Data.DataTable" /> 中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的所有資料列<xref:System.Data.DataTable>會複製到目的地資料表，除了已刪除。  
  
 大量複製作業正在進行時，相關聯的目的地<xref:System.Data.SqlClient.SqlConnection>忙碌處理，而且可以在連接上執行任何其他的作業。  
  
 <xref:System.Data.SqlClient.SqlBulkCopy.ColumnMappings%2A>集合對應從<xref:System.Data.DataTable>目的地資料庫的資料表資料行。  
  
   
  
## Examples  
 下列主控台應用程式示範如何在大量載入資料，從<xref:System.Data.DataTable>。 目的地資料表是中的資料表**AdventureWorks**資料庫。  
  
 在此範例中，<xref:System.Data.DataTable>建立在執行階段和來源的`SqlBulkCopy`作業。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.DataTable#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.DataTable/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.DataTable#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.DataTable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToServer">
      <MemberSignature Language="C#" Value="public void WriteToServer (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteToServer(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteToServer (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteToServer(System::Data::IDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" />，其資料列會複製到目的資料表。</param>
        <summary>將已提供之 <see cref="T:System.Data.IDataReader" /> 中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在下一個可用的資料列，讀取器中開始複製作業。 大部分的情況下，讀取器只傳回<xref:System.Data.IDbCommand.ExecuteReader%2A>或類似的呼叫，因此下一個可用的資料列是第一個資料列。 若要處理多個結果，請呼叫<xref:System.Data.IDataReader.NextResult%2A>上的資料讀取器和呼叫<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>一次。  
  
 請注意，使用<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>修改讀取器的狀態。 方法會呼叫<xref:System.Data.IDataReader.Read%2A>直到它傳回 false，作業已中止時，或發生錯誤。 這表示資料讀取器會在不同的狀態，可能會在結果集中，結尾時<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>作業已完成。  
  
 大量複製作業正在進行時，相關聯的目的地<xref:System.Data.SqlClient.SqlConnection>忙碌處理，而且可以在連接上執行任何其他的作業。  
  
 <xref:System.Data.SqlClient.SqlBulkCopy.ColumnMappings%2A>集合的資料讀取器資料行對應到目的地資料庫資料表。  
  
   
  
## Examples  
 下列主控台應用程式示範如何在大量載入資料，從<xref:System.Data.SqlClient.SqlDataReader>。 目的地資料表是中的資料表**AdventureWorks**資料庫。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.ConnectionString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.ConnectionString/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.ConnectionString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.ConnectionString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToServer">
      <MemberSignature Language="C#" Value="public void WriteToServer (System.Data.DataTable table, System.Data.DataRowState rowState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteToServer(class System.Data.DataTable table, valuetype System.Data.DataRowState rowState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteToServer (table As DataTable, rowState As DataRowState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteToServer(System::Data::DataTable ^ table, System::Data::DataRowState rowState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="rowState" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" />，其資料列會複製到目的資料表。</param>
        <param name="rowState">
          <see cref="T:System.Data.DataRowState" /> 列舉中的值。 只有符合資料列狀態的資料列會複製到目的地。</param>
        <summary>只將已提供之 <see cref="T:System.Data.DataTable" /> 中符合已提供資料列狀態的資料列，複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有當資料列中<xref:System.Data.DataTable>中所示的狀態`rowState`引數而且不刪除複製到目的地資料表。  
  
> [!NOTE]
>  如果<xref:System.Data.DataRowState.Deleted>指定，則任何<xref:System.Data.DataRowState.Unchanged>， <xref:System.Data.DataRowState.Added>，和<xref:System.Data.DataRowState.Modified>資料列也會複製到伺服器。 將會不引發任何例外狀況。  
  
 大量複製作業正在進行時，相關聯的目的地<xref:System.Data.SqlClient.SqlConnection>忙碌處理，而且可以在連接上執行任何其他的作業。  
  
 <xref:System.Data.SqlClient.SqlBulkCopy.ColumnMappings%2A>集合對應從<xref:System.Data.DataTable>目的地資料庫的資料表資料行。  
  
   
  
## Examples  
 下列主控台應用程式示範如何在大量載入中的列<xref:System.Data.DataTable>之符合指定的狀態。 在此情況下，只有未變更的資料列會加入。 目的地資料表是中的資料表**AdventureWorks**資料庫。  
  
 在此範例中，<xref:System.Data.DataTable>建立在執行的階段和三個資料列會加入。 之前<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>執行方法，其中一個資料列編輯。 <xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>方法呼叫`DataRowState.Unchanged``rowState`引數，因此只有兩個變更的資料列會使用大量複製到目的地。  
  
> [!IMPORTANT]
>  此範例不會執行，除非您已建立工作資料表中所述[大量複製範例設定](~/docs/framework/data/adonet/sql/bulk-copy-example-setup.md)。 此程式碼可示範如何使用的語法**SqlBulkCopy**只。 如果來源和目的地資料表位於相同的 SQL Server 執行個體，則您更輕鬆且快速地使用 Transact SQL`INSERT … SELECT`陳述式來複製資料。  
  
 [!code-csharp[DataWorks SqlBulkCopy.DataRowState#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.DataRowState/CS/source.cs#1)]
 [!code-vb[DataWorks SqlBulkCopy.DataRowState#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlBulkCopy.DataRowState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataRowState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="Overload:System.Data.SqlClient.SqlBulkCopy.WriteToServer" /> 的非同步版本，該版本會將資料來源中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 multiple active result set (MARS) 停用，<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>忙碌中 」 建立的連接。 如果啟用 MARS 時，您可以交錯使用呼叫<xref:System.Data.SqlClient.SqlBulkCopy.WriteToServer%2A>與相同的連接中的其他命令。  
  
 其中一個失敗時，會回復的資料列數目取決於幾項工作：  
  
-   如果<xref:System.Data.SqlClient.SqlBulkCopyOptions.UseInternalTransaction>指定。  
  
-   如果您有自己的交易。  
  
-   <xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A> 的值。  
  
 同時將資料傳送至伺服器，也就是目前的批次發生錯誤時 (所指定<xref:System.Data.SqlClient.SqlBulkCopy.BatchSize%2A>) 將會回復。 如果<xref:System.Data.SqlClient.SqlBulkCopyOptions.UseInternalTransaction>未指定，並且已經您自己的交易，整個交易將會回復 （其中包含以及所有先前批次）。  
  
 使用<xref:System.Data.SqlClient.SqlBulkCopy.SqlRowsCopied>知道多少資料列被複製到伺服器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteToServerAsync (reader As DbDataReader) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" />，其資料列會複製到目的資料表。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.Common.DbDataReader)" /> 的非同步版本，其會將提供的 <see cref="T:System.Data.Common.DbDataReader" /> 陣列中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteToServerAsync (rows As DataRow()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">要複製至目的資料表之 <see cref="T:System.Data.DataRow" /> 物件的陣列。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" /> 的非同步版本，其會將提供的 <see cref="T:System.Data.DataRow" /> 陣列中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需在.NET Framework Data Provider for SQL Server 的非同步程式設計的詳細資訊，請參閱[進行非同步程式設計](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在工作完成前為相同的執行個體多次呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />。  
  
 在工作完成前為相同的執行個體呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> 和 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />。  
  
 在 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> 執行期間，連線中斷或關閉。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlBulkCopy" />物件在方法執行期間關閉。  
  
 於工作物件中傳回，連接集區逾時。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlConnection" />物件在方法執行之前關閉。  
  
 在連接字串中指定了 <see langword="Context Connection=true" />。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">於工作物件中傳回，SQL Server 傳回於開啟連線時所發生的任何錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteToServerAsync (table As DataTable) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" />，其資料列會複製到目的資料表。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" /> 的非同步版本，其會將提供的 <see cref="T:System.Data.DataTable" /> 中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需在.NET Framework Data Provider for SQL Server 的非同步程式設計的詳細資訊，請參閱[進行非同步程式設計](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在工作完成前為相同的執行個體多次呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />。  
  
 在工作完成前為相同的執行個體呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> 和 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />。  
  
 在 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> 執行期間，連線中斷或關閉。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlBulkCopy" />物件在方法執行期間關閉。  
  
 於工作物件中傳回，連接集區逾時。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlConnection" />物件在方法執行之前關閉。  
  
 在連接字串中指定了 <see langword="Context Connection=true" />。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">於工作物件中傳回，SQL Server 傳回於開啟連線時所發生的任何錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteToServerAsync (reader As IDataReader) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(System::Data::IDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" />，其資料列會複製到目的資料表。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" /> 的非同步版本，其會將提供的 <see cref="T:System.Data.IDataReader" /> 中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需在.NET Framework Data Provider for SQL Server 的非同步程式設計的詳細資訊，請參閱[進行非同步程式設計](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在工作完成前為相同的執行個體多次呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />。  
  
 在工作完成前為相同的執行個體呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> 和 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />。  
  
 在 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> 執行期間，連線中斷或關閉。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlBulkCopy" />物件在方法執行期間關閉。  
  
 於工作物件中傳回，連接集區逾時。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlConnection" />物件在方法執行之前關閉。  
  
 <see cref="T:System.Data.IDataReader" />在已完成的<see cref="T:System.Threading.Tasks.Task" />傳回之前已關閉。  
  
 <see cref="T:System.Data.IDataReader" />的關聯連接在已完成的<see cref="T:System.Threading.Tasks.Task" />傳回之前已關閉。  
  
 在連接字串中指定了 <see langword="Context Connection=true" />。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">於工作物件中傳回，SQL Server 傳回於開啟連線時所發生的任何錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.Common.DbDataReader reader, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.Common.DbDataReader reader, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.Common.DbDataReader,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(System::Data::Common::DbDataReader ^ reader, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" />，其資料列會複製到目的資料表。</param>
        <param name="cancellationToken">取消指令。 這個參數中的 <see cref="P:System.Threading.CancellationToken.None" /> 值會使這個方法相當於 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.Common.DbDataReader)" />。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.Common.DbDataReader)" /> 的非同步版本，其會將提供的 <see cref="T:System.Data.Common.DbDataReader" /> 陣列中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <returns>傳回 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.DataRow[] rows, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.DataRow[] rows, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="rows">要複製至目的資料表之 <see cref="T:System.Data.DataRow" /> 物件的陣列。</param>
        <param name="cancellationToken">取消指令。 這個參數中的 <see cref="P:System.Threading.CancellationToken.None" /> 值會使這個方法相當於 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" /> 的非同步版本，其會將提供的 <see cref="T:System.Data.DataRow" /> 陣列中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。  
  
 取消語彙基元可用於要求在命令逾時之前捨棄作業。  例外狀況將經由傳回的 Task 物件回報。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需在.NET Framework Data Provider for SQL Server 的非同步程式設計的詳細資訊，請參閱[進行非同步程式設計](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在工作完成前為相同的執行個體多次呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />。  
  
 在工作完成前為相同的執行個體呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> 和 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />。  
  
 在 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" /> 執行期間，連線中斷或關閉。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlBulkCopy" />物件在方法執行期間關閉。  
  
 於工作物件中傳回，連接集區逾時。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlConnection" />物件在方法執行之前關閉。  
  
 在連接字串中指定了 <see langword="Context Connection=true" />。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">於工作物件中傳回，SQL Server 傳回於開啟連線時所發生的任何錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.DataTable table, System.Data.DataRowState rowState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.DataTable table, valuetype System.Data.DataRowState rowState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteToServerAsync (table As DataTable, rowState As DataRowState) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(System::Data::DataTable ^ table, System::Data::DataRowState rowState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="rowState" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" />，其資料列會複製到目的資料表。</param>
        <param name="rowState">
          <see cref="T:System.Data.DataRowState" /> 列舉中的值。 只有符合資料列狀態的資料列會複製到目的地。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" /> 的非同步版本只將已提供之 <see cref="T:System.Data.DataTable" /> 中符合已提供資料列狀態的資料列，複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需在.NET Framework Data Provider for SQL Server 的非同步程式設計的詳細資訊，請參閱[進行非同步程式設計](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在工作完成前為相同的執行個體多次呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />。  
  
 在工作完成前為相同的執行個體呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> 和 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />。  
  
 在 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> 執行期間，連線中斷或關閉。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlBulkCopy" />物件在方法執行期間關閉。  
  
 於工作物件中傳回，連接集區逾時。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlConnection" />物件在方法執行之前關閉。  
  
 在連接字串中指定了 <see langword="Context Connection=true" />。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">於工作物件中傳回，SQL Server 傳回於開啟連線時所發生的任何錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.DataTable table, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.DataTable table, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(System::Data::DataTable ^ table, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" />，其資料列會複製到目的資料表。</param>
        <param name="cancellationToken">取消指令。 這個參數中的 <see cref="P:System.Threading.CancellationToken.None" /> 值會使這個方法相當於 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" /> 的非同步版本，其會將提供的 <see cref="T:System.Data.DataTable" /> 中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。  
  
 取消語彙基元可用於要求在命令逾時之前捨棄作業。  例外狀況將經由傳回的 Task 物件回報。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需在.NET Framework Data Provider for SQL Server 的非同步程式設計的詳細資訊，請參閱[進行非同步程式設計](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在工作完成前為相同的執行個體多次呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />。  
  
 在工作完成前為相同的執行個體呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> 和 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />。  
  
 在 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" /> 執行期間，連線中斷或關閉。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlBulkCopy" />物件在方法執行期間關閉。  
  
 於工作物件中傳回，連接集區逾時。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlConnection" />物件在方法執行之前關閉。  
  
 在連接字串中指定了 <see langword="Context Connection=true" />。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">於工作物件中傳回，SQL Server 傳回於開啟連線時所發生的任何錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.IDataReader reader, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.IDataReader reader, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(System::Data::IDataReader ^ reader, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" />，其資料列會複製到目的資料表。</param>
        <param name="cancellationToken">取消指令。 這個參數中的 <see cref="P:System.Threading.CancellationToken.None" /> 值會使這個方法相當於 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" /> 的非同步版本，其會將提供的 <see cref="T:System.Data.IDataReader" /> 中的所有資料列複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件的 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。  
  
 取消語彙基元可用於要求在命令逾時之前捨棄作業。  例外狀況將經由傳回的 Task 物件回報。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需在.NET Framework Data Provider for SQL Server 的非同步程式設計的詳細資訊，請參閱[進行非同步程式設計](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在工作完成前為相同的執行個體多次呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />。  
  
 在工作完成前為相同的執行個體呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> 和 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />。  
  
 在 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" /> 執行期間，連線中斷或關閉。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlBulkCopy" />物件在方法執行期間關閉。  
  
 於工作物件中傳回，連接集區逾時。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlConnection" />物件在方法執行之前關閉。  
  
 <see cref="T:System.Data.IDataReader" />在已完成的<see cref="T:System.Threading.Tasks.Task" />傳回之前已關閉。  
  
 <see cref="T:System.Data.IDataReader" />的關聯連接在已完成的<see cref="T:System.Threading.Tasks.Task" />傳回之前已關閉。  
  
 在連接字串中指定了 <see langword="Context Connection=true" />。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">於工作物件中傳回，SQL Server 傳回於開啟連線時所發生的任何錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteToServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteToServerAsync (System.Data.DataTable table, System.Data.DataRowState rowState, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteToServerAsync(class System.Data.DataTable table, valuetype System.Data.DataRowState rowState, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteToServerAsync(System::Data::DataTable ^ table, System::Data::DataRowState rowState, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="rowState" Type="System.Data.DataRowState" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" />，其資料列會複製到目的資料表。</param>
        <param name="rowState">
          <see cref="T:System.Data.DataRowState" /> 列舉中的值。 只有符合資料列狀態的資料列會複製到目的地。</param>
        <param name="cancellationToken">取消指令。 這個參數中的 <see cref="P:System.Threading.CancellationToken.None" /> 值會使這個方法相當於 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" /> 的非同步版本只將已提供之 <see cref="T:System.Data.DataTable" /> 中符合已提供資料列狀態的資料列，複製到 <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" /> 物件之 <see cref="T:System.Data.SqlClient.SqlBulkCopy" /> 屬性所指定的目的資料表。  
  
 取消語彙基元可用於要求在命令逾時之前捨棄作業。  例外狀況將經由傳回的 Task 物件回報。</summary>
        <returns>表示非同步作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需在.NET Framework Data Provider for SQL Server 的非同步程式設計的詳細資訊，請參閱[進行非同步程式設計](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在工作完成前為相同的執行個體多次呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />。  
  
 在工作完成前為相同的執行個體呼叫 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> 和 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />。  
  
 在 <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" /> 執行期間，連線中斷或關閉。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlBulkCopy" />物件在方法執行期間關閉。  
  
 於工作物件中傳回，連接集區逾時。  
  
 在工作物件中傳回，<see cref="T:System.Data.SqlClient.SqlConnection" />物件在方法執行之前關閉。  
  
 在連接字串中指定了 <see langword="Context Connection=true" />。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">於工作物件中傳回，SQL Server 傳回於開啟連線時所發生的任何錯誤。</exception>
      </Docs>
    </Member>
  </Members>
</Type>