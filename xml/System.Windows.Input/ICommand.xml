<Type Name="ICommand" FullName="System.Windows.Input.ICommand">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ea5eff6a81bd27b0ab5ad70e628f1d59b7ee7f56" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30647932" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface ICommand" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ICommand" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.ICommand" />
  <TypeSignature Language="VB.NET" Value="Public Interface ICommand" />
  <TypeSignature Language="C++ CLI" Value="public interface class ICommand" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定義命令。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.RoutedCommand> 和<xref:System.Windows.Input.RoutedUICommand>兩種方式實作<xref:System.Windows.Input.ICommand>介面中[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]。  
  
## <a name="icommand-in-windows-runtime-apps"></a>在 Windows 中的 ICommand 執行階段應用程式  
 <xref:System.Windows.Input.ICommand>介面是.NET 的 Windows 執行階段應用程式中撰寫命令的程式碼合約。 這些命令會將命令的行為提供 UI 項目，例如 Windows 執行階段 XAML`Button`和特別`AppBarButton`。 如果您正在定義 Windows 執行階段應用程式的命令，則您基本上是使用相同的技術，您會用來定義.NET 應用程式中的命令。 定義實作的類別來實作命令<xref:System.Windows.Input.ICommand>和特別實作<xref:System.Windows.Input.ICommand.Execute%2A>方法。  
  
 XAML 的 Windows 執行階段不支援 x`:Static`，因此請勿嘗試使用`x:Static`如果命令使用從 Windows 執行階段 XAML 標記延伸。 此外，Windows 執行階段沒有任何預先定義的命令程式庫，因此如下所示的 XAML 語法不會真的適用於您正在實作介面並定義 Windows 執行階段使用的命令的情況。  
  
<a name="xamlTextUsage_ICommand"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
 \<*object property*="*predefinedCommandName*"/>  
  
 \-或-  
  
 \<*object property*="*predefinedCommandName.predefinedCommandName*"/>  
  
 \-或-  
  
 \<*object property*="{ *customClassName.customCommandName*}"/>  
  
<a name="xamlValues_ICommand"></a>   
## <a name="xaml-values"></a>XAML 值  
 *predefinedClassName*  
 其中一個預先定義的命令類別。  
  
 *predefinedCommandName*  
 其中一個預先定義的命令。  
  
 *customClassName*  
 自訂類別，其中包含自訂的命令。 自訂類別，通常需要`xlmns`前置詞對應，請參閱 < [XAML 命名空間和 WPF XAML 命名空間對應](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。  
  
 *customCommandName*  
 自訂的命令。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CanExecute">
      <MemberSignature Language="C#" Value="public bool CanExecute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanExecute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ICommand.CanExecute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanExecute (parameter As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanExecute(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">命令所用的資料。  如果命令不需要傳遞資料，則這個物件可設為 <see langword="null" />。</param>
        <summary>定義用來判斷命令是否能以其目前狀態執行的方法。</summary>
        <returns>
          如果這個命令可執行，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，命令來源會呼叫<xref:System.Windows.Input.ICommand.CanExecute%2A>方法時<xref:System.Windows.Input.ICommand.CanExecuteChanged>就會引發事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="CanExecuteChanged">
      <MemberSignature Language="C#" Value="event EventHandler CanExecuteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CanExecuteChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.ICommand.CanExecuteChanged" />
      <MemberSignature Language="VB.NET" Value="Event CanExecuteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CanExecuteChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於影響命令是否應執行的變更發生時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，命令來源呼叫<xref:System.Windows.Input.ICommand.CanExecute%2A>命令時就會發生此事件。  
  
 一般來說，如果無法執行命令，命令來源停用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Execute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ICommand.Execute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">命令所用的資料。  如果命令不需要傳遞資料，則這個物件可設為 <see langword="null" />。</param>
        <summary>定義叫用命令時要呼叫的方法。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
  </Members>
</Type>