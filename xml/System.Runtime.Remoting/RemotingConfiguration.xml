<Type Name="RemotingConfiguration" FullName="System.Runtime.Remoting.RemotingConfiguration">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0554d2e88d141d7556faab29eb0b0384d9715fea" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51873273" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RemotingConfiguration extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingConfiguration" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingConfiguration abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingConfiguration = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供各種靜態 (Static) 方法來設定遠端基礎結構。</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ApplicationId">
      <MemberSignature Language="C#" Value="public static string ApplicationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationId : string" Usage="System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前正在執行的應用程式 ID。</summary>
        <value>
          <see cref="T:System.String" />，包含目前正在執行的應用程式 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式識別碼前面會加上目前正在執行的應用程式所建立之物件的 uri。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">立即呼叫端沒有基礎結構使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">針對使用基礎結構程式碼執行作業。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定遠端應用程式的名稱。</summary>
        <value>遠端應用程式的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 透過目前的屬性，或是透過組態檔，可以一次，設定應用程式名稱。 如果應用程式正在執行在裝載環境，例如網際網路資訊服務 (IIS) 中，這個值可能會有已設定 （通常是以虛擬目錄中）。 目前的屬性會傳回`null`如果尚未設定應用程式名稱。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Runtime.Remoting.RemotingConfiguration.ApplicationName%2A>屬性以表示遠端處理應用程式的名稱。 完整範例程式碼，請參閱範例<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>和<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A>方法。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
  
 下列程式碼範例示範如何存取遠端物件的具名的應用程式。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
 [!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。 只有在設定屬性值時才會擲回這個例外狀況。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="static member Configure : string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.Configure filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use Configure(String,Boolean)")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.Remoting.RemotingConfiguration.Configure(string fileName, bool ensureSecurity) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">遠端組態檔的名稱。 可以是 <see langword="null" />。</param>
        <summary>讀取組態檔，並設定遠端基礎結構。 <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" /> 已經過時。 請改用 <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%29> 已經過時。 請改用 <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>。  
  
 傳遞`null`做為`filename`參數會導致遠端執行功能的預設初始化，而不需要組態檔是否存在。  
  
 如需組態檔語法，請參閱[遠端設定結構描述](https://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)。  
  
> [!NOTE]
>  傳址方式封送處理物件 (Mbr) 不永遠位於記憶體中。 相反地，除非類型覆寫<xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType>若要控制它自己的存留期原則，每個 MBR 具有有限的存留期之前的.NET Framework 遠端處理系統開始刪除它，並回收記憶體的程序。 如需詳細資訊，請參閱 <<c0> [ 存留期租用期](https://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a)。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#1)]
 [!code-vb[RemotingConfiguration_Configure_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename, bool ensureSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename, bool ensureSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String, ensureSecurity As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename, bool ensureSecurity);" />
      <MemberSignature Language="F#" Value="static member Configure : string * bool -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.Configure (filename, ensureSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="ensureSecurity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">遠端組態檔的名稱。 可以是 <see langword="null" />。</param>
        <param name="ensureSecurity">如果設定為 <see langword="true" />，則需要安全性。 如果設定為 <see langword="false" />，則不需要安全性，但仍然可以使用它。</param>
        <summary>讀取組態檔，並設定遠端基礎結構。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳遞`null`做為`filename`參數會導致遠端執行功能的預設初始化，而不需要組態檔是否存在。 如需遠端處理和安全性詳細資訊，請參閱[遠端處理中的安全性。](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/9hwst9th(v=vs.100))  
  
 如需組態檔語法，請參閱[遠端設定結構描述](https://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)。  
  
> [!NOTE]
>  傳址方式封送處理物件 (Mbr) 不永遠位於記憶體中。 相反地，除非類型覆寫<xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType>若要控制它自己的存留期原則，每個 MBR 具有有限的存留期之前的.NET Framework 遠端處理系統開始刪除它，並回收記憶體的程序。 如需詳細資訊，請參閱 <<c0> [ 存留期租用期](https://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsEnabled">
      <MemberSignature Language="C#" Value="public static bool CustomErrorsEnabled (bool isLocalRequest);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CustomErrorsEnabled(bool isLocalRequest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CustomErrorsEnabled (isLocalRequest As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CustomErrorsEnabled(bool isLocalRequest);" />
      <MemberSignature Language="F#" Value="static member CustomErrorsEnabled : bool -&gt; bool" Usage="System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled isLocalRequest" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isLocalRequest" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isLocalRequest">若要指定本機呼叫端，為 <see langword="true" />；若要指定遠端呼叫端，則為 <see langword="false" />。</param>
        <summary>指示這個應用程式定義域中的伺服器通道是否會將篩選過或完整的例外狀況資訊，傳回至本機或遠端的呼叫端。</summary>
        <returns>如果僅將篩選的例外狀況資訊傳回至本機或遠端呼叫端，則為 <see langword="true" />，正如 <paramref name="isLocalRequest" /> 參數所指定的，如果傳回完整的例外狀況資訊，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完整的例外狀況資訊包括確切的伺服器例外狀況和伺服器堆疊追蹤。 篩選過的資訊包括標準的遠端例外狀況，但不包括伺服器堆疊追蹤。  
  
 `CustomErrorsEnabled`方法會反映中所指定的組態設定`mode`屬性`<customErrors>`應用程式組態檔的項目。 如需有關組態選項的詳細資訊，請參閱 < [ &#91; \<topic://cpconconfiguration >&#93;](https://msdn.microsoft.com/library/92c0c097-d984-4315-835b-7490ecdf1097)。  
  
 下表顯示這三種伺服器通道屬性值，指定哪個呼叫端接收例外狀況資訊，以及它們所接收的資訊類型。  
  
|值|描述|  
|-----------|-----------------|  
|`off`|所有呼叫端都接收完整的例外狀況資訊。|  
|`on`|所有呼叫端都接收篩選過的例外狀況資訊。|  
|`remoteOnly`|本機呼叫端接收完整的例外狀況資訊；遠端呼叫端接收篩選過的例外狀況資訊。|  
  
 下表顯示的互動`isLocalRequest`參數和伺服器通道屬性。  
  
|值|isLocalRequest|傳回值|描述|  
|-----------|--------------------|------------------|-----------------|  
|`on`|`true`|`true`|本機呼叫端接收篩選過的例外狀況資訊。|  
|`on`|`false`|`true`|遠端呼叫端接收篩選過的例外狀況資訊。|  
|`off`|`true`|`false`|本機呼叫端都接收完整的例外狀況資訊。|  
|`off`|`false`|`false`|遠端呼叫端都接收完整的例外狀況資訊。|  
|`remoteOnly`|`true`|`false`|本機呼叫端都接收完整的例外狀況資訊。|  
|`remoteOnly`|`false`|`true`|遠端呼叫端接收篩選過的例外狀況資訊。|  
  
 如需使用應用程式組態檔控制的例外狀況資訊傳回給呼叫者的詳細資訊，請參閱`<customErrors>`項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CustomErrorsMode As CustomErrorsModes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::CustomErrorsModes CustomErrorsMode { System::Runtime::Remoting::CustomErrorsModes get(); void set(System::Runtime::Remoting::CustomErrorsModes value); };" />
      <MemberSignature Language="F#" Value="member this.CustomErrorsMode : System.Runtime.Remoting.CustomErrorsModes with get, set" Usage="System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.CustomErrorsModes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出如何處理自訂錯誤。</summary>
        <value>
          <see cref="T:System.Runtime.Remoting.CustomErrorsModes" /> 列舉型別的成員，其指出如何處理自訂錯誤。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedClientTypes () As ActivatedClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedClientTypeEntry ^&gt; ^ GetRegisteredActivatedClientTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredActivatedClientTypes : unit -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取登錄在用戶端做為將遠端啟動型別的物件型別陣列。</summary>
        <returns>登錄在用戶端做為將遠端啟動型別的物件型別陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端啟動物件的詳細說明，請參閱 <<c0> [ 用戶端啟動過程](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedServiceTypes () As ActivatedServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedServiceTypeEntry ^&gt; ^ GetRegisteredActivatedServiceTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredActivatedServiceTypes : unit -&gt; System.Runtime.Remoting.ActivatedServiceTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取登錄在服務端可從用戶端要求啟動的物件型別陣列。</summary>
        <returns>登錄在服務端可從用戶端要求啟動的物件型別陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端啟動物件的詳細說明，請參閱 <<c0> [ 用戶端啟動過程](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#2)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownClientTypes () As WellKnownClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownClientTypeEntry ^&gt; ^ GetRegisteredWellKnownClientTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredWellKnownClientTypes : unit -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取登錄在用戶端做為已知型別的物件型別陣列。</summary>
        <returns>登錄在用戶端做為已知型別的物件型別陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已知物件型別可以是單一呼叫或單一物件。 如果單一呼叫的物件類型，它的新執行個體被建立每次從用戶端呼叫進來。 一個執行個體，該物件會處理單一物件的所有呼叫。  
  
 如需已知物件的更詳細說明，請參閱[啟用伺服器](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CPP/remotingconfiguration_getregisteredwellknownclient_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CS/remotingconfiguration_getregisteredwellknownclient_client.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/VB/remotingconfiguration_getregisteredwellknownclient_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownServiceTypes () As WellKnownServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownServiceTypeEntry ^&gt; ^ GetRegisteredWellKnownServiceTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredWellKnownServiceTypes : unit -&gt; System.Runtime.Remoting.WellKnownServiceTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取登錄在服務端做為已知型別的物件型別陣列。</summary>
        <returns>登錄在服務端做為已知型別的物件型別陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已知物件型別可以是單一呼叫或單一物件。 如果單一呼叫的物件類型，它的新執行個體被建立每次從用戶端呼叫進來。 一個執行個體，該物件會處理單一物件的所有呼叫。  
  
 如需已知物件的更詳細說明，請參閱[啟用伺服器](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#2)]
 [!code-vb[RemotingConfiguration_Configure_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsActivationAllowed">
      <MemberSignature Language="C#" Value="public static bool IsActivationAllowed (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsActivationAllowed(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsActivationAllowed (svrType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsActivationAllowed(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsActivationAllowed : Type -&gt; bool" Usage="System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">要檢查的物件 <see cref="T:System.Type" />。</param>
        <summary>傳回布林 (Boolean) 值，指出指定的 <see cref="T:System.Type" /> 是否可由用戶端啟動。</summary>
        <returns>如果指定的 <see cref="T:System.Type" /> 可由用戶端啟動，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的方法來判斷物件的啟動時，可在伺服器端<xref:System.Type>明確允許的伺服器。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsRemotelyActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>檢查指定物件型別是否登錄為遠端啟動的用戶端型別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (svrType As Type) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsRemotelyActivatedClientType : Type -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">要檢查的物件型別。</param>
        <summary>檢查指定物件 <see cref="T:System.Type" /> 是否登錄為遠端啟動的用戶端型別。</summary>
        <returns>
          <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />，對應至指定的物件型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CS/remotingconfiguration_isremotelyactivatedclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/VB/remotingconfiguration_isremotelyactivatedclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)">用戶端啟動過程</related>
      </Docs>
    </Member>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (typeName As String, assemblyName As String) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="static member IsRemotelyActivatedClientType : string * string -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType (typeName, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要檢查的物件型別名稱。</param>
        <param name="assemblyName">要檢查的物件組件名稱。</param>
        <summary>檢查由型別名稱和組件名稱指定的物件是否登錄為遠端啟動的用戶端型別。</summary>
        <returns>
          <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />，對應至指定的物件型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CS/remotingconfiguration_isremotelyactivatedclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/VB/remotingconfiguration_isremotelyactivatedclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)">用戶端啟動過程</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>檢查指定物件型別是否登錄為已知用戶端型別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (svrType As Type) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsWellKnownClientType : Type -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">要檢查的物件 <see cref="T:System.Type" />。</param>
        <summary>檢查指定物件 <see cref="T:System.Type" /> 是否登錄為已知用戶端型別。</summary>
        <returns>
          <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />，對應至指定的物件型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CPP/remotingconfiguration_iswellknownclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CS/remotingconfiguration_iswellknownclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/VB/remotingconfiguration_iswellknownclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)">伺服器啟動過程</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (typeName As String, assemblyName As String) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="static member IsWellKnownClientType : string * string -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType (typeName, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要檢查的物件型別名稱。</param>
        <param name="assemblyName">要檢查的物件組件名稱。</param>
        <summary>檢查由型別名稱和組件名稱指定的物件是否登錄為已知用戶端型別。</summary>
        <returns>
          <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />，對應至指定的物件型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CPP/remotingconfiguration_iswellknownclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CS/remotingconfiguration_iswellknownclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/VB/remotingconfiguration_iswellknownclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)">伺服器啟動過程</related>
      </Docs>
    </Member>
    <Member MemberName="ProcessId">
      <MemberSignature Language="C#" Value="public static string ProcessId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProcessId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProcessId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessId : string" Usage="System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前正在執行的處理序 ID。</summary>
        <value>
          <see cref="T:System.String" />，包含目前正在執行的處理序 ID。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">立即呼叫端沒有基礎結構使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">針對使用基礎結構程式碼執行作業。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在用戶端上登錄物件 <see cref="T:System.Type" /> 為可在伺服器上啟動的型別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (System.Runtime.Remoting.ActivatedClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Runtime.Remoting.ActivatedClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedClientType (entry As ActivatedClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(System::Runtime::Remoting::ActivatedClientTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedClientType : System.Runtime.Remoting.ActivatedClientTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">用戶端啟動型別的組態設定。</param>
        <summary>登錄記錄在用戶端上所提供 <see cref="T:System.Type" /> 中的物件 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> 為可在伺服器上啟動的型別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在伺服器上建立用戶端啟動物件的執行個體，您必須知道其<xref:System.Type>，則必須使用註冊的伺服器端上<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>方法。 若要取得的用戶端啟動物件的新執行個體的 proxy，用戶端必須先註冊通道，以與<xref:System.Runtime.Remoting.Channels.ChannelServices>，然後再啟動物件，藉由呼叫`new`。  
  
 若要啟動的用戶端啟動物件類型`new`關鍵字，您必須先註冊用戶端端使用的物件型別<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法。 呼叫<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法提供的遠端基礎結構的遠端應用程式的位置，`new`嘗試建立它。 如果相反地，您使用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法用來建立新的執行個體的用戶端啟動物件，因此需要將用戶端上的沒有之前註冊，您必須做為參數，提供遠端應用程式的 URL。 若要提供<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法與您想要用來建立物件的伺服器 URL，您必須將封裝中的執行個體的 URL<xref:System.Runtime.Remoting.Activation.UrlAttribute>類別。  
  
 用戶端啟動物件的詳細說明，請參閱 <<c0> [ 用戶端啟動過程](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (Type type, string appUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Type type, string appUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(Type ^ type, System::String ^ appUrl);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedClientType : Type * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType (type, appUrl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="appUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">物件 <see cref="T:System.Type" />。</param>
        <param name="appUrl">啟動這個型別的應用程式的 URL。</param>
        <summary>在用戶端上登錄物件 <see cref="T:System.Type" /> 為可在伺服器上啟動的型別，藉由使用指定的參數初始化 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在伺服器上建立用戶端啟動物件的執行個體，您必須知道其<xref:System.Type>，則必須使用註冊的伺服器端上<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>方法。 若要取得的用戶端啟動物件的新執行個體的 proxy，用戶端必須先註冊通道，以與<xref:System.Runtime.Remoting.Channels.ChannelServices>，然後再啟動物件，藉由呼叫`new`。  
  
 若要啟動的用戶端啟動物件類型`new`關鍵字，您必須先註冊用戶端端使用的物件型別<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法。 呼叫<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法提供的遠端基礎結構的遠端應用程式的位置，`new`嘗試建立它。 如果相反地，您使用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法用來建立新的執行個體的用戶端啟動物件，因此需要將用戶端上的沒有之前註冊，您必須做為參數，提供遠端應用程式的 URL。 若要提供<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法與您想要用來建立物件的伺服器 URL，您必須將封裝中的執行個體的 URL<xref:System.Runtime.Remoting.Activation.UrlAttribute>類別。  
  
 用戶端啟動物件的詳細說明，請參閱[用戶端啟動過程](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))  
  
   
  
## Examples  
 下列程式碼範例會示範用戶端上的物件型別登錄為可以在伺服器啟動的型別。 對應至提供的用戶端程式碼的伺服器程式碼，請參閱範例<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>方法。  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/client.cpp#1)]
 [!code-csharp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/client.cs#1)]
 [!code-vb[RemotingConfiguration.ClientActivation#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 或 <paramref name="URI" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在服務端上登錄物件 <see cref="T:System.Type" /> 為可從用戶端要求啟動的型別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (System.Runtime.Remoting.ActivatedServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Runtime.Remoting.ActivatedServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedServiceType (entry As ActivatedServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(System::Runtime::Remoting::ActivatedServiceTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedServiceType : System.Runtime.Remoting.ActivatedServiceTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">用戶端啟動型別的組態設定。</param>
        <summary>登錄記錄在服務端上所提供 <see cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" /> 中的物件型別為可從用戶端要求啟動的型別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在伺服器上建立用戶端啟動物件的執行個體，您必須知道其<xref:System.Type>，則必須使用註冊的伺服器端上<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>方法。 若要取得的用戶端啟動物件的新執行個體的 proxy，用戶端必須先註冊通道，以與<xref:System.Runtime.Remoting.Channels.ChannelServices>，然後再啟動物件，藉由呼叫`new`或<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>。  
  
 若要啟動的用戶端啟動物件類型`new`關鍵字，您必須先註冊用戶端端使用的物件型別<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法。 呼叫<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法可讓遠端基礎結構的遠端應用程式中，位置其中`new`嘗試建立它。 如果相反地，您使用<xref:System.Activator.CreateInstance%2A>方法用來建立新的執行個體的用戶端啟動物件，因此需要將用戶端上的沒有之前註冊，您必須做為參數，提供遠端應用程式的 URL。 若要提供<xref:System.Activator.CreateInstance%2A>方法與您想要用來建立物件的伺服器 URL，您必須將封裝中的執行個體的 URL<xref:System.Runtime.Remoting.Activation.UrlAttribute>類別。  
  
 用戶端啟動物件的詳細說明，請參閱 <<c0> [ 用戶端啟動過程](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedServiceType : Type -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要登錄的物件 <see cref="T:System.Type" />。</param>
        <summary>在服務端登錄指定的物件型別為可從用戶端要求啟動的型別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在伺服器上建立用戶端啟動物件的執行個體，您必須知道其<xref:System.Type>，則必須使用註冊的伺服器端上<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>方法。 若要取得的用戶端啟動物件的新執行個體的 proxy，用戶端必須先註冊通道，以與<xref:System.Runtime.Remoting.Channels.ChannelServices>，然後再啟動物件，藉由呼叫`new`或<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>。  
  
 若要啟動的用戶端啟動物件類型`new`關鍵字，您必須先註冊用戶端端使用的物件型別<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法。 呼叫<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法可讓遠端基礎結構的遠端應用程式中，位置其中`new`嘗試建立它。 如果相反地，您使用<xref:System.Activator.CreateInstance%2A>方法用來建立新的執行個體的用戶端啟動物件，因此需要將用戶端上的沒有之前註冊，您必須做為參數，提供遠端應用程式的 URL。 若要提供<xref:System.Activator.CreateInstance%2A>方法與您想要用來建立物件的伺服器 URL，您必須將封裝中的執行個體的 URL<xref:System.Runtime.Remoting.Activation.UrlAttribute>類別。  
  
 用戶端啟動物件的詳細說明，請參閱 <<c0> [ 用戶端啟動過程](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
   
  
## Examples  
 下列程式碼範例示範在伺服器上的物件型別登錄為可以由用戶端啟動型別。 對應至提供的伺服器程式碼的用戶端程式碼，請參閱範例<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法。  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ClientActivation#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/server.vb#2)]  
  
 下列程式碼範例會顯示在上述範例程式碼中註冊的服務物件。  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/service.cpp#3)]
 [!code-csharp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/service.cs#3)]
 [!code-vb[RemotingConfiguration.ClientActivation#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/service.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在用戶端上登錄物件 <see cref="T:System.Type" /> 為已知型別 (單一呼叫或單一物件)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (System.Runtime.Remoting.WellKnownClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Runtime.Remoting.WellKnownClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownClientType (entry As WellKnownClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(System::Runtime::Remoting::WellKnownClientTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownClientType : System.Runtime.Remoting.WellKnownClientTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">已知型別的組態設定。</param>
        <summary>登錄記錄在用戶端上所提供 <see cref="T:System.Type" /> 中的物件 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> 為可在伺服器上啟動的已知型別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 知道已註冊的已知物件任何的 URI 用戶端可以取得物件的 proxy 註冊通道，則會使用偏好<xref:System.Runtime.Remoting.Channels.ChannelServices>，並啟動該物件藉由呼叫`new`或<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>。 若要啟動的已知物件具有`new`，您必須先註冊已知物件型別，在用戶端使用<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法。 呼叫<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法可讓遠端基礎結構的遠端物件上，可讓位置`new`關鍵字來建立它。 如果相反地，您使用<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法來啟動已知物件，您必須提供它的物件 url 做為引數，因此沒有先前的登錄用戶端上需要。  
  
 已知物件的詳細說明，請參閱 <<c0> [ 啟用伺服器](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (Type type, string objectUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Type type, string objectUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(Type ^ type, System::String ^ objectUrl);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownClientType : Type * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType (type, objectUrl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">物件 <see cref="T:System.Type" />。</param>
        <param name="objectUrl">已知用戶端物件的 URL。</param>
        <summary>使用指定的參數初始化 <see cref="T:System.Type" /> 類別的新執行個體，在用戶端上將物件 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> 登錄為可在伺服器上啟動的已知型別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 知道已註冊的已知物件任何的 URI 用戶端可以取得物件的 proxy 註冊通道，則會使用偏好<xref:System.Runtime.Remoting.Channels.ChannelServices>，並啟動該物件藉由呼叫`new`或<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>。 若要啟動的已知物件具有`new`，您必須先註冊已知物件型別，在用戶端使用<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法。 呼叫<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法可讓遠端基礎結構的遠端物件上，可讓位置`new`關鍵字來建立它。 如果相反地，您使用<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法來啟動已知物件，您必須提供它的物件 url 做為引數，因此沒有先前的登錄用戶端上需要。  
  
 已知物件的詳細說明，請參閱 <<c0> [ 啟用伺服器](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 下列程式碼範例會示範用戶端上的物件型別登錄為已知型別。 對應至提供的用戶端程式碼的伺服器程式碼，請參閱範例<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A>方法。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#5)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#5)]
 [!code-vb[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#5)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
[!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
[!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#7)]
[!code-csharp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#7)]
[!code-vb[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在服務端上登錄物件 <see cref="T:System.Type" /> 為已知型別 (單一呼叫或單一物件)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (System.Runtime.Remoting.WellKnownServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Runtime.Remoting.WellKnownServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownServiceType (entry As WellKnownServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(System::Runtime::Remoting::WellKnownServiceTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownServiceType : System.Runtime.Remoting.WellKnownServiceTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">已知型別的組態設定。</param>
        <summary>登錄記錄在服務端上所提供 <see cref="T:System.Type" /> 中的物件 <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> 為已知型別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 知道已註冊的已知物件任何的 URI 用戶端可以取得物件的 proxy 註冊通道，則會使用偏好<xref:System.Runtime.Remoting.Channels.ChannelServices>，並啟動該物件藉由呼叫`new`或<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法。 若要啟動的已知物件具有`new`，您必須先註冊已知物件型別，在用戶端使用<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法。 呼叫<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法可讓遠端基礎結構的遠端物件上，可讓位置`new`關鍵字來建立它。 如果相反地，您使用<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法來啟動已知物件，您必須提供它的物件 url 做為引數，因此沒有先前的登錄用戶端上需要。  
  
 當呼叫抵達伺服器時，.NET Framework 從訊息擷取的 URI 時，會檢查遠端資料表，以找出參考之物件的比對 URI，並接著會執行個體化物件，如有必要，將方法呼叫轉送至的物件。 如果物件註冊為<xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>，方法呼叫完成之後終結。 呼叫每一個方法被建立物件的新執行個體。 唯一的差別<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>和`new`在於，前者可讓您指定的 URL 做為參數，而後者從組態取得 URL。  
  
 註冊程序未執行個體化遠端物件本身。 這只有在用戶端嘗試在物件上呼叫方法時執行的動作，或啟動從用戶端物件。  
  
 已知物件的詳細說明，請參閱 <<c0> [ 啟用伺服器](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 [!code-cpp[CreateObjRef2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/CreateObjRef2/CPP/example.cpp#2)]
 [!code-csharp[CreateObjRef2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/CreateObjRef2/CS/example.cs#2)]
 [!code-vb[CreateObjRef2#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/CreateObjRef2/VB/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Type type, string objectUri, valuetype System.Runtime.Remoting.WellKnownObjectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(Type ^ type, System::String ^ objectUri, System::Runtime::Remoting::WellKnownObjectMode mode);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownServiceType : Type * string * System.Runtime.Remoting.WellKnownObjectMode -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType (type, objectUri, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUri" Type="System.String" />
        <Parameter Name="mode" Type="System.Runtime.Remoting.WellKnownObjectMode" />
      </Parameters>
      <Docs>
        <param name="type">物件 <see cref="T:System.Type" />。</param>
        <param name="objectUri">物件 URI。</param>
        <param name="mode">要登錄的已知物件型別的啟動模式  (請參閱<see cref="T:System.Runtime.Remoting.WellKnownObjectMode" />)。</param>
        <summary>在服務端上登錄物件 <see cref="T:System.Type" /> 為已知型別，藉由使用指定的參數來初始化 <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 知道已註冊的已知物件任何的 URI 用戶端可以取得物件的 proxy 註冊通道，則會使用偏好<xref:System.Runtime.Remoting.Channels.ChannelServices>，並啟動該物件藉由呼叫`new`或<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法。 若要啟動的已知物件具有`new`，您必須先註冊已知物件型別，在用戶端使用<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法。 呼叫<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法可讓遠端基礎結構的遠端物件上，可讓位置`new`關鍵字來建立它。 如果相反地，您使用<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法來啟動已知物件，您必須提供它的物件 url 做為引數，因此沒有先前的登錄用戶端上需要。  
  
 當呼叫抵達伺服器時，.NET Framework 從訊息擷取的 URI 時，會檢查遠端資料表，以找出參考之物件的比對 URI，並接著會執行個體化物件，如有必要，將方法呼叫轉送至的物件。 如果物件註冊為<xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>，方法呼叫完成之後終結。 呼叫每一個方法被建立物件的新執行個體。 唯一的差別<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>和`new`在於，前者可讓您指定的 URL 做為參數，而後者從組態取得 URL。  
  
 註冊程序未執行個體化遠端物件本身。 這只有在用戶端嘗試在物件上呼叫方法時執行的動作，或啟動從用戶端物件。  
  
 已知物件的詳細說明，請參閱 <<c0> [ 啟用伺服器](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 下列程式碼範例會示範在伺服器上的物件型別登錄為已知物件型別。 對應至提供的伺服器程式碼的用戶端程式碼，請參閱範例<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#1)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#1)]
 [!code-vb[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#1)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
[!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
[!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#3)]
[!code-csharp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#3)]
[!code-vb[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#3)]  
  
 下列程式碼範例會顯示在上述範例程式碼中註冊的服務物件。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/service.cpp#4)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/service.cs#4)]
 [!code-vb[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/service.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">至少有一個呼叫堆疊中較高的呼叫端，不具有設定遠端類型和通道的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">遠端基礎結構的組態。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
  </Members>
</Type>