<Type Name="TypeCodeDomSerializer" FullName="System.ComponentModel.Design.Serialization.TypeCodeDomSerializer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="03158091dea1e91d871fe438a3a204490ccae7dd" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37697999" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TypeCodeDomSerializer : System.ComponentModel.Design.Serialization.CodeDomSerializerBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TypeCodeDomSerializer extends System.ComponentModel.Design.Serialization.CodeDomSerializerBase" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeCodeDomSerializer&#xA;Inherits CodeDomSerializerBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeCodeDomSerializer : System::ComponentModel::Design::Serialization::CodeDomSerializerBase" />
  <TypeSignature Language="F#" Value="type TypeCodeDomSerializer = class&#xA;    inherit CodeDomSerializerBase" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Design.Serialization.CodeDomSerializerBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DefaultSerializationProvider(typeof(System.ComponentModel.Design.Serialization.CodeDomSerializationProvider))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>將物件序列化為新的型別。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer>類別會執行相同的工作<xref:System.ComponentModel.Design.Serialization.CodeDomSerializer>，但將物件序列化為透過此類別會定義新的型別。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.Design.Serialization.CodeDomSerializer" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
    <altmember cref="T:System.CodeDom.Compiler.CodeDomProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeCodeDomSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeCodeDomSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public virtual object Deserialize (System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager, System.CodeDom.CodeTypeDeclaration declaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Deserialize(class System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager, class System.CodeDom.CodeTypeDeclaration declaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Deserialize(System.ComponentModel.Design.Serialization.IDesignerSerializationManager,System.CodeDom.CodeTypeDeclaration)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Deserialize (manager As IDesignerSerializationManager, declaration As CodeTypeDeclaration) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Deserialize(System::ComponentModel::Design::Serialization::IDesignerSerializationManager ^ manager, System::CodeDom::CodeTypeDeclaration ^ declaration);" />
      <MemberSignature Language="F#" Value="abstract member Deserialize : System.ComponentModel.Design.Serialization.IDesignerSerializationManager * System.CodeDom.CodeTypeDeclaration -&gt; obj&#xA;override this.Deserialize : System.ComponentModel.Design.Serialization.IDesignerSerializationManager * System.CodeDom.CodeTypeDeclaration -&gt; obj" Usage="typeCodeDomSerializer.Deserialize (manager, declaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <Parameter Name="declaration" Type="System.CodeDom.CodeTypeDeclaration" />
      </Parameters>
      <Docs>
        <param name="manager">用於序列化的序列化管理員。</param>
        <param name="declaration">要用於序列化的型別宣告。</param>
        <summary>還原序列化指定的型別宣告 (Type Declaration)。</summary>
        <returns>根物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Deserialize%2A>方法還原序列化先前序列化的程式碼型別宣告。 下表顯示工作預設實作會執行。  
  
|工作|描述|  
|----------|-----------------|  
|區分大小寫檢查|實作搜尋<xref:System.CodeDom.Compiler.CodeDomProvider>決定如果它應該將成員視為區分大小寫或不區分大小寫的服務。|  
|陳述式排序|所有成員變數和 init 方法的本機變數會都儲存在資料表中。 然後在 init 方法中的每個陳述式加入至陳述式集合中根據其左上方，組成群組，以便指派或作業特定的變數上的所有陳述式之下該變數。 沒有陳述式的變數都會被捨棄。|  
|還原序列化|每個變數的陳述式集合會根據變數還原序列化。|  
  
 下表顯示服務<xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Deserialize%2A>方法需要。  
  
|服務|描述|  
|-------------|-----------------|  
|<xref:System.CodeDom.Compiler.CodeDomProvider>|雖然不是絕對必要，服務，如果有的話，用來決定序列化是否要區分大小寫或不區分大小寫。|  
|<xref:System.ComponentModel.IContainer>|如果物件不存在名稱表格中還原序列化期間，查詢<xref:System.ComponentModel.IContainer>為止。 如果此查詢成功，會檢查物件的容器。 容器也會做為替代的元件所需的任何容器引數。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="manager" /> 或 <paramref name="typeDecl" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.CodeDomSerializer" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <altmember cref="T:System.CodeDom.Compiler.CodeDomProvider" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="GetInitializeMethod">
      <MemberSignature Language="C#" Value="protected virtual System.CodeDom.CodeMemberMethod GetInitializeMethod (System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager, System.CodeDom.CodeTypeDeclaration declaration, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.CodeDom.CodeMemberMethod GetInitializeMethod(class System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager, class System.CodeDom.CodeTypeDeclaration declaration, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.GetInitializeMethod(System.ComponentModel.Design.Serialization.IDesignerSerializationManager,System.CodeDom.CodeTypeDeclaration,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetInitializeMethod (manager As IDesignerSerializationManager, declaration As CodeTypeDeclaration, value As Object) As CodeMemberMethod" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::CodeDom::CodeMemberMethod ^ GetInitializeMethod(System::ComponentModel::Design::Serialization::IDesignerSerializationManager ^ manager, System::CodeDom::CodeTypeDeclaration ^ declaration, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetInitializeMethod : System.ComponentModel.Design.Serialization.IDesignerSerializationManager * System.CodeDom.CodeTypeDeclaration * obj -&gt; System.CodeDom.CodeMemberMethod&#xA;override this.GetInitializeMethod : System.ComponentModel.Design.Serialization.IDesignerSerializationManager * System.CodeDom.CodeTypeDeclaration * obj -&gt; System.CodeDom.CodeMemberMethod" Usage="typeCodeDomSerializer.GetInitializeMethod (manager, declaration, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeMemberMethod</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <Parameter Name="declaration" Type="System.CodeDom.CodeTypeDeclaration" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="manager">用於序列化的序列化管理員。</param>
        <param name="declaration">用於序列化的類型宣告。</param>
        <param name="value">供序列化使用的值。</param>
        <summary>傳回一個方法，而在該方法中會儲存用於序列化成員的陳述式。</summary>
        <returns>用於為指定成員發出所有初始化程式碼的方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.GetInitializeMethod%2A>方法會傳回指定成員發出所有初始化程式碼的方法。 預設實作會傳回空的建構函式。 如果相同的方法是將傳回之多個值，應該會傳回相同的執行個體的方法。 您可以使用<xref:System.CodeDom.CodeObject.UserData%2A?displayProperty=nameWithType>字典記住您已建立的方法。 `typeDecl`參數也可用來新增基礎結構的方法。 例如，如果您想要發出的每個物件不同的方法，您需要依次呼叫所有這些方法的單一方法。 這個方法可以加入所需的程式碼類型宣告。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="manager" />
          <paramref name="typeDecl" /> 或 <paramref name="value" /> 是 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.CodeDomSerializer" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <altmember cref="T:System.CodeDom.Compiler.CodeDomProvider" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="GetInitializeMethods">
      <MemberSignature Language="C#" Value="protected virtual System.CodeDom.CodeMemberMethod[] GetInitializeMethods (System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager, System.CodeDom.CodeTypeDeclaration declaration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.CodeDom.CodeMemberMethod[] GetInitializeMethods(class System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager, class System.CodeDom.CodeTypeDeclaration declaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.GetInitializeMethods(System.ComponentModel.Design.Serialization.IDesignerSerializationManager,System.CodeDom.CodeTypeDeclaration)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetInitializeMethods (manager As IDesignerSerializationManager, declaration As CodeTypeDeclaration) As CodeMemberMethod()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::CodeDom::CodeMemberMethod ^&gt; ^ GetInitializeMethods(System::ComponentModel::Design::Serialization::IDesignerSerializationManager ^ manager, System::CodeDom::CodeTypeDeclaration ^ declaration);" />
      <MemberSignature Language="F#" Value="abstract member GetInitializeMethods : System.ComponentModel.Design.Serialization.IDesignerSerializationManager * System.CodeDom.CodeTypeDeclaration -&gt; System.CodeDom.CodeMemberMethod[]&#xA;override this.GetInitializeMethods : System.ComponentModel.Design.Serialization.IDesignerSerializationManager * System.CodeDom.CodeTypeDeclaration -&gt; System.CodeDom.CodeMemberMethod[]" Usage="typeCodeDomSerializer.GetInitializeMethods (manager, declaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeMemberMethod[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <Parameter Name="declaration" Type="System.CodeDom.CodeTypeDeclaration" />
      </Parameters>
      <Docs>
        <param name="manager">用於序列化的序列化管理員。</param>
        <param name="declaration">用於序列化的類型宣告。</param>
        <summary>傳回要在還原序列化期間解譯的方法陣列。</summary>
        <returns>方法的 <see cref="T:System.CodeDom.CodeMemberMethod" /> 陣列，要在還原序列化期間解譯。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回在其建構函式的單一元素陣列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="manager" /> 或 <paramref name="typeDecl" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.CodeDomSerializer" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <altmember cref="T:System.CodeDom.Compiler.CodeDomProvider" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeTypeDeclaration Serialize (System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager, object root, System.Collections.ICollection members);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeTypeDeclaration Serialize(class System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager, object root, class System.Collections.ICollection members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Serialize(System.ComponentModel.Design.Serialization.IDesignerSerializationManager,System.Object,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Serialize (manager As IDesignerSerializationManager, root As Object, members As ICollection) As CodeTypeDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeTypeDeclaration ^ Serialize(System::ComponentModel::Design::Serialization::IDesignerSerializationManager ^ manager, System::Object ^ root, System::Collections::ICollection ^ members);" />
      <MemberSignature Language="F#" Value="abstract member Serialize : System.ComponentModel.Design.Serialization.IDesignerSerializationManager * obj * System.Collections.ICollection -&gt; System.CodeDom.CodeTypeDeclaration&#xA;override this.Serialize : System.ComponentModel.Design.Serialization.IDesignerSerializationManager * obj * System.Collections.ICollection -&gt; System.CodeDom.CodeTypeDeclaration" Usage="typeCodeDomSerializer.Serialize (manager, root, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="members" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="manager">用於序列化的序列化管理員。</param>
        <param name="root">要序列化的物件。</param>
        <param name="members">成員的選擇性集合。 可以為 <see langword="null" /> 或空白。</param>
        <summary>藉由建立定義根 (Root) 的新型別宣告序列化物件根。</summary>
        <returns>
          <see cref="T:System.CodeDom.CodeTypeDeclaration" />，定義根物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Serialize%2A>方法會序列化給定的根物件和要建立新的類型定義之成員的選擇性集合。 如果`members`集合包含值，這些值序列化。 做為成員變數或本機變數，將這些值可能會序列化。 這項決定是藉由擴充項屬性上呼叫的物件搜尋`GenerateMember`。 如果`true`，成員就會產生。 否則，會產生的本機變數。 為了方便起見，`members`集合可以包含根物件。 在此情況下，根物件不也會加入做為成員或本機變數。  
  
 如果是具名的物件，傳回型別名稱是取自根物件的名稱。 如果沒有，則名稱簡單類型名稱的根類別中傳遞。  
  
 下表顯示的預設實作所執行的工作<xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Serialize%2A>方法。  
  
|工作|描述|  
|----------|-----------------|  
|植入的內容|序列化內容會使用資料，包括初始化<xref:System.ComponentModel.Design.Serialization.RootContext>和 <xref:System.CodeDom.CodeTypeDeclaration>|  
|成員序列化|下一步<xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Serialize%2A>將逐步引導的所有成員和呼叫<xref:System.ComponentModel.Design.Serialization.CodeDomSerializerBase.SerializeToExpression%2A>。 因為序列化必須完成才視情況在<xref:System.ComponentModel.Design.Serialization.CodeDomSerializerBase.SerializeToExpression%2A>，這可確保序列化未完成兩次。|  
|根序列化|接下來，將根物件序列化和它的陳述式新增至陳述式集合。|  
|陳述式整合|所有物件都會都序列化之後，<xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Serialize%2A>方法排序陳述式，並且將它們新增至方法，從傳回<xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.GetInitializeMethod%2A>。 最後，建構函式在其中傳遞呼叫的所有方法所傳回<xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.GetInitializeMethod%2A>。|  
  
-  
  
 下表顯示的物件<xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer.Serialize%2A>方法置於內容堆疊。  
  
|執行個體|描述|  
|--------------|-----------------|  
|<xref:System.ComponentModel.Design.Serialization.TypeCodeDomSerializer>|此序列化程式。 衍生類別，可能會發現它可將加入這個類別的公用屬性。|  
|<xref:System.CodeDom.CodeTypeDeclaration>|正在建立的型別。 大部分的物件不需要直接存取。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="manager" /> 或 <paramref name="root" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.CodeDomSerializer" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <altmember cref="T:System.CodeDom.Compiler.CodeDomProvider" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
      </Docs>
    </Member>
  </Members>
</Type>