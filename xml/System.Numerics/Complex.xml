<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a0cda22c38e7360bbfcf554504d6be8b0e35673c" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48690367" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="3c1f9-101">表示複數。</span>
      <span class="sxs-lookup">
        <span data-stu-id="3c1f9-101">Represents a complex number.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-102">複數是包含實數和虛數部分的數字。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="3c1f9-103">複數 z 通常以表單 z = x + 爨文，其中*x*並*y*是實數，和*我*是具有屬性的虛單位*i*<sup>2</sup> =-1。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="3c1f9-104">複數的實數部分，由*x*，而且會以表示複數的虛數部分*y*。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="3c1f9-105"><xref:System.Numerics.Complex>型別會使用笛卡兒座標系統 （real 虛） 時具現化和管理複雜的數字。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="3c1f9-106">複數可以表示成二維座標系統，也就是複數平面的點。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="3c1f9-107">複數的實數部分，位於 x 軸 （水平軸），且虛數部分位於 y 軸 （垂直軸） 上。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="3c1f9-108">複平面中的任何時間點也可以表示根據其絕對值，使用極座標圖的座標系統，在極座標，點以兩個數字：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="3c1f9-109">它的範圍，也就是從原點的點的距離 （也就是 0，0 或 x 軸和 y 軸相交的點）。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="3c1f9-110">其階段，也就是在實數軸和從原點繪製點之間的角度。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="3c1f9-111">具現化複數</span><span class="sxs-lookup"><span data-stu-id="3c1f9-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="3c1f9-112">您可以指派到複數的值，以下列方式之一：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="3c1f9-113">藉由傳遞兩個<xref:System.Double>其建構函式的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="3c1f9-114">第一個值代表的複數，實數部分，而第二個值代表其虛數部分。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="3c1f9-115">這些值代表複數的二維的笛卡兒座標系統中的位置。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="3c1f9-116">藉由呼叫靜態 (`Shared`在 Visual Basic 中)<xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>方法，以從其極座標建立複數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="3c1f9-117">藉由指派<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.Single>，或<xref:System.Double>值<xref:System.Numerics.Complex>物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3c1f9-118">值會變成複數，實數部分，其虛數部分等於 0。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="3c1f9-119">（在 C# 中) 轉型或轉換 （在 Visual Basic)<xref:System.Decimal>或是<xref:System.Numerics.BigInteger>值<xref:System.Numerics.Complex>物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3c1f9-120">值會變成複數，實數部分，其虛數部分等於 0。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="3c1f9-121">藉由指定的方法或運算子所傳回的複數<xref:System.Numerics.Complex>物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3c1f9-122">例如，<xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType>是傳回加總的兩個複數，複數的靜態方法和<xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType>運算子兩個複數相加，並傳回結果。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="3c1f9-123">下列範例會示範每個指派值到複數的五種。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="3c1f9-124">複雜數字的作業</span><span class="sxs-lookup"><span data-stu-id="3c1f9-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="3c1f9-125"><xref:System.Numerics.Complex> .NET Framework 中的結構包含成員，可以提供下列功能：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="3c1f9-126">比較兩個複數相加，以判斷它們是否相等的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="3c1f9-127">若要執行複數算術運算的運算子。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="3c1f9-128"><xref:System.Numerics.Complex> 運算子可讓您能夠執行加法、 減法、 乘法、 除法和複雜數字的一元否定運算。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="3c1f9-129">執行複雜的數字其他數值作業的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="3c1f9-130">除了四個基本的算術運算，您可以引發指定的乘冪的複數，找出的平方根的複數，並取得複數的絕對值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="3c1f9-131">執行三角運算複雜數字上的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="3c1f9-132">例如，您可以計算角度表示複數的正切函數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="3c1f9-133">請注意，因為<xref:System.Numerics.Complex.Real%2A>並<xref:System.Numerics.Complex.Imaginary%2A>屬性是唯讀，您無法修改的現有值<xref:System.Numerics.Complex>物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="3c1f9-134">執行作業的所有方法<xref:System.Numerics.Complex>數字，其傳回的值屬於類型<xref:System.Numerics.Complex>，傳回新<xref:System.Numerics.Complex>數目。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="3c1f9-135">有效位數和複數</span><span class="sxs-lookup"><span data-stu-id="3c1f9-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="3c1f9-136">兩個雙精確度浮點值來表示複數的實數和虛數部分。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="3c1f9-137">這表示<xref:System.Numerics.Complex>值，例如雙精度浮點數值，可能會遺失有效位數數值作業的結果。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="3c1f9-138">這表示，嚴格相等的兩個比較<xref:System.Numerics.Complex>值可能會失敗，即使兩個值之間的差異是因為遺失有效位數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="3c1f9-139">如需詳細資訊，請參閱<xref:System.Double>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="3c1f9-140">例如，執行乘上數字的對數，應該傳回原始的數字。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="3c1f9-141">不過，在某些情況下，浮點值的精確度遺失的可能造成些微的差異，兩個值，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="3c1f9-142">同樣地，下列範例中，它會計算平方根<xref:System.Numerics.Complex>數字，則會產生稍微不同的結果，在 32 位元和 IA64 版本的.NET Framework。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="3c1f9-143">複雜數字、 無限大和 NaN</span><span class="sxs-lookup"><span data-stu-id="3c1f9-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="3c1f9-144">複數的實數和虛數部分都由<xref:System.Double>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="3c1f9-145">除了舉凡<xref:System.Double.MinValue?displayProperty=nameWithType>要<xref:System.Double.MaxValue?displayProperty=nameWithType>，複數的實數或虛數部分可以有值為<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，或<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c1f9-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，和<xref:System.Double.NaN?displayProperty=nameWithType>所有傳播任何算術或三角作業中。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="3c1f9-147">在下列範例中，除以<xref:System.Numerics.Complex.Zero>會產生複數的實數和虛數部分都<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c1f9-148">如此一來，執行乘法，這個值也會產生複數的實數和虛數部分<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c1f9-149">同樣地，執行的範圍溢位的乘法<xref:System.Double>所產生類型的複數的實數部分<xref:System.Double.NaN?displayProperty=nameWithType>，而其虛數部分是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c1f9-150">後續執行與這個複數的部門會傳回複數的實數部分<xref:System.Double.NaN?displayProperty=nameWithType>，而其虛數部分是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="3c1f9-151">使用複雜的數值無效，或，時發生溢位的數學運算<xref:System.Double>資料型別並不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="3c1f9-152">相反地，它們會傳回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，或<xref:System.Double.NaN?displayProperty=nameWithType>在下列情況下：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="3c1f9-153">由零傳回正數的劃分<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3c1f9-154">超出上限的任何作業<xref:System.Double>資料類型會傳回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3c1f9-155">零個傳回的負數的除法<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3c1f9-156">任何作業，就會溢位的下限<xref:System.Double>資料類型會傳回<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3c1f9-157">為零的零部門傳回<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3c1f9-158">其值的運算元執行任何作業<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，或<xref:System.Double.NaN?displayProperty=nameWithType>會傳回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，或<xref:System.Double.NaN?displayProperty=nameWithType>，取決於特定的作業。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="3c1f9-159">請注意，這適用於方法所執行的任何中繼計算。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="3c1f9-160">例如的乘法`new Complex(9e308, 9e308) and new Complex(2.5, 3.5)`會使用公式 (ac-bd) + （ad + bc） 我。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="3c1f9-161">相乘得出的實數部分的計算會評估運算式 9e308 \* 2.5-9e308 \* 3.5。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 \* 2.5 - 9e308 \* 3.5.</span></span> <span data-ttu-id="3c1f9-162">傳回此運算式中的每個中繼乘法<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>，並嘗試減去<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>從<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>傳回<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="3c1f9-163">複雜數字格式化</span><span class="sxs-lookup"><span data-stu-id="3c1f9-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="3c1f9-164">根據預設，複合的數字的字串表示會在表單`(`*實際*`,` *虛數*`)`，其中*實際*和*假想*是的字串表示法<xref:System.Double>形成複數的實數和虛數元件的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="3c1f9-165">一些多載<xref:System.Numerics.Complex.ToString%2A>方法允許自訂的字串表示，其中<xref:System.Double>以反映特定文化特性的格式化慣例，或出現在標準或自訂的數字所定義的特定格式的值格式字串。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="3c1f9-166">(如需詳細資訊，請參閱 <<c0> [ 標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="3c1f9-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="3c1f9-167">其中一種較常見的方式表達的複雜數字的字串表示的形式 a + bi，其中是複數的實數部分，而 b 是複數的虛數部分。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="3c1f9-168">電機理學士複數最常以 + bj。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="3c1f9-169">您可以使用這兩種形式其中一種方法來傳回複數的字串表示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="3c1f9-170">若要這樣做，請藉由實作中定義自訂的格式提供者<xref:System.ICustomFormatter>並<xref:System.IFormatProvider>介面，然後再呼叫<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3c1f9-171">下列範例會定義`ComplexFormatter`類別，做為字串的形式表示複數 a + bi 或 + bj。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="3c1f9-172">然後，下列範例會顯示 複雜數字的字串表示使用此自訂格式器。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">
          <span data-ttu-id="3c1f9-173">複數的實數部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-173">The real part of the complex number.</span>
          </span>
        </param>
        <param name="imaginary">
          <span data-ttu-id="3c1f9-174">複數的虛數部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-174">The imaginary part of the complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-175">使用指定的實數和虛數，初始化 <see cref="T:System.Numerics.Complex" /> 結構的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-176">`real`或是`imaginary`引數可能會遺失有效位數，如果不需要明確轉換成的資料型別<xref:System.Double>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-177">下列範例會具現化兩個複數相加，之後再使用其在加法、 減法、 乘法和除法的作業。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-178">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-178">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-179">取得複數的絕對值 (或範圍)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-179">Gets the absolute value (or magnitude) of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-180">
            <paramref name="value" /> 的絕對值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-180">The absolute value of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-181">複數的絕對值就相當於其<xref:System.Numerics.Complex.Magnitude%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="3c1f9-182">實際數字的絕對值 + bi 的計算方式如下：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="3c1f9-183">如果 b = 0，則結果為 0。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="3c1f9-184">如果 > b，結果會是 \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>)。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="3c1f9-185">如果 b >，則結果是 b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>b<sup>2</sup>)。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="3c1f9-186">如果計算的絕對值會產生溢位，此方法會傳回其中一個<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c1f9-187">如果有任一<xref:System.Numerics.Complex.Real%2A>或<xref:System.Numerics.Complex.Imaginary%2A>屬性是<xref:System.Double.NaN?displayProperty=nameWithType>和其他屬性既不是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>也<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，則方法會傳回<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-188">下列範例會計算複數的絕對值，並示範它就相當於 windows 7<xref:System.Numerics.Complex.Magnitude%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-189">表示餘弦值的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-189">A complex number that represents a cosine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-190">傳回角度，這個角度是指定之複數的反餘弦值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-190">Returns the angle that is the arc cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-191">反餘弦值為 <paramref name="value" /> 的角度 (以弧度為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-192"><xref:System.Numerics.Complex.Acos%2A>複數的方法對應於<xref:System.Math.Acos%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-193"><xref:System.Numerics.Complex.Acos%2A>方法會使用下列公式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="3c1f9-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="3c1f9-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-195">下列範例說明<xref:System.Numerics.Complex.Acos%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="3c1f9-196">它會顯示成功所傳回的值<xref:System.Numerics.Complex.Acos%2A>方法，以<xref:System.Numerics.Complex.Cos%2A>方法會傳回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-197">要相加的第一個複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-197">The first complex number to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-198">要相加的第二個複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-198">The second complex number to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-199">兩個複數相加，並傳回結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-199">Adds two complex numbers and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-200">
            <paramref name="left" /> 和 <paramref name="right" /> 的總和。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-201">新增複雜數字、 a + bi，和第二個複數、 c + di，都會使用下列格式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3c1f9-202">（a + c） + （b + d） i。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="3c1f9-203">如果方法呼叫的結果在溢位之實際或虛數元件，元件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-204">不支援自訂運算子的語言可以使用<xref:System.Numerics.Complex.Add%2A>方法來執行複雜數字相加。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-205">下列範例說明使用複數的加法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-206">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-206">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-207">傳回角度，這個角度是指定之複數的反正弦值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-207">Returns the angle that is the arc sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-208">反正弦值為 <paramref name="value" /> 的角度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-208">The angle which is the arc sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-209"><xref:System.Numerics.Complex.Asin%2A>複數的方法對應於<xref:System.Math.Asin%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-210"><xref:System.Numerics.Complex.Asin%2A>方法會使用下列公式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="3c1f9-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* 值 + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -值 \* 值))</span><span class="sxs-lookup"><span data-stu-id="3c1f9-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-212">下列範例說明<xref:System.Numerics.Complex.Asin%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="3c1f9-213">它會顯示成功所傳回的值<xref:System.Numerics.Complex.Asin%2A>方法，以<xref:System.Numerics.Complex.Sin%2A>方法會傳回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-214">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-214">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-215">傳回角度，這個角度是指定之複數的反正切值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-215">Returns the angle that is the arc tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-216">反正切值為 <paramref name="value" /> 的角度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-216">The angle that is the arc tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-217"><xref:System.Numerics.Complex.Atan%2A>複數的方法對應於<xref:System.Math.Atan%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-218"><xref:System.Numerics.Complex.Atan%2A>方法會使用下列公式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="3c1f9-219"><xref:System.Numerics.Complex.ImaginaryOne> / 新增複雜 （2.0，0.0）) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* 值)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* 值)</span><span class="sxs-lookup"><span data-stu-id="3c1f9-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-220">下列範例說明<xref:System.Numerics.Complex.Atan%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="3c1f9-221">它會顯示成功所傳回的值<xref:System.Numerics.Complex.Atan%2A>方法，以<xref:System.Numerics.Complex.Tan%2A>方法會傳回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-222">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-222">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-223">計算複數的共軛，並傳回結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-223">Computes the conjugate of a complex number and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-224">
            <paramref name="value" /> 的共軛。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-224">The conjugate of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-225">複數的共軛反轉正負號的虛數的元件;也就是說，它適用於一元負運算的虛數元件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="3c1f9-226">如果 + bi 是複數，其共軛-bi。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-227">下列範例會顯示兩個複數的共軛。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-228">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-228">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-229">傳回指定複數的餘弦函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-229">Returns the cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-230">
            <paramref name="value" /> 的餘弦函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-230">The cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-231"><xref:System.Numerics.Complex.Cos%2A>複數的方法對應於<xref:System.Math.Cos%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-232"><xref:System.Numerics.Complex.Cos%2A>方法會使用下列公式計算複數的餘弦 a + bi:</span><span class="sxs-lookup"><span data-stu-id="3c1f9-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="3c1f9-233">(<xref:System.Math.Cos%2A>（a） \* <xref:System.Math.Cosh%2A>（b)、-(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="3c1f9-233">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-234">下列範例說明<xref:System.Numerics.Complex.Acos%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="3c1f9-235">它會顯示成功所傳回的值<xref:System.Numerics.Complex.Acos%2A>方法，以<xref:System.Numerics.Complex.Cos%2A>方法會傳回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-236">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-236">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-237">傳回指定複數的雙曲餘弦。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-237">Returns the hyperbolic cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-238">
            <paramref name="value" /> 的雙曲線餘弦函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-238">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-239"><xref:System.Numerics.Complex.Cosh%2A>複數的方法對應於<xref:System.Math.Cosh%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-240"><xref:System.Numerics.Complex.Cosh%2A>方法會使用下列公式來計算複數的雙曲餘弦 a + bi:</span><span class="sxs-lookup"><span data-stu-id="3c1f9-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="3c1f9-241">(<xref:System.Math.Cosh%2A>（a） \* <xref:System.Math.Cos%2A>（b)， <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="3c1f9-241">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">
          <span data-ttu-id="3c1f9-242">要當做被除數的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-242">The complex number to be divided.</span>
          </span>
        </param>
        <param name="divisor">
          <span data-ttu-id="3c1f9-243">要當做除數的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-243">The complex number to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-244">以某複數除以另一個複數，並傳回結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-244">Divides one complex number by another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-245">相除的商數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-245">The quotient of the division.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-246">複雜數字，除法 + bi，第二個複數、 數字，c + di，都會使用下列格式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3c1f9-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) 我</span><span class="sxs-lookup"><span data-stu-id="3c1f9-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="3c1f9-248">如果商數的計算會產生溢位在實際或虛數元件，該元件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-249"><xref:System.Numerics.Complex.Divide%2A>方法可供不支援自訂運算子的語言。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="3c1f9-250">它的行為等同於使用除法運算子的除法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-251">下列範例會將複數除以複雜數字陣列中每個項目。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-252">傳回值，這個值表示兩個複數是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-252">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-253">要比較的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-253">The complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-254">傳回值，這個值指出目前執行個體和指定複數是否有相同的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-255">如果這個複數和 <paramref name="value" /> 有相同的值則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-255">
              <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-256"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法會提供<xref:System.IEquatable%601>實作<xref:System.Numerics.Complex>結構。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="3c1f9-257">它會執行稍微優於<xref:System.Numerics.Complex.Equals%28System.Object%29>方法因為並沒有將其參數轉換成複數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="3c1f9-258">如果其真正的部分相等且虛數部分相等，兩個複數相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="3c1f9-259"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法相當於下列運算式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="3c1f9-260">使用<see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />方法小心，因為兩個值，相當明顯可以視為不相等，因為它們的實數和虛數元件的不同有效位數。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-260">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span>
            </span>
            <span data-ttu-id="3c1f9-261">下列範例會回報<c>3.33333 (0.142857）</c>並<c>（10/3，1/7）</c>是否不相等。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-261">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span>
            </span>
            <span data-ttu-id="3c1f9-262">[！ 的程式碼 csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [！ 的程式碼 vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-262">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span>
            </span>
            <span data-ttu-id="3c1f9-263">建議的技巧是要定義可接受的界的兩個值之間的差異 (例如。 其中一個值的實數和虛數元件的 01%) 而不是比較是否相等的值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-263">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span>
            </span>
            <span data-ttu-id="3c1f9-264">如果兩個值之間差異的絕對值是小於或等於該邊界，差異是有可能是因為有不同的有效位數，而且，因此，值為可能會相等。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-264">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span>
            </span>
            <span data-ttu-id="3c1f9-265">下列範例會使用這項技術，來比較兩個先前的程式碼範例，請參閱元的複雜值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-265">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span>
            </span>
            <span data-ttu-id="3c1f9-266">它會尋找兩個複數相加，才會相等。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-266">It finds the two complex numbers to be equal.</span>
            </span>
            <span data-ttu-id="3c1f9-267">[！ 的程式碼 csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [！ 的程式碼 vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-267">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="3c1f9-268">要比較的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-268">The object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-269">傳回值，這個值表示目前執行個體與指定的物件是否有相同的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-269">Returns a value that indicates whether the current instance and a specified object have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-270">如果 <paramref name="obj" /> 參數為 <see cref="T:System.Numerics.Complex" /> 物件，或是可隱含轉換為 <see cref="T:System.Numerics.Complex" /> 物件的型別，且其值等於目前的 <see cref="T:System.Numerics.Complex" /> 物件，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-270">
              <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-271">如果其真正的部分相等且虛數部分相等，兩個複數相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-271">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="3c1f9-272"><xref:System.Numerics.Complex.Equals%28System.Object%29>方法相當於下列運算式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-272">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="3c1f9-273">如果`obj`參數不是<xref:System.Numerics.Complex>物件，但它是為其定義的隱含轉換，資料類型<xref:System.Numerics.Complex.Equals%28System.Object%29>方法轉換`obj`到<xref:System.Numerics.Complex>物件的實數部分等於值`obj`且其虛數部分等於零再執行比較。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-273">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="3c1f9-274">下列範例會說明這尋找複數和雙精確度浮點值相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-274">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="3c1f9-275">使用<see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />方法小心，因為兩個值，相當明顯可以視為不相等，因為它們的實數和虛數元件的不同有效位數。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-275">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span>
            </span>
            <span data-ttu-id="3c1f9-276">如果可以更引人注意問題<paramref name="obj" />必須轉換成<see cref="T:System.Double" />之前執行比較。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-276">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span>
            </span>
            <span data-ttu-id="3c1f9-277">下列範例會比較其真正的元件似乎是相等的複數<see cref="T:System.Single" />值以<see cref="T:System.Single" />值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-277">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span>
            </span>
            <span data-ttu-id="3c1f9-278">如輸出所示，要傳回的相等比較<see langword="False" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-278">As the output shows, the comparison for equality returns <see langword="False" />.</span>
            </span>
            <span data-ttu-id="3c1f9-279">[！ 的程式碼 csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [！ 的程式碼 vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-279">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span>
            </span>
            <span data-ttu-id="3c1f9-280">建議的技巧是要定義可接受的界的兩個值之間的差異 (例如。 其中一個值的實數和虛數元件的 01%) 而不是比較是否相等的值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-280">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span>
            </span>
            <span data-ttu-id="3c1f9-281">如果兩個值之間差異的絕對值是小於或等於該邊界，差異是有可能是因為有不同的有效位數而且，因此，值為可能會相等。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-281">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span>
            </span>
            <span data-ttu-id="3c1f9-282">下列範例會使用這項技術，來比較兩個先前的程式碼範例，請參閱元的值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-282">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span>
            </span>
            <span data-ttu-id="3c1f9-283">現在會尋找它們會相等。</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-283">It now finds them to be equal.</span>
            </span>
            <span data-ttu-id="3c1f9-284">[！ 的程式碼 csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [！ 的程式碼 vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="3c1f9-284">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-285">指定乘冪的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-285">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-286">傳回乘至複數指定乘冪的 <see langword="e" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-286">Returns <see langword="e" /> raised to the power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-287">具有乘冪數 <see langword="e" /> 的數字 <paramref name="value" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-287">The number <see langword="e" /> raised to the power <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-288">使用<xref:System.Numerics.Complex.Pow%2A>方法來計算其他基數的乘冪。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-288">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="3c1f9-289"><xref:System.Numerics.Complex.Exp%2A>複數的方法對應於<xref:System.Math.Exp%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-289">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="3c1f9-290"><xref:System.Numerics.Complex.Exp%2A> 是的反向<xref:System.Numerics.Complex.Log%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-290"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-291">下列範例說明<xref:System.Numerics.Complex.Exp%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-291">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="3c1f9-292">它會顯示，與一些額度的有效位數缺乏<xref:System.Double>資料類型，傳遞所傳回的值<xref:System.Numerics.Complex.Log%2A>方法來<xref:System.Numerics.Complex.Exp%2A>方法會傳回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-292">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">
          <span data-ttu-id="3c1f9-293">範圍，即從原點 (X 軸和 Y 軸的交點) 到複數點的距離。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-293">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span>
          </span>
        </param>
        <param name="phase">
          <span data-ttu-id="3c1f9-294">相位，即從直線到水平軸的角度 (以弧度為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-294">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-295">由點的極座標建立複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-295">Creates a complex number from a point's polar coordinates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-296">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-296">A complex number.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-297"><xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法具現化的複數，其極座標為基礎。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-297">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="3c1f9-298">因為有多種表示複數平面，傳回的值上的點<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法會正規化。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-298">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="3c1f9-299">大小會正規化為正數，且 「 階段 」 會正規化為-的範圍內的值<xref:System.Math.PI>至<xref:System.Math.PI>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-299">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="3c1f9-300">如此一來，值<xref:System.Numerics.Complex.Phase%2A>並<xref:System.Numerics.Complex.Magnitude%2A>屬性所產生的複雜數字不會和相同的原始值`magnitude`和`phase`參數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-300">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="3c1f9-301">若要將數值轉換為弧度的度數`phase`參數，multiply，即可以 <xref:System.Math.PI?displayProperty=nameWithType> /180。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-301">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-302">下列範例會使用<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法具現化複數其極座標為基礎，並接著會顯示的值及其<xref:System.Numerics.Complex.Magnitude%2A>和<xref:System.Numerics.Complex.Phase%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-302">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-303">傳回目前 <see cref="T:System.Numerics.Complex" /> 物件的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-303">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-304">32 位元帶正負號的整數雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-304">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-305">取得目前 <see cref="T:System.Numerics.Complex" /> 物件的虛數部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-305">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3c1f9-306">複數的虛數部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-306">The imaginary component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-307">指定複數 a + bi、<xref:System.Numerics.Complex.Imaginary%2A>屬性會傳回 b 的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-307">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-308">下列範例會具現化陣列<xref:System.Numerics.Complex>物件並顯示每個格式的實數和虛數元件 a + bi。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-308">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-309">在實數等於零且虛數等於一條件下，傳回新 <see cref="T:System.Numerics.Complex" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-309">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3c1f9-310">下列範例會具現化<xref:System.Numerics.Complex>值使用<xref:System.Numerics.Complex.ImaginaryOne>屬性。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-310">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="3c1f9-311">然後會比較此值藉由呼叫具現化的另一個值<xref:System.Numerics.Complex>實數部分等於零，虛數部分等於一的建構函式。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-311">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="3c1f9-312">如範例輸出所示，兩個值相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-312">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-313">傳回複數的對數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-313">Returns the logarithm of a complex number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-314">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-314">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-315">傳回指定複數的自然 (底數 <see langword="e" />) 對數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-315">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-316">
            <paramref name="value" /> 的自然對數 (底數 <see langword="e" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-316">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-317"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29>複數的方法對應於<xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-317">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-318">下列範例說明<xref:System.Numerics.Complex.Log%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-318">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="3c1f9-319">它會顯示，與一些額度的有效位數缺乏<xref:System.Double>資料類型，傳遞所傳回的值<xref:System.Numerics.Complex.Log%2A>方法來<xref:System.Numerics.Complex.Exp%2A>方法會傳回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-319">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-320">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-320">A complex number.</span>
          </span>
        </param>
        <param name="baseValue">
          <span data-ttu-id="3c1f9-321">對數的底數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-321">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-322">傳回指定底數中指定複數的對數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-322">Returns the logarithm of a specified complex number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-323">底數 <paramref name="value" /> 中的對數 <paramref name="baseValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-323">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-324"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29>複數的方法對應於<xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-324">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-325">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-325">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-326">傳回指定複數底數為 10 的對數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-326">Returns the base-10 logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-327">底數為 10 的 <paramref name="value" /> 對數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-327">The base-10 logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-328"><xref:System.Numerics.Complex.Log10%2A>複數的方法對應於<xref:System.Math.Log10%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-328">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-329">取得複數的範圍 (或絕對值)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-329">Gets the magnitude (or absolute value) of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3c1f9-330">目前執行個體的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-330">The magnitude of the current instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-331"><xref:System.Numerics.Complex.Magnitude%2A>屬性就相當於複數的絕對值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-331">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="3c1f9-332">它會指定從原點 （x 軸和 y 軸笛卡兒座標系統中的交集處） 之間的距離來表示複數的二維點。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-332">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="3c1f9-333">絕對值的計算方式如下：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-333">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="3c1f9-334">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(\* + b \* b)</span><span class="sxs-lookup"><span data-stu-id="3c1f9-334">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span></span>  
  
 <span data-ttu-id="3c1f9-335">如果計算的絕對值會產生溢位，這個屬性會傳回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-335">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-336"><xref:System.Numerics.Complex.Magnitude%2A>而<xref:System.Numerics.Complex.Phase%2A>屬性會定義一個代表複數的極座標系統中的點的位置。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-336">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="3c1f9-337">您可以具現化呼叫，根據其極座標，而不是笛卡兒座標的複數<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-337">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-338">下列範例會計算複數的絕對值，並示範它就相當於 windows 7<xref:System.Numerics.Complex.Magnitude%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-338">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-339">要相乘的第一個複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-339">The first complex number to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-340">要相乘的第二個複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-340">The second complex number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-341">傳回兩個複數的乘積。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-341">Returns the product of two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-342">
            <paramref name="left" /> 和 <paramref name="right" /> 參數的乘積。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-342">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-343">相乘的複雜數字、 a + bi，和第二個複數、 c + di，都會使用下列格式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-343">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3c1f9-344">(ac-bd) + （ad + bc） 我</span><span class="sxs-lookup"><span data-stu-id="3c1f9-344">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="3c1f9-345">如果乘法造成溢位在實際或虛數元件，該元件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-345">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-346"><xref:System.Numerics.Complex.Multiply%2A>方法的實作不支援自訂運算子的語言。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-346">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="3c1f9-347">它的行為等同於使用乘法運算子的乘法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-347">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-348">下列範例中的複雜數字陣列中每一個元素的複雜數字的倍數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-348">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-349">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-349">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-350">傳回指定之複數的加法反元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-350">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-351">
            <paramref name="value" /> 參數之 <see cref="P:System.Numerics.Complex.Real" /> 和 <see cref="P:System.Numerics.Complex.Imaginary" /> 部分乘以 -1 的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-351">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-352">複數的加法反元素為產生值的複數<xref:System.Numerics.Complex>新增至原始的複數時。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-352">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="3c1f9-353">這個方法會傳回原始複數的實數和虛數元件會乘以-1 的複數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-353">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="3c1f9-354"><xref:System.Numerics.Complex.Negate%2A>方法的實作不支援自訂運算子的語言。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-354">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="3c1f9-355">它的行為等同於使用一元負運算子，否定<xref:System.Numerics.Complex.op_UnaryNegation%2A>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-355">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-356">下列範例會取得每個項目的複雜數字陣列中的加法反元素。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-356">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-357">在實數等於一且虛數等於零條件下，傳回新 <see cref="T:System.Numerics.Complex" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-357">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3c1f9-358">下列範例會具現化<xref:System.Numerics.Complex>值使用<xref:System.Numerics.Complex.One>屬性。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-358">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="3c1f9-359">然後會比較此值藉由呼叫具現化的另一個值<xref:System.Numerics.Complex>建構函式的實數部分等於一個與虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-359">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="3c1f9-360">如範例輸出所示，兩個值相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-360">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-361">要相加的第一個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-361">The first value to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-362">要相加的第二個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-362">The second value to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-363">將兩個複數相加。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-363">Adds two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-364">
            <paramref name="left" /> 和 <paramref name="right" /> 的總和。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-364">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-365"><xref:System.Numerics.Complex.op_Addition%2A>方法定義複數加法運算。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-365">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="3c1f9-366">它可讓程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-366">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="3c1f9-367">新增複雜數字、 a + bi，和第二個複數、 c + di，都會使用下列格式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-367">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3c1f9-368">（a + c） + （b + d） i</span><span class="sxs-lookup"><span data-stu-id="3c1f9-368">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="3c1f9-369">如果方法呼叫的結果在溢位之實際或虛數元件，該元件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-369">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-370">不支援自訂運算子的語言可以呼叫<xref:System.Numerics.Complex.Add%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-370">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="3c1f9-371">這個運算子的對等方法是 <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3c1f9-371">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="3c1f9-372">下列範例說明使用複數的加法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-372">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-373">已進行除法的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-373">The value to be divided.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-374">要進行除法的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-374">The value to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-375">以某指定複數除以另一個指定複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-375">Divides a specified complex number by another specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-376">
            <paramref name="left" /> 除以 <paramref name="right" /> 的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-376">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-377"><xref:System.Numerics.Complex.op_Division%2A>方法定義的除法運算的複數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-377">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="3c1f9-378">它可讓程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-378">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="3c1f9-379">複雜的數字、 a + bi，和第二個複數、 c + di，都會使用下列格式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-379">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3c1f9-380">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) 我</span><span class="sxs-lookup"><span data-stu-id="3c1f9-380">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="3c1f9-381">如果在除法運算造成溢位在實際或虛數元件，該元件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-381">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-382">不支援自訂運算子和運算子多載的語言可以呼叫<xref:System.Numerics.Complex.Divide%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-382">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="3c1f9-383">這個運算子的對等方法是 <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3c1f9-383">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-384">要相乘的第一個複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-384">The first complex number to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-385">要相乘的第二個複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-385">The second complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-386">傳回值，這個值表示兩個複數是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-386">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-387">如果 <paramref name="left" /> 與 <paramref name="right" /> 參數有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-387">
              <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-388"><xref:System.Numerics.Complex.op_Equality%2A>方法來定義等號比較運算子的營運<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-388">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="3c1f9-389">它可讓程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-389">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="3c1f9-390">不支援自訂運算子的語言可以呼叫<xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法改為。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-390">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="3c1f9-391">如果其真正的部分相等且虛數部分相等，兩個複數相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-391">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="3c1f9-392"><xref:System.Numerics.Complex.op_Equality%2A>方法相當於下列運算式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-392">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="3c1f9-393">請注意，有效位數的差異，因為兩個複數相加，顯然相當可以視為不相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-393">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="3c1f9-394">如需詳細資訊和可能的解決方法，請參閱<xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-394">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="3c1f9-395">這個運算子的對等方法是 <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3c1f9-395">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-396">定義 <see cref="T:System.Numerics.Complex" /> 物件與另一個型別之間的明確轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-396">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-397">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-397">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-398">定義從 <see cref="T:System.Decimal" /> 值到複數的明確轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-398">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-399">實數部分等於 <paramref name="value" /> 及虛數部分等於零的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-399">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-400">明確轉換運算子定義可以轉換成的型別<xref:System.Numerics.Complex>物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-400">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3c1f9-401">語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-401">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="3c1f9-402">相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`Visual Basic 中) 使用。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-402">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="3c1f9-403">否則，它們會顯示編譯器錯誤。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-403">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="3c1f9-404">轉換<xref:System.Decimal>值到複數的實數部分，可能會導致失去精確度因為<xref:System.Double>，這是複雜的數種<xref:System.Numerics.Complex.Real%2A>屬性，具有較少的有效位數比<xref:System.Decimal>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-404">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="3c1f9-405">下列範例說明的明確轉換<xref:System.Decimal>值來<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-405">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-406">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-406">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-407">定義從 <see cref="T:System.Numerics.BigInteger" /> 值到複數的明確轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-407">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-408">實數部分等於 <paramref name="value" /> 及虛數部分等於零的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-408">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-409">明確轉換運算子定義可以轉換成的型別<xref:System.Numerics.Complex>物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-409">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="3c1f9-410">語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-410">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="3c1f9-411">相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`Visual Basic 中) 使用。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-411">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="3c1f9-412">否則，它們會顯示編譯器錯誤。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-412">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="3c1f9-413">轉換<xref:System.Numerics.BigInteger>值到複數的實數部分，可能會導致失去精確度因為<xref:System.Double>，這是複雜的數種<xref:System.Numerics.Complex.Real%2A>屬性，具有較少的有效位數比<xref:System.Numerics.BigInteger>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-413">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="3c1f9-414">如果轉換成功，則因為<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Double>型別，此作業不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-414">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="3c1f9-415">相反地，如果`value`是小於<xref:System.Double.MinValue>，結果是具有複數<xref:System.Numerics.Complex.Real%2A>屬性值等於<xref:System.Double.NegativeInfinity>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-415">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="3c1f9-416">如果`value`大於<xref:System.Double.MaxValue>，結果是具有複數<xref:System.Numerics.Complex.Real%2A>屬性值等於<xref:System.Double.PositiveInfinity>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-416">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="3c1f9-417">下列範例說明的明確轉換<xref:System.Numerics.BigInteger>值來<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-417">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-418">定義 <see cref="T:System.Numerics.Complex" /> 物件與另一個型別之間的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-418">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-419">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-419">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-420">定義從不帶正負號的位元組到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-420">Defines an implicit conversion of an unsigned byte to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-421">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-421">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-422">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-422">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-423">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-423">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-424">這個多載可讓編譯器處理從不<xref:System.Byte>複數，如下列範例所示的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-424">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-425">請注意，轉換的結果會是複數的實數部分等於<xref:System.Byte>值和其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-425">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-426">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-426">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-427">定義從雙精確度浮點數到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-427">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-428">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-428">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-429">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-429">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-430">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-430">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-431">這個多載可讓編譯器處理從不<xref:System.Double>複數，如下列範例所示的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-431">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-432">請注意，轉換的結果會是複數的實數部分等於<xref:System.Double>值和其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-432">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-433">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-433">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-434">定義從 16 位元帶正負號整數到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-434">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-435">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-435">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-436">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-436">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-437">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-437">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-438">這個多載可讓編譯器處理從不帶正負號的 16 位元整數到複數，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-438">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-439">請注意，轉換的結果複數的實數部分等於帶正負號的 16 位元整數，而且其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-439">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-440">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-440">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-441">定義從 32 位元帶正負號整數到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-441">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-442">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-442">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-443">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-443">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-444">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-444">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-445">這個多載可讓編譯器處理從不帶正負號的 32 位元整數到複數，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-445">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-446">請注意，轉換的結果複數的實數部分等於帶正負號的 32 位元整數，而且其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-446">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-447">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-447">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-448">定義從 64 位元帶正負號整數到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-448">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-449">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-449">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-450">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-450">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-451">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-451">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-452">這個多載可讓編譯器處理從不帶正負號的 64 位元整數到複數，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-452">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-453">請注意，轉換的結果複數的實數部分等於帶正負號的 64 位元整數，而且其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-453">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-454">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-454">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-455">定義從帶正負號的位元組到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-455">Defines an implicit conversion of a signed byte to a complex number.</span>
          </span>
          <span data-ttu-id="3c1f9-456">此應用程式開發介面不符合 CLS 標準。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-456">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-457">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-457">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-458">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-458">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-459">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-459">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-460">這個多載可讓編譯器處理從不帶正負號的位元組到複數，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-460">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-461">請注意，轉換的結果複數的實數部分等於帶正負號的位元組，而其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-461">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-462">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-462">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-463">定義從單精確度浮點數到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-463">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-464">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-464">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-465">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-465">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-466">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-466">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-467">這個多載可讓編譯器處理從不<xref:System.Single>複數，如下列範例所示的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-467">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-468">請注意，轉換的結果會是複數的實數部分等於<xref:System.Single>值和其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-468">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-469">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-469">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-470">定義從 16 位元不帶正負號整數到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-470">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="3c1f9-471">此應用程式開發介面不符合 CLS 標準。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-471">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-472">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-472">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-473">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-473">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-474">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-474">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-475">這個多載可讓編譯器處理從不帶正負號的 16 位元整數到複數，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-475">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-476">請注意，轉換的結果複數的實數部分等於不帶正負號的 16 位元整數，而且其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-476">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-477">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-477">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-478">定義從 32 位元不帶正負號整數到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-478">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="3c1f9-479">此應用程式開發介面不符合 CLS 標準。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-479">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-480">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-480">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-481">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-481">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-482">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-482">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-483">這個多載可讓編譯器處理從不帶正負號的 32 位元整數到複數，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-483">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-484">請注意，轉換的結果複數的實數部分等於不帶正負號的 32 位元整數，而且其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-484">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-485">要轉換成複數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-485">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-486">定義從 64 位元不帶正負號整數到複數的隱含轉換。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-486">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="3c1f9-487">此應用程式開發介面不符合 CLS 標準。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-487">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-488">物件，包含 <paramref name="value" /> 參數值 (做為其實數部分) 以及零 (做為其虛數部分)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-488">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-489">多載<xref:System.Numerics.Complex.op_Implicit%2A>運算子定義的類型的編譯器可以自動轉換<xref:System.Numerics.Complex>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-489">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="3c1f9-490">它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-490">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="3c1f9-491">這個多載可讓編譯器處理從不帶正負號的 64 位元整數到複數，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-491">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="3c1f9-492">請注意，轉換的結果複數的實數部分等於不帶正負號的 64 位元整數，而且其虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-492">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-493">要比較的第一個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-493">The first value to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-494">要比較的第二個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-494">The second value to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-495">傳回值，這個值表示兩個複數是否不相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-495">Returns a value that indicates whether two complex numbers are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-496">如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-496">
              <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-497"><xref:System.Numerics.Complex.op_Equality%2A>方法來定義複雜的數字不等比較運算子的作業。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-497">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="3c1f9-498">它可讓程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-498">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="3c1f9-499">不支援自訂運算子的語言可以測試是否不相等，藉由呼叫<xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法，並反轉其值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-499">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="3c1f9-500">請注意，有效位數的差異，因為兩個複數相加，顯然相當可以視為不相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-500">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="3c1f9-501">一個可能的解決方法是實作傳回的比較方法`true`複雜數字的兩個實數和虛數部分之間的差異超過特定臨界值時，才 (例如。 01%的真實或假想元件的值其中一個複雜的數字）。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-501">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="3c1f9-502">如需詳細資訊，請參閱 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-502">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-503">要相乘的第一個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-503">The first value to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-504">要相乘的第二個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-504">The second value to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-505">乘上兩個指定的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-505">Multiplies two specified complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-506">
            <paramref name="left" /> 與 <paramref name="right" /> 的乘積。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-506">The product of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-507"><xref:System.Numerics.Complex.op_Multiply%2A>方法定義複數的乘法運算子的作業。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-507">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="3c1f9-508">它可讓程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-508">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="3c1f9-509">相乘的複雜數字、 a + bi，和第二個複數、 c + di，都會使用下列格式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-509">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="3c1f9-510">(ac-bd) + （ad + bc） 我</span><span class="sxs-lookup"><span data-stu-id="3c1f9-510">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="3c1f9-511">如果乘法造成溢位在實際或虛數元件，該元件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-511">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-512">不支援自訂運算子的語言可以呼叫<xref:System.Numerics.Complex.Multiply%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-512">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="3c1f9-513">這個運算子的對等方法是 <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3c1f9-513">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-514">要被減的值 (被減數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-514">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-515">要減去的值 (減數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-515">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-516">從另一個複數減去一個複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-516">Subtracts a complex number from another complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-517">
            <paramref name="right" /> 減去 <paramref name="left" /> 的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-517">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-518"><xref:System.Numerics.Complex.op_Subtraction%2A>方法來定義複雜的數字的減法運算子的作業。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-518">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="3c1f9-519">它可讓程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-519">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="3c1f9-520">如果方法呼叫的結果在溢位之實際或虛數元件，該元件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-520">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-521">相減的複數，c + di，從另一個複數，+ bi，會採用下列格式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-521">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="3c1f9-522">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="3c1f9-522">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="3c1f9-523">不支援自訂運算子的語言可以呼叫<xref:System.Numerics.Complex.Subtract%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-523">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="3c1f9-524">這個運算子的對等方法是 <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3c1f9-524">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-525">要變換正負號的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-525">The value to negate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-526">傳回指定之複數的加法反元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-526">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-527">
            <paramref name="value" /> 參數之 <see cref="P:System.Numerics.Complex.Real" /> 和 <see cref="P:System.Numerics.Complex.Imaginary" /> 部分乘以 -1 的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-527">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-528"><xref:System.Numerics.Complex.op_UnaryNegation%2A>方法來定義複雜的數字的一元否定運算 （加法反元素） 運算子的作業。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-528">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="3c1f9-529">它可讓程式碼，如下所示：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-529">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="3c1f9-530">產生的複雜數字會產生值為<xref:System.Numerics.Complex>0 （零） 時，它會新增至原始的複數。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-530">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="3c1f9-531">不支援自訂運算子的語言可以呼叫<xref:System.Numerics.Complex.Negate%2A>方法改為。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-531">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="3c1f9-532">這個運算子的對等方法是 <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3c1f9-532">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-533">取得複數的階段。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-533">Gets the phase of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3c1f9-534">複數的相位 (以弧度為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-534">The phase of a complex number, in radians.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-535">為複數 + bi，階段會計算為<xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b)。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-535">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="3c1f9-536">您可以識別複數，複數平面上笛卡兒座標或其極座標。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-536">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="3c1f9-537">複數的階段 （引數） 是在實數軸從原點 （x 軸和 y 軸交集） 所畫之線條的角度來代表複數的指標。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-537">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="3c1f9-538">大小 (以<xref:System.Numerics.Complex.Magnitude%2A>屬性) 是從原點到複數表示的點的距離。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-538">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="3c1f9-539">您可以具現化呼叫，根據其極座標，而不是笛卡兒座標的複數<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-539">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="3c1f9-540">若要將階段從弧度轉換為度，將它乘以 180 /<xref:System.Math.PI?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-540">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-541">下列範例會使用<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法具現化複數根據極座標，，，然後顯示的值及其<xref:System.Numerics.Complex.Magnitude%2A>和<xref:System.Numerics.Complex.Phase%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-541">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-542">傳回乘至指定乘冪的指定複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-542">Returns a specified complex number raised to a specified power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-543">傳回乘至乘冪的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-543">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="3c1f9-544">雙精確度浮點數，用來指定乘冪數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-544">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-545">傳回指定之複數自乘至雙精確度浮點數指定之乘冪的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-545">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-546">乘至乘冪 <paramref name="value" /> 的複數 <paramref name="power" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-546">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-547">如果 `value` 是 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>，則方法會傳回 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-547">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c1f9-548">如需其他的值，如果`power`為 0，則方法會傳回<xref:System.Numerics.Complex.One?displayProperty=nameWithType>，而且如果`power`為 1，它會傳回`value`。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-548">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="3c1f9-549">這個方法會對應至<xref:System.Math.Pow%2A?displayProperty=nameWithType>基本數值類型的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-549">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-550">下列範例說明使用複數和指數乘冪的值的範圍從-1 到 10。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-550">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-551">傳回乘至乘冪的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-551">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="3c1f9-552">指定乘冪的複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-552">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-553">傳回指定的複數自乘至複數指定之乘冪的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-553">Returns a specified complex number raised to a power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-554">乘至乘冪 <paramref name="value" /> 的複數 <paramref name="power" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-554">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-555">取得目前 <see cref="T:System.Numerics.Complex" /> 物件的實數部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-555">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3c1f9-556">複數的實數部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-556">The real component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-557">指定複數 a + bi、<xref:System.Numerics.Complex.Real%2A>屬性傳回的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-557">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-558">下列範例會具現化陣列<xref:System.Numerics.Complex>物件並顯示每個格式的實數和虛數元件 a + bi。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-558">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-559">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-559">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-560">傳回複數的乘法逆元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-560">Returns the multiplicative inverse of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-561">
            <paramref name="value" /> 的倒數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-561">The reciprocal of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-562">倒數或數字的乘法反元素， *x*是數字*y*位置*x*乘以*y*產生 1。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-562">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="3c1f9-563">複雜數字的倒數是產生的複數<xref:System.Numerics.Complex.One?displayProperty=nameWithType>兩個數字相乘的時機。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-563">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="3c1f9-564">如果 a + bi 來表示複數，其倒數由運算式 / (<sup>2</sup>+ b<sup>2</sup>) +-b / (<sup>2</sup> + b<sup>2</sup>)。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-564">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="3c1f9-565">如果值為<xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>，則方法會傳回<xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-565">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c1f9-566">否則，它會傳回運算式的結果<xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-566">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-567">下列範例會使用<xref:System.Numerics.Complex.Reciprocal%2A>方法，以計算相互數個複數的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-567">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="3c1f9-568">它也會示範複數乘以其倒數的結果是<xref:System.Numerics.Complex.One?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-568">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-569">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-569">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-570">傳回指定複數的正弦函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-570">Returns the sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-571">
            <paramref name="value" /> 的正弦函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-571">The sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-572"><xref:System.Numerics.Complex.Sin%2A>複數的方法對應於<xref:System.Math.Sin%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-572">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-573"><xref:System.Numerics.Complex.Sin%2A>方法會使用下列公式來計算正弦函數複數 a + bi:</span><span class="sxs-lookup"><span data-stu-id="3c1f9-573">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="3c1f9-574">(<xref:System.Math.Sin%2A>（a） \* <xref:System.Math.Cosh%2A>（b)， <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="3c1f9-574">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-575">下列範例說明<xref:System.Numerics.Complex.Sin%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-575">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="3c1f9-576">它會顯示成功所傳回的值<xref:System.Numerics.Complex.Asin%2A>方法，以<xref:System.Numerics.Complex.Sin%2A>方法會傳回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-576">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-577">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-577">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-578">傳回指定複數的雙曲正弦。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-578">Returns the hyperbolic sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-579">
            <paramref name="value" /> 的雙曲線正弦函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-579">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-580"><xref:System.Numerics.Complex.Sinh%2A>複數的方法對應於<xref:System.Math.Sinh%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-580">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-581"><xref:System.Numerics.Complex.Sinh%2A>方法會使用下列公式來計算複數的雙曲正弦值 a + bi:</span><span class="sxs-lookup"><span data-stu-id="3c1f9-581">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="3c1f9-582">(<xref:System.Math.Sinh%2A>（a） \* <xref:System.Math.Cos%2A>（b)， <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="3c1f9-582">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-583">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-583">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-584">傳回指定複數的平方根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-584">Returns the square root of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-585">
            <paramref name="value" /> 的平方根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-585">The square root of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-586">複數的平方根`value`的計算方式是使用下列公式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-586">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="3c1f9-587"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/ 2.0）</span><span class="sxs-lookup"><span data-stu-id="3c1f9-587"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="3c1f9-588"><xref:System.Numerics.Complex.Sqrt%2A>複數的方法對應於<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-588">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="3c1f9-589">要被減的值 (被減數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-589">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="3c1f9-590">要減去的值 (減數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-590">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-591">從某複數減去另一個複數，並傳回結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-591">Subtracts one complex number from another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-592">
            <paramref name="right" /> 減去 <paramref name="left" /> 的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-592">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-593">相減的複數，c + di，從另一個複數，+ bi，會採用下列格式：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-593">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="3c1f9-594">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="3c1f9-594">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="3c1f9-595">如果方法呼叫的結果在溢位之實際或虛數元件，該元件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-595">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3c1f9-596">不支援自訂運算子的語言可以使用<xref:System.Numerics.Complex.Subtract%2A>方法，以執行使用複雜的數字的減法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-596">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-597">下列範例會減去每一個複數，複數從陣列中。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-597">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-598">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-598">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-599">傳回指定複數的正切函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-599">Returns the tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-600">
            <paramref name="value" /> 的正切函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-600">The tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-601"><xref:System.Numerics.Complex.Tan%2A>複數的方法對應於<xref:System.Math.Tan%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-601">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-602"><xref:System.Numerics.Complex.Tan%2A>方法會使用下列公式來計算複數的正切函數`value`:</span><span class="sxs-lookup"><span data-stu-id="3c1f9-602">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="3c1f9-603"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="3c1f9-603"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-604">下列範例說明<xref:System.Numerics.Complex.Tan%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-604">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="3c1f9-605">它會顯示成功所傳回的值<xref:System.Numerics.Complex.Atan%2A>方法，以<xref:System.Numerics.Complex.Tan%2A>方法會傳回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-605">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="3c1f9-606">複數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-606">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-607">傳回指定複數的雙曲正切。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-607">Returns the hyperbolic tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-608">
            <paramref name="value" /> 的雙曲線正切函數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-608">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-609"><xref:System.Numerics.Complex.Tanh%2A>複數的方法對應於<xref:System.Math.Tanh%2A?displayProperty=nameWithType>實際數字的方法。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-609">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="3c1f9-610"><xref:System.Numerics.Complex.Tanh%2A>方法會使用下列公式來計算複數的雙曲正切值`value`:</span><span class="sxs-lookup"><span data-stu-id="3c1f9-610">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="3c1f9-611"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="3c1f9-611"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-612">將複數的值轉換為其相等的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-612">Converts the value of a complex number to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-613">將目前複數的值轉換為直角座標形式 (Cartesian form) 的相等字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-613">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-614">採取直角座標形式 (Cartesian form) 之目前執行個體的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-614">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-615">複數的預設字串表示會顯示在表單中使用其笛卡兒座標數字`(`  `,` *b*`)`，其中是實數部分的複數，並*b*是其虛數部分。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-615">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="3c1f9-616">兩者並*b*使用一般格式規範 ("G") 和目前的系統文化特性的慣例格式化。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-616">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-617">下列範例會顯示數個複雜的數字的字串表示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-617">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="3c1f9-618">輸出會使用英文-美國 ("EN-US") 文化特性，在此情況下，這是目前系統文化特性的格式化慣例。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-618">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="3c1f9-619">物件，提供文化特性特定格式資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-619">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-620">使用指定文化特性格式資訊，將目前的複數值轉換為採取直角座標形式 (Cartesian form) 的相等字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-620">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-621">採取直角座標形式 (Cartesian form) 之目前執行個體的字串表示，如 <paramref name="provider" /> 所指定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-621">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-622">這個方法所傳回的複雜數字的字串表示會顯示使用笛卡兒座標格式數字`(`  `,` *b*`)`，何處是實數部分的複數，並*b*是其虛數部分。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-622">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="3c1f9-623">兩者並*b*使用一般格式規範 ("G") 和所定義的文化特性的慣例格式化`provider`。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-623">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="3c1f9-624">`provider`參數是<xref:System.IFormatProvider>實作。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-624">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="3c1f9-625">其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供特定文化特性格式資訊的實數和虛數字，傳回的字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-625">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="3c1f9-626">如果`provider`已`null`，傳回的字串會使用格式化<xref:System.Globalization.NumberFormatInfo>目前文化特性的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-626">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="3c1f9-627">`provider`參數可以是下列其中之一：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-627">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="3c1f9-628">A<xref:System.Globalization.CultureInfo>物件，表示提供的格式資訊的文化特性</span><span class="sxs-lookup"><span data-stu-id="3c1f9-628">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="3c1f9-629"><xref:System.Globalization.NumberFormatInfo>物件，提供格式設定資訊。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-629">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="3c1f9-630">自訂物件實作<xref:System.IFormatProvider>介面。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-630">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="3c1f9-631">其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供的格式資訊的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-631">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-632">下列範例會顯示數個複雜的數字的字串表示。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-632">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="3c1f9-633">結果會使用英文-美國 ("EN-US") 和法文-法國 ("FR-FR") 文化特性的格式化慣例。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-633">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="3c1f9-634">標準或自訂數值格式字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-634">A standard or custom numeric format string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-635">使用實數及虛數格式的指定格式，將目前的複數值轉換為採取直角座標形式 (Cartesian form) 的相等字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-635">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-636">採取直角座標形式 (Cartesian form) 之目前執行個體的字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-636">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-637">這個方法所傳回的複雜數字的字串表示會顯示使用笛卡兒座標格式數字`(`  `,` *b*`)`，何處是實數部分的複數，並*b*是其虛數部分。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-637">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="3c1f9-638">兩者並*b*會使用所指定的格式字串格式化`format`。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-638">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="3c1f9-639">`format`參數可以是任何有效的標準數值格式規範或自訂數值格式規範的任何組合。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-639">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="3c1f9-640">如果`format`等於<xref:System.String.Empty?displayProperty=nameWithType>或是`null`，複數的實數和虛數部分會以一般格式規範格式化 ("G")。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-640">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="3c1f9-641">如果`format`是任何其他值，則方法會擲回<xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-641">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="3c1f9-642">.NET Framework 會提供廣泛的格式化支援，這會在下列主題中的更詳細地說明：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-642">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="3c1f9-643">如需有關數值格式字串的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-643">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="3c1f9-644">如需.NET Framework 中的格式設定的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-644">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="3c1f9-645">傳回字串的格式取決於<xref:System.Globalization.NumberFormatInfo>目前的文化特性的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-645">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="3c1f9-646">取決於`format`參數，這個物件可控制例如負號、 群組分隔符號和小數點符號，輸出字串中的符號。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-646">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="3c1f9-647">若要提供目前的文化特性以外的文化特性格式資訊，請呼叫<xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29>多載。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-647">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-648">下列範例會初始化複數，並顯示它使用數個標準格式字串。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-648">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="3c1f9-649">
            <paramref name="format" /> 不是有效的格式字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-649">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">
          <span data-ttu-id="3c1f9-650">標準數值格式字串</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-650">Standard Numeric Format Strings</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">
          <span data-ttu-id="3c1f9-651">自訂數值格式字串</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-651">Custom Numeric Format Strings</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="3c1f9-652">標準或自訂數值格式字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-652">A standard or custom numeric format string.</span>
          </span>
        </param>
        <param name="provider">
          <span data-ttu-id="3c1f9-653">物件，提供文化特性特定格式資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-653">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c1f9-654">使用指定格式以及文化特性格式資訊來組成實數及虛數，將目前的複數值轉換為採取直角座標形式 (Cartesian form) 的相等字串表示。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-654">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c1f9-655">採取直角座標形式 (Cartesian form) 之目前執行個體的字串表示，如 <paramref name="format" /> 和 <paramref name="provider" /> 所指定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-655">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-656">這個方法所傳回的複雜數字的字串表示會顯示使用笛卡兒座標格式數字`(`  `,` *b*`)`，何處是實數部分的複數，並*b*是其虛數部分。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-656">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="3c1f9-657">兩者並*b*會使用所指定的格式字串格式化`format`。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-657">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="3c1f9-658">`format`參數可以是任何有效的標準數值格式規範或自訂數值格式規範的任何組合。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-658">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="3c1f9-659">如果`format`等於<xref:System.String.Empty?displayProperty=nameWithType>或是`null`，複數的實數和虛數部分會以一般格式規範格式化 ("G")。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-659">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="3c1f9-660">如果`format`是任何其他值，則方法會擲回<xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-660">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="3c1f9-661">.NET Framework 會提供廣泛的格式化支援，這會在下列主題中的更詳細地說明：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-661">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="3c1f9-662">如需有關數值格式字串的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-662">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="3c1f9-663">如需.NET Framework 中的格式設定的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-663">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="3c1f9-664">`provider`參數是<xref:System.IFormatProvider>實作。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-664">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="3c1f9-665">其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供特定文化特性格式資訊的實數和虛數字，傳回的字串中的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-665">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="3c1f9-666">取決於`format`參數，這個物件可控制例如負號、 群組分隔符號和小數點符號，輸出字串中的符號。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-666">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="3c1f9-667">如果`provider`已`null`，傳回的字串會使用格式化<xref:System.Globalization.NumberFormatInfo>目前文化特性的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-667">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="3c1f9-668">`provider`參數可以是下列其中之一：</span><span class="sxs-lookup"><span data-stu-id="3c1f9-668">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="3c1f9-669">A<xref:System.Globalization.CultureInfo>物件，表示提供的格式資訊的文化特性</span><span class="sxs-lookup"><span data-stu-id="3c1f9-669">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="3c1f9-670"><xref:System.Globalization.NumberFormatInfo>物件，提供格式設定資訊。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-670">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="3c1f9-671">自訂物件實作<xref:System.IFormatProvider>介面。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-671">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="3c1f9-672">其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供的格式資訊的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-672">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-673">下列範例會建立複雜的數字的陣列，並顯示每一個使用數個標準格式字串，以及<xref:System.Globalization.CultureInfo>代表英文-美國 ("EN-US") 和法文-法國 ("FR-FR") 文化特性的物件。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-673">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="3c1f9-674">
            <paramref name="format" /> 不是有效的格式字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-674">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">
          <span data-ttu-id="3c1f9-675">標準數值格式字串</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-675">Standard Numeric Format Strings</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">
          <span data-ttu-id="3c1f9-676">自訂數值格式字串</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-676">Custom Numeric Format Strings</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c1f9-677">在實數等於零且虛數等於零條件下，傳回新 <see cref="T:System.Numerics.Complex" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c1f9-677">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c1f9-678"><xref:System.Numerics.Complex.Zero>屬性最常用於比較<xref:System.Numerics.Complex>為零的值。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-678">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c1f9-679">下列範例會具現化<xref:System.Numerics.Complex>值使用<xref:System.Numerics.Complex.Zero>屬性。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-679">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="3c1f9-680">然後會比較此值藉由呼叫具現化的另一個值<xref:System.Numerics.Complex>建構函式的實數部分等於零，虛數部分等於零。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-680">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="3c1f9-681">如範例輸出所示，兩個值相等。</span><span class="sxs-lookup"><span data-stu-id="3c1f9-681">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>