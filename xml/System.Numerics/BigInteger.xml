<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f056c187bb10b8f9661af42feea9b2eb22303fef" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53300670" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示任意大、帶正負號的整數。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger>類型是不可變的類型表示任意大整數，其值在理論上沒有上限或下限。 成員<xref:System.Numerics.BigInteger>型別極為相似的其他整數類資料類型 ( <xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.SByte>， <xref:System.UInt16>， <xref:System.UInt32>，和<xref:System.UInt64>類型)。 此型別不同於其他整數類資料類型中[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，其具有所指定的範圍及其`MinValue`和`MaxValue`屬性。  
  
> [!NOTE]
>  因為<xref:System.Numerics.BigInteger>型別是不可變 (請參閱[可變動性和 BigInteger 結構](#mutability))，因為它有沒有上限或下限的界限，<xref:System.OutOfMemoryException>可能會導致任何作業中擲回<xref:System.Numerics.BigInteger>太成長值大型。  
  
## <a name="instantiating-a-biginteger-object"></a>BigInteger 物件具現化  
 您可以具現化<xref:System.Numerics.BigInteger>物件以數種方式：  
  
-   您可以使用`new`關鍵字，並做為參數提供的任何整數或浮點值<xref:System.Numerics.BigInteger>建構函式。 (浮點數的值會被截斷，才能指派給<xref:System.Numerics.BigInteger>。)下列範例說明如何使用`new`關鍵字來具現化<xref:System.Numerics.BigInteger>值。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   您可以宣告<xref:System.Numerics.BigInteger>變數並指派值，就像您一樣任何數值類型，只要該值是整數型別。 下列範例會使用指派來建立<xref:System.Numerics.BigInteger>值從<xref:System.Int64>。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   您可以指派十進位或浮點數的值給<xref:System.Numerics.BigInteger>物件，如果您將值轉換，或先將它轉換。 下列範例明確轉換 （在 C# 中)，或將轉換 （在 Visual Basic)<xref:System.Double>並<xref:System.Decimal>值<xref:System.Numerics.BigInteger>。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 這些方法可讓您具現化<xref:System.Numerics.BigInteger>物件，其值為其中一個現有的數字的範圍中的類型才。 您可以具現化<xref:System.Numerics.BigInteger>物件，其值可能會超過三種方式之一中的現有數值類型的範圍：  
  
-   您可以使用`new`關鍵字，並提供任何大小的位元組陣列<xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType>建構函式。 例如：  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   您可以呼叫<xref:System.Numerics.BigInteger.Parse%2A>或是<xref:System.Numerics.BigInteger.TryParse%2A>方法，將轉換的數字的字串表示<xref:System.Numerics.BigInteger>。 例如：  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   您可以呼叫`static`(`Shared` Visual Basic 中)<xref:System.Numerics.BigInteger>方法，執行數值運算式上的某項作業，並傳回導出<xref:System.Numerics.BigInteger>結果。 下列範例會藉由 cube<xref:System.UInt64.MaxValue?displayProperty=nameWithType>並指派結果<xref:System.Numerics.BigInteger>。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 未初始化的值<xref:System.Numerics.BigInteger>是<xref:System.Numerics.BigInteger.Zero%2A>。  
  
## <a name="performing-operations-on-biginteger-values"></a>BigInteger 值上執行的作業  
 您可以使用<xref:System.Numerics.BigInteger>像您使用任何其他整數類資料類型執行個體。 <xref:System.Numerics.BigInteger> 可讓您執行基本數學運算，例如加法、 減法、 部門、 乘法、 減法、 負號、 和一元負運算的標準數值運算子會多載。 您也可以使用標準數值運算子比較兩個<xref:System.Numerics.BigInteger>彼此的值。 像其他整數類資料類型，<xref:System.Numerics.BigInteger>也支援 位元`And`， `Or`， `XOr`，左 shift 鍵和向右移位運算子。 語言不支援自訂運算子<xref:System.Numerics.BigInteger>結構也會提供用於執行數學運算的對等方法。 其中包括<xref:System.Numerics.BigInteger.Add%2A>， <xref:System.Numerics.BigInteger.Divide%2A>， <xref:System.Numerics.BigInteger.Multiply%2A>， <xref:System.Numerics.BigInteger.Negate%2A>， <xref:System.Numerics.BigInteger.Subtract%2A>，和其他許多選項。  
  
 許多成員的<xref:System.Numerics.BigInteger>結構會直接對應至整數類資料類型的成員。 颾魤 ㄛ<xref:System.Numerics.BigInteger>新增成員，如下所示：  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>它會傳回值，表示正負號的<xref:System.Numerics.BigInteger>值。  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>它會傳回數值的絕對值<xref:System.Numerics.BigInteger>值。  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>它會傳回商數及除法運算的餘數。  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>它會傳回兩個最大公因數<xref:System.Numerics.BigInteger>值。  
  
 許多這些額外的成員對應至的成員<xref:System.Math>類別，可提供基本數值類型所使用的功能。  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>可變動性和 BigInteger 結構  
 下列範例會具現化<xref:System.Numerics.BigInteger>物件，然後逐一遞增其值。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 雖然此範例中會出現來修改現有值，但這不是物件的如此。 <xref:System.Numerics.BigInteger> 物件是不可變的這表示在內部，common language runtime 實際上會建立新<xref:System.Numerics.BigInteger>物件，並將其指派的值大於其先前的值。 然後會將這個新物件傳回給呼叫者。  
  
> [!NOTE]
>  .NET Framework 中的其他數值類型也是不可變的。 不過，因為<xref:System.Numerics.BigInteger>類型沒有沒有上限或下限的界限，其值可以變得非常大，對效能造成可觀的衝擊。  
  
 雖然此程序是呼叫端透明的就會產生對效能帶來負面影響。 在某些情況下，尤其是當重複的作業將會在迴圈中上非常大<xref:System.Numerics.BigInteger>值，該效能產生負面影響可能更為顯著。 例如，在下列範例中，作業回應達百萬次和<xref:System.Numerics.BigInteger>值都會加一每次作業成功。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 在此情況下，您可以改善效能，藉由執行的所有中繼指派<xref:System.Int32>變數。 最後一個變數的值再指派給<xref:System.Numerics.BigInteger>迴圈結束時的物件。 下列範例提供一個實例。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>使用位元組陣列與十六進位字串  
 如果您將轉換<xref:System.Numerics.BigInteger>值為位元組陣列，或如果您將轉換的位元組陣列，以<xref:System.Numerics.BigInteger>值，您必須考慮的位元組順序。 <xref:System.Numerics.BigInteger>結構會預期要有個別的位元組才會出現在 little-endian 順序的位元組陣列 （也就是低序位位元組值的前面的高序位位元組）。 您可以往返<xref:System.Numerics.BigInteger>值，藉由呼叫<xref:System.Numerics.BigInteger.ToByteArray%2A>方法，然後再將傳遞產生的位元組陣列<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>建構函式，如下列範例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 若要具現化<xref:System.Numerics.BigInteger>值，您可以從位元組陣列，代表某些其他整數類資料類型的值，傳遞將整數值<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>方法，然後再產生的位元組陣列的傳遞<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>建構函式。 下列範例會具現化<xref:System.Numerics.BigInteger>值從位元組陣列，表示<xref:System.Int16>值。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <xref:System.Numerics.BigInteger>結構假設，負值會儲存使用二補數表示。 因為<xref:System.Numerics.BigInteger>結構代表數值，但是沒有固定的長度，<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>建構函式一律會解譯為正負號位元陣列中的最後一個位元組的最大顯著性位元。 若要避免<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>從令人困惑的二補數表示負值正值，正值的正負號和大小表示的建構函式中的值的最高有效位元的位元組陣列中的最後一個位元組一般被視為集合應該包含額外的位元組，其值為 0。 比方說，0xC0 0xBD 0xF0 0xFF 是-1,000,000 或 4,293,967,296 由小到大十六進位表示法。 因為此陣列中的最後一個位元組的最大顯著性位元上，會由解譯的位元組陣列值<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>-1,000,000 為建構函式。 若要具現化<xref:System.Numerics.BigInteger>其值為正數，位元組陣列，其元素為 0xC0 0xBD 0xF0 0xFF 0x00 必須傳遞給建構函式。 下列範例將說明這點。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 所建立的位元組陣列<xref:System.Numerics.BigInteger.ToByteArray%2A>正值方法包含此額外的零值的位元組。 因此，<xref:System.Numerics.BigInteger>結構可以成功地反覆存取值所指派，然後將它們還原從位元組陣列，如下列範例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 不過，您可能需要將此額外的零值位元組至位元組陣列，動態地建立開發人員，或將不帶正負號的整數轉換成位元組陣列的方法所傳回的 (例如<xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>， <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>，和<xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>)。  
  
 剖析十六進位的字串，當<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>和<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法會假設，如果字串中的第一個位元組的最大顯著性位元設定，或如果字串的第一個十六進位數字表示較低的四位元的位元組值，這個值是表示使用二補數表示。 例如，"FF01"和"F01 」 代表-255 的十進位值。 若要區分正從負數值，正值應該包含前置零。 相關的多載<xref:System.Numerics.BigInteger.ToString%2A>方法，傳遞"X"格式字串時加入前置零的正數值傳回十六進位的字串。 這使得來回<xref:System.Numerics.BigInteger>使用的值<xref:System.Numerics.BigInteger.ToString%2A>和<xref:System.Numerics.BigInteger.Parse%2A>方法，如下列範例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 不過，將十六進位字串建立藉由呼叫`ToString`其他整數型別或多載的方法<xref:System.Convert.ToString%2A>方法，包括`toBase`參數並不表示正負號的值或從其來源資料類型衍生的十六進位字串。 已成功具現化<xref:System.Numerics.BigInteger>從這類字串的值需要某些額外邏輯。 下列範例提供一個可能的實作。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Numerics.BigInteger" /> 結構的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">位元組由小到大順序的位元組值陣列。</param>
        <summary>使用位元組陣列中的值，初始化 <see cref="T:System.Numerics.BigInteger" /> 結構的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的個別位元組`value`陣列應該是位元組由小到大順序，從最低順序最高序位位元組的位元組。 例如，數值 1,000,000,000,000 表示下表所示：  
  
|||  
|-|-|  
|十六進位字串|E8D4A51000|  
|位元組陣列 （第一次最低索引）|00 10 A5 D4 E8 00|  
  
 大部分的方法，例如將數值轉換成位元組陣列，請<xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType>和<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>，以位元組由小到大的順序傳回位元組陣列。  
  
 建構函式會預期要有正數值来使用標誌大小表示法，而負數的值来使用二補數表示的位元組陣列。 換句話說，如果最高順序位元中的最高序位位元組`value`設定，產生<xref:System.Numerics.BigInteger>值為負數。 根據位元組陣列的來源，這可能會導致正值以被錯誤解譯為負數值。 位元組陣列通常是透過下列方式產生：  
  
-   藉由呼叫<xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType>方法。 因為這個方法會傳回最高序位位元組的最高序位位元的位元組陣列中的陣列設定為零的正數值，絕不會發生的錯誤解譯為否定是正數值。 未修改的方式所建立的位元組陣列<xref:System.Numerics.BigInteger.ToByteArray%2A>方法永遠成功地反覆存取時傳遞至<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>建構函式。  
  
-   藉由呼叫<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>方法，並將其做為參數傳遞的帶正負號的整數。 帶正負號的整數處理標誌大小表示和二補數表示法，因為沒有可能的錯誤解譯為否定是正數值。  
  
-   藉由呼叫<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>方法，並將其做為參數傳遞的不帶正負號的整數。 因為其大小只表示不帶正負號的整數，正值可以被錯誤解譯為負數值。 若要避免這個錯誤解譯，您可以將零位元組的值加入陣列結尾。 下一節中的範例提供說明。  
  
-   藉由建立位元組陣列可能動態或靜態方式不一定呼叫任何先前的方法，或是藉由修改現有的位元組陣列。 若要避免正值會錯誤解譯為負數值，您可以將零位元組的值加入陣列結尾。  
  
 如果`value`為空<xref:System.Byte>array，新<xref:System.Numerics.BigInteger>物件會初始化為值<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>。 如果`value`已`null`，建構函式會擲回<xref:System.ArgumentNullException>。  
  
   
  
## Examples  
 下列範例會具現化<xref:System.Numerics.BigInteger>{5，4，3，2，1}，其值是 5 個元素位元組陣列中的物件。 然後它會顯示<xref:System.Numerics.BigInteger>值，表示為十進位和十六進位數字，到主控台。 輸入陣列的文字輸出的比較可以清楚為什麼的這個多載<xref:System.Numerics.BigInteger>類別建構函式建立<xref:System.Numerics.BigInteger>物件，其值為 4328719365 （或 0x102030405）。 位元組陣列，其值為 5，第一個項目定義的最低序位位元組值<xref:System.Numerics.BigInteger>物件，它是 0x05:sp。 位元組陣列，其值為 4，第二個項目定義的第二個位元組的值<xref:System.Numerics.BigInteger>物件，也就是 0x04，依此類推。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 下列範例會具現化正和負<xref:System.Numerics.BigInteger>值，請將它們傳遞至<xref:System.Numerics.BigInteger.ToByteArray%2A>方法，然後還原原始<xref:System.Numerics.BigInteger>產生的位元組陣列中的值。 請注意兩個值都由相同的位元組陣列。 兩者之間唯一的差別是在最大顯著性位元的位元組陣列中的最後一個元素。 此位元會設定 （位元組的值是 0xFF），如果陣列從負建立<xref:System.Numerics.BigInteger>值。 位元未設定 （位元組的值為零），如果陣列從正建立<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 下列範例說明如何確認，正值會不正確具現化為負值加上其值為陣列結尾的零位元組。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">十進位數字。</param>
        <summary>使用 <see cref="T:System.Numerics.BigInteger" /> 值，初始化 <see cref="T:System.Decimal" /> 結構的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個建構函式的結果會等於明確指派<xref:System.Decimal>值<xref:System.Numerics.BigInteger>變數。  
  
 呼叫這個建構函式可能會導致資料遺失。任何小數部分`value`具現化時，會被截斷<xref:System.Numerics.BigInteger>物件。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29>建構函式來具現化<xref:System.Numerics.BigInteger>物件。 它會定義各種<xref:System.Decimal>值，然後接著會將每個值傳遞<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29>建構函式。 請注意，<xref:System.Decimal>就會截斷值而不是四捨五入時將它指派給<xref:System.Numerics.BigInteger>物件。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">雙精確度浮點值。</param>
        <summary>使用雙精確度浮點值，初始化 <see cref="T:System.Numerics.BigInteger" /> 結構的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小數部分`value`具現化時，參數會被截斷<xref:System.Numerics.BigInteger>物件。  
  
 因為缺少有效位數<xref:System.Double>資料型別，呼叫這個建構函式可能會導致資料遺失。  
  
 <xref:System.Numerics.BigInteger>由呼叫這個建構函式產生的值等於值所產生明確指派<xref:System.Double>值<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Numerics.BigInteger.%23ctor%28System.Double%29>建構函式來具現化<xref:System.Numerics.BigInteger>物件。 它也會說明當您使用時，可能會發生的精確度遺失的<xref:System.Double>資料型別。 A<xref:System.Double>指派較大的值，然後指派給<xref:System.Numerics.BigInteger>物件。 如輸出所示，這個作業牽涉到遺失有效位數。 這兩個值則是以 1 遞增。 輸出顯示<xref:System.Numerics.BigInteger>物件會反映變更的值，而<xref:System.Double>物件則否。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 為 <see cref="F:System.Double.NaN" />、<see cref="F:System.Double.NegativeInfinity" /> 或 <see cref="F:System.Double.PositiveInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">32 位元帶正負號的整數。</param>
        <summary>使用 32 位元帶正負號的整數值，初始化 <see cref="T:System.Numerics.BigInteger" /> 結構的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具現化時不會遺失任何精確度的<xref:System.Numerics.BigInteger>使用這個建構函式的物件。  
  
 <xref:System.Numerics.BigInteger>由呼叫這個建構函式產生的值完全相同的值所產生的指派<xref:System.Int32>值<xref:System.Numerics.BigInteger>。  
  
 <xref:System.Numerics.BigInteger>結構不包含的型別參數的建構函式<xref:System.Byte>， <xref:System.Int16>， <xref:System.SByte>，或<xref:System.UInt16>。 不過，<xref:System.Int32>型別支援 8 位元和 16 位元帶正負號和不帶正負號的整數隱含轉換為帶正負號的 32 位元整數。 如果，如此一來，呼叫這個建構函式`value`是這四個整數類資料類型的任何一個。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29>建構函式來具現化<xref:System.Numerics.BigInteger>32 位元整數的陣列中的值。 它也會使用隱含轉換將每個 32 位元整數值指派給<xref:System.Numerics.BigInteger>變數。 然後它會比較兩個值來建立產生<xref:System.Numerics.BigInteger>值都相同。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">64 位元帶正負號的整數。</param>
        <summary>使用 64 位元帶正負號的整數值，初始化 <see cref="T:System.Numerics.BigInteger" /> 結構的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具現化時不會遺失任何精確度的<xref:System.Numerics.BigInteger>使用這個建構函式的物件。  
  
 <xref:System.Numerics.BigInteger>由呼叫這個建構函式產生的值完全相同的值所產生的指派<xref:System.Int64>值<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29>建構函式來具現化<xref:System.Numerics.BigInteger>64 位元整數的陣列中的值。 它也會使用隱含轉換將每個 64 位元整數值指派給<xref:System.Numerics.BigInteger>變數。 然後它會比較兩個值來建立產生<xref:System.Numerics.BigInteger>值都相同。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">單精確度浮點值。</param>
        <summary>使用單精確度浮點值，初始化 <see cref="T:System.Numerics.BigInteger" /> 結構的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小數部分`value`具現化時，參數會被截斷<xref:System.Numerics.BigInteger>物件。  
  
 因為缺少有效位數<xref:System.Single>資料型別，呼叫這個建構函式可能會導致資料遺失。  
  
 <xref:System.Numerics.BigInteger>由呼叫這個建構函式產生的值等於值所產生明確指派<xref:System.Single>值<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Numerics.BigInteger.%23ctor%28System.Single%29>建構函式來具現化<xref:System.Numerics.BigInteger>物件。 它也會說明當您使用時，可能會發生的精確度遺失的<xref:System.Single>資料型別。 A<xref:System.Single>會指派一個大型的負數值，它接著會指派給<xref:System.Numerics.BigInteger>物件。 如輸出所示，這個作業牽涉到遺失有效位數。 這兩個值則是以 1 遞增。 輸出顯示<xref:System.Numerics.BigInteger>物件會反映變更的值，而<xref:System.Single>物件則否。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 為 <see cref="F:System.Single.NaN" />、<see cref="F:System.Single.NegativeInfinity" /> 或 <see cref="F:System.Single.PositiveInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">32 位元不帶正負號的整數值。</param>
        <summary>使用不帶正負號的 32 位元整數值，初始化 <see cref="T:System.Numerics.BigInteger" /> 結構的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具現化時不會遺失任何精確度的<xref:System.Numerics.BigInteger>使用這個建構函式。  
  
 <xref:System.Numerics.BigInteger>由呼叫這個建構函式產生的值完全相同的值所產生的指派<xref:System.UInt32>值<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29>建構函式和指派陳述式來初始化<xref:System.Numerics.BigInteger>不帶正負號的 32 位元整數的陣列中的值。 然後它會比較兩個值来示範兩種初始化<xref:System.Numerics.BigInteger>值產生相同的結果。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">不帶正負號的 64 位元整數。</param>
        <summary>使用不帶正負號的 64 位元整數值，初始化 <see cref="T:System.Numerics.BigInteger" /> 結構的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具現化時不會遺失任何精確度的<xref:System.Numerics.BigInteger>使用這個建構函式。  
  
 <xref:System.Numerics.BigInteger>由呼叫這個建構函式產生的值完全相同的值所產生的指派<xref:System.UInt64>值<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29>建構函式來具現化<xref:System.Numerics.BigInteger>物件，其值等於<xref:System.UInt64.MaxValue>。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">數字。</param>
        <summary>取得 <see cref="T:System.Numerics.BigInteger" /> 物件的絕對值。</summary>
        <returns><paramref name="value" /> 的絕對值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表所示，數字的絕對值是沒有正負號，該數字。  
  
|`value` 參數|傳回值|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 <xref:System.Numerics.BigInteger.Abs%2A>方法就相當於<xref:System.Math.Abs%2A?displayProperty=nameWithType>基本數值類型的方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Numerics.BigInteger.Abs%2A>方法，將轉換<xref:System.Numerics.BigInteger>二補數表示序列化至檔案之前的標誌大小表示的值。 檔案中的資料然後還原序列化，並指派給新<xref:System.Numerics.BigInteger>物件。  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相加的第一個值。</param>
        <param name="right">要相加的第二個值。</param>
        <summary>兩個 <see cref="T:System.Numerics.BigInteger" /> 值相加，並傳回結果。</summary>
        <returns><paramref name="left" /> 和 <paramref name="right" /> 的總和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用運算子多載或自訂運算子不支援的語言<xref:System.Numerics.BigInteger.Add%2A>方法，以執行加法使用<xref:System.Numerics.BigInteger>值。  
  
 <xref:System.Numerics.BigInteger.Add%2A>具現化時，方法是加法運算子的有用替代<xref:System.Numerics.BigInteger>變數將它指派加法，產生的總和，如下列範例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>比較兩個 <see cref="T:System.Numerics.BigInteger" /> 值並傳回整數，這個整數表示第一個值小於、等於或大於第二個值。</summary>
        <returns>帶正負號的整數，表示 <paramref name="left" /> 和 <paramref name="right" /> 的相對值，如下表所示。  
  
 <list type="table"><listheader><term> 值 
 </term><description> 條件 
 </description></listheader><item><term> 小於零 
 </term><description><paramref name="left" /> 小於 <paramref name="right" />。  
  
 </description></item><item><term> 零 
 </term><description><paramref name="left" />等於 <paramref name="right" />。  
  
 </description></item><item><term> 大於零 
 </term><description><paramref name="left" /> 大於 <paramref name="right" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然<xref:System.Numerics.BigInteger>類型的任何固定的範圍比較<xref:System.Numerics.BigInteger>缺乏特性的比較浮點數的有效位數不特性值。 下列範例會比較兩個<xref:System.Numerics.BigInteger>一個且每個不同的值有 1,896 的數字。 <xref:System.Numerics.BigInteger.Compare%2A>方法會正確報告兩個值是否不相等。  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比較這個執行個體的值與另一個值，並且傳回整數，這個整數表示這個執行個體的值小於、等於或大於另一個值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">要比較的帶正負號 64 位元整數。</param>
        <summary>比較這個執行個體與帶正負號的 64 位元整數，並且傳回整數，這個整數表示這個執行個體的值小於、等於或大於帶正負號 64 位元整數的值。</summary>
        <returns>帶正負號的整數值，表示這個執行個體與 <paramref name="other" /> 的關聯性，如下表所示。  
  
 <list type="table"><listheader><term> 傳回值 
 </term><description> 描述 
 </description></listheader><item><term> 小於零 
 </term><description> 目前的執行個體小於 <paramref name="other" />。  
  
 </description></item><item><term> 零 
 </term><description> 目前的執行個體等於 <paramref name="other" />。  
  
 </description></item><item><term> 大於零 
 </term><description> 目前的執行個體大於 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`other`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29>呼叫方法。  
  
   
  
## Examples  
 下列範例說明呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29>具有整數值的方法。  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">要比較的物件。</param>
        <summary>比較這個執行個體與第二個 <see cref="T:System.Numerics.BigInteger" />，並且傳回整數，這個整數表示這個執行個體的值小於、等於或大於指定之物件的值。</summary>
        <returns>帶正負號的整數值，表示這個執行個體與 <paramref name="other" /> 的關聯性，如下表所示。  
  
 <list type="table"><listheader><term> 傳回值 
 </term><description> 描述 
 </description></listheader><item><term> 小於零 
 </term><description> 目前的執行個體小於 <paramref name="other" />。  
  
 </description></item><item><term> 零 
 </term><description> 目前的執行個體等於 <paramref name="other" />。  
  
 </description></item><item><term> 大於零 
 </term><description> 目前的執行個體大於 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Numerics.BigInteger.CompareTo%2A>方法會實作<xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType>方法。 它是泛型集合物件所用來排序的項目集合中。  
  
   
  
## Examples  
 下列範例示範如何將<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>方法來排序的清單`StarInfo`物件。 每個`StarInfo`物件會提供有關星號的名稱和其英哩地球的距離資訊。 `StarInfo` 會實作<xref:System.IComparable%601>介面，可讓`StarInfo`要排序的泛型集合類別的物件。 其<xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType>實作包裝起來呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>。  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 下列程式碼接著會執行個體化四`StarInfo`物件，並將它們儲存在泛型<xref:System.Collections.Generic.List%601>物件。 在後<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>呼叫方法時，`StarInfo`物件會顯示在地球的距離的順序。  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要比較的物件。</param>
        <summary>比較這個執行個體與特定物件，並且傳回一個整數，指出這個執行個體的值是小於、等於或大於特定物件的值。</summary>
        <returns>帶正負號的整數，表示目前執行個體與 <paramref name="obj" /> 參數的關聯性，如下表所示。  
  
 <list type="table"><listheader><term> 傳回值 
 </term><description> 描述 
 </description></listheader><item><term> 小於零 
 </term><description> 目前的執行個體小於 <paramref name="obj" />。  
  
 </description></item><item><term> 零 
 </term><description> 目前的執行個體等於 <paramref name="obj" />。  
  
 </description></item><item><term> 大於零 
 </term><description> 目前執行個體大於 <paramref name="obj" />，或者 <paramref name="obj" /> 參數為 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Numerics.BigInteger.CompareTo%2A>方法會實作<xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType>方法。 若要排序的項目集合中，它供非泛型集合物件。  
  
 `obj`參數必須是下列其中之一：  
  
-   物件，其執行階段型別為<xref:System.Numerics.BigInteger>。  
  
-   <xref:System.Object>變數，其值為`null`。 如果值`obj`參數是`null`，則方法會傳回 1，表示目前的執行個體大於`obj`。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Object%29>方法來比較<xref:System.Numerics.BigInteger>每個項目的物件陣列中的值  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> 不是 <see cref="T:System.Numerics.BigInteger" />。</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">要比較的不帶正負號 64 位元整數。</param>
        <summary>比較這個執行個體與不帶正負號的 64 位元整數，並且傳回整數，這個整數表示這個執行個體的值小於、等於或大於不帶正負號 64 位元整數的值。</summary>
        <returns>帶正負號的整數，表示這個執行個體與 <paramref name="other" /> 的相對值，如下表所示。  
  
 <list type="table"><listheader><term> 傳回值 
 </term><description> 描述 
 </description></listheader><item><term> 小於零 
 </term><description> 目前的執行個體小於 <paramref name="other" />。  
  
 </description></item><item><term> 零 
 </term><description> 目前的執行個體等於 <paramref name="other" />。  
  
 </description></item><item><term> 大於零 
 </term><description> 目前的執行個體大於 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">做為被除數的值。</param>
        <param name="divisor">做為除數的值。</param>
        <summary>某個 <see cref="T:System.Numerics.BigInteger" /> 值除以另一個值，並且傳回結果。</summary>
        <returns>相除的商數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Divide%2A>方法執行整數除法運算，會捨棄任何所得相除的餘數。 若要執行整數除法，同時保留其餘部分，呼叫<xref:System.Numerics.BigInteger.DivRem%2A>方法。 若要擷取的其餘部分，請呼叫<xref:System.Numerics.BigInteger.Remainder%2A>方法。  
  
 <xref:System.Numerics.BigInteger.Divide%2A>方法可供不支援運算子多載的語言。 它的行為等同於使用除法運算子的除法。  
  
   
  
## Examples  
 下列範例會建立陣列<xref:System.Numerics.BigInteger>值。 然後它會使用每個項目為在除法運算中使用的商數<xref:System.Numerics.BigInteger.Divide%2A>方法，除法運算子 （/），而<xref:System.Numerics.BigInteger.DivRem%2A>方法。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0 (零)。</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">做為被除數的值。</param>
        <param name="divisor">做為除數的值。</param>
        <param name="remainder">當這個方法傳回時，會包含表示相除餘數的 <see cref="T:System.Numerics.BigInteger" /> 值。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>某個 <see cref="T:System.Numerics.BigInteger" /> 值除以另一個值，傳回結果，並在輸出參數中傳回餘數。</summary>
        <returns>相除的商數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會保留的商數和所產生的整數除法的餘數。 如果您不想要的其餘部分中，使用<xref:System.Numerics.BigInteger.Divide%2A>只想要了解其餘部分，方法或除法運算子; 如果您是使用<xref:System.Numerics.BigInteger.Remainder%2A>方法。  
  
 傳回登`remainder`值是相同的正負號`dividend`參數。  
  
 行為<xref:System.Numerics.BigInteger.DivRem%2A>方法有相同的<xref:System.Math.DivRem%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會建立陣列<xref:System.Numerics.BigInteger>值。 然後它會使用每個項目為在除法運算中使用的商數<xref:System.Numerics.BigInteger.Divide%2A>方法，除法運算子 （/），而<xref:System.Numerics.BigInteger.DivRem%2A>方法。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0 (零)。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值，這個值表示兩個數值是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">要比較的帶正負號 64 位元整數值。</param>
        <summary>傳回值，這個值表示目前執行個體與帶正負號的 64 位元整數是否有相同的值。</summary>
        <returns>如果帶正負號的 64 位元整數與目前執行個體有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`other`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>時呼叫該方法的值。  
  
 若要判斷兩個物件，而不是只測試是否相等之間的關聯性，請呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會具現化<xref:System.Numerics.BigInteger>以外的每個整數類資料類型從物件<xref:System.UInt64>。 然後它會呼叫<xref:System.Numerics.BigInteger.Equals%28System.Int64%29>方法來比較<xref:System.Numerics.BigInteger>值與原始的整數值傳遞給<xref:System.Numerics.BigInteger>建構函式。 如輸出所示，就有一個值相等在每個案例。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">要比較的物件。</param>
        <summary>傳回值，這個值表示目前執行個體與指定的 <see cref="T:System.Numerics.BigInteger" /> 物件是否有相同的值。</summary>
        <returns>如果這個 <see cref="T:System.Numerics.BigInteger" /> 物件與 <paramref name="other" /> 有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會實作<xref:System.IEquatable%601>介面並執行稍微優於<xref:System.Numerics.BigInteger.Equals%28System.Object%29>因為它沒有轉換`other`參數來<xref:System.Numerics.BigInteger>物件。  
  
 若要判斷兩者之間的關聯性<xref:System.Numerics.BigInteger>物件，而非只測試是否相等，呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會比較從地球幾顆星的近似距離 Epsilon 指出，從以判斷它們是否相等的地球的距離。 此範例會使用的每個多載<xref:System.Numerics.BigInteger.Equals%2A>方法來測試是否相等。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要比較的物件。</param>
        <summary>傳回值，這個值表示目前執行個體與指定的物件是否有相同的值。</summary>
        <returns>如果 <paramref name="obj" /> 引數為 <see cref="T:System.Numerics.BigInteger" /> 物件，且其值等於目前 <see cref="T:System.Numerics.BigInteger" /> 執行個體的值，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`obj`引數不是<xref:System.Numerics.BigInteger>值，此方法會傳回`false`。 此方法會傳回`true`只有當`obj`是<xref:System.Numerics.BigInteger>其值等於目前的執行個體的執行個體。  
  
 若要判斷兩個物件，而不是只測試是否相等之間的關聯性，請呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Object%29>方法。  
  
   
  
## Examples  
 下列範例會定義平行<xref:System.Object>和<xref:System.Numerics.BigInteger>陣列。 其中一個陣列的每個項目具有相同的值為第二個陣列的對應元素。 範例所示，在執行個體的輸出<xref:System.Numerics.BigInteger>陣列會被視為等於中的執行個體<xref:System.Object>陣列才後者<xref:System.Numerics.BigInteger>和其值是否相等。  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">要比較的不帶正負號 64 位元整數。</param>
        <summary>傳回值，這個值表示目前執行個體與不帶正負號的 64 位元整數是否有相同的值。</summary>
        <returns>如果目前執行個體與不帶正負號的 64 位元整數有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要判斷兩個物件，而不是只測試是否相等之間的關聯性，請呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會比較從地球幾顆星的近似距離 Epsilon 指出，從以判斷它們是否相等的地球的距離。 此範例會使用的每個多載<xref:System.Numerics.BigInteger.Equals%2A>方法來測試是否相等。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前 <see cref="T:System.Numerics.BigInteger" /> 物件的雜湊碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一個值。</param>
        <param name="right">第二個值。</param>
        <summary>求兩個 <see cref="T:System.Numerics.BigInteger" /> 值的最大公因數。</summary>
        <returns><paramref name="left" /> 和 <paramref name="right" /> 的最大公因數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最大公因數是最大的數字，其中兩個<xref:System.Numerics.BigInteger>可以分割成的值，而不會傳回餘數。  
  
 如果`left`和`right`參數為非零的數字，此方法一律會傳回最小值為 1，因為所有數字除以 1。 如果其中一個參數為零，則方法會傳回非零參數的絕對值。 如果這兩個值都是零，則該方法會傳回零。  
  
> [!NOTE]
>  運算的很大的值的最大公因數`left`和`right`可以是非常耗時的作業。  
  
 所傳回的值<xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>方法一律是正數的正負號不論`left`和`right`參數。  
  
   
  
## Examples  
 下列範例說明呼叫<xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>方法和例外狀況處理所需的實用資訊提供有關<xref:System.ArgumentOutOfRangeException>。 結果會指出這兩個數字的最大公因數是 1。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示目前 <see cref="T:System.Numerics.BigInteger" /> 物件的值是否為偶數。</summary>
        <value>如果 <see cref="T:System.Numerics.BigInteger" /> 物件的值為偶數，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是方便的功能，指出是否<xref:System.Numerics.BigInteger>值是可由兩個。 相當於下列運算式：  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 如果目前的值<xref:System.Numerics.BigInteger>物件是否<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>，此屬性傳回`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示目前 <see cref="T:System.Numerics.BigInteger" /> 物件的值是否為 <see cref="P:System.Numerics.BigInteger.One" />。</summary>
        <value>如果 <see cref="T:System.Numerics.BigInteger" /> 物件的值為 <see cref="P:System.Numerics.BigInteger.One" />，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性提供的效能明顯優於其他的比較，例如`thisBigInteger.Equals(BigInteger.One)`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示目前 <see cref="T:System.Numerics.BigInteger" /> 物件的值是否為二乘冪。</summary>
        <value>如果 <see cref="T:System.Numerics.BigInteger" /> 物件的值為二乘冪，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性會決定是否<xref:System.Numerics.BigInteger>值已設定的單一非零位元。 這表示，它會傳回`true`如果目前的值<xref:System.Numerics.BigInteger>物件為 1 (也就是 2<sup>0</sup>) 或任何大於 2 的乘冪。 它會傳回`false`如果目前的值<xref:System.Numerics.BigInteger>物件為 0。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示目前 <see cref="T:System.Numerics.BigInteger" /> 物件的值是否為 <see cref="P:System.Numerics.BigInteger.Zero" />。</summary>
        <value>如果 <see cref="T:System.Numerics.BigInteger" /> 物件的值為 <see cref="P:System.Numerics.BigInteger.Zero" />，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會提供效能明顯優於`BigInteger.Equals(BigInteger.Zero)`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定數字的對數。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要找出其對數的數字。</param>
        <summary>傳回指定數字的自然 (底數為 <see langword="e" />) 對數。</summary>
        <returns><paramref name="value" /> 的 (以 <see langword="e" /> 為底數) 自然對數，如＜備註＞一節中的表格所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`參數指定為基底 10 的數字。  
  
 這個方法的值取決於的正負號的確切傳回`value`，如下表所示。  
  
|登入的`value`參數|傳回值|  
|-------------------------------|------------------|  
|正|自然對數`value`; 也就是 ln `value`，或 log e`value`。|  
|零|<xref:System.Double.NegativeInfinity>.|  
|負|<xref:System.Double.NaN>.|  
  
 若要計算的基底 10 對數<xref:System.Numerics.BigInteger>值，請呼叫<xref:System.Numerics.BigInteger.Log10%2A>方法。 若要計算在另一個基底中數字的對數，呼叫<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29>方法。  
  
 您可以找到數字的平方根，藉由呼叫<xref:System.Numerics.BigInteger.Log%2A>方法，連同<xref:System.Math.Exp%2A?displayProperty=nameWithType>方法。 請注意，結果是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>如果結果大於<xref:System.Double.MaxValue?displayProperty=nameWithType>。 下列範例會計算陣列中每個項目的平方根<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 這個方法會對應至<xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType>基本數值類型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> 的自然對數超出 <see cref="T:System.Double" /> 資料型別範圍。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要找出其對數的數字。</param>
        <param name="baseValue">對數的底數。</param>
        <summary>傳回指定底數中指定數字的對數。</summary>
        <returns><paramref name="baseValue" /> 的以 <paramref name="value" /> 為底數的對數，如＜備註＞一節中的表格所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`和`baseValue`參數會指定做為基底 10 的數字。  
  
 精確傳回方法的值而定的符號`value`正負號和值在`baseValue`，如下表所示。  
  
|`value` 參數|`baseValue` 參數|傳回值|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1)-(`baseValue` > 1)|logbaseValue (`value`)|  
|`value` < 0|(任意值)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(任意值)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(任意值)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(任意值)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 若要計算的基底 10 對數<xref:System.Numerics.BigInteger>值，請呼叫<xref:System.Numerics.BigInteger.Log10%2A>方法。 若要計算數字的自然對數，呼叫<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29>方法。  
  
 這個方法會對應至<xref:System.Math.Log%2A?displayProperty=nameWithType>基本數值類型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> 的對數超出 <see cref="T:System.Double" /> 資料型別範圍。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要找出其對數的數字。</param>
        <summary>傳回指定數字的以 10 為底數的對數。</summary>
        <returns><paramref name="value" /> 的以 10 為底數的對數，如＜備註＞一節中的表格所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`參數指定為基底 10 的數字。  
  
 方法的值而定的正負號的確切傳回`value`，如下表所示。  
  
|Value 參數的符號|傳回值|  
|-----------------------------|------------------|  
|正|基底 10 的對數`value`; 也就是說，log10`value`。|  
|零|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|負|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 若要計算自然對數<xref:System.Numerics.BigInteger>值，請呼叫<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法。 若要計算在另一個基底中數字的對數，呼叫<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType>方法。  
  
 這個方法會對應至<xref:System.Math.Log10%2A?displayProperty=nameWithType>基本數值類型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> 的底數 10 對數超出 <see cref="T:System.Double" /> 資料型別範圍。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回兩個 <see cref="T:System.Numerics.BigInteger" /> 值的較大值。</summary>
        <returns><paramref name="left" /> 或 <paramref name="right" /> 參數，擇一較大者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會對應至<xref:System.Math.Max%2A?displayProperty=nameWithType>基本數值類型的方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Numerics.BigInteger.Max%2A>方法來選取陣列中的最大數字<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回兩個 <see cref="T:System.Numerics.BigInteger" /> 值的較小值。</summary>
        <returns><paramref name="left" /> 或 <paramref name="right" /> 參數，擇一較小者。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會對應至<xref:System.Math.Min%2A?displayProperty=nameWithType>基本數值類型的方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Numerics.BigInteger.Min%2A>方法來選取陣列中的最小的數字<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示數字負一 (-1) 的值。</summary>
        <value>值為負一 (-1) 的整數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.MinusOne%2A>屬性用來比較<xref:System.Numerics.BigInteger>值為-1，或指派-1 表示<xref:System.Numerics.BigInteger>物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">具有乘冪數 <paramref name="exponent" /> 的數字。</param>
        <param name="exponent"><paramref name="value" /> 的乘冪指數。</param>
        <param name="modulus">要除以具有乘冪數 <paramref name="value" /> 之 <paramref name="exponent" /> 的數字。</param>
        <summary>一個數目自乘至另一個數目的乘冪後，執行模數除法。</summary>
        <returns><paramref name="value" /><sup>指數</sup> 除以 <paramref name="modulus" /> 後的餘數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ModPow%2A>方法會評估下列運算式：  
  
 (baseValue ^ 指數)Mod 的模數  
  
 若要執行上的乘冪<xref:System.Numerics.BigInteger>值而模數除法不使用<xref:System.Numerics.BigInteger.Pow%2A>方法。  
  
   
  
## Examples  
 下列範例提供簡單說明呼叫<xref:System.Numerics.BigInteger.ModPow%2A>方法。  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="modulus" /> 為零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> 為負。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相乘的第一個數字。</param>
        <param name="right">要相乘的第二個數字。</param>
        <summary>傳回兩個 <see cref="T:System.Numerics.BigInteger" /> 值的乘積。</summary>
        <returns><paramref name="left" /> 和 <paramref name="right" /> 參數的乘積。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Multiply%2A>方法的實作不支援運算子多載的語言。 它的行為等同於使用乘法運算子的乘法。 颾魤 ㄛ<xref:System.Numerics.BigInteger.Multiply%2A>具現化時，方法是乘法運算子的有用替代<xref:System.Numerics.BigInteger>變數指派給產品所產生的乘法，如下列範例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 如果有必要，這個方法會自動執行的其他整數類資料類型的隱含轉換<xref:System.Numerics.BigInteger>物件。 在下一步 區段中，此範例所示所在<xref:System.Numerics.BigInteger.Multiply%2A>方法會傳遞兩個<xref:System.Int64>值。  
  
   
  
## Examples  
 下列範例會嘗試執行乘法與兩個長整數。 結果超出範圍的長整數，因為<xref:System.OverflowException>就會擲回，而<xref:System.Numerics.BigInteger.Multiply%2A>呼叫方法來處理乘法運算。 請注意，C# 需要使用任何一種`checked`關鍵字 （如此範例所示） 或`/checked+`編譯器選項，請確定在數值溢位上擲回例外狀況。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要變換正負號的值。</param>
        <summary>將指定的 <see cref="T:System.Numerics.BigInteger" /> 值變換正負號。</summary>
        <returns><paramref name="value" /> 參數乘以負一 (-1) 的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 否定取得數字的加法反元素。 數字的加法反元素為它新增至原始的數字時，會產生值為零的數字。  
  
 <xref:System.Numerics.BigInteger.Negate%2A>方法的實作不支援自訂運算子的語言。 它的行為等同於使用一元負運算子的否定運算。 颾魤 ㄛ<xref:System.Numerics.BigInteger.Negate%2A>具現化時，方法是負運算子的有用替代<xref:System.Numerics.BigInteger>變數，如下列範例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 下列範例說明要變換正負號的值的三種方式<xref:System.Numerics.BigInteger>物件。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示數字一 (1) 的值。</summary>
        <value>值為一 (1) 的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.One%2A>屬性通常用來比較<xref:System.Numerics.BigInteger>值為 1，或指派 1 到<xref:System.Numerics.BigInteger>物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相加的第一個值。</param>
        <param name="right">要相加的第二個值。</param>
        <summary>兩個指定之 <see cref="T:System.Numerics.BigInteger" /> 物件的值相加。</summary>
        <returns><paramref name="left" /> 和 <paramref name="right" /> 的總和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Addition%2A>方法來定義加法運算，如<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Add%2A>方法改為。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一個值。</param>
        <param name="right">第二個值。</param>
        <summary>對兩個 <see cref="T:System.Numerics.BigInteger" /> 值執行位元 <see langword="And" /> 運算。</summary>
        <returns>位元 <see langword="And" /> 運算的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>方法定義的位元`And`作業<xref:System.Numerics.BigInteger>值。 位元`And`作業會設定結果位元只有當對應的位元`left`和`right`也設定下, 表所示。  
  
|位元 `left`|位元 `right`|在結果中的位元|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>方法可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>方法會執行位元`And`對兩個作業<xref:System.Numerics.BigInteger>值如同它們是在二補數具有表示虛擬的正負號擴充。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一個值。</param>
        <param name="right">第二個值。</param>
        <summary>對兩個 <see cref="T:System.Numerics.BigInteger" /> 值執行位元 <see langword="Or" /> 運算。</summary>
        <returns>位元 <see langword="Or" /> 運算的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>方法定義的位元`Or`作業<xref:System.Numerics.BigInteger>值。 位元`Or`作業會設定結果位元只有當一個或兩個對應位元`left`和`right`設定下, 表所示。  
  
|位元 `left`|位元 `right`|在結果中的位元|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>方法可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>方法會執行位元`Or`對兩個作業<xref:System.Numerics.BigInteger>值如同它們是在二補數具有表示虛擬的正負號擴充。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要遞減的值。</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 值遞減 1。</summary>
        <returns><paramref name="value" /> 參數遞減 1 後的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Decrement%2A>方法定義的遞減運算<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Subtract%2A>方法改為。 例如：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 因為<xref:System.Numerics.BigInteger>物件是不可變的<xref:System.Numerics.BigInteger.op_Decrement%2A>運算子會建立新<xref:System.Numerics.BigInteger>物件，其值為一個小於<xref:System.Numerics.BigInteger>所表示的物件`value`。 這表示，重複呼叫<xref:System.Numerics.BigInteger.op_Decrement%2A>可能很昂貴。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">做為被除數的值。</param>
        <param name="divisor">做為除數的值。</param>
        <summary>使用整數除法，將指定的 <see cref="T:System.Numerics.BigInteger" /> 值除以另一個指定的 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>相除的整數結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Division%2A>方法定義的除法運算<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 不支援自訂運算子和運算子多載的語言可以呼叫<xref:System.Numerics.BigInteger.Divide%2A>方法改為。  
  
 這個運算子的對等方法是 <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 下列範例會建立陣列<xref:System.Numerics.BigInteger>值。 然後它會使用每個項目為在除法運算中使用的商數<xref:System.Numerics.BigInteger.Divide%2A>方法，除法運算子 （/），而<xref:System.Numerics.BigInteger.DivRem%2A>方法。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0 (零)。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值，這個值表示兩個值是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示帶正負號長整數值與 <see cref="T:System.Numerics.BigInteger" /> 值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 與 <paramref name="right" /> 參數有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29>方法定義的相等比較運算<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>改為執行個體方法。  
  
 如果`left`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值與帶正負號長整數值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 與 <paramref name="right" /> 參數有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29>方法定義的相等比較運算<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>改為執行個體方法。  
  
 如果`right`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示兩個 <see cref="T:System.Numerics.BigInteger" /> 物件的值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 與 <paramref name="right" /> 參數有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法來定義等號比較運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>改為執行個體方法。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值與不帶正負號長整數值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 與 <paramref name="right" /> 參數有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法定義的相等比較運算<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>改為執行個體方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示不帶正負號長整數值與 <see cref="T:System.Numerics.BigInteger" /> 值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 與 <paramref name="right" /> 參數有相同的值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法定義的相等比較運算<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>改為執行個體方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一個值。</param>
        <param name="right">第二個值。</param>
        <summary>對兩個 <see cref="T:System.Numerics.BigInteger" /> 值執行位元互斥 <see langword="Or" /> (<see langword="XOr" />) 運算。</summary>
        <returns>位元 <see langword="Or" /> 運算的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 結果的位元互斥`Or`作業`true`如果兩個位元的值不同，否則為，則是`false`。 下表說明專用`Or`作業。  
  
|中的位元 x `left`|中的位元 x `right`|傳回值|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>方法可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>方法會執行位元互斥`Or`對兩個作業<xref:System.Numerics.BigInteger>值如同它們是在二補數具有表示虛擬的正負號擴充。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義 <see cref="T:System.Numerics.BigInteger" /> 物件與另一個類型之間的明確轉換。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從 <see cref="T:System.Decimal" /> 物件到 <see cref="T:System.Numerics.BigInteger" /> 值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小數部分`value`轉換前的參數會被截斷。

 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 因為從轉換<xref:System.Decimal>要<xref:System.Numerics.BigInteger>可能是截斷的任何小數部分`value`，語言編譯器不要自動執行這項轉換。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。   

 不支援自訂運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>。


## Examples
 下列範例會將陣列中的個別項目<xref:System.Decimal>值來<xref:System.Numerics.BigInteger>物件，並接著會顯示每個轉換的結果。 請注意，任何小數部分的<xref:System.Decimal>在轉換期間截斷值。   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從 <see cref="T:System.Double" /> 值到 <see cref="T:System.Numerics.BigInteger" /> 值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小數部分`value`轉換前的參數會被截斷。

 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 因為從轉換<xref:System.Double>要<xref:System.Numerics.BigInteger>可能是截斷的任何小數部分`value`，語言編譯器不要自動執行這項轉換。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。

 不支援自訂運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>。


## Examples
 下列範例會將陣列中的個別項目<xref:System.Double>值來<xref:System.Numerics.BigInteger>物件，並接著會顯示每個轉換的結果。 請注意，任何小數部分的<xref:System.Double>在轉換期間截斷值。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 為 <see cref="F:System.Double.NaN" />、<see cref="F:System.Double.PositiveInfinity" /> 或 <see cref="F:System.Double.NegativeInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Byte" /> 的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到不帶正負號位元組值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CByte`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。   

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Byte>資料型別。 不會在產生的有效位數遺失任何<xref:System.Byte>值，如果轉換成功。

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.Byte>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Byte>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.Byte.MinValue" /> 或大於 <see cref="F:System.Byte.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Decimal" /> 的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到 <see cref="T:System.Decimal" /> 值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CDec`Visual Basic 中) 使用。   

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Decimal>資料型別。 

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.Decimal>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Decimal>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.Decimal.MinValue" /> 或大於 <see cref="F:System.Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Double" /> 的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到 <see cref="T:System.Double" /> 值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CDbl`Visual Basic 中) 使用。   

 因為<xref:System.Numerics.BigInteger>值可以是範圍之外的<xref:System.Double>資料類型，這項作業是縮小轉換。 如果轉換失敗，它不會擲回<xref:System.OverflowException>。 相反地，如果<xref:System.Numerics.BigInteger>值是小於<xref:System.Double.MinValue?displayProperty=nameWithType>，產生<xref:System.Double>的值是<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。 如果<xref:System.Numerics.BigInteger>值大於<xref:System.Double.MaxValue?displayProperty=nameWithType>，產生<xref:System.Double>的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。
 
 轉換<xref:System.Numerics.BigInteger>至<xref:System.Double>可能會遺失有效位數。 在某些情況下，遺失有效位數可能會導致成功轉型或轉換作業即使<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Double>資料型別。 下列範例提供一個實例。 它會將指派的最大值<xref:System.Double>有兩個<xref:System.Numerics.BigInteger>變數，會遞增一個<xref:System.Numerics.BigInteger>9.999e291，然後測試是否相等的兩個變數的變數。 如預期般呼叫<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法會顯示不相等。 不過，較大的轉換<xref:System.Numerics.BigInteger>值反向<xref:System.Double>成功，雖然<xref:System.Numerics.BigInteger>值現在超過<xref:System.Double.MaxValue?displayProperty=nameWithType>。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.Double>值。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 16 位元帶正負號整數的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到 16 位元帶正負號整數值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CShort`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。   

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Int16>資料型別。 不會在產生的有效位數遺失任何<xref:System.Int16>值，如果轉換成功。

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.Int16>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Int16>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.Int16.MinValue" />，或是大於 <see cref="F:System.Int16.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 32 位元帶正負號整數的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到 32 位元帶正負號整數值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CInt`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。   

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Int32>資料型別。 不會在產生的有效位數遺失任何<xref:System.Int16>值，如果轉換成功。

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.Int32>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Int32>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.Int32.MinValue" />，或是大於 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 64 位元帶正負號整數的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到 64 位元帶正負號整數值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CLng`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。  

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Int64>資料型別。 

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.Int64>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Int64>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.Int64.MinValue" />，或是大於 <see cref="F:System.Int64.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為帶正負號 8 位元值的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到帶正負號 8 位元值的明確轉換。  
  
此應用程式開發介面不符合 CLS 標準。 符合規範的替代項目為 <see cref="T:System.Int16" />。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CSByte`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。  

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.SByte>資料型別。 不會在產生的有效位數遺失任何<xref:System.SByte>值，如果轉換成功。

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.SByte>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.SByte>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.SByte.MinValue" />，或是大於 <see cref="F:System.SByte.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為單精確度浮點值的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到單精確度浮點值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的最接近的可能表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為可能遺失資料或遺失有效位數。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CSng`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。    

 因為<xref:System.Numerics.BigInteger>值可以是範圍之外的<xref:System.Single>資料類型，這項作業是縮小轉換。 如果轉換失敗，它不會擲回<xref:System.OverflowException>。 相反地，如果<xref:System.Numerics.BigInteger>值是小於<xref:System.Single.MinValue?displayProperty=nameWithType>，產生<xref:System.Single>的值是<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>。 如果<xref:System.Numerics.BigInteger>值大於<xref:System.Single.MaxValue?displayProperty=nameWithType>，產生<xref:System.Single>的值是<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>。

 轉換<xref:System.Numerics.BigInteger>至<xref:System.Single>可能會遺失有效位數。 在某些情況下，遺失有效位數可能會導致成功轉型或轉換作業即使<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.Single>資料型別。 下列範例提供一個實例。 它會將指派的最大值<xref:System.Single>有兩個<xref:System.Numerics.BigInteger>變數，會遞增一個<xref:System.Numerics.BigInteger>9.999e291，然後測試是否相等的兩個變數的變數。 如預期般呼叫<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法會顯示不相等。 不過，較大的轉換<xref:System.Numerics.BigInteger>值反向<xref:System.Single>成功，雖然<xref:System.Numerics.BigInteger>值現在超過<xref:System.Single.MaxValue?displayProperty=nameWithType>。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.Single>值。   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為不帶正負號 16 位元整數的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到不帶正負號 16 位元整數值的明確轉換。  
  
此應用程式開發介面不符合 CLS 標準。 符合規範的替代項目為 <see cref="T:System.Int32" />。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CUShort`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。    

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.UInt16>資料型別。 不會在產生的有效位數遺失任何<xref:System.UInt16>值，如果轉換成功。

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.UInt16>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.UInt16>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.UInt16.MinValue" />，或是大於 <see cref="F:System.UInt16.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為不帶正負號 32 位元整數的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到不帶正負號 32 位元整數值的明確轉換。  
  
此應用程式開發介面不符合 CLS 標準。 符合規範的替代項目為 <see cref="T:System.Int64" />。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CUInt`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。    

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.UInt32>資料型別。 不會在產生的有效位數遺失任何<xref:System.UInt32>值，如果轉換成功。

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.UInt32>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.UInt32>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.UInt32.MinValue" />，或是大於 <see cref="F:System.UInt32.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為不帶正負號 64 位元整數的值。</param>
        <summary>定義從 <see cref="T:System.Numerics.BigInteger" /> 物件到不帶正負號 64 位元整數值的明確轉換。  
  
此應用程式開發介面不符合 CLS 標準。 符合規範的替代項目為 <see cref="T:System.Double" />。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 語言編譯器不會執行這項轉換會自動因為它可能會遺失資料。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`或`CULng`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。    

 由於這項作業定義的縮小轉換，仍會擲回<xref:System.OverflowException>如果在執行階段<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.UInt64>資料型別。 不會在產生的有效位數遺失任何<xref:System.UInt64>值，如果轉換成功。

## Examples
 下列範例說明轉換<xref:System.Numerics.BigInteger>至<xref:System.UInt64>值。 它也會處理<xref:System.OverflowException>因為擲回<xref:System.Numerics.BigInteger>的值超出範圍<xref:System.UInt64>資料型別。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 小於 <see cref="F:System.UInt64.MinValue" />，或是大於 <see cref="F:System.UInt64.MaxValue" />。</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從 <see cref="T:System.Single" /> 值到 <see cref="T:System.Numerics.BigInteger" /> 值的明確轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小數部分`value`轉換前的參數會被截斷。
 
 多載<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定義的類型，其中或從中<xref:System.Numerics.BigInteger>物件可以轉換。 因為從轉換<xref:System.Single>要<xref:System.Numerics.BigInteger>可能是截斷的任何小數部分`value`，語言編譯器不要自動執行這項轉換。 相反地，它們執行轉換 （在 C# 中) 轉型運算子或轉換函式時，才可以 (例如`CType`Visual Basic 中) 使用。 否則，它們會顯示編譯器錯誤。

 不支援自訂運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>。


## Examples
 下列範例會將陣列中的個別項目<xref:System.Single>值來<xref:System.Numerics.BigInteger>物件，並接著會顯示每個轉換的結果。 請注意，任何小數部分的<xref:System.Single>在轉換期間截斷值。
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> 為 <see cref="F:System.Single.NaN" />、<see cref="F:System.Single.PositiveInfinity" /> 或 <see cref="F:System.Single.NegativeInfinity" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值，這個值表示指定的值是否大於另一個指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元帶正負號的整數是否大於 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定義的作業 greater than 運算子<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>改為執行個體方法。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 如果`left`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 是否大於 64 位元帶正負號的整數值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定義的作業 greater than 運算子<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 如果`right`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否大於另一個 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定義的作業 greater than 運算子<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>方法改為。 它們也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否大於 64 位元不帶正負號的整數。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定義的作業 greater than 運算子<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否大於 64 位元不帶正負號的整數。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定義的作業 greater than 運算子<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值，這個值表示指定的值是否大於或等於另一個指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元帶正負號的整數是否大於或等於 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法來定義大於或等於運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 如果`left`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否大於或等於 64 位元帶正負號的整數值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法來定義大於或等於運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 如果`right`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否大於或等於另一個 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法來定義大於或等於運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否大於或等於 64 位元不帶正負號的整數值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法來定義大於或等於運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元不帶正負號的整數是否大於或等於 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大於 <paramref name="left" /> 則為 <paramref name="right" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法來定義大於或等於運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義 <see cref="T:System.Numerics.BigInteger" /> 物件與另一個型別之間的隱含轉換。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從不帶正負號的位元組到 <see cref="T:System.Numerics.BigInteger" /> 值的隱含轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小數部分`value`轉換前的參數會被截斷。

 不支援隱含運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 多載<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法會定義類型，或從自動轉換編譯器可以<xref:System.Numerics.BigInteger>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的值。 它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。 這個多載可讓編譯器處理從不<xref:System.Byte>值<xref:System.Numerics.BigInteger>值，如下列範例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從帶正負號的 16 位元整數到 <see cref="T:System.Numerics.BigInteger" /> 值的隱含轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支援隱含運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 多載<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法會定義類型，或從自動轉換編譯器可以<xref:System.Numerics.BigInteger>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的值。 它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。 這個多載可讓編譯器處理從不<xref:System.Int16>值<xref:System.Numerics.BigInteger>值，如下列範例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從帶正負號的 32 位元整數到 <see cref="T:System.Numerics.BigInteger" /> 值的隱含轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支援隱含運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。  

 多載<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法會定義類型，或從自動轉換編譯器可以<xref:System.Numerics.BigInteger>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的值。 它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。 這個多載可讓編譯器處理從不<xref:System.Int32>值<xref:System.Numerics.BigInteger>值，如下列範例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從帶正負號的 64 位元整數到 <see cref="T:System.Numerics.BigInteger" /> 值的隱含轉換。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支援隱含運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>。   
 
 多載<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法會定義類型，或從自動轉換編譯器可以<xref:System.Numerics.BigInteger>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的值。 它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。 這個多載可讓編譯器處理從不<xref:System.Int64>值<xref:System.Numerics.BigInteger>值，如下列範例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從 8 位元帶正負號的整數到 <see cref="T:System.Numerics.BigInteger" /> 值的隱含轉換。  
  
此應用程式開發介面不符合 CLS 標準。 符合規範的替代項目為 <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支援隱含運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 多載<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法會定義類型，或從自動轉換編譯器可以<xref:System.Numerics.BigInteger>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的值。 它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。 這個多載可讓編譯器處理從不<xref:System.SByte>值<xref:System.Numerics.BigInteger>值，如下列範例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從 16 位元不帶正負號的整數到 <see cref="T:System.Numerics.BigInteger" /> 值的隱含轉換。  
  
此應用程式開發介面不符合 CLS 標準。 符合規範的替代項目為 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支援隱含運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>。   

 多載<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法會定義類型，或從自動轉換編譯器可以<xref:System.Numerics.BigInteger>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的值。 它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。 這個多載可讓編譯器處理從不<xref:System.UInt16>值<xref:System.Numerics.BigInteger>值，如下列範例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從 32 位元不帶正負號的整數到 <see cref="T:System.Numerics.BigInteger" /> 值的隱含轉換。  
  
此應用程式開發介面不符合 CLS 標準。 符合規範的替代項目為 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支援隱含運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>。   

 多載<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法會定義類型，或從自動轉換編譯器可以<xref:System.Numerics.BigInteger>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的值。 它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。 這個多載可讓編譯器處理從不<xref:System.UInt32>值<xref:System.Numerics.BigInteger>值，如下列範例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">要轉換為 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定義從 64 位元不帶正負號的整數到 <see cref="T:System.Numerics.BigInteger" /> 值的隱含轉換。  
  
此應用程式開發介面不符合 CLS 標準。 符合規範的替代項目為 <see cref="T:System.Double" />。</summary>
        <returns>物件，包含 <paramref name="value" /> 參數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支援隱含運算子的語言，另一種方法是<xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>。   

 多載<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法會定義類型，或從自動轉換編譯器可以<xref:System.Numerics.BigInteger>而不需要明確轉型運算子 （在 C# 中) 或 （在 Visual Basic) 的轉換函式呼叫的值。 它們擴展轉換不會涉及資料遺失，並不會擲回<xref:System.OverflowException>。 這個多載可讓編譯器處理從不<xref:System.UInt64>值<xref:System.Numerics.BigInteger>值，如下列範例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要遞增的值。</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 值遞增 1。</summary>
        <returns><paramref name="value" /> 參數遞增 1 後的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Increment%2A>方法定義的遞增作業<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 某些語言 （例如 Visual Basic) 缺少遞增運算子，或不支援運算子多載可以呼叫<xref:System.Numerics.BigInteger.op_Increment%2A>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 因為<xref:System.Numerics.BigInteger>物件是不可變的<xref:System.Numerics.BigInteger.op_Increment%2A>運算子會建立新<xref:System.Numerics.BigInteger>物件，其值為一個以上<xref:System.Numerics.BigInteger>所表示的物件`value`。 因此，重複呼叫<xref:System.Numerics.BigInteger.op_Increment%2A>可能很昂貴。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值，這個值表示兩個數值是否不相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元帶正負號的整數與 <see cref="T:System.Numerics.BigInteger" /> 值是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定義的不等比較運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 不支援自訂運算子的語言可以使用其中一個下列技巧來測試不相等：  
  
-   呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>執行個體方法，這表示之間的關聯性<xref:System.Numerics.BigInteger>和帶正負號的長整數值。  
  
-   呼叫<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>執行個體方法，並反轉其值。  
  
 如果`left`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值與 64 位元帶正負號的整數是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定義的不等比較運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 不支援自訂運算子的語言可以使用其中一個下列技巧來測試不相等：  
  
-   呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法，即表示之間的關聯性<xref:System.Numerics.BigInteger>和帶正負號的長整數值。  
  
-   呼叫<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>方法，並反轉其值。  
  
 如果`right`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，指出兩個 <see cref="T:System.Numerics.BigInteger" /> 物件是否有不同的值。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定義的不等比較運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 不支援自訂運算子的語言可以使用其中一個下列技巧來測試不相等：  
  
-   呼叫<xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>方法，即表示兩個之間的關聯性<xref:System.Numerics.BigInteger>物件。  
  
-   呼叫<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法，並反轉其值。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值與 64 位元不帶正負號的整數是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定義的不等比較運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 不支援自訂運算子的語言可以使用其中一個下列技巧來測試不相等：  
  
-   呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法，即表示之間的關聯性<xref:System.Numerics.BigInteger>和不帶正負號的長整數值。  
  
-   呼叫<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>方法，並反轉其值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元不帶正負號的整數與 <see cref="T:System.Numerics.BigInteger" /> 值是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定義的不等比較運算子的營運<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 不支援自訂運算子的語言可以使用其中一個下列技巧來測試不相等：  
  
-   呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法，即表示之間的關聯性<xref:System.Numerics.BigInteger>和不帶正負號的長整數值。  
  
-   呼叫<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>方法，並反轉其值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要執行位元移位的值。</param>
        <param name="shift"><paramref name="value" /> 向左移位的位元數。</param>
        <summary>將 <see cref="T:System.Numerics.BigInteger" /> 值向左移動指定的位元數。</summary>
        <returns>已經向左移動指定之位元數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LeftShift%2A>方法定義的位元左移運算子操作<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  不同位元左移運算與整數基本項目中，於<xref:System.Numerics.BigInteger.op_LeftShift%2A>方法會保留原始的正負號<xref:System.Numerics.BigInteger>值。  
  
 不支援自訂運算子的語言可以執行位元左移運算，乘以`value`由`BigInteger.Pow(2, shift)`。 下列範例示範結果會使用這個運算子的結果相同。  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值，這個值表示指定的值是否小於第二個指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元帶正負號的整數是否小於 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法會定義為小於運算子的作業<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 如果`left`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否小於 64 位元帶正負號的整數。</summary>
        <returns>如果 <paramref name="left" /> 小於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法會定義為小於運算子的作業<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 如果`right`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否小於另一個 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法會定義為小於運算子的作業<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>方法改為。 某些語言也可以呼叫<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否小於 64 位元不帶正負號的整數。</summary>
        <returns>如果 <paramref name="left" /> 小於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法會定義為小於運算子的作業<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法改為。 它們也可以呼叫<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元不帶正負號的整數是否小於 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法會定義為小於運算子的作業<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法改為。 它們也可以呼叫<xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回值，這個值表示指定的值是否小於或等於另一個指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元帶正負號的整數是否小於或等於 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於或等於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定義作業的運算子的小於或等於<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法改為。 它們也可以呼叫<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 如果`left`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否小於或等於 64 位元帶正負號的整數。</summary>
        <returns>如果 <paramref name="left" /> 小於或等於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定義作業的運算子的小於或等於<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法改為。 它們也可以呼叫<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 如果`right`已<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>的值，則會隱含地轉換成<xref:System.Int64>值執行作業時。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否小於或等於另一個 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於或等於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定義作業的運算子的小於或等於<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Compare%2A>方法改為。 它們也可以呼叫<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 <see cref="T:System.Numerics.BigInteger" /> 值是否小於或等於 64 位元不帶正負號的整數。</summary>
        <returns>如果 <paramref name="left" /> 小於或等於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定義作業的運算子的小於或等於<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法改為。 它們也可以呼叫<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比較的第一個值。</param>
        <param name="right">要比較的第二個值。</param>
        <summary>傳回值，這個值表示 64 位元不帶正負號的整數是否小於或等於 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小於或等於 <paramref name="right" />，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定義作業的運算子的小於或等於<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法改為。 它們也可以呼叫<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法直接，如下列範例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">做為被除數的值。</param>
        <param name="divisor">做為除數的值。</param>
        <summary>傳回從兩個指定的 <see cref="T:System.Numerics.BigInteger" /> 值相除所得的餘數。</summary>
        <returns>相除所得到的餘數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Modulus%2A>方法定義的模數運算子操作<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType>方法改為。  
  
 正負號的模數作業所傳回的值而定的符號`dividend`:如果`dividend`是正數，模數作業會傳回正數的結果; 如果它是負數，模數運算會傳回負的結果。 模數作業的行為<xref:System.Numerics.BigInteger>值等同於與其他整數類資料類型的模數運算。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0 (零)。</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相乘的第一個值。</param>
        <param name="right">要相乘的第二個值。</param>
        <summary>將兩個指定的 <see cref="T:System.Numerics.BigInteger" /> 值相乘。</summary>
        <returns><paramref name="left" /> 與 <paramref name="right" /> 的乘積。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Multiply%2A>方法定義的乘法運算子操作<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">整數值。</param>
        <summary>傳回 <see cref="T:System.Numerics.BigInteger" /> 值的位元一進位補數。</summary>
        <returns><paramref name="value" /> 的位元一進位補數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_OnesComplement%2A>方法定義作業的位元一補數運算子的<xref:System.Numerics.BigInteger>值。 位元一補數運算子會反轉每個位元的數字的值。 也就是位元在`value`屬於 0 會設定為結果中的 1 和 1 的位元會設為 0，結果中。 <xref:System.Numerics.BigInteger.op_OnesComplement%2A>方法可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 不支援自訂運算子的語言或許可以呼叫<xref:System.Numerics.BigInteger.op_OnesComplement%2A>方法直接以執行位元一進位補數作業。 例如:   
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要執行位元移位的值。</param>
        <param name="shift"><paramref name="value" /> 向右移位的位元數。</param>
        <summary>將 <see cref="T:System.Numerics.BigInteger" /> 值向右移動指定的位元數。</summary>
        <returns>已經向右移動指定之位元數的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_RightShift%2A>方法定義的位元右移位運算子操作<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 不支援自訂運算子的語言可以執行位元右移運算，除以`value`所`BigInteger.Pow(2, shift)`，然後減去 1 次`shift`負值。 下列範例示範結果會使用這個運算子的結果相同。  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 如果`shift`大於或等於是肯定的位元數<xref:System.Numerics.BigInteger>的值，向右移位作業的結果是<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>。 如果`shift`負值的位元數大於<xref:System.Numerics.BigInteger>的值，向右移位作業的結果是<xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要被減的值 (被減數)。</param>
        <param name="right">要減去的值 (減數)。</param>
        <summary>將某個 <see cref="T:System.Numerics.BigInteger" /> 值減去另一個 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns><paramref name="right" /> 減去 <paramref name="left" /> 的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Subtraction%2A>方法定義之減法運算子的作業<xref:System.Numerics.BigInteger>值。 它可讓程式碼，如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType>方法改為。  
  
 這個運算子的對等方法是<xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要變換正負號的值。</param>
        <summary>將指定的 BigInteger 值變換正負號。</summary>
        <returns><paramref name="value" /> 參數乘以負一 (-1) 的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryNegation%2A>方法定義的一元負運算子 （或加法反元素運算子） 作業<xref:System.Numerics.BigInteger>值。 作業會產生值，它會新增至原始的數字時，導致 0 （零）。 不支援自訂運算子的語言可以呼叫<xref:System.Numerics.BigInteger.Negate%2A>方法改為。  
  
 這個運算子的對等方法是 <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 下列範例說明三種不同的方式，要變換正負號的值<xref:System.Numerics.BigInteger>物件。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">整數值。</param>
        <summary>傳回 <see cref="T:System.Numerics.BigInteger" /> 運算元的值。 (運算元的正負號不會變更)。</summary>
        <returns><paramref name="value" /> 運算元的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryPlus%2A>方法來定義一元正運算子，用於操作<xref:System.Numerics.BigInteger>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將數字的字串表示，轉換為其相等的 <see cref="T:System.Numerics.BigInteger" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">字串，包含要轉換的數字。</param>
        <summary>將數字的字串表示，轉換為其相等的 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>值，相當於以 <paramref name="value" /> 參數指定的數字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`參數應該是下列格式之數字的字串表示。  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|選擇性的泛空白字元。|  
|*簽署*|選擇性正負號。 有效的符號字元由<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>目前文化特性的屬性。|  
|*digits*|範圍從 0 到 9 的數字順序。 任何前置的零都會被忽略。|  
  
> [!NOTE]
>  所指定的字串`value`參數會解譯使用<xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>樣式。 它不能包含任何的群組分隔符號或小數分隔符號，而且不得有小數部分。  
  
 `value`參數會剖析使用的格式設定資訊中<xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType>初始化目前系統文化特性的物件。 如需詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。 若要將字串剖析使用特定文化特性格式資訊，請使用<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29>方法。  
  
> [!IMPORTANT]
>  如果您使用<xref:System.Numerics.BigInteger.Parse%2A>方法，以往返的字串表示的<xref:System.Numerics.BigInteger>所輸出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，您應該使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式規範，以產生的字串表示的方法<xref:System.Numerics.BigInteger>值。 否則的字串表示法<xref:System.Numerics.BigInteger>會保留 50 的原始值和資料的最高有效位數時可能會遺失您使用僅<xref:System.Numerics.BigInteger.Parse%2A>方法，以還原<xref:System.Numerics.BigInteger>值。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Numerics.BigInteger.Parse%28System.String%29>方法具現化兩個<xref:System.Numerics.BigInteger>物件。 乘以每個物件，另一個數字，然後再呼叫<xref:System.Numerics.BigInteger.Compare%2A>方法，以判斷兩個值之間的關聯性。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> 的格式不正確。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">字串，包含要轉換的數字。</param>
        <param name="style">指定 <paramref name="value" /> 可以使用的格式之列舉值的位元組合。</param>
        <summary>將指定樣式中數字的字串表示轉換為其相等的 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>值，相當於以 <paramref name="value" /> 參數指定的數字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`參數定義中允許的樣式項目 （例如空白字元、 正數或負數符號、 群組分隔符號或小數點符號）`value`剖析作業成功的參數。 `styles` 必須是從位元旗標組合<xref:System.Globalization.NumberStyles>列舉型別。 `style`參數可讓這個方法多載有用的時機`value`包含十六進位值的字串表示，當所表示之數字系統，（十進位或十六進位）`value`已知只能在執行階段，或當您不允許空白字元，或登符號在`value`。  
  
 值而定`style`，則`value`參數可能包括下列項目：  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 如果`style`包含<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>，則`value`參數可能包含下列項目：  
  
 [*ws*]*hexdigits*[*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|選擇性的泛空白字元。 空白字元可以出現在開頭`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標，也可以顯示在結尾`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。|  
|*$*|特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>目前文化特性的屬性。 目前的文化特性的貨幣符號會出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。|  
|*簽署*|選擇性正負號。 符號可以出現在開頭`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，也可以顯示在結尾`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 可用於括號`value`表示負值`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|從 0 到 9 的數字序列。 針對*fractional_digits*，只有數字 0 是有效。|  
|*、*|特定文化特性的群組分隔符號。 目前的文化特性的群組分隔符號可以出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。|  
|*.*|特定文化特性的貨幣符號。 目前的文化特性的貨幣符號會出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。 只是數字 0 會顯示為小數位數的剖析作業才會成功;如果*fractional_digits*包含任何其他數字，<xref:System.FormatException>就會擲回。|  
|E|"E"或者"E"字元，表示代表的值時，會以指數 （科學記號） 標記法。 `value`參數可代表指數標記法之數字，如果`style`包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*hexdigits*|一連串的從 0 到 f 或 0 到 f 的十六進位數字|  
  
> [!NOTE]
> 中的任何終止 NUL (u+0000) 字元`s`剖析作業中，不論值會忽略`style`引數。

 只有數字的字串 (對應至<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>樣式) 一律會成功剖析。 大部分的其餘<xref:System.Globalization.NumberStyles>成員控制可能存在，但不是一定要出現在輸入字串的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>成員會影響可能會出現在項目`value`。  
  
|`NumberStyles` 值|中的項目允許`value`除了數字|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*數字*只有項目。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小數點 （.） 及*小數位數*項目。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或"E"字元，這表示指數標記法，連同*exponential_digits*。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*號*開頭的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*號*結尾的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*號*括號括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|群組分隔符號 （，） 項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|貨幣 （$） 的項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有項目。 不過，`value`無法表示十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*開頭或結尾的項目`value`，*登*開頭`value`，並在小數點 (*。*) 符號。 `value`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`、 群組分隔符號 (*，*)，和小數點 (*。*) 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有項目。 不過，`value`無法代表十六進位數字。|  
  
> [!IMPORTANT]
>  如果您使用<xref:System.Numerics.BigInteger.Parse%2A>方法，以往返的字串表示的<xref:System.Numerics.BigInteger>所輸出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，您應該使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式規範，以產生的字串表示的方法<xref:System.Numerics.BigInteger>值。 否則的字串表示法<xref:System.Numerics.BigInteger>會保留 50 的原始值和資料的最高有效位數時可能會遺失您使用僅<xref:System.Numerics.BigInteger.Parse%2A>方法，以還原<xref:System.Numerics.BigInteger>值。  
  
 不同於其他<xref:System.Globalization.NumberStyles>的值，允許，但不是需要，在特定的樣式項目出現與否`value`，則<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>樣式值表示，在個別的數字字元`value`一律會解譯為十六進位字元。 有效的十六進位字元是 0-9、 A-F 和 a-f。 只有其他旗標，可以結合`style`參數都<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 (<xref:System.Globalization.NumberStyles>列舉會包含複合的數字樣式<xref:System.Globalization.NumberStyles.HexNumber>，其中包含這兩個空格旗標。)  
  
> [!NOTE]
>  如果`value`的字串表示法的十六進位數字，它無法加上任何裝飾 (例如`0x`或`&h`)，區隔其為十六進位的數字。 這會導致轉換失敗。  
  
 如果`value`是十六進位字串，<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法會解譯`value`為負數儲存透過其前兩個十六進位數字是否大於或等於二補數表示`0x80`。 換句話說，此方法會解譯中的第一個位元組的最高序位位元`value`為正負號位元。 若要確定為正數中的第一個數字會正確解譯為十六進位字串`value`必須具有值為零。 比方說，此方法會將解譯`0x80`為負數值，但它會解譯其中一個`0x080`或`0x0080`為正值。 下列範例說明十六進位的字串代表負數和正數的值之間的差異。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `value`參數會剖析使用的格式設定資訊中<xref:System.Globalization.NumberFormatInfo>初始化目前系統文化特性的物件。 若要指定的文化特性的格式資訊用於剖析作業，請呼叫<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>多載。  
  
   
  
## Examples  
 下列範例說明如何呼叫<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法有數個可能的值為`style`參數。 它說明如何將字串解譯為十六進位值時，以及如何不允許空格和登入的符號。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
-或- 
 <paramref name="style" /> 包含 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 旗標和其他值。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> 不符合由 <see cref="T:System.Globalization.NumberStyles" /> 所指定的輸入模式。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">字串，包含要轉換的數字。</param>
        <param name="provider">提供關於 <paramref name="value" /> 之特定文化特性格式資訊的物件。</param>
        <summary>將使用指定特定文化特性格式之數字的字串表示轉換為其相等的 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>值，相當於以 <paramref name="value" /> 參數指定的數字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`參數應該是下列格式之數字的字串表示：  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|選擇性的泛空白字元。|  
|*簽署*|選擇性正負號。 有效的符號字元由<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>並<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>的屬性<xref:System.Globalization.NumberFormatInfo>所傳回的物件`provider`物件的<xref:System.IFormatProvider.GetFormat%2A>方法。|  
|*digits*|範圍從 0 到 9 的數字順序。 任何前置的零都會被忽略。|  
  
> [!NOTE]
>  所指定的字串`value`參數會解譯使用<xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>樣式。 它不能包含任何的群組分隔符號或小數分隔符號，而且不得有小數部分。  
  
> [!IMPORTANT]
>  如果您使用<xref:System.Numerics.BigInteger.Parse%2A>方法，以往返的字串表示的<xref:System.Numerics.BigInteger>所輸出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，您應該使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式規範，以產生的字串表示的方法<xref:System.Numerics.BigInteger>值。 否則的字串表示法<xref:System.Numerics.BigInteger>會保留 50 的原始值和資料的最高有效位數時可能會遺失您使用僅<xref:System.Numerics.BigInteger.Parse%2A>方法，以還原<xref:System.Numerics.BigInteger>值。  
  
 `provider`參數是<xref:System.IFormatProvider>實作其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供特定文化特性格式資訊的物件。 當<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29>叫用方法時，它會呼叫`provider`參數的<xref:System.IFormatProvider.GetFormat%2A>方法並將它傳遞<xref:System.Type>物件，表示<xref:System.Globalization.NumberFormatInfo>型別。 <xref:System.IFormatProvider.GetFormat%2A>方法接著會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供格式的相關資訊`value`參數。 若要使用的三種方式`provider`參數來提供自訂格式化剖析作業資訊：  
  
-   您可以傳遞<xref:System.Globalization.CultureInfo>物件，表示提供的格式資訊的文化特性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供用於該文化特性的數值格式資訊的物件。  
  
-   您可以傳遞的實際<xref:System.Globalization.NumberFormatInfo>提供數值格式資訊的物件。 (其實作的<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只會傳回本身。)  
  
-   您可以傳遞自訂物件實作<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法具現化，並傳回<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 如果`provider`已`null`的格式化`value`解譯根據<xref:System.Globalization.NumberFormatInfo>目前文化特性的物件。  
  
   
  
## Examples  
 下列範例會顯示兩種方式可定義波狀符號 （~） 為格式化的負號<xref:System.Numerics.BigInteger>值。 請注意，顯示<xref:System.Numerics.BigInteger>相同的格式為原始字串中的值，您的程式碼必須呼叫<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法並將它傳遞<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 第一個範例中定義類別可實作<xref:System.IFormatProvider>並用<xref:System.IFormatProvider.GetFormat%2A>方法來傳回<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 A<xref:System.Numerics.BigInteger>可以然後具現化物件為下列程式碼：  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 第二個範例是更簡單。 它會傳遞<xref:System.Globalization.NumberFormatInfo>物件，提供格式設定資訊給`provider`參數。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> 的格式不正確。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">字串，包含要轉換的數字。</param>
        <param name="style">指定 <paramref name="value" /> 可以使用的格式之列舉值的位元組合。</param>
        <param name="provider">提供關於 <paramref name="value" /> 之特定文化特性格式資訊的物件。</param>
        <summary>將數字的字串表示 (使用指定樣式和特定文化特性的格式) 轉換為其相等的 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>值，相當於以 <paramref name="value" /> 參數指定的數字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`參數定義中允許的樣式項目 （例如空白字元、 正數或負數符號、 群組分隔符號或小數點符號）`value`剖析作業成功的參數。 `styles` 必須是從位元旗標組合<xref:System.Globalization.NumberStyles>列舉型別。 `style`參數可讓這個方法多載有用的時機`value`包含十六進位值的字串表示，當所表示之數字系統，（十進位或十六進位）`value`已知只能在執行階段，或當您不允許空白字元，或登符號在`value`。  
  
 值而定`style`，則`value`參數可能包括下列項目：  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 如果`style`包含<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>，則`value`參數可能包括下列項目：  
  
 [*ws*]*hexdigits*[*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|選擇性的泛空白字元。 空白字元可以出現在開頭`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標，也可以顯示在結尾`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。|  
|*$*|特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>並<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>所指定的文化特性屬性`provider`參數。 目前的文化特性的貨幣符號會出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。|  
|*簽署*|選擇性正負號。 符號可以出現在開頭`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，也可以顯示在結尾`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 可用於括號`value`表示負值`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|從 0 到 9 的數字序列。 針對*fractional_digits*，只有數字 0 是有效。|  
|*、*|特定文化特性的群組分隔符號。 指定的文化特性的群組分隔符號`provider`可以出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。|  
|*.*|特定文化特性的貨幣符號。 所指定的文化特性的小數點符號`provider`可以出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。 只是數字 0 會顯示為小數位數的剖析作業才會成功;如果*fractional_digits*包含任何其他數字，<xref:System.FormatException>就會擲回。|  
|E|"E"或者"E"字元，表示代表的值時，會以指數 （科學記號） 標記法。 `value`參數可代表指數標記法之數字，如果`style`包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*hexdigits*|一連串的從 0 到 f 或 0 到 f 的十六進位數字|  
  
> [!NOTE]
> 中的任何終止 NUL (u+0000) 字元`s`剖析作業中，不論值會忽略`style`引數。

 只有數字的字串 (對應至<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>樣式) 一律會成功剖析。 大部分的其餘<xref:System.Globalization.NumberStyles>成員控制可能存在，但不是一定要出現在輸入字串的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>成員會影響可能會出現在項目`value`。  
  
|NumberStyles 值|除了數字的值中允許的項目|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*數字*只有項目。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小數點 （.） 及*小數位數*項目。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或者"E"字元，這表示指數標記法。 連同*exponential_digits*。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*號*開頭的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*號*結尾的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*號*括號括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|群組分隔符號 （，） 項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|貨幣 （$） 的項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有項目。 不過，`value`無法表示十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*開頭或結尾的項目`value`，*登*開頭`value`，且小數點 （.） 的符號。 `value`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`、 群組分隔符號 （、）、 和小數點 （.） 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有項目。 不過，`value`無法代表十六進位數字。|  
  
> [!IMPORTANT]
>  如果您使用<xref:System.Numerics.BigInteger.Parse%2A>方法，以往返的字串表示的<xref:System.Numerics.BigInteger>所輸出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，您應該使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式規範，以產生的字串表示的方法<xref:System.Numerics.BigInteger>值。 否則的字串表示法<xref:System.Numerics.BigInteger>會保留 50 的原始值和資料的最高有效位數時可能會遺失您使用僅<xref:System.Numerics.BigInteger.Parse%2A>方法，以還原<xref:System.Numerics.BigInteger>值。  
  
 不同於其他<xref:System.Globalization.NumberStyles>的值，允許，但不是需要特定的 style 項目出現與否`value`，則<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>樣式值表示，在個別的數字字元`value`一律會解譯為十六進位字元。 有效的十六進位字元是 0-9、 A-F 和 a-f。 只有其他旗標，可以結合`style`參數都<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 (<xref:System.Globalization.NumberStyles>列舉會包含複合的數字樣式<xref:System.Globalization.NumberStyles.HexNumber>，其中包含這兩個空格旗標。)  
  
> [!NOTE]
>  如果`value`的字串表示法的十六進位數字，它無法加上任何裝飾 (例如`0x`或`&h`)，區隔其為十六進位的數字。 這會導致轉換失敗。  
  
 如果`value`是十六進位字串，<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法會解譯`value`為負數儲存透過其前兩個十六進位數字是否大於或等於二補數表示`0x80`。 換句話說，此方法會解譯中的第一個位元組的最高序位位元`value`為正負號位元。 若要確定為正數中的第一個數字會正確解譯為十六進位字串`value`必須具有值為零。 比方說，此方法會將解譯`0x80`為負數值，但它會解譯其中一個`0x080`或`0x0080`為正值。 下列範例說明十六進位的字串代表負數和正數的值之間的差異。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `provider`參數是<xref:System.IFormatProvider>實作。 其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性格式資訊`value`。 一般而言，`provider`可以是下列任一項：  
  
-   A<xref:System.Globalization.CultureInfo>物件，表示提供數值格式資訊的文化特性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供數值格式資訊的物件。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。 (其實作的<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只會傳回本身。)  
  
-   自訂物件實作<xref:System.IFormatProvider>並用<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>方法來具現化，並傳回<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 如果`provider`已`null`，則<xref:System.Globalization.NumberFormatInfo>物件會使用目前的文化特性。  
  
   
  
## Examples  
 下列範例使數次呼叫<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法使用的值的各種組合`style`和`provider`參數。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 個別的呼叫數<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法傳遞執行個體的下列`BigIntegerFormatProvider`類別，定義為負號的波狀符號 （~）。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
-或- 
 <paramref name="style" /> 包含 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 旗標和其他值。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> 不符合由 <paramref name="style" /> 所指定的輸入模式。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">具有乘冪數 <paramref name="exponent" /> 的數字。</param>
        <param name="exponent"><paramref name="value" /> 的乘冪指數。</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 值自乘至指定之值的乘冪。</summary>
        <returns><paramref name="value" /> 自乘至 <paramref name="exponent" /> 乘冪的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Pow%2A>指數參數的值為 0，則方法會傳回 1 的值`value`和`exponent`參數為 0。 如果`exponent`為 1，<xref:System.Numerics.BigInteger.Pow%2A>方法會傳回`value`。 如果`value`是負數，此方法會傳回負的結果。  
  
 這個方法會對應至<xref:System.Math.Pow%2A?displayProperty=nameWithType>基本數值類型的方法。  
  
   
  
## Examples  
 下列範例說明使用乘冪<xref:System.Numerics.BigInteger>值和其值範圍從 0 到 10 的指數。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> 為負。</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">做為被除數的值。</param>
        <param name="divisor">做為除數的值。</param>
        <summary>對兩個 <see cref="T:System.Numerics.BigInteger" /> 值執行整數除法運算，並傳回餘數。</summary>
        <returns><paramref name="dividend" /> 除以 <paramref name="divisor" /> 後的餘數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 餘數的正負號是`dividend`參數。  
  
 <xref:System.Numerics.BigInteger.Remainder%2A>方法的實作不支援自訂運算子的語言。 它的行為等同於使用模數運算子的除法。  
  
 如果有必要，方法會自動執行的其他整數類資料類型的隱含轉換<xref:System.Numerics.BigInteger>物件再執行模數運算。  
  
   
  
## Examples  
 下列範例會比較從餘數<xref:System.Numerics.BigInteger.DivRem%2A>方法所傳回的其餘<xref:System.Numerics.BigInteger.Remainder%2A>方法，以建立兩種方法計算相同的餘數。  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> 是 0 (零)。</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得數字，這個數字表示目前 <see cref="T:System.Numerics.BigInteger" /> 物件的正負號 (負數、正數或零)。</summary>
        <value>數字，表示 <see cref="T:System.Numerics.BigInteger" /> 物件的正負號，如下表所示。  
  
 <list type="table"><listheader><term> number 
 </term><description> 描述 
 </description></listheader><item><term> -1 
 </term><description> 這個物件的值為負數。  
  
 </description></item><item><term> 0 
 </term><description> 這個物件的值為 0 (零)。  
  
 </description></item><item><term> 1 
 </term><description> 這個物件的值為正數。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Sign%2A>屬性就相當於<xref:System.Math.Sign%2A?displayProperty=nameWithType>基本數值類型的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要被減的值 (被減數)。</param>
        <param name="right">要減去的值 (減數)。</param>
        <summary>某個 <see cref="T:System.Numerics.BigInteger" /> 值減去另一個值，並且傳回結果。</summary>
        <returns><paramref name="right" /> 減去 <paramref name="left" /> 的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用不支援自訂運算子的語言<xref:System.Numerics.BigInteger.Subtract%2A>方法，以執行減法使用<xref:System.Numerics.BigInteger>值。  
  
 <xref:System.Numerics.BigInteger.Subtract%2A>具現化時，方法是減法運算子的有用替代<xref:System.Numerics.BigInteger>變數將它指派減法，產生的差異，如下列範例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將 <see cref="T:System.Numerics.BigInteger" /> 值轉換成位元組陣列。</summary>
        <returns>目前 <see cref="T:System.Numerics.BigInteger" /> 物件的值，已轉換為位元組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法所傳回陣列中個別的位元組由小到大順序出現。 也就是低序位位元組值的前面的高序位位元組。 陣列的第一個位元組會反映第一個八位元<xref:System.Numerics.BigInteger>第二個位元組的值會反映，接下來的八個位元，依此類推。 例如，值為 1024 或 0x0400，儲存為下列兩個位元組的陣列：  
  
|元素|位元組值|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 負值會寫入到陣列中的最精簡的格式可能使用二補數表示法。 例如，-1 以其值是單一位元組`0xFF`而不是以多個項目時，陣列這類`0xFF`，`0xFF`或`0xFF`， `0xFF`， `0xFF`， `0xFF`。  
  
 因為二補數表示一律會解譯陣列中的最後一個位元組的最高序位位元 (位置處的位元組<xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) 做為正負號位元，方法會傳回額外的項目，其值為零的位元組陣列至釐清正數值，否則無法解譯為具有其正負號位元都設定。 比方說，120 的值或`0x78`表示為單一位元組陣列： `0x78`。 不過，128，或是`0x80`，表示為兩個位元組陣列： `0x80`， `0x00`。  
  
 您可以往返<xref:System.Numerics.BigInteger>值，將其儲存為位元組陣列，然後再還原使用<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>建構函式。  
  
> [!CAUTION]
>  如果您的程式碼修改個別陣列中的位元組之前它會還原值，這個方法所傳回的值，您必須確定，您不小心變更正負號位元。 例如，如果您修改增加正數值，使最高順序位元的位元組陣列的最後一個元素會變成設定，您可以加入新的位元組，其值為陣列結尾的零。  
  
   
  
## Examples  
 下列範例將說明一些<xref:System.Numerics.BigInteger>值都表示位元組陣列。  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將目前 <see cref="T:System.Numerics.BigInteger" /> 物件的數值，轉換為其相等的字串表示。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前 <see cref="T:System.Numerics.BigInteger" /> 物件的數值，轉換為其相等的字串表示。</summary>
        <returns>目前 <see cref="T:System.Numerics.BigInteger" /> 值的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString>方法格式<xref:System.Numerics.BigInteger>"R"或反覆存取，目前的文化特性的格式中的值。 如果您想要指定不同的格式或文化特性，使用的其他多載<xref:System.Numerics.BigInteger.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用多載|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 格式|特定文化特性|<xref:System.Numerics.BigInteger.ToString%2A>|  
|以特定格式|預設值 （目前） 的文化特性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|以特定格式|特定文化特性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 字串表示<xref:System.Numerics.BigInteger>值包含負號，如果其值為負數，且沒有前置零範圍從 0 到 9 的數字順序。 所定義的負號<xref:System.Globalization.NumberFormatInfo>目前的文化特性的物件。  
  
   
  
## Examples  
 下列範例會顯示<xref:System.Numerics.BigInteger>使用預設值<xref:System.Numerics.BigInteger.ToString>方法。 它也會顯示的字串表示<xref:System.Numerics.BigInteger>無法使用某些標準格式規範所產生的值。 範例會顯示使用 EN-US 文化特性的格式化慣例。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>使用指定的文化特性特定格式資訊，將目前 <see cref="T:System.Numerics.BigInteger" /> 物件的數值轉換為其對等字串表示。</summary>
        <returns>目前 <see cref="T:System.Numerics.BigInteger" /> 值的字串表示，採用 <paramref name="provider" /> 參數所指定的格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>方法格式<xref:System.Numerics.BigInteger>值中的"R"或反覆存取，使用格式化<xref:System.Globalization.NumberFormatInfo>指定文化特性的物件。 如果您想要指定不同的格式或目前的文化特性，使用的其他多載<xref:System.Numerics.BigInteger.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用多載|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 格式|預設值 （目前） 的文化特性|<xref:System.Numerics.BigInteger.ToString>|  
|以特定格式|預設值 （目前） 的文化特性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|以特定格式|特定文化特性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `provider`參數是<xref:System.IFormatProvider>實作。 其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供特定文化特性格式資訊的字串，這個方法所傳回的物件。 如果`provider`已`null`，則<xref:System.Numerics.BigInteger>值的格式使用<xref:System.Globalization.NumberFormatInfo>目前文化特性的物件。 唯一的屬性<xref:System.Globalization.NumberFormatInfo>控制項的字串表示的物件<xref:System.Numerics.BigInteger>使用一般格式規範的值是<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>，它會定義表示的負號的字元。  
  
 `provider`參數可以是下列其中之一：  
  
-   A<xref:System.Globalization.CultureInfo>物件，表示提供的格式資訊的文化特性。  
  
-   <xref:System.Globalization.NumberFormatInfo>物件，提供格式設定資訊。  
  
-   自訂物件實作<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供的格式資訊的物件。  
  
   
  
## Examples  
 下列範例會具現化自訂<xref:System.Globalization.NumberFormatInfo>波狀符號 （~） 中定義的負號的物件。 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>方法接著會使用自訂<xref:System.Globalization.NumberFormatInfo>物件，以顯示負<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">標準或自訂數值格式字串。</param>
        <summary>使用指定的格式，將目前 <see cref="T:System.Numerics.BigInteger" /> 物件的值，轉換為其相等字串表示。</summary>
        <returns>目前 <see cref="T:System.Numerics.BigInteger" /> 值的字串表示，採用 <paramref name="format" /> 參數所指定的格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%29>方法格式<xref:System.Numerics.BigInteger>中指定的格式，使用值<xref:System.Globalization.NumberFormatInfo>物件，表示目前的文化特性的慣例。 如果您想要使用"R"或反覆存取時，格式化或指定不同的文化特性，請使用的其他多載<xref:System.Numerics.BigInteger.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用多載|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 格式|預設值 （目前） 的文化特性|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") 格式|特定文化特性|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|以特定格式|特定文化特性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `format`參數可以是任何有效[標準數值字串](~/docs/standard/base-types/standard-numeric-format-strings.md)，或任何組合[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 如果`format`等於<xref:System.String.Empty?displayProperty=nameWithType>是否`null`，目前的傳回值<xref:System.Numerics.BigInteger>物件的格式使用來回行程格式規範 ("R")。 如果`format`是任何其他值，則方法會擲回<xref:System.FormatException>。  
  
 .NET Framework 會提供廣泛的格式化支援，這會在下列格式化主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需在.NET Framework 格式支援的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 傳回字串的格式取決於<xref:System.Globalization.NumberFormatInfo>目前的文化特性的物件。 取決於`format`參數，這個物件可控制例如負號、 群組分隔符號和小數點符號，輸出字串中的符號。 若要提供目前的文化特性以外的文化特性格式資訊，請呼叫<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>多載。  
  
   
  
## Examples  
 下列範例會初始化<xref:System.Numerics.BigInteger>值並將它顯示使用每個標準格式字串和一些自訂格式字串。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 不是有效的格式字串。</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">標準或自訂數值格式字串。</param>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <summary>使用指定的格式和特定文化特性的格式資訊，將目前 <see cref="T:System.Numerics.BigInteger" /> 物件的數值，轉換為其相等的字串表示。</summary>
        <returns>目前 <see cref="T:System.Numerics.BigInteger" /> 值的字串表示 (如 <paramref name="format" /> 和 <paramref name="provider" /> 參數所指定)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>方法格式<xref:System.Numerics.BigInteger>中指定的格式，使用值<xref:System.Globalization.NumberFormatInfo>指定文化特性的物件。 如果您想要使用的來回行程格式或預設文化特性設定，使用的其他多載<xref:System.Numerics.BigInteger.ToString%2A>方法，如下所示：  
  
|若要使用格式|文化特性|使用多載|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 格式|預設值 （目前） 的文化特性|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") 格式|特定文化特性|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|以特定格式|預設值 （目前） 的文化特性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 `format`參數可以是任何有效[標準數值字串](~/docs/standard/base-types/standard-numeric-format-strings.md)，或任何組合[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 如果`format`等於<xref:System.String.Empty?displayProperty=nameWithType>是否`null`，目前的傳回值<xref:System.Numerics.BigInteger>物件的格式使用來回行程格式規範 ("R")。 如果`format`是任何其他值，則方法會擲回<xref:System.FormatException>。  
  
 .NET Framework 會提供廣泛的格式化支援，這會在下列格式化主題中的更詳細地說明：  
  
-   如需有關數值格式規範的詳細資訊，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   如需在.NET Framework 格式支援的詳細資訊，請參閱[格式化型別](~/docs/standard/base-types/formatting-types.md)。  
  
 `provider`參數是<xref:System.IFormatProvider>實作。 其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供特定文化特性格式資訊的字串，這個方法所傳回的物件。 當<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>叫用方法時，它會呼叫`provider`參數的<xref:System.IFormatProvider.GetFormat%2A>方法並將它傳遞<xref:System.Type>物件，表示<xref:System.Globalization.NumberFormatInfo>型別。 <xref:System.IFormatProvider.GetFormat%2A>方法接著會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供格式化資訊`value`參數，例如負號、 群組分隔符號或小數點符號。 若要使用的三種方式`provider`參數來提供格式設定資訊給<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>方法：  
  
-   您可以傳遞<xref:System.Globalization.CultureInfo>物件，表示提供的格式資訊的文化特性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供用於該文化特性的數值格式資訊的物件。  
  
-   您可以傳遞的實際<xref:System.Globalization.NumberFormatInfo>提供數值格式資訊的物件。 (其實作的<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只會傳回本身。)  
  
-   您可以傳遞自訂物件實作<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法具現化，並傳回<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 如果`provider`已`null`，傳回字串的格式根據<xref:System.Globalization.NumberFormatInfo>目前文化特性的物件。  
  
   
  
## Examples  
 下列範例會初始化<xref:System.Numerics.BigInteger>值，並將它顯示到主控台使用的標準格式字串和<xref:System.Globalization.NumberFormatInfo>波狀符號 （~） 中定義的負號的物件。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 不是有效的格式字串。</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試將數字的字串表示轉換成其相等的 <see cref="T:System.Numerics.BigInteger" />，並傳回一個值表示轉換是否成功。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">數字的字串表示。</param>
        <param name="result">當這個方法傳回時，如果轉換成功，則會包含相當於 <paramref name="value" /> 中所含之數字的 <see cref="T:System.Numerics.BigInteger" />；如果轉換失敗則為零 (0)。 轉換失敗的狀況包括：如果 <paramref name="value" /> 參數為 <see langword="null" /> 或不是正確的格式。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>嘗試將數字的字串表示轉換成其相等的 <see cref="T:System.Numerics.BigInteger" />，並傳回一個值表示轉換是否成功。</summary>
        <returns>如果 <see langword="true" /> 轉換成功，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29>方法就像<xref:System.Numerics.BigInteger.Parse%28System.String%29>方法，但是它不會擲回例外狀況如果轉換失敗。 這個方法就不需要使用例外狀況處理來測試<xref:System.FormatException>如果`value`無效，無法成功剖析。  
  
 `value`參數應該是以下列形式的十進位數字的字串表示：  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|選擇性的泛空白字元。|  
|*簽署*|選擇性正負號。 有效的符號字元由<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>目前文化特性的屬性。|  
|*digits*|範圍從 0 到 9 的十進位數字的序列。|  
  
> [!NOTE]
>  所指定的字串`value`參數不能包含任何的群組分隔符號或小數分隔符號，而且它不能有小數部分。  
  
 `value`參數會解譯使用<xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>樣式。 除了十進位數字，只允許前置和尾端空格取代前置正負號。 明確地定義使用中會有特定文化特性格式資訊的樣式項目`value`，呼叫<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法。  
  
 `value`參數會剖析使用的格式設定資訊中<xref:System.Globalization.NumberFormatInfo>目前的文化特性的物件。 如需詳細資訊，請參閱<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。  
  
 這個多載會解譯中的所有位數`value`參數做為十進位數字。 若要剖析的十六進位數字的字串表示，呼叫<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>改為多載。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29>方法具現化兩個<xref:System.Numerics.BigInteger>物件。 如果轉換成功，乘以另一個數字的每個物件，然後再呼叫<xref:System.Numerics.BigInteger.Compare%2A>方法，以判斷兩個物件之間的關聯性。  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">數字的字串表示。 這個字串使用 <paramref name="style" /> 指定的樣式來解譯。</param>
        <param name="style">列舉值的位元組合，表示 <paramref name="value" /> 中可以存在的樣式項目。 一般會指定的值是 <see cref="F:System.Globalization.NumberStyles.Integer" />。</param>
        <param name="provider">物件，提供關於 <paramref name="value" /> 的特定文化特性格式資訊。</param>
        <param name="result">當這個方法傳回時，如果轉換成功，則會包含相當於 <paramref name="value" /> 中所含之數字的 <see cref="T:System.Numerics.BigInteger" />；如果轉換失敗則為 <see cref="P:System.Numerics.BigInteger.Zero" />。 轉換失敗的狀況包括：如果 <paramref name="value" /> 參數為 <see langword="null" /> 或格式不符合 <paramref name="style" />。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>使用指定的文化特性特定格式資訊和格式樣式，將日期和時間的指定字串表示轉換為其對等的 <see cref="T:System.Numerics.BigInteger" />，並傳回值，這個值表示轉換是否成功。</summary>
        <returns>如果 <see langword="true" /> 參數轉換成功，則為 <paramref name="value" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法就像<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法，但是它不會擲回例外狀況如果轉換失敗。 這個方法就不需要使用例外狀況處理來測試<xref:System.FormatException>如果`value`無效，無法成功剖析。  
  
 `style`參數定義中允許的樣式項目 （例如空格或正的或負號）`value`剖析作業成功的參數。 它必須是從位元旗標的組合<xref:System.Globalization.NumberStyles>列舉型別。 值而定`style`，則`value`參數可能包括下列項目：  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 如果`style`參數包含<xref:System.Globalization.NumberStyles.AllowHexSpecifier>，則`value`參數可能包括下列項目：  
  
 [*ws*]*hexdigits*[*ws*]  
  
 在方括號 ([ 和 ]) 中的項目是選擇性的項目。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|選擇性的泛空白字元。 空白字元可以出現在開頭`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>旗標，或在結尾`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>旗標。|  
|*$*|特定文化特性的貨幣符號。 在字串中的位置由定義<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A>的屬性<xref:System.Globalization.NumberFormatInfo>所傳回的物件<xref:System.IFormatProvider.GetFormat%2A>方法`provider`參數。 貨幣符號會出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>旗標。|  
|*簽署*|選擇性正負號。 符號可以出現在開頭`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>旗標，也可以顯示在結尾`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>旗標。 可用於括號`value`表示負值`style`包含<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>旗標。|  
|*digits*|從 0 到 9 的數字序列。|  
|*、*|特定文化特性的群組分隔符號。 指定的文化特性的群組分隔符號`provider`可以出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>旗標。|  
|*.*|特定文化特性的貨幣符號。 指定的文化特性的小數點符號`provider`可以出現在`value`如果`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|*fractional_digits*|數字 0 的一或多個項目。 小數點後數字可以出現在`value`只有當`style`包含<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>旗標。|  
|E|"E"或者"E"字元，表示代表的值時，會以指數 （科學記號） 標記法。 `value`參數可代表指數標記法之數字，如果`style`包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*exponential_digits*|從 0 到 9 的數字序列。 `value`參數可代表指數標記法之數字，如果`style`包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>旗標。|  
|*hexdigits*|一連串的從 0 到 f 或 0 到 f 的十六進位數字|  
  
> [!NOTE]
> 中的任何終止 NUL (u+0000) 字元`s`剖析作業中，不論值會忽略`style`引數。

 十進位數字的字串 (對應至<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>旗標) 一律會成功剖析。 大部分的其餘<xref:System.Globalization.NumberStyles>成員控制可能存在，但不是一定要存在，在此輸入字串中的項目。 下表指出如何個別<xref:System.Globalization.NumberStyles>成員會影響可能會出現在項目`value`。  
  
|非複合`NumberStyles`值|除了數字的值中允許的項目|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|只有小數位數。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小數點 (*。*) 和*fractional_digits*項目。 不過， *fractional_digits*必須包含一個或多個 0 數字，或是這個方法會傳回`false`。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或"E"字元，這表示指數標記法，連同*exponential_digits*。 如果`value`代表一個數字以指數標記法，它不能有非零的小數點後的元件。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*開頭的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*結尾的項目`value`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*號*項目之前*位數*。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*號*之後的項目*位數*。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*號*括號括住的數字值的形式的項目。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|群組分隔符號 (*，*) 項目。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|貨幣 (*$*) 項目。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有項目。 不過，`value`無法表示十六進位數字或指數標記法之數字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*開頭或結尾的項目`value`，*登*開頭`value`，並在小數點 (*。*) 符號。 `value`參數也可以使用指數標記法。|  
|<xref:System.Globalization.NumberStyles.Number>|*Ws*，*號*，群組分隔符號 (*，*)，和小數點 (*。*) 項目。|  
|<xref:System.Globalization.NumberStyles.Any>|所有項目。 不過，`value`無法代表十六進位數字。|  
  
> [!IMPORTANT]
>  如果您使用<xref:System.Numerics.BigInteger.TryParse%2A>方法，以往返的字串表示的<xref:System.Numerics.BigInteger>所輸出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，您應該使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式規範，以產生的字串表示的方法<xref:System.Numerics.BigInteger>值。 否則的字串表示法<xref:System.Numerics.BigInteger>會保留 50 的原始值和資料的最高有效位數時可能會遺失您使用僅<xref:System.Numerics.BigInteger.TryParse%2A>方法，以還原<xref:System.Numerics.BigInteger>值。  
  
 如果<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>旗標用，`value`必須是十六進位的值。 只有其他旗標可存在於`style`都<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 (<xref:System.Globalization.NumberStyles>列舉型別有複合樣式， <xref:System.Globalization.NumberStyles.HexNumber>，其中包含這兩個空格旗標。)  
  
> [!NOTE]
>  如果`value`的字串表示法的十六進位數字，它無法加上任何裝飾 (例如`0x`或`&h`)，區隔其為十六進位的數字。 這會導致轉換失敗。  
  
 如果`value`是十六進位字串，<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法會解譯`value`為負數儲存透過其前兩個十六進位數字是否大於或等於二補數表示`0x80`。 換句話說，此方法會解譯中的第一個位元組的最高序位位元`value`為正負號位元。 若要確定為正數中的第一個數字會正確解譯為十六進位字串`value`必須具有值為零。 比方說，此方法會將解譯`0x80`為負數值，但它會解譯其中一個`0x080`或`0x0080`為正值。 下列範例說明十六進位的字串代表負數和正數的值之間的差異。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 `provider`參數是<xref:System.IFormatProvider>實作。 其<xref:System.IFormatProvider.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性格式資訊`value`。 `provider`參數可以是下列任一項：  
  
-   A<xref:System.Globalization.CultureInfo>物件，表示提供的格式資訊的文化特性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法會傳回<xref:System.Globalization.NumberFormatInfo>提供用於該文化特性的數值格式資訊的物件。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供數值格式資訊的物件。 (其實作的<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只會傳回本身。)  
  
-   自訂物件實作<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法具現化，並傳回<xref:System.Globalization.NumberFormatInfo>提供格式設定資訊的物件。  
  
 如果`provider`已`null`，則<xref:System.Globalization.NumberFormatInfo>物件會使用目前的文化特性。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法使用的值的各種組合`style`和`provider`參數。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 個別的呼叫數<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法傳遞執行個體的下列`BigIntegerFormatProvider`類別，定義為負號的波狀符號 （~）。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
-或- 
 <paramref name="style" /> 包含 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 旗標和其他值。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示數字 0 (零) 的值。</summary>
        <value>值為 0 (零) 的整數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger>這個屬性所傳回的物件提供用於指派和比較方便零值的來源。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>