<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40b2c78f0578265e0c0e26dd71b5d317238df73c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37476917" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>提供 <see cref="T:System.Net.WebRequest" /> 類別的 HTTP 特定實作。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest>類別會提供支援的屬性和方法定義在<xref:System.Net.WebRequest>以及其他屬性和方法，讓使用者直接與使用 HTTP 伺服器互動。  
  
 請勿使用<xref:System.Net.HttpWebRequest.%23ctor%2A>建構函式。 使用<xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>方法來初始化新<xref:System.Net.HttpWebRequest>物件。 配置的統一資源識別元 (URI) 是否`http://`或是`https://`，<xref:System.Net.WebRequest.Create%2A>傳回<xref:System.Net.HttpWebRequest>物件。  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A>方法中指定的資源提出同步要求<xref:System.Net.HttpWebRequest.RequestUri%2A>屬性，並傳回<xref:System.Net.HttpWebResponse>，包含回應物件。 可接收回應資料，請使用所傳回的資料流<xref:System.Net.HttpWebResponse.GetResponseStream%2A>。 如果回應物件或回應資料流已關閉，剩餘的資料即告作廢。 將會清空剩餘的資料和通訊端時，會重複使用的後續要求關閉回應物件或資料流，如果下列條件： keep-alive 或管線的要求，只有少量的資料需要被接收，或小型時間間隔內接收到剩餘的資料。 如果上述條件保存或超過清空時間，將會關閉通訊端。 如為 keep-alive 或以管線連接時，我們強烈建議應用程式讀取資料流，直到 EOF 為止。 這可確保通訊端，將會產生較佳的效能，並降低使用資源的後續要求重複使用。  
  
 當您想要將資料傳送至資源，<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法會傳回<xref:System.IO.Stream>物件，用來傳送資料。 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法提供傳送資料流的非同步存取。  
  
 對於使用用戶端驗證<xref:System.Net.HttpWebRequest>，用戶端憑證必須安裝在我的憑證存放區目前的使用者。  
  
 <xref:System.Net.HttpWebRequest>類別會擲回<xref:System.Net.WebException>何時存取資源時沒有發生錯誤。 <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>屬性包含<xref:System.Net.WebExceptionStatus>值，指出錯誤的來源。 當<xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>已<xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>，則<xref:System.Net.WebException.Response%2A>屬性包含<xref:System.Net.HttpWebResponse>接收自資源。  
  
 <xref:System.Net.HttpWebRequest> 會公開一般 HTTP 標頭值傳送至網際網路資源，為屬性，設定方法，或是由系統; 所設定下表包含完整的清單。 您可以設定其他標頭<xref:System.Net.HttpWebRequest.Headers%2A>屬性當做名稱/值組。 請注意，伺服器和快取可能會變更或在要求期間新增標頭。  
  
 下表列出由屬性或方法或系統設定 HTTP 標頭。  
  
|頁首|設定|  
|------------|------------|  
|接受|設定<xref:System.Net.HttpWebRequest.Accept%2A>屬性。|  
|連線|藉由設定<xref:System.Net.HttpWebRequest.Connection%2A>屬性，<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性。|  
|內容長度|設定<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性。|  
|Content-Type|設定<xref:System.Net.HttpWebRequest.ContentType%2A>屬性。|  
|預期|設定<xref:System.Net.HttpWebRequest.Expect%2A>屬性。|  
|日期|設定由系統目前的日期。|  
|主機|由系統目前的主機資訊設定。|  
|如果修改自|設定<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性。|  
|範圍|設定<xref:System.Net.HttpWebRequest.AddRange%2A>方法。|  
|推薦者|設定<xref:System.Net.HttpWebRequest.Referer%2A>屬性。|  
|傳輸編碼方式|藉由設定<xref:System.Net.HttpWebRequest.TransferEncoding%2A>屬性 (<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性必須是`true`)。|  
|使用者代理程式|設定<xref:System.Net.HttpWebRequest.UserAgent%2A>屬性。|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> 會自動註冊。 您不需要呼叫<xref:System.Net.WebRequest.RegisterPrefix%2A>方法，以註冊<xref:System.Net.HttpWebRequest?displayProperty=nameWithType>之前使用 Uri 開頭`http://`或`https://`。  
  
 在本機電腦或應用程式組態檔，可能會指定使用預設 proxy。 如果<xref:System.Net.HttpWebRequest.Proxy%2A>指定屬性，然後從的 proxy 設定<xref:System.Net.HttpWebRequest.Proxy%2A>屬性會覆寫本機電腦或應用程式組態檔和<xref:System.Net.HttpWebRequest>執行個體將會使用指定的 proxy 設定。 如果未不指定任何 proxy 在組態檔中，<xref:System.Net.HttpWebRequest.Proxy%2A>屬性未指定，<xref:System.Net.HttpWebRequest>類別會使用繼承自 Internet Explorer 中，在本機電腦上的 proxy 設定。 如果沒有在 Internet Explorer proxy 設定，要求會直接傳送到伺服器。  
  
 <xref:System.Net.HttpWebRequest>類別可剖析 proxy 略過清單包含繼承自 Internet Explorer 以不同的方式略過清單由 Internet Explorer 直接剖析非萬用字元。 比方說，<xref:System.Net.HttpWebRequest>類別將會剖析"nt *"從 Internet Explorer 略過清單做為規則運算式的 「 nt。 $"。 這不同於 Internet Explorer 的原生行為。 因此的 URL 」`http://intxxxxx`」 會略過 proxy 使用<xref:System.Net.HttpWebRequest>類別，但不是會略過使用 Internet Explorer 的 proxy。  
  
> [!NOTE]
>  架構在建立快取的 SSL 工作階段，並嘗試盡可能重複使用快取的工作階段，對新的要求。 嘗試將重複使用的 SSL 工作階段時，架構會使用第一個項目<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果有一個），或嘗試重複使用匿名的工作階段，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>是空的。  
  
> [!NOTE]
>  基於安全性理由，預設會停用 cookie。 如果您想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>屬性，來啟用 cookie。  
  
 .NET Framework 4.6 包含會封鎖不安全的加密和雜湊演算法進行連線的新安全性功能。 使用 TLS/SSL 透過例如 HttpClient、 HttpWebRequest、 FTPClient、 SmtpClient、 SslStream 」 等的 Api 和以.NET Framework 4.6 為目標的應用程式預設會取得更安全的行為。  
  
 開發人員可能想要退出此行為，以維護與 RC4 服務具有其現有 SSL3 服務或 TLS 的互通性。 [這篇文章](https://support.microsoft.com/kb/3069494)說明如何修改您的程式碼，讓新的行為會停用。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Net.HttpWebRequest>uri http://www.contoso.com/。  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">若要存取要求的 URI 或任何要求重新導向的 URI。 相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.HttpWebRequest" /> 類別的新執行個體。 這些建構函式已淘汰；如需詳細資料，請參閱＜備註＞一節。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

兩者<xref:System.Net.HttpWebRequest>建構函式已經過時，而且不應該使用。 呼叫<xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType>方法來初始化新<xref:System.Net.HttpWebRequest>物件。     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Net.HttpWebRequest" /> 類別的新執行個體。 這個建構函式已經過時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件，包含將新的 <see cref="T:System.Net.HttpWebRequest" /> 物件序列化所需的資訊。</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> 物件，包含與新 <see cref="T:System.Net.HttpWebRequest" /> 物件關聯的序列化資料流的來源和目的端。</param>
        <summary>從 <see cref="T:System.Net.HttpWebRequest" /> 和 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 類別的已指定執行個體，初始化 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 類別的新執行個體。 這個建構函式已經過時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用序列化時，必須在完全信任模式下執行應用程式。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">不受限制存取網路資源。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消對網際網路資源的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A>方法取消資源的要求。 取消要求之後，呼叫<xref:System.Net.HttpWebRequest.GetResponse%2A>， <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>， <xref:System.Net.HttpWebRequest.EndGetResponse%2A>， <xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>，或<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法會使<xref:System.Net.WebException>具有<xref:System.Net.WebException.Status%2A>屬性設為<xref:System.Net.WebExceptionStatus.RequestCanceled>。  
  
 <xref:System.Net.HttpWebRequest.Abort%2A>方法會以同步方式執行指定的回呼<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>或是<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法如果<xref:System.Net.HttpWebRequest.Abort%2A>任一這些作業未完成時，會呼叫方法。 這可能會導致潛在的死結問題。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 <<c0> [ 網路追蹤](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)。  
  
   
  
## Examples  
 如果是非同步的要求，它負責用戶端應用程式，來實作其本身的逾時機制。 下列程式碼範例示範如何執行這項操作。  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Accept" /> HTTP 標頭的值。</summary>
        <value>
          <see langword="Accept" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要清除`Accept`HTTP 標頭，設定<xref:System.Net.HttpWebRequest.Accept%2A>屬性設`null`。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例將<xref:System.Net.HttpWebRequest.Accept%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">範圍的起始和結束點。</param>
        <summary>針對從已要求資料的起始或結尾的特定範圍，將位元組範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將位元組範圍標頭加入要求。  
  
 如果`range`為正數，`range`參數指定範圍的起點。 伺服器應開始傳送資料，從`range`HTTP 實體中的資料結尾指定的參數。  
  
 如果`range`是負數，`range`參數指定範圍的結束點。 伺服器應開始傳送資料，從 HTTP 實體中的資料開始`range`指定的參數。  
  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 範圍標頭在 HTTP 通訊協定要求，要求伺服器傳送的前 100 個位元組，（從開始到 99 的位元組位置中） 會是如下所示的範例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 此範例中，針對`range`參數便是-99。  
  
 HTTP 伺服器指出範圍包含 Accept-ranges 標頭的標頭的支援。 支援位元組範圍的伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 標頭未收到來自伺服器回應的標頭中，如果伺服器不支援範圍標頭。 不支援範圍，但可辨識的 Accept-ranges 標頭中，伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時從範圍要求收到回應時，不會剖析與可透過屬性<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
   
  
## Examples  
 下列程式碼範例會將範圍標頭加入至要求。  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">範圍的起始和結束點。</param>
        <summary>針對從已要求資料的起始或結尾的特定範圍，將位元組範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將位元組範圍標頭加入要求。  
  
 如果`range`為正數，`range`參數指定範圍的起點。 伺服器應開始傳送資料，從`range`HTTP 實體中的資料結尾指定的參數。  
  
 如果`range`是負數，`range`參數指定範圍的結束點。 伺服器應開始傳送資料，從 HTTP 實體中的資料開始`range`指定的參數。  
  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 範圍標頭在 HTTP 通訊協定要求，要求伺服器傳送的前 100 個位元組，（從開始到 99 的位元組位置中） 會是如下所示的範例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 此範例中，針對`range`參數便是-99。  
  
 HTTP 伺服器指出範圍包含 Accept-ranges 標頭的標頭的支援。 支援位元組範圍的伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 標頭未收到來自伺服器回應的標頭中，如果伺服器不支援範圍標頭。 不支援範圍，但可辨識的 Accept-ranges 標頭中，伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時從範圍要求收到回應時，不會剖析與可透過屬性<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">要開始傳送資料的位置。</param>
        <param name="to">要停止傳送資料的位置。</param>
        <summary>將範圍標頭加入至特定範圍的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將位元組範圍標頭加入要求。  
  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 下列是要求前 100 個位元組會透過 HTTP 通訊協定要求的範圍標頭的範例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 此範例中，如`from`參數會指定為 0 和`to`參數會指定為 99。 這個方法，會自動範圍規範設定為 「 位元組 」。  
  
 HTTP 伺服器指出範圍包含 Accept-ranges 標頭的標頭的支援。 支援位元組範圍的伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 標頭未收到來自伺服器回應的標頭中，如果伺服器不支援範圍標頭。 不支援範圍，但可辨識的 Accept-ranges 標頭中，伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時從範圍要求收到回應時，不會剖析與可透過屬性<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
   
  
## Examples  
 下列程式碼範例會將範圍標頭加入至要求。  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> 大於 <paramref name="to" />  -或-   <paramref name="from" /> 或 <paramref name="to" /> 小於 0。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">要開始傳送資料的位置。</param>
        <param name="to">要停止傳送資料的位置。</param>
        <summary>將範圍標頭加入至特定範圍的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將位元組範圍標頭加入要求。  
  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 下列是要求前 100 個位元組會透過 HTTP 通訊協定要求的範圍標頭的範例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 此範例中，如`from`參數會指定為 0 和`to`參數會指定為 99。 這個方法，會自動範圍規範設定為 「 位元組 」。  
  
 HTTP 伺服器指出範圍包含 Accept-ranges 標頭的標頭的支援。 支援位元組範圍的伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 標頭未收到來自伺服器回應的標頭中，如果伺服器不支援範圍標頭。 不支援範圍，但可辨識的 Accept-ranges 標頭中，伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時從範圍要求收到回應時，不會剖析與可透過屬性<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> 大於 <paramref name="to" />  -或-   <paramref name="from" /> 或 <paramref name="to" /> 小於 0。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">範圍的描述。</param>
        <param name="range">範圍的起始和結束點。</param>
        <summary>針對從已要求資料的起始或結尾的特定範圍，將範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將範圍標頭加入要求。  
  
 如果`range`為正數，`range`參數指定範圍的起點。 伺服器應開始傳送資料，從`range`HTTP 實體中的資料結尾指定的參數。  
  
 如果`range`是負數，`range`參數指定範圍的結束點。 伺服器應開始傳送資料，從 HTTP 實體中的資料開始`range`指定的參數。  
  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 `rangeSpecifier`參數通常會指定為"bytes"，因為這是唯一可辨識大部分的 HTTP 伺服器的範圍規範。 設定`rangeSpecifier`某些其他字串的參數允許位元組 （由 IETF RFC 2616 中所定義的位元組範圍規範） 以外的自訂範圍指定名稱的支援。  
  
 下列是要求前 100 個位元組會透過 HTTP 通訊協定要求的範圍標頭的範例：  
  
 `Range: bytes=-99\r\n\r\n`  
  
 此範例中，如`rangeSpecifier`參數會指定為 「 位元組 」 和`range`參數便是-99。  
  
 HTTP 伺服器指出 Accept-ranges 標頭回應中的範圍標頭的支援。 支援位元組範圍的伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 標頭未收到來自伺服器回應的標頭中，如果伺服器不支援範圍標頭。 不支援範圍，但可辨識的 Accept-ranges 標頭中，伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時從範圍要求收到回應時，不會剖析與可透過屬性<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">範圍的描述。</param>
        <param name="range">範圍的起始和結束點。</param>
        <summary>針對從已要求資料的起始或結尾的特定範圍，將範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將範圍標頭加入要求。  
  
 如果`range`為正數，`range`參數指定範圍的起點。 伺服器應開始傳送資料，從`range`HTTP 實體中的資料結尾指定的參數。  
  
 如果`range`是負數，`range`參數指定範圍的結束點。 伺服器應開始傳送資料，從 HTTP 實體中的資料開始`range`指定的參數。  
  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 `rangeSpecifier`參數通常會指定為"bytes"，因為這是唯一可辨識大部分的 HTTP 伺服器的範圍規範。 設定`rangeSpecifier`某些其他字串的參數允許位元組 （由 IETF RFC 2616 中所定義的位元組範圍規範） 以外的自訂範圍指定名稱的支援。  
  
 下列是要求前 100 個位元組會透過 HTTP 通訊協定要求的範圍標頭的範例：  
  
 `Range: bytes=-99\r\n\r\n`  
  
 此範例中，如`rangeSpecifier`參數會指定為 「 位元組 」 和`range`參數便是-99。  
  
 HTTP 伺服器指出 Accept-ranges 標頭回應中的範圍標頭的支援。 支援位元組範圍的伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 標頭未收到來自伺服器回應的標頭中，如果伺服器不支援範圍標頭。 不支援範圍，但可辨識的 Accept-ranges 標頭中，伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時從範圍要求收到回應時，不會剖析與可透過屬性<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">範圍的描述。</param>
        <param name="from">要開始傳送資料的位置。</param>
        <param name="to">要停止傳送資料的位置。</param>
        <summary>將範圍標頭加入至特定範圍的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將範圍標頭加入要求。  
  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 `rangeSpecifier`參數通常會指定為"bytes"，因為這是唯一可辨識大部分的 HTTP 伺服器的範圍規範。 設定`rangeSpecifier`某些其他字串的參數允許位元組 （由 IETF RFC 2616 中所定義的位元組範圍規範） 以外的自訂範圍指定名稱的支援。  
  
 下列是要求前 100 個位元組會透過 HTTP 通訊協定要求的範圍標頭的範例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 針對此範例中，`rangeSpecifier`參數會指定為 「 位元組 」`from`參數便是 0，而`to`參數會是 99。  
  
 HTTP 伺服器指出 Accept-ranges 標頭回應中的範圍標頭的支援。 支援位元組範圍的伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 標頭中指定的字串是藉由指定的範圍規範`rangeSpecifier`這個方法的參數。  
  
 Accept-ranges 標頭未收到來自伺服器回應的標頭中，如果伺服器不支援範圍標頭。 不支援範圍，但可辨識的 Accept-ranges 標頭中，伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時從範圍要求收到回應時，不會剖析與可透過屬性<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> 大於 <paramref name="to" />  -或-   <paramref name="from" /> 或 <paramref name="to" /> 小於 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">範圍的描述。</param>
        <param name="from">要開始傳送資料的位置。</param>
        <param name="to">要停止傳送資料的位置。</param>
        <summary>將範圍標頭加入至特定範圍的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將範圍標頭加入要求。  
  
 因為所有的 HTTP 實體以位元組序列的 HTTP 訊息中，位元組範圍的概念是有意義的任何 HTTP 實體。 不過，並非所有的用戶端和伺服器必須支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要接收指定的位元組範圍的某個部分 HTTP 實體中。 伺服器不需要支援範圍標頭的要求。  
  
 `rangeSpecifier`參數通常會指定為"bytes"，因為這是唯一可辨識大部分的 HTTP 伺服器的範圍規範。 設定`rangeSpecifier`某些其他字串的參數允許位元組 （由 IETF RFC 2616 中所定義的位元組範圍規範） 以外的自訂範圍指定名稱的支援。  
  
 下列是要求前 100 個位元組會透過 HTTP 通訊協定要求的範圍標頭的範例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 針對此範例中，`rangeSpecifier`參數會指定為 「 位元組 」`from`參數便是 0，而`to`參數會是 99。  
  
 HTTP 伺服器指出 Accept-ranges 標頭回應中的範圍標頭的支援。 支援位元組範圍的伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 標頭中指定的字串是藉由指定的範圍規範`rangeSpecifier`這個方法的參數。  
  
 Accept-ranges 標頭未收到來自伺服器回應的標頭中，如果伺服器不支援範圍標頭。 不支援範圍，但可辨識的 Accept-ranges 標頭中，伺服器的 Accept-ranges 標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時從範圍要求收到回應時，不會剖析與可透過屬性<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> 大於 <paramref name="to" />  -或-   <paramref name="from" /> 或 <paramref name="to" /> 小於 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得實際回應要求的網際網路資源統一資源識別元 (URI)。</summary>
        <value>
          <see cref="T:System.Uri" />，識別實際回應要求的網際網路資源。 預設值為 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 方法用來初始化要求的 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A>屬性設定為 URI 要求期間發生任何重新導向完成後。  
  
 原始要求的 URI 會保留在<xref:System.Net.HttpWebRequest.RequestUri%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會檢查是否<xref:System.Net.HttpWebRequest>物件`req`已重新導向至另一個位置完成要求，並設定的值`hasChanged`變數`true`如果重新導向要求; 否則為`hasChanged`設為`false`。  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值指出要求是否應該緊接在重新導向回應之後。</summary>
        <value>如果要求應該自動追蹤來自網際網路資源的重新導向回應，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>至`true`如果您想要的要求會自動遵循 HTTP 重新導向標頭之資源的新位置。 若要遵循重新導向的最大數目由設定<xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>屬性。  
  
 如果<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>設為`false`，所有回應 HTTP 狀態碼從 300 399 會傳都回到應用程式。  
  
 授權標頭都會自動重新導向和<xref:System.Net.HttpWebRequest>會自動嘗試重新驗證，才能重新導向的位置。 在實務上，這表示如果它是可能發生重新導向應用程式無法將授權標頭自訂驗證資訊。 相反地，應用程式必須實作並註冊自訂驗證模組。 <xref:System.Net.AuthenticationManager?displayProperty=nameWithType>和相關的類別用來實作自訂驗證模組。 <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType>方法註冊的自訂驗證模組。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>屬性，以允許進行重新導向回應要求。  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否要緩衝處理從網際網路資源接收的資料。</summary>
        <value>
          <see langword="true" /> 表示要對從網際網路資源接收的資料啟用緩衝處理，<see langword="false" /> 則表示要停用緩衝處理。 預設值為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要緩衝傳送至網際網路資源的資料。</summary>
        <value>
          <see langword="true" /> 表示要對傳送至網際網路資源的資料啟用緩衝處理，<see langword="false" /> 則表示要停用緩衝處理。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A>是`true`，資料進入緩衝記憶體，以準備要求時，重新導向或驗證發生時重新傳送。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A>屬性，以停用緩衝處理資料。  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>設定<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />至<see langword="true" />上傳大型資料集，因為資料緩衝區可以使用所有可用的記憶體時可能會造成效能問題。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定使用的解壓縮類型。</summary>
        <value>A<see cref="T:System.Net.DecompressionMethods" />物件，表示所使用的解壓縮類型。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">此物件的目前狀態不允許設定這個屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">這個要求的狀態物件。</param>
        <summary>開始用來寫入資料之 <see cref="T:System.IO.Stream" /> 物件的非同步要求。</summary>
        <returns>參考非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法會啟動用來將資料傳送資料流的非同步要求<xref:System.Net.HttpWebRequest>。 非同步回呼方法會使用<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法，以傳回實際的資料流。  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法需要進行一些同步安裝程式工作，這個方法才會非同步完成 （DNS 解析、 proxy 偵測和 TCP 通訊端連線，例如）。 如此一來，這個方法永遠不可叫用使用者介面 (UI) 執行緒上因為可能需要相當長的時間 （最多幾分鐘，視網路設定而定） 才能完成初始同步設定的例外狀況之前的錯誤會擲回或此方法成功。  
  
 若要深入了解執行緒集區，請參閱[的 Managed 執行緒集區](~/docs/standard/threading/the-managed-thread-pool.md)。  
  
> [!NOTE]
>  您的應用程式不能混用特定要求的同步和非同步方法。 如果您呼叫<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，則必須使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法，以擷取回應。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，讓資料流執行個體的非同步要求。  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 屬性是 GET 或 HEAD。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。</exception>
        <exception cref="T:System.InvalidOperationException">此資料流正由先前對 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 的呼叫所使用，或 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。  -或-  執行緒集區中的執行緒即將用盡。</exception>
        <exception cref="T:System.NotSupportedException">要求快取驗證程式指出，可以從快取處理此要求的回應；不過，寫入資料的要求絕對不能使用快取。 如果您使用實作自訂快取驗證程式不正確，便會發生這個例外狀況。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。</exception>
        <exception cref="T:System.ObjectDisposedException">在 .NET Compact Framework 應用程式中，未取得且未正確關閉內容長度為零的要求資料流。 如需處理零內容長度要求的詳細資訊，請參閱 [.NET Compact Framework 中的網路程式設計] (https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx)。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派</param>
        <param name="state">這個要求的狀態物件。</param>
        <summary>開始對網際網路資源的非同步要求。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，參考回應的非同步要求。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法開始非同步要求的回應來自網際網路資源。 非同步回呼方法會使用<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法，以傳回實際<xref:System.Net.WebResponse>。  
  
 A<xref:System.Net.ProtocolViolationException>上設定屬性時擲回在有些情況下<xref:System.Net.HttpWebRequest>類別會互相衝突。 如果應用程式設定，就會發生這個例外狀況<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性和<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性設`true`，然後將傳送 HTTP GET 要求。 如果應用程式嘗試以區塊傳送至伺服器，只支援 HTTP 1.0 通訊協定，其中不支援此功能，就會發生這個例外狀況。 如果應用程式嘗試傳送資料，而不設定，就會發生這個例外狀況<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性或<xref:System.Net.HttpWebRequest.SendChunked%2A>是`false`停用緩衝處理時，和 keepalive 連接上 (<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性是`true`)`.`  
  
 如果<xref:System.Net.WebException>會擲回，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>要決定從伺服器回應的例外狀況的屬性。  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法需要進行一些同步安裝程式工作，這個方法才會非同步完成 （DNS 解析、 proxy 偵測和 TCP 通訊端連線，例如）。 如此一來，這個方法永遠不可叫用使用者介面 (UI) 執行緒上因為可能需要相當長的時間 （最多幾分鐘，視網路設定而定） 才能完成初始同步設定的例外狀況之前的錯誤會擲回或此方法成功。  
  
 若要深入了解執行緒集區，請參閱[ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927)。  
  
> [!NOTE]
>  您的應用程式不能混用特定要求的同步和非同步方法。 如果您呼叫<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，則必須使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法，以擷取回應。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法，讓網際網路資源非同步要求。  
  
> [!NOTE]
>  如果是非同步的要求，它負責用戶端應用程式，來實作其本身的逾時機制。 下列程式碼範例顯示如何執行此動作。  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此資料流已由先前對 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 的呼叫所使用，或 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。  -或-  執行緒集區中的執行緒即將用盡。</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 是 GET 或 HEAD，而且若不是 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大於零，就是 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 為 <see langword="true" />。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1 或 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 為 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。  -或-  <see cref="T:System.Net.HttpWebRequest" /> 具有實體主體，但 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法在沒有呼叫 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 方法的情況下呼叫。  -或-  <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大於零，但該應用程式不會寫入所有承諾的資料。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個要求關聯的安全憑證集合。</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />，包含與這個要求相關的安全憑證。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可以將憑證新增至集合，但可能沒有存取權限。 若要使用集合中包含的憑證，應用程式必須與發出憑證的實體相同的存取權限。  
  
> [!NOTE]
>  架構在建立快取的 SSL 工作階段，並嘗試盡可能重複使用快取的工作階段，對新的要求。 嘗試將重複使用的 SSL 工作階段時，架構會使用第一個項目<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果有一個），或嘗試重複使用匿名的工作階段，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>是空的。  
  
> [!NOTE]
>  基於效能考量，您不應該將用戶端憑證才能新增<xref:System.Net.HttpWebRequest>除非您知道伺服器將會要求它。  
>   
>  如需程式碼範例，說明如何列舉中的用戶端憑證存放區的憑證，請參閱<xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection>類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">為設定作業指定的值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Connection" /> HTTP 標頭的值。</summary>
        <value>
          <see langword="Connection" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求會傳送<xref:System.Net.HttpWebRequest.Connection%2A>屬性設為網際網路資源`Connection`HTTP 標頭。 如果值<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性是`true`、 「 保持運作 」 的值會附加至結尾`Connection`標頭。  
  
 若要清除`Connection`HTTP 標頭，設定<xref:System.Net.HttpWebRequest.Connection%2A>屬性設`null`。  
  
 變更<xref:System.Net.HttpWebRequest.Connection%2A>屬性，藉由呼叫要求啟動後<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法會擲回<xref:System.InvalidOperationException>。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.Connection%2A>屬性來設定連線 HTTP 標頭的值。  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.Connection" /> 的值已設為 Keep-alive 或 Close。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的連接群組名稱。</summary>
        <value>這個要求的連接群組名稱。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>屬性可讓您連接群組相關聯的要求。 當您的應用程式到一部伺服器提出要求，針對不同的使用者，例如從資料庫伺服器中擷取客戶資訊的網站時，這非常有用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用使用者資訊，以形成連接群組，但前提變數`username`， `password`，和`domain`這段程式碼會在呼叫之前，應用程式所設定。  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>每個連接群組建立其他連線的伺服器。這可能會導致超過所設定的連接數目<see cref="P:System.Net.ServicePoint.ConnectionLimit" />該伺服器的屬性。</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Content-length" /> HTTP 標頭。</summary>
        <value>資料位元組數，要傳送至網際網路資源。 預設值為 -1，表示還沒有設定屬性且沒有要傳送的要求資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A>屬性包含值以做為傳送`Content-length`與要求的 HTTP 標頭。  
  
 為-1 以外的任何值<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性會指出要求將資料上傳，並將資料上傳的方法可以設定<xref:System.Net.HttpWebRequest.Method%2A>屬性。  
  
 在後<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性設定為值，該位元組數必須寫入要求資料流，藉由呼叫會傳回<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法或兩者皆<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例將<xref:System.Net.HttpWebRequest.ContentLength%2A>公佈的字串長度屬性。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要求已藉由呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法啟動。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">新的 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 值小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Content-type" /> HTTP 標頭的值。</summary>
        <value>
          <see langword="Content-type" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A>屬性包含要求的媒體類型。 值，指派給<xref:System.Net.HttpWebRequest.ContentType%2A>屬性會取代任何現有的內容時的要求會傳送`Content-type`HTTP 標頭。  
  
 若要清除`Content-type`HTTP 標頭，設定<xref:System.Net.HttpWebRequest.ContentType%2A>屬性設`null`。  
  
> [!NOTE]
>  此屬性的值會儲存在<xref:System.Net.WebHeaderCollection>。 如果<xref:System.Net.WebHeaderCollection>時，就會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例將<xref:System.Net.HttpWebRequest.ContentType%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定從網際網路資源接收 HTTP 100-continue 回應時所呼叫的委派 (Delegate) 方法。</summary>
        <value>委派，實作從網際網路資源傳回 HTTP Continue 回應時所執行的回呼 (Callback) 方法。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A>屬性指定的回呼方法呼叫，當用戶端收到 100-Continue 回應。  
  
 當<xref:System.Net.HttpWebRequest.ContinueDelegate%2A>屬性設定，用戶端會呼叫委派時通訊協定類型的回應<xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType>(100) 接收。 這非常有用，如果您想要顯示從網際網路資源接收的資料狀態的用戶端。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要在收到伺服器的 100-Continue 以前等候的逾時 (以毫秒為單位)。</summary>
        <value>要在收到 100-Continue 以前等候的逾時 (以毫秒為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 100-繼續進行之前逾時到期，可以傳送的實體主體，會接收到回應。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與要求相關的 Cookie。</summary>
        <value>
          <see cref="T:System.Net.CookieContainer" />，包含與這個要求相關的 Cookie。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A>屬性所提供的執行個體<xref:System.Net.CookieContainer>類別，其中包含與此要求相關聯的 cookie。  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 是`null`預設。 您必須指派<xref:System.Net.CookieContainer>物件的屬性將傳回的 cookie<xref:System.Net.HttpWebResponse.Cookies%2A>屬性<xref:System.Net.HttpWebResponse>所傳回<xref:System.Net.HttpWebRequest.GetResponse%2A>方法。  
  
> [!NOTE]
>  基於安全性理由，預設會停用 cookie。 如果您想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>屬性，來啟用 cookie。  
  
   
  
## Examples  
 下列程式碼範例會將要求傳送至的 URL，並顯示回應中傳回的 cookie。  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的驗證資訊。</summary>
        <value>
          <see cref="T:System.Net.ICredentials" />，包含與要求關聯的驗證認證。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A>屬性包含驗證資訊來識別要求的建立者。 <xref:System.Net.HttpWebRequest.Credentials%2A>屬性可以是<xref:System.Net.NetworkCredential>、 在哪些情況下使用者、 密碼和網域中所包含的資訊<xref:System.Net.NetworkCredential>物件用來驗證要求，或者它可以是<xref:System.Net.CredentialCache>，在此情況下統一的資源要求的識別碼 (URI) 用來判斷使用者、 密碼和網域資訊，用來驗證要求。  
  
 在大部分的用戶端案例中，您應該使用<xref:System.Net.CredentialCache.DefaultCredentials%2A>屬性，其中包含目前登入使用者的認證。 若要這樣做，請設定<xref:System.Net.WebClient.UseDefaultCredentials%2A>屬性設`true`而不是設定這個屬性。  
  
 如果<xref:System.Net.HttpWebRequest>類別用於中介層應用程式，例如 ASP.NET 應用程式中的認證<xref:System.Net.CredentialCache.DefaultCredentials%2A>屬性屬於執行 ASP 頁面 （伺服器端的認證） 的帳戶。 一般而言，您會設定此屬性代表其提出要求的用戶端的認證。  
  
> [!NOTE]
>  NTLM 驗證配置，不能模擬其他使用者。 Kerberos 必須經過特別設定為支援模擬。  
  
 若要限制 HttpWebRequest 一或多個驗證方法，使用<xref:System.Net.CredentialCache>類別，並將您的認證繫結至一個或多個驗證配置  
  
 支援的驗證配置包含摘要式、 交涉、 Kerberos、 NTLM 及 Basic。  
  
 基於安全性理由，會自動遵循重新導向時，儲存的認證，您想要包含在中的重新導向<xref:System.Net.CredentialCache>並將它指派給這個屬性。 這個屬性會自動設定為`null`在重新導向，如果它包含以外的項目時<xref:System.Net.CredentialCache>。 具有這個屬性值自動設定為`null`在這些情況下不會將認證傳送至任何非預期的目的地。
  
## Examples  
 下列程式碼範例會設定要求的認證。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要用於 HTTP 要求中的 <see langword="Date" /> HTTP 標頭值。</summary>
        <value>HTTP 要求中的 Date 標頭值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果日期標頭`null`，則傳回的值會設為<xref:System.DateTime.MinValue?displayProperty=nameWithType>。  
  
 <xref:System.Net.HttpWebRequest.Date%2A>屬性是一種標準<xref:System.DateTime?displayProperty=nameWithType>物件，並可包含<xref:System.DateTimeKind?displayProperty=nameWithType>欄位<xref:System.DateTimeKind.Local?displayProperty=nameWithType>， <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 使用時，就可以設定任何一種時間<xref:System.Net.HttpWebRequest.Date%2A>屬性。 如果<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>是設定或擷取<xref:System.Net.HttpWebRequest.Date%2A>屬性會假設為<xref:System.DateTimeKind.Local?displayProperty=nameWithType>（本地時間）。  
  
 中的類別<xref:System.Net>命名空間永遠寫出<xref:System.Net.HttpWebRequest.Date%2A>使用 GMT (Utc) 格式的標準格式的傳輸期間在網路上的屬性。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>屬性設定為<xref:System.DateTime.MinValue?displayProperty=nameWithType>，則`Date`HTTP 標頭移除<xref:System.Net.HttpWebRequest.Headers%2A>屬性而<xref:System.Net.WebHeaderCollection>。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>屬性是<xref:System.DateTime.MinValue?displayProperty=nameWithType>，這表示`Date`HTTP 標頭不會納入<xref:System.Net.HttpWebRequest.Headers%2A>屬性而<xref:System.Net.WebHeaderCollection>。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>設定和嘗試傳送<xref:System.Net.HttpWebRequest>沒有本文中，則會顯示<xref:System.Net.ProtocolViolationException?displayProperty=nameWithType>將會擲回<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，和<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個要求的預設快取原則。</summary>
        <value>
          <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />，在沒有其他適用的原則時，為這個要求指定作用中的快取原則。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性會註冊指定的原則，針對 HTTP 和 HTTPS 配置。 如果此要求會使用這項原則：  
  
 沒有任何<xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType>針對這個要求指定的屬性。  
  
 \-或-  
  
 電腦和應用程式組態檔沒有指定用來建立此要求的快取原則所適用的統一資源識別元 (URI)。  
  
 快取原則會決定是否可以從快取，而非將要求傳送至資源的主機電腦獲得所要求的資源。  
  
 如果資源的回應資料流擷取和讀取資料流末端，則一份資源只會加入至快取。 因此針對相同資源的另一個要求可以使用快取的複本，根據此要求的快取原則層級。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">不受限制存取網路資源。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 HTTP 錯誤回應的預設最大長度。</summary>
        <value>HTTP 錯誤回應的預設最大長度。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小於零且不等於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> 屬性的預設值。</summary>
        <value>收到的回應標頭的預設最大長度 (以 KB (1024 個位元祖) 為單位)。 預設組態檔將這個值設為 64 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 回應狀態行及任何額外的控制字元收到的 HTTP 通訊協定的一部分，就會接收回應標頭的長度。 值為-1 表示沒有限制加諸於已接收的回應標頭值為 0 表示所有的要求會失敗。  
  
 此值也可以變更組態檔中。 此屬性的影響，可以藉由設定覆寫<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>的執行個體上的屬性<xref:System.Net.HttpWebRequest>類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值不等於 -1 且小於零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結束用來寫入資料之 <see cref="T:System.IO.Stream" /> 物件的非同步要求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">資料流的暫止要求。</param>
        <summary>結束用來寫入資料之 <see cref="T:System.IO.Stream" /> 物件的非同步要求。</summary>
        <returns>用來寫入要求資料的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法完成所啟動的資料流的非同步要求<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法。 在後<xref:System.IO.Stream>已傳回物件，您可以傳送資料<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  您必須設定的值<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性，才能將資料寫入至資料流。  
  
> [!CAUTION]
>  您必須呼叫<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法來關閉資料流並釋出以便重複使用的連線。 若要關閉資料流的失敗會造成您的應用程式沒有足夠的連線。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法以結束資料流執行個體的非同步要求。  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">要求未完成，而且沒有可用的資料流。</exception>
        <exception cref="T:System.ArgumentException">呼叫 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 時，目前的執行個體未傳回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前使用 <paramref name="asyncResult" /> 呼叫過這個方法。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  處理這個要求時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">資料流的暫止要求。</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>結束用來寫入資料之 <see cref="T:System.IO.Stream" /> 物件的非同步要求，並輸出與資料流關聯的 <see cref="T:System.Net.TransportContext" />。</summary>
        <returns>用來寫入要求資料的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法完成所啟動的資料流的非同步要求<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，並輸出<xref:System.Net.TransportContext>資料流相關聯。 在後<xref:System.IO.Stream>已傳回物件，您可以傳送資料<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 使用擴充保護的整合式的 Windows 驗證的某些應用程式可能需要能夠查詢所使用的傳輸層<xref:System.Net.HttpWebRequest>以從基礎的 TLS 通道擷取通道繫結語彙基元 (CBT)。 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法可以存取這項資訊的 HTTP 方法可以有要求本文 (`POST`和`PUT`要求)。 只有當時需要此應用程式實作自己的驗證，以及需要存取的 CBT。  
  
> [!NOTE]
>  如果應用程式需要的值設定<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性，則這必須擷取資料流，並對其寫入資料之前完成。  
  
> [!CAUTION]
>  您必須呼叫<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法來關閉資料流並釋出以便重複使用的連線。 若要關閉資料流的失敗會造成您的應用程式沒有足夠的連線。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">呼叫 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 時，目前的執行個體未傳回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前使用 <paramref name="asyncResult" /> 呼叫過這個方法。</exception>
        <exception cref="T:System.IO.IOException">要求未完成，而且沒有可用的資料流。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  處理這個要求時發生錯誤。</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">回應的暫止要求。</param>
        <summary>結束對網際網路資源的非同步要求。</summary>
        <returns>包含來自網際網路資源回應的 <see cref="T:System.Net.WebResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法會完成藉由呼叫啟動網際網路資源非同步要求<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法。  
  
> [!CAUTION]
>  您必須呼叫<xref:System.Net.HttpWebResponse.Close%2A>方法來關閉資料流並釋出連線。 若要這樣做可能導致您的應用程式沒有足夠的連線。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法以結束對網際網路資源非同步要求。  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前使用 <paramref name="asyncResult." /> 呼叫過這個方法。-或-  <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 屬性大於 0，但資料尚未寫入要求資料流。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  處理這個要求時發生錯誤。</exception>
        <exception cref="T:System.ArgumentException">呼叫 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 時，目前的執行個體未傳回 <paramref name="asyncResult" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Expect" /> HTTP 標頭的值。</summary>
        <value>
          <see langword="Expect" /> HTTP 標頭的內容。 預設值是 <see langword="null" />。  
  
 <block subset="none" type="note"><para> 此屬性的值會儲存在<see cref="T:System.Net.WebHeaderCollection" />。如果 webheadercollection，屬性值將會遺失。  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> 設定為含有子字串 "100-continue" 的字串。</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">要以資料填入的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />，指定這個序列化的目的地。</param>
        <summary>將序列化目標物件的所需資料填入 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中所包含的任何物件<xref:System.Runtime.Serialization.SerializationInfo>自動追蹤和序列化格式器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得用來寫入要求資料的 <see cref="T:System.IO.Stream" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得用來寫入要求資料的 <see cref="T:System.IO.Stream" /> 物件。</summary>
        <returns>用來寫入要求資料的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法會傳回用來傳送資料資料流<xref:System.Net.HttpWebRequest>。 在後<xref:System.IO.Stream>已傳回物件，您可以傳送資料<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 如果應用程式需要的值設定<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性，則這必須完成之前擷取的資料流。  
  
 您必須呼叫<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法來關閉資料流並釋出以便重複使用的連線。 若要關閉資料流的失敗會造成您的應用程式沒有足夠的連線。  
  
> [!NOTE]
>  您的應用程式不能混用特定要求的同步和非同步方法。 如果您呼叫<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，則必須使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法，以擷取回應。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法來傳回資料流執行個體。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 屬性是 GET 或 HEAD。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法已多次呼叫。  -或-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">要求快取驗證程式指出，可以從快取處理此要求的回應；不過，寫入資料的要求絕對不能使用快取。 如果您使用實作自訂快取驗證程式不正確，便會發生這個例外狀況。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  此要求的逾時期限已過期。  -或-  處理這個要求時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">在 .NET Compact Framework 應用程式中，未取得且未正確關閉內容長度為零的要求資料流。 如需處理零內容長度要求的詳細資訊，請參閱 [.NET Compact Framework 中的網路程式設計] (https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx)。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> 的 <see cref="T:System.IO.Stream" />。</param>
        <summary>取得 <see cref="T:System.IO.Stream" /> 物件，此物件是用來寫入要求資料和輸出資料流相關聯的 <see cref="T:System.Net.TransportContext" />。</summary>
        <returns>用來寫入要求資料的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法會傳回用來傳送資料資料流<xref:System.Net.HttpWebRequest>，並將輸出<xref:System.Net.TransportContext>資料流相關聯。 在後<xref:System.IO.Stream>已傳回物件，您可以傳送資料<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 使用擴充保護的整合式的 Windows 驗證的某些應用程式可能需要能夠查詢所使用的傳輸層<xref:System.Net.HttpWebRequest>以從基礎的 TLS 通道擷取通道繫結語彙基元 (CBT)。 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法可以存取這項資訊的 HTTP 方法可以有要求本文 (`POST`和`PUT`要求)。 只有當時需要此應用程式實作自己的驗證，以及需要存取的 CBT。  
  
 如果應用程式需要的值設定<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性，則這必須完成之前擷取的資料流。  
  
 您必須呼叫<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法來關閉資料流並釋出以便重複使用的連線。 若要關閉資料流的失敗會造成您的應用程式沒有足夠的連線。  
  
> [!NOTE]
>  您的應用程式不能混用特定要求的同步和非同步方法。 如果您呼叫<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，則必須使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法，以擷取回應。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法無法取得 <see cref="T:System.IO.Stream" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法已多次呼叫。  -或-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">要求快取驗證程式指出，可以從快取處理此要求的回應；不過，寫入資料的要求絕對不能使用快取。 如果您使用未正確實作的自訂快取驗證程式，便會發生這個例外狀況。</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 屬性是 GET 或 HEAD。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  此要求的逾時期限已過期。  -或-  處理這個要求時發生錯誤。</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回來自網際網路資源的回應。</summary>
        <returns>包含來自網際網路資源回應的 <see cref="T:System.Net.WebResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A>方法會傳回<xref:System.Net.WebResponse>物件，其中包含來自網際網路資源的回應。 實際的執行個體傳回<xref:System.Net.HttpWebResponse>，和可以轉換型別為該類別來存取 HTTP 特定屬性。  
  
 A<xref:System.Net.ProtocolViolationException>上設定屬性時擲回在有些情況下<xref:System.Net.HttpWebRequest>類別會互相衝突。 如果應用程式設定，就會發生這個例外狀況<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性和<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性設`true`，然後將傳送 HTTP GET 要求。 如果應用程式嘗試以區塊傳送至伺服器，只支援 HTTP 1.0 通訊協定，其中不支援此功能，就會發生這個例外狀況。 如果應用程式嘗試傳送資料，而不設定，就會發生這個例外狀況<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性或<xref:System.Net.HttpWebRequest.SendChunked%2A>是`false`停用緩衝處理時，和 keepalive 連接上 (<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性是`true`)`.`  
  
> [!CAUTION]
>  您必須呼叫<xref:System.Net.HttpWebResponse.Close%2A>方法來關閉資料流並釋出連線。 若要這樣做可能導致您的應用程式沒有足夠的連線。  
  
 使用 POST 方法時，必須取得要求資料流，將資料寫入至張貼，並關閉資料流。 此方法會封鎖等候要張貼; 的內容如果未逾時設定，而且您未提供內容，則呼叫端執行緒會封鎖無限期。  
  
> [!NOTE]
>  多次呼叫<xref:System.Net.HttpWebRequest.GetResponse%2A>傳回相同的回應物件中; 要求不會重新發出。  
  
> [!NOTE]
>  您的應用程式不能混用特定要求的同步和非同步方法。 如果您呼叫<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，則必須使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法，以擷取回應。  
  
> [!NOTE]
>  如果<xref:System.Net.WebException>會擲回，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>要決定從伺服器回應的例外狀況的屬性。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  基於安全性理由，預設會停用 cookie。 如果您想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>屬性，來啟用 cookie。  
  
   
  
## Examples  
 下列程式碼範例會取得要求的回應。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">資料流已經由先前對 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 的呼叫所使用。  -或-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> 是 GET 或 HEAD，而且若不是 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大於等於零，就是 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 為 <see langword="true" />。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。  -或-  <see cref="T:System.Net.HttpWebRequest" /> 具有實體主體，但 <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 方法在沒有呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法的情況下呼叫。  -或-  <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大於零，但該應用程式不會寫入所有承諾的資料。</exception>
        <exception cref="T:System.NotSupportedException">要求快取驗證程式指出，此要求的回應可以由快取服務；不過，此要求包含要傳送到此伺服器的資料。 傳送資料的要求不得使用此快取。 如果您使用不正確實作的自訂快取驗證程式，便會發生這個例外狀況。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  此要求的逾時期限已過期。  -或-  處理這個要求時發生錯誤。</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否已經接收到來自網際網路資源的回應。</summary>
        <value>如果已經接收到回應，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會檢查<xref:System.Net.HttpWebRequest.HaveResponse%2A>屬性來判斷是否來自網際網路資源收到回應。  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定組成 HTTP 標頭的名稱/值組集合。</summary>
        <value>
          <see cref="T:System.Net.WebHeaderCollection" />，包含組成 HTTP 要求標頭的名稱/值組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A>集合包含與要求相關聯的通訊協定標頭。 下表列出不會儲存在 HTTP 標頭<xref:System.Net.HttpWebRequest.Headers%2A>集合，而是由系統設定，或設定由屬性或方法。  
  
|頁首|設定|  
|------------|------------|  
|接受|設定<xref:System.Net.HttpWebRequest.Accept%2A>屬性。|  
|連線|藉由設定<xref:System.Net.HttpWebRequest.Connection%2A>屬性和<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性。|  
|內容長度|設定<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性。|  
|Content-Type|設定<xref:System.Net.HttpWebRequest.ContentType%2A>屬性。|  
|預期|設定<xref:System.Net.HttpWebRequest.Expect%2A>屬性。|  
|日期|設定<xref:System.Net.HttpWebRequest.Date%2A>屬性。|  
|主機|設定<xref:System.Net.HttpWebRequest.Host%2A>屬性。|  
|如果修改自|設定<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性。|  
|範圍|設定<xref:System.Net.HttpWebRequest.AddRange%2A>方法。|  
|推薦者|設定<xref:System.Net.HttpWebRequest.Referer%2A>屬性。|  
|傳輸編碼方式|藉由設定<xref:System.Net.HttpWebRequest.TransferEncoding%2A>屬性 (<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性必須為 true)。|  
|使用者代理程式|設定<xref:System.Net.HttpWebRequest.UserAgent%2A>屬性。|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A>方法會擲回<xref:System.ArgumentException>如果您嘗試設定其中一個受保護的標頭。  
  
 變更<xref:System.Net.HttpWebRequest.Headers%2A>屬性，藉由呼叫要求啟動後<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法會擲回<xref:System.InvalidOperationException>。  
  
 您不應該假設的標頭值會維持不變，因為 Web 伺服器和快取可能會變更或新增至 Web 要求的標頭。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.Headers%2A>列印至主控台的 HTTP 標頭名稱/值組的屬性。  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要求已藉由呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法啟動。</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Host 標頭值，此標頭可用於獨立於要求 URI 的 HTTP 要求中。</summary>
        <value>HTTP 要求中的 Host 標頭值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A>屬性可以用來設定主應用程式獨立於要求 URI 的 HTTP 要求中所使用的標頭值。 <xref:System.Net.HttpWebRequest.Host%2A>屬性可包含主機名稱和選擇性的連接埠號碼。 不含連接埠資訊的主機標頭表示要求的服務 （連接埠 80 的 HTTP URL，例如） 的預設連接埠。  
  
 用於主機和連接埠指定的格式必須遵循 IETF 發行的 RFC2616 14.23 區段中的規則。 指定連接埠 8080 的範例符合這些需求會是下列值<xref:System.Net.HttpWebRequest.Host%2A>屬性：  
  
 `www.contoso.com:8080`  
  
 使用<xref:System.Net.HttpWebRequest.Host%2A>快取的區域、 cookie 和驗證，也會影響屬性來明確指定自訂的主機標頭值。 當應用程式特定的 URI 前置詞提供的認證時，應用程式必須確定使用的 URI 包含主機標頭，而不是在 URI 中的目標伺服器的值。 主機標頭值，而不是在要求 URI，則會使用快取資源時所用的索引鍵。 Cookie 會儲存在<xref:System.Net.CookieContainer>及伺服器的網域名稱以邏輯方式分組。 如果應用程式指定主機標頭，則會使用此值作為網域。  
  
 如果<xref:System.Net.HttpWebRequest.Host%2A>未設定屬性，則在 HTTP 要求中使用的主機標頭值根據在要求 URI。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">主機標頭不能設定為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">主機標頭無法設定為無效值。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.HttpWebRequest" /> 啟動待傳送之後，不能設定主機標頭。</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="If-Modified-Since" /> HTTP 標頭的值。</summary>
        <value>
          <see cref="T:System.DateTime" />，包含 <see langword="If-Modified-Since" /> HTTP 標頭的內容。 預設值為目前的日期和時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性是一種標準<xref:System.DateTime?displayProperty=nameWithType>物件，並可包含<xref:System.DateTimeKind?displayProperty=nameWithType>欄位<xref:System.DateTimeKind.Local?displayProperty=nameWithType>， <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 使用時，就可以設定任何一種時間<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性。 如果<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>是設定或擷取<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性會假設為<xref:System.DateTimeKind.Local?displayProperty=nameWithType>（本地時間）。  
  
 中的類別<xref:System.Net>命名空間永遠寫出<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>使用 GMT (Utc) 格式的標準格式的傳輸期間在網路上的屬性。  
  
 如果<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性設定為<xref:System.DateTime.MinValue?displayProperty=nameWithType>，則`If-Modified-Since`HTTP 標頭移除<xref:System.Net.HttpWebRequest.Headers%2A>屬性而<xref:System.Net.WebHeaderCollection>。  
  
 如果<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性是<xref:System.DateTime.MinValue?displayProperty=nameWithType>，這表示`If-Modified-Since`HTTP 標頭不會納入<xref:System.Net.HttpWebRequest.Headers%2A>屬性而<xref:System.Net.WebHeaderCollection>。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例會檢查<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要與網際網路資源建立持續連線。</summary>
        <value>如果對網際網路資源的要求應該包含具有值 Keep-alive 的 <see langword="true" /> HTTP 標頭，則為 <see langword="Connection" />；<see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將此屬性設定為`true`傳送`Connection`具有值 keep-alive 的 HTTP 標頭。 應用程式使用<xref:System.Net.HttpWebRequest.KeepAlive%2A>可指出持續連線喜好設定。 當<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性是`true`，應用程式所進行的伺服器上支援它們的持續連線。  
  
> [!NOTE]
>  當使用 HTTP/1.1，保持預設為開啟。 設定<xref:System.Net.HttpWebRequest.KeepAlive%2A>要`false`可能會導致傳送`Connection: Close`到伺服器的標頭。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性設`false`以避免建立與網際網路資源的持續性連線。  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求追蹤的最大重新導向數目。</summary>
        <value>要求追蹤的最大重新導向回應數目。 預設值為 50。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>屬性設定為如果遵循要求重新導向的數目上限<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>屬性是`true`。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性的值。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">此值設定為 0 或更小的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定回應標頭的最大允許長度。</summary>
        <value>回應標頭的長度，以 KB (1024 位元組) 為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 回應標頭的長度會包含回應狀態行及收到的 HTTP 通訊協定的一部分的任何額外的控制字元。 值為-1 表示沒有限制加諸於回應標頭;值為 0 表示所有的要求會失敗。  
  
 如果<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>屬性未明確設定，則預設值為<xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A>屬性。  
  
 如果收到的回應標頭的長度超過的值<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>屬性，<xref:System.Net.HttpWebRequest.EndGetResponse%2A>或是<xref:System.Net.HttpWebRequest.GetResponse%2A>方法會擲回<xref:System.Net.WebException>使用<xref:System.Net.WebException.Status%2A>屬性設定為<xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性的值。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此屬性已在送出要求後設定。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值小於零且不等於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的媒體類型。</summary>
        <value>要求的媒體類型。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Net.HttpWebRequest.MediaType%2A>屬性會影響<xref:System.Net.HttpWebResponse.CharacterSet%2A>屬性。 當您設定<xref:System.Net.HttpWebRequest.MediaType%2A>在要求中，對應的媒體類型從回應中傳回的字元集清單中選擇`Content-type`HTTP 標頭。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的方法。</summary>
        <value>用來連繫網際網路資源的要求方法。 預設值為 GET。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A>屬性可以設定為任何 HTTP 1.1 通訊協定動詞命令： GET、 HEAD、 POST、 PUT、 刪除，請追蹤] 或 [選項。  
  
 如果<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性設定為-1 以外的任何值<xref:System.Net.HttpWebRequest.Method%2A>屬性必須設定為將資料上傳的通訊協定屬性。  
  
   
  
## Examples  
 下列程式碼範例將<xref:System.Net.HttpWebRequest.Method%2A>貼文的屬性。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未提供任何方法。  -或-  方法字串含有無效字元。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否將要求導送至網際網路資源。</summary>
        <value>如果要求應該要導送，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式使用<xref:System.Net.HttpWebRequest.Pipelined%2A>可指出以管線連接喜好設定的屬性。 當<xref:System.Net.HttpWebRequest.Pipelined%2A>是`true`，應用程式會以管線的連接的伺服器上支援它們。  
  
 以管線的連接進行時，才<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性也是`true`。  
  
   
  
## Examples  
 下列程式碼範例會列印值<xref:System.Net.HttpWebRequest.Pipelined%2A>屬性至主控台。  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否隨著要求傳送驗證標頭。</summary>
        <value>
          <see langword="true" /> 表示在進行驗證後隨同要求傳送 HTTP 驗證標頭，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在特定用戶端提出要求後<xref:System.Uri>成功驗證時，如果<xref:System.Net.HttpWebRequest.PreAuthenticate%2A>是`true`並提供認證，授權標頭會隨著每個要求傳送至任何<xref:System.Uri>符合特定<xref:System.Uri>到最後的斜線。 因此，如果用戶端要求已成功驗證特定<xref:System.Uri>包含下列：  
  
 `http://www.contoso.com/firstpath/`  
  
 然後進行預先驗證的授權標頭與每個要求傳送至下列任一項<xref:System.Uri>執行個體：  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 不過，授權標頭不會傳送要求到下列任一項<xref:System.Uri>執行個體：  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 如果用戶端要求在特定<xref:System.Uri>是驗證不成功，要求會使用標準驗證程序。  
  
 第一個要求中，除了<xref:System.Net.WebRequest.PreAuthenticate%2A>屬性會指出是否要傳送的後續要求使用的驗證資訊<xref:System.Uri>符合特定<xref:System.Uri>到而不需要等待進行最後的斜線伺服器所面臨的挑戰。  
  
 用戶端與伺服器之間的下列對話方塊說明這個屬性的效果。 對話方塊會假設該基本驗證是使用中。  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 是`false`:  
  
 用戶端： GET someUrl  
  
 伺服器： 401 Www-authenticate Basic  
  
 取得使用授權標頭的用戶端：  
  
 伺服器： 200 確定  
  
 用戶端： GET someUrl  
  
 伺服器： 401 Www-authenticate Basic  
  
 取得使用授權標頭的用戶端：  
  
 伺服器： 200 確定  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 是`true`:  
  
 用戶端： GET someUrl  
  
 伺服器： 401 Www-authenticate Basic  
  
 取得使用授權標頭的用戶端：  
  
 伺服器： 200 確定  
  
 用戶端： 取得使用授權標頭 someUrl  
  
 如果不支援預先驗證的驗證配置，則會忽略這個屬性的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求所使用的 HTTP 版本。</summary>
        <value>要求所使用的 HTTP 版本。 預設值為 <see cref="F:System.Net.HttpVersion.Version11" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest>類別支援只 1.0 和 1.1 版的 HTTP。 設定<xref:System.Net.HttpWebRequest.ProtocolVersion%2A>至不同的版本則會擲回例外狀況。  
  
> [!NOTE]
>  若要設定目前要求的 HTTP 版本，請使用<xref:System.Net.HttpVersion.Version10>並<xref:System.Net.HttpVersion.Version11>的欄位<xref:System.Net.HttpVersion>類別。  
  
   
  
## Examples  
 下列程式碼範例將<xref:System.Net.HttpWebRequest.ProtocolVersion%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">HTTP 版本設定為 1.0 或 1.1 以外的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的 Proxy 資訊。</summary>
        <value>
          <see cref="T:System.Net.IWebProxy" /> 物件，用來代理 (Proxy) 要求。 呼叫 <see cref="P:System.Net.GlobalProxySelection.Select" /> 屬性可以設定預設值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A>屬性會識別<xref:System.Net.WebProxy>物件，用來處理對網際網路資源的要求。 若要指定任何 proxy，應使用，請設定<xref:System.Net.HttpWebRequest.Proxy%2A>屬性所傳回的 proxy 執行個體<xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType>方法。  
  
 在本機電腦或應用程式組態檔，可能會指定使用預設 proxy。 如果<xref:System.Net.HttpWebRequest.Proxy%2A>指定屬性，然後從的 proxy 設定<xref:System.Net.HttpWebRequest.Proxy%2A>屬性會覆寫本機電腦或應用程式組態檔和<xref:System.Net.HttpWebRequest>執行個體將會使用指定的 proxy 設定。 如果未不指定任何 proxy 在組態檔中，<xref:System.Net.HttpWebRequest.Proxy%2A>屬性未指定，<xref:System.Net.HttpWebRequest>類別會使用繼承自 Internet Explorer 中，在本機電腦上的 proxy 設定。 如果沒有在 Internet Explorer proxy 設定，要求會直接傳送到伺服器。  
  
 <xref:System.Net.HttpWebRequest>類別剖析包含萬用字元的 proxy 略過清單繼承自 Internet Explorer 相同略過清單是由 Internet Explorer 直接剖析。 例如，<xref:System.Net.HttpWebRequest>類別將會剖析"nt *"從 Internet Explorer 略過清單做為規則運算式的 「 nt。\*"。 因此的 URL 」`http://nt.com`」 會略過 proxy 使用<xref:System.Net.HttpWebRequest>類別和使用 Internet Explorer。  
  
 <xref:System.Net.HttpWebRequest>類別支援本機 proxy 略過。 類別會將目的地為本機，如果下列任一條件成立：  
  
-   目的地包含一般名稱 （不在 URL 中的點）。  
  
-   目的地包含迴路位址 (<xref:System.Net.IPAddress.Loopback>或是<xref:System.Net.IPAddress.IPv6Loopback>) 或目的地包含<xref:System.Net.IPAddress>指派給本機電腦。  
  
-   目的地的網域尾碼符合本機電腦的網域尾碼 (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>)。  
  
 變更<xref:System.Net.HttpWebRequest.Proxy%2A>屬性，藉由呼叫要求啟動後<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法會擲回<xref:System.InvalidOperationException>。 如需 proxy 項目，請參閱[ \&l t; defaultProxy\&gt;項目 （網路設定）](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.Proxy%2A>方法來取得要求的 proxy 資訊。  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> 設定為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">要求已經藉由呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 啟動。</exception>
        <exception cref="T:System.Security.SecurityException">此呼叫端沒有要求的作業之權限。</exception>
        <permission cref="T:System.Net.WebPermission">取得或設定<see cref="P:System.Net.HttpWebRequest.Proxy" />屬性。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定寫入或讀取資料流時的逾時 (以毫秒為單位)。</summary>
        <value>寫入或讀取逾時前的毫秒數。預設值為 300,000 毫秒 (5 分鐘)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>寫入至所傳回的資料流時使用屬性<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法或從傳回的資料流讀取<xref:System.Net.HttpWebResponse.GetResponseStream%2A>方法。  
  
 具體而言，<xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>屬性控制的逾時值<xref:System.IO.Stream.Read%2A>方法，用來讀取傳回之資料流<xref:System.Net.HttpWebResponse.GetResponseStream%2A>方法，以及<xref:System.IO.Stream.Write%2A>方法，用來寫入資料流由<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法。  
  
 若要指定的等候要求完成的時間量，請使用<xref:System.Net.HttpWebRequest.Timeout%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會示範如何設定 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 屬性。  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已傳送此要求。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定給設定作業的值小於或等於零，並且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Referer" /> HTTP 標頭的值。</summary>
        <value>
          <see langword="Referer" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>屬性是`true`，則<xref:System.Net.HttpWebRequest.Referer%2A>要求重新導向至其他站台時自動設定屬性。  
  
 若要清除`Referer`HTTP 標頭，設定<xref:System.Net.HttpWebRequest.Referer%2A>屬性設`null`。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例將<xref:System.Net.HttpWebRequest.Referer%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求的原始統一資源識別元 (URI)。</summary>
        <value>
          <see cref="T:System.Uri" />，包含傳遞到 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 方法的網際網路資源 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri>物件傳遞給<xref:System.Net.HttpWebRequest>的呼叫所<xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>。  
  
 遵循重新導向標頭不會變更<xref:System.Net.HttpWebRequest.RequestUri%2A>屬性。 若要取得實際回應要求的 URI，請檢查<xref:System.Net.HttpWebRequest.Address%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會檢查是否<xref:System.Net.HttpWebRequest>物件`req`已重新導向至另一個位置完成要求，並設定的值`hasChanged`變數`true`如果要求重新導向，否則`hasChanged`設為`false`。  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要分區段傳送資料至網際網路資源。</summary>
        <value>若要分區段傳送資料至網際網路資源，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Net.HttpWebRequest.SendChunked%2A>是`true`，要求將資料傳送至網際網路資源區段中。 網際網路資源必須支援接收區塊的資料。  
  
 變更<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性，藉由呼叫要求啟動後<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法會擲回<xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性設`true`，以便可以傳送資料至網際網路資源的區段中。  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要求已藉由呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法啟動。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來驗證伺服器憑證的回呼函式。</summary>
        <value>用來驗證伺服器憑證的回呼函式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設值是沒有任何回呼函式，會設定並<xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A>屬性是`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求所使用的服務點。</summary>
        <value>
          <see cref="T:System.Net.ServicePoint" />，表示網際網路資源的網路連線。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType>屬性可能不同於<xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType>如果已重新導向。  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出要求是否提供對 <see cref="T:System.Net.CookieContainer" /> 的支援。</summary>
        <value>
          <see langword="true" /> 如果要求提供對<see cref="T:System.Net.CookieContainer" />; 否則<see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">要以資料填入的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />，指定這個序列化的目的地。</param>
        <summary>將序列化目標物件所需的資料填入 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中所包含的任何物件<xref:System.Runtime.Serialization.SerializationInfo>自動追蹤和序列化格式器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 和 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法的逾時值 (以毫秒為單位)。</summary>
        <value>等待要求逾時之前的毫秒數。預設值為 100,000 毫秒 (100 秒)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 會提出後續的同步要求的毫秒數<xref:System.Net.HttpWebRequest.GetResponse%2A>方法會等候回應，而<xref:System.Net.HttpWebRequest.GetRequestStream%2A>; 方法等候資料流。 <xref:System.Net.HttpWebRequest.Timeout%2A>整個要求和回應，適用於個別為不<xref:System.Net.HttpWebRequest.GetRequestStream%2A>和<xref:System.Net.HttpWebRequest.GetResponse%2A>方法呼叫。 如果資源不會傳回逾時期限內，要求會擲回<xref:System.Net.WebException>具有<xref:System.Net.WebException.Status%2A>屬性設定為<xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>。  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A>必須設定屬性，才<xref:System.Net.HttpWebRequest.GetRequestStream%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>呼叫方法。 變更<xref:System.Net.HttpWebRequest.Timeout%2A>屬性之後呼叫<xref:System.Net.HttpWebRequest.GetRequestStream%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>方法沒有任何作用  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A>屬性具有非同步使用提出的要求不會影響<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>或<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法。  
  
> [!CAUTION]
>  如果是非同步的要求，用戶端應用程式會實作其本身的逾時機制。 中的範例，請參閱<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法。  
  
 若要指定的時間等候讀取或寫入作業逾時，使用<xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>屬性。  
  
 網域名稱系統 (DNS) 查詢可能需要最多 15 秒鐘傳回或逾時。如果您的要求包含需要解析的主機名稱，而且您設定<xref:System.Net.FileWebRequest.Timeout%2A>的值小於 15 秒，可能需要 15 秒以上之前<xref:System.Net.WebException>就會擲回以指出您的要求逾時。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.Timeout%2A>屬性<xref:System.Net.HttpWebRequest>物件。  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的值小於零，而且不是 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Transfer-encoding" /> HTTP 標頭的值。</summary>
        <value>
          <see langword="Transfer-encoding" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然後您才能設定<xref:System.Net.HttpWebRequest.TransferEncoding%2A>屬性，您必須先設定<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性設`true`。 清除<xref:System.Net.HttpWebRequest.TransferEncoding%2A>設定為`null`的值沒有影響<xref:System.Net.HttpWebRequest.SendChunked%2A>。  
  
 指派給值<xref:System.Net.HttpWebRequest.TransferEncoding%2A>屬性取代任何現有的內容。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">當 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 為 <see langword="false" /> 時，會設定 <see cref="P:System.Net.HttpWebRequest.SendChunked" />。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值「Chunked」。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否允許高速 NTLM 驗證連接共用。</summary>
        <value>保持已驗證連接於開啟的狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的預設值是`false`，因而導致要求完成之後關閉目前的連接。 您的應用程式必須通過驗證的順序，每一次，就會發出新的要求。  
  
 如果這個屬性設定為`true`，執行驗證之後，用來擷取回應的連線保持開啟。 在此情況下，其他要求，將此屬性設定為`true`可能使用的連接，而不需重新驗證。 換句話說，如果使用者 A 已驗證的連線，使用者 B 可以重複使用 A 的連線;使用者 B 的要求完成根據使用者 a 的認證  
  
> [!CAUTION]
>  因為它可能會有應用程式使用的連接，而不必經過驗證，您必須要確定沒有任何系統管理的弱點可能會在您的系統時將此屬性設定為`true`。 如果您的應用程式會將要求傳送多個使用者 （會模擬多個使用者帳戶），並需要驗證來保護資源，執行未設定這個屬性為`true`除非您使用連線群組，如下所述。  
  
 您可能要考慮啟用這項機制，如果您有效能問題，並使用整合式 Windows 驗證的 Web 伺服器上執行您的應用程式。  
  
 啟用此設定會使系統的安全性風險。 如果您設定<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>屬性設`true`務必採取下列預防措施：  
  
-   使用<xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>屬性來管理不同使用者的連線。 這會避免潛在的連線使用未經驗證的應用程式。 例如，使用者 A 應該有唯一的連線群組名稱，不同於使用者 b。這會提供每個使用者帳戶的隔離層。  
  
-   執行您的應用程式中受保護的環境，可協助避免可能的連接入侵。  
  
 如果您控制後端伺服器，或者您可以考慮關閉驗證持續性。 這會增加效能，以較小的程度，但是比較安全。 如需詳細資訊，搜尋 MSDN library 中的 AuthPersistence [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)。  
  
> [!NOTE]
>  如果兩個<xref:System.Net.WebRequest.PreAuthenticate%2A>並<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>設定為`true`，每個要求會傳送來自不安全的集區，但具有授權標頭使用的連接。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">不受限制的 Web 權限，才能設定這個屬性。</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，控制是否隨著要求傳送預設認證。</summary>
        <value>如果使用預設認證，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將此屬性設定為`true`當要求所做的變更<xref:System.Net.HttpWebRequest>物件應該如果要求的伺服器上，驗證使用目前登入使用者的認證。 用戶端應用程式，這是在大部分情況下想要的行為。 對於中介層應用程式，例如 ASP.NET 應用程式，而不是使用這個屬性中，您通常設定<xref:System.Net.HttpWebRequest.Credentials%2A>屬性，以代表其提出要求的用戶端的認證。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您嘗試在送出要求之後設定這個屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="User-agent" /> HTTP 標頭的值。</summary>
        <value>
          <see langword="User-agent" /> HTTP 標頭的值。 預設值是 <see langword="null" />。  
  
 <block subset="none" type="note"><para> 此屬性的值會儲存在<see cref="T:System.Net.WebHeaderCollection" />。如果 webheadercollection，屬性值將會遺失。  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例將<xref:System.Net.HttpWebRequest.UserAgent%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>