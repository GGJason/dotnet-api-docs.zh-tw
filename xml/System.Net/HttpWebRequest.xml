<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>提供 <see cref="T:System.Net.WebRequest" /> 類別的 HTTP 特定實作。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest>類別會提供支援的屬性和方法定義在<xref:System.Net.WebRequest>以及其他屬性和方法，讓使用者直接與使用 HTTP 伺服器互動。  
  
 請勿使用<xref:System.Net.HttpWebRequest.%23ctor%2A>建構函式。 使用<xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>方法來初始化新<xref:System.Net.HttpWebRequest>物件。 配置的統一資源識別元 (URI) 是否`http://`或`https://`，<xref:System.Net.WebRequest.Create%2A>傳回<xref:System.Net.HttpWebRequest>物件。  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A>方法讓一項同步要求中指定的資源<xref:System.Net.HttpWebRequest.RequestUri%2A>屬性，並傳回<xref:System.Net.HttpWebResponse>，其中包含回應物件。 可接收回應資料，請使用所傳回的資料流<xref:System.Net.HttpWebResponse.GetResponseStream%2A>。 如果回應物件或回應資料流已關閉，將會失效剩餘資料。 其餘資料將會耗盡，關閉回應物件或資料流，如果下列條件時，通訊端將會重複使用的後續要求： 它是為 keep-alive 或管線的要求，只有少量的資料必須收到，或小型時間間隔內接收到剩餘的資料。 如果所述條件保存或超過清空時間，將會關閉通訊端。 為 keep-alive 或以管線連接，我們強烈建議在應用程式讀取資料流，直到 EOF。 這可確保通訊端，皆套用於後續要求產生較佳的效能和較低的資源使用。  
  
 當您想要將資料傳送至資源，<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法會傳回<xref:System.IO.Stream>物件用來傳送資料。 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法提供非同步傳送資料流存取。  
  
 用戶端驗證具有<xref:System.Net.HttpWebRequest>，用戶端憑證必須安裝在目前使用者的憑證存放區。  
  
 <xref:System.Net.HttpWebRequest>類別會擲回<xref:System.Net.WebException>何時存取資源的時候發生錯誤。 <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>屬性包含<xref:System.Net.WebExceptionStatus>值，指出錯誤的來源。 當<xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>是<xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>、<xref:System.Net.WebException.Response%2A>屬性包含<xref:System.Net.HttpWebResponse>接收到來自資源。  
  
 <xref:System.Net.HttpWebRequest> 公開一般 HTTP 標頭值傳送至網際網路資源做為屬性，設定方法，或是由系統; 所設定下表包含完整的清單。 您可以設定其他標頭<xref:System.Net.HttpWebRequest.Headers%2A>屬性當做名稱/值組。 請注意，伺服器和快取可能會變更或加入要求期間的標頭。  
  
 下表列出可能是屬性或方法或系統所設定的 HTTP 標頭。  
  
|頁首|設定|  
|------------|------------|  
|接受|設定<xref:System.Net.HttpWebRequest.Accept%2A>屬性。|  
|連線|設定<xref:System.Net.HttpWebRequest.Connection%2A>屬性，<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性。|  
|內容長度|設定<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性。|  
|Content-Type|設定<xref:System.Net.HttpWebRequest.ContentType%2A>屬性。|  
|預期|設定<xref:System.Net.HttpWebRequest.Expect%2A>屬性。|  
|日期|設定由系統目前的日期。|  
|主機|設定由系統目前的主機資訊。|  
|如果修改自|設定<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性。|  
|範圍|設定<xref:System.Net.HttpWebRequest.AddRange%2A>方法。|  
|推薦者|設定<xref:System.Net.HttpWebRequest.Referer%2A>屬性。|  
|傳輸編碼|設定<xref:System.Net.HttpWebRequest.TransferEncoding%2A>屬性 (<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性必須是`true`)。|  
|使用者代理程式|設定<xref:System.Net.HttpWebRequest.UserAgent%2A>屬性。|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> 會自動註冊。 您不需要呼叫<xref:System.Net.WebRequest.RegisterPrefix%2A>方法，登錄<xref:System.Net.HttpWebRequest?displayProperty=nameWithType>之前使用 Uri 開頭為`http://`或`https://`。  
  
 在本機電腦或應用程式組態檔，可以指定使用預設 proxy。 如果<xref:System.Net.HttpWebRequest.Proxy%2A>指定屬性，然後從的 proxy 設定<xref:System.Net.HttpWebRequest.Proxy%2A>屬性覆寫在本機電腦或應用程式組態檔和<xref:System.Net.HttpWebRequest>執行個體會使用指定的 proxy 設定。 如果沒有任何 proxy 在組態檔中指定了和<xref:System.Net.HttpWebRequest.Proxy%2A>屬性並未指定，<xref:System.Net.HttpWebRequest>類別會使用繼承自 Internet Explorer，在本機電腦上的 proxy 設定。 如果沒有在 Internet Explorer proxy 設定，會將要求傳送到伺服器。  
  
 <xref:System.Net.HttpWebRequest>類別與繼承自 Internet Explorer 以不同的方式略過清單直接由 Internet Explorer 剖析非萬用字元剖析 proxy 略過清單。 例如，<xref:System.Net.HttpWebRequest>類別將會剖析的"nt *"與 Internet Explorer 略過清單做為規則運算式的 「 nt。 $"。 這不同於 Internet Explorer 的原生行為。 因此的 URL"`http://intxxxxx`」 會略過 proxy 使用<xref:System.Net.HttpWebRequest>類別，但不是會略過使用 Internet Explorer 的 proxy。  
  
> [!NOTE]
>  架構快取的 SSL 工作階段建立時，並嘗試盡可能重複使用快取的工作階段為新的要求。 當嘗試重複使用的 SSL 工作階段，架構會使用第一個項目<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果有一個），或嘗試重複使用匿名的工作階段，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>是空的。  
  
> [!NOTE]
>  基於安全性理由，預設會停用 cookie。 如果您想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>屬性來啟用 cookie。  
  
 .NET Framework 4.6 包含新的安全性功能會封鎖不安全的加密與雜湊演算法的連線。 使用 TLS/SSL 透過例如 HttpClient、 HttpWebRequest、 FTPClient、 SmtpClient、 SslStream 」 等的 Api，並以.NET Framework 4.6 為目標的應用程式預設會取得更安全的行為。  
  
 開發人員可能想要取消這個行為，以維護與 RC4 服務以其現有 SSL3 服務或 TLS 的互通性。 [這篇文章](https://support.microsoft.com/kb/3069494)說明如何修改您的程式碼，讓新的行為會停用。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Net.HttpWebRequest>uri http://www.contoso.com/。  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">若要存取要求的 URI 或任何已重新導向至的 URI。 相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.HttpWebRequest" /> 類別的新執行個體。 這些建構函式已淘汰；如需詳細資料，請參閱＜備註＞一節。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

同時<xref:System.Net.HttpWebRequest>建構函式已經過時，而且不應使用。 呼叫<xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType>方法來初始化新<xref:System.Net.HttpWebRequest>物件。     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Net.HttpWebRequest" /> 類別的新執行個體。 這個建構函式已經過時。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件，包含將新的 <see cref="T:System.Net.HttpWebRequest" /> 物件序列化所需的資訊。</param>
        <param name="streamingContext"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 物件，包含與新 <see cref="T:System.Net.HttpWebRequest" /> 物件關聯的序列化資料流的來源和目的端。</param>
        <summary>從 <see cref="T:System.Net.HttpWebRequest" /> 和 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 類別的已指定執行個體，初始化 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 類別的新執行個體。 這個建構函式已經過時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用序列化時，應用程式必須以完全信任模式執行。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">不受限制存取網路資源。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消對網際網路資源的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A>方法取消資源的要求。 要求取消之後，呼叫<xref:System.Net.HttpWebRequest.GetResponse%2A>， <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>， <xref:System.Net.HttpWebRequest.EndGetResponse%2A>， <xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>，或<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法會使<xref:System.Net.WebException>與<xref:System.Net.WebException.Status%2A>屬性設定為<xref:System.Net.WebExceptionStatus.RequestCanceled>。  
  
 <xref:System.Net.HttpWebRequest.Abort%2A>方法會以同步方式執行指定的回呼<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法如果<xref:System.Net.HttpWebRequest.Abort%2A>任一這些作業未完成時，會呼叫方法。 這可能會導致潛在的死結問題。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)。  
  
   
  
## Examples  
 如果非同步要求，它負責用戶端應用程式，來實作其本身的逾時機制。 下列程式碼範例示範如何執行這項操作。  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Accept" /> HTTP 標頭的值。</summary>
        <value><see langword="Accept" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要清除`Accept`設定 HTTP 標頭，<xref:System.Net.HttpWebRequest.Accept%2A>屬性`null`。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.Accept%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">範圍的起始和結束點。</param>
        <summary>針對從已要求資料的起始或結尾的特定範圍，將位元組範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法將位元組範圍標頭加入至要求。  
  
 如果`range`是正數，`range`參數指定之範圍的起點。 伺服器應開始傳送資料，從`range`參數指定為 [HTTP] 實體中資料的結尾。  
  
 如果`range`是負數，`range`參數指定之範圍的結束點。 伺服器應開始傳送資料，從 HTTP 實體中的資料開始`range`指定參數。  
  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 要求伺服器傳送前 100 個位元組 （從開始到 99 的位元組位置中） 會是如下所示的 HTTP 通訊協定要求中的範圍標頭範例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 例如，`range`參數便是-99。  
  
 HTTP 伺服器指出範圍標頭，以接受範圍標頭的支援。 從支援位元組範圍的伺服器接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果接受範圍標頭未收到來自伺服器的回應標頭中，伺服器不支援範圍標頭。 將伺服器不支援的範圍，但可辨識的接受範圍標頭的接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時收到來自 「 範圍 」 要求的回應，被剖析，並透過屬性提供<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
   
  
## Examples  
 下列程式碼範例會將範圍標頭加入至要求。  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">範圍的起始和結束點。</param>
        <summary>針對從已要求資料的起始或結尾的特定範圍，將位元組範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法將位元組範圍標頭加入至要求。  
  
 如果`range`是正數，`range`參數指定之範圍的起點。 伺服器應開始傳送資料，從`range`參數指定為 [HTTP] 實體中資料的結尾。  
  
 如果`range`是負數，`range`參數指定之範圍的結束點。 伺服器應開始傳送資料，從 HTTP 實體中的資料開始`range`指定參數。  
  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 要求伺服器傳送前 100 個位元組 （從開始到 99 的位元組位置中） 會是如下所示的 HTTP 通訊協定要求中的範圍標頭範例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 例如，`range`參數便是-99。  
  
 HTTP 伺服器指出範圍標頭，以接受範圍標頭的支援。 從支援位元組範圍的伺服器接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果接受範圍標頭未收到來自伺服器的回應標頭中，伺服器不支援範圍標頭。 將伺服器不支援的範圍，但可辨識的接受範圍標頭的接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時收到來自 「 範圍 」 要求的回應，被剖析，並透過屬性提供<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">要開始傳送資料的位置。</param>
        <param name="to">要停止傳送資料的位置。</param>
        <summary>將範圍標頭加入至特定範圍的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法將位元組範圍標頭加入至要求。  
  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 在 HTTP 通訊協定的要求會要求前 100 個位元組的範圍標頭的範例應如下所示：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 例如，`from`參數會指定為 0 和`to`參數會指定為 99。 這個方法，會自動範圍規範設為 「 位元組 」。  
  
 HTTP 伺服器指出範圍標頭，以接受範圍標頭的支援。 從支援位元組範圍的伺服器接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果接受範圍標頭未收到來自伺服器的回應標頭中，伺服器不支援範圍標頭。 將伺服器不支援的範圍，但可辨識的接受範圍標頭的接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時收到來自 「 範圍 」 要求的回應，被剖析，並透過屬性提供<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
   
  
## Examples  
 下列程式碼範例會將範圍標頭加入至要求。  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> 大於 <paramref name="to" />  -或-   <paramref name="from" /> 或 <paramref name="to" /> 小於 0。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">要開始傳送資料的位置。</param>
        <param name="to">要停止傳送資料的位置。</param>
        <summary>將範圍標頭加入至特定範圍的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法將位元組範圍標頭加入至要求。  
  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 在 HTTP 通訊協定的要求會要求前 100 個位元組的範圍標頭的範例應如下所示：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 例如，`from`參數會指定為 0 和`to`參數會指定為 99。 這個方法，會自動範圍規範設為 「 位元組 」。  
  
 HTTP 伺服器指出範圍標頭，以接受範圍標頭的支援。 從支援位元組範圍的伺服器接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果接受範圍標頭未收到來自伺服器的回應標頭中，伺服器不支援範圍標頭。 將伺服器不支援的範圍，但可辨識的接受範圍標頭的接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時收到來自 「 範圍 」 要求的回應，被剖析，並透過屬性提供<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> 大於 <paramref name="to" />  -或-   <paramref name="from" /> 或 <paramref name="to" /> 小於 0。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">範圍的描述。</param>
        <param name="range">範圍的起始和結束點。</param>
        <summary>針對從已要求資料的起始或結尾的特定範圍，將範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將範圍標頭加入要求。  
  
 如果`range`是正數，`range`參數指定之範圍的起點。 伺服器應開始傳送資料，從`range`參數指定為 [HTTP] 實體中資料的結尾。  
  
 如果`range`是負數，`range`參數指定之範圍的結束點。 伺服器應開始傳送資料，從 HTTP 實體中的資料開始`range`指定參數。  
  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 `rangeSpecifier`參數會通常指定為"bytes"，因為這是唯一可辨識大部分的 HTTP 伺服器的範圍規範。 設定`rangeSpecifier`某些其他字串的參數允許支援位元組 （由 IETF RFC 2616 中定義的位元組範圍規範） 以外的自訂範圍規範。  
  
 在 HTTP 通訊協定的要求會要求前 100 個位元組的範圍標頭的範例應如下所示：  
  
 `Range: bytes=-99\r\n\r\n`  
  
 例如，`rangeSpecifier`參數會指定為 「 位元組 」 和`range`參數便是-99。  
  
 HTTP 伺服器表示接受範圍標頭會在回應中的範圍標頭的支援。 從支援位元組範圍的伺服器接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果接受範圍標頭未收到來自伺服器的回應標頭中，伺服器不支援範圍標頭。 將伺服器不支援的範圍，但可辨識的接受範圍標頭的接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時收到來自 「 範圍 」 要求的回應，被剖析，並透過屬性提供<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">範圍的描述。</param>
        <param name="range">範圍的起始和結束點。</param>
        <summary>針對從已要求資料的起始或結尾的特定範圍，將範圍標頭加入至要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將範圍標頭加入要求。  
  
 如果`range`是正數，`range`參數指定之範圍的起點。 伺服器應開始傳送資料，從`range`參數指定為 [HTTP] 實體中資料的結尾。  
  
 如果`range`是負數，`range`參數指定之範圍的結束點。 伺服器應開始傳送資料，從 HTTP 實體中的資料開始`range`指定參數。  
  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 `rangeSpecifier`參數會通常指定為"bytes"，因為這是唯一可辨識大部分的 HTTP 伺服器的範圍規範。 設定`rangeSpecifier`某些其他字串的參數允許支援位元組 （由 IETF RFC 2616 中定義的位元組範圍規範） 以外的自訂範圍規範。  
  
 在 HTTP 通訊協定的要求會要求前 100 個位元組的範圍標頭的範例應如下所示：  
  
 `Range: bytes=-99\r\n\r\n`  
  
 例如，`rangeSpecifier`參數會指定為 「 位元組 」 和`range`參數便是-99。  
  
 HTTP 伺服器表示接受範圍標頭會在回應中的範圍標頭的支援。 從支援位元組範圍的伺服器接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果接受範圍標頭未收到來自伺服器的回應標頭中，伺服器不支援範圍標頭。 將伺服器不支援的範圍，但可辨識的接受範圍標頭的接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時收到來自 「 範圍 」 要求的回應，被剖析，並透過屬性提供<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">範圍的描述。</param>
        <param name="from">要開始傳送資料的位置。</param>
        <param name="to">要停止傳送資料的位置。</param>
        <summary>將範圍標頭加入至特定範圍的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將範圍標頭加入要求。  
  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 `rangeSpecifier`參數會通常指定為"bytes"，因為這是唯一可辨識大部分的 HTTP 伺服器的範圍規範。 設定`rangeSpecifier`某些其他字串的參數允許支援位元組 （由 IETF RFC 2616 中定義的位元組範圍規範） 以外的自訂範圍規範。  
  
 在 HTTP 通訊協定的要求會要求前 100 個位元組的範圍標頭的範例應如下所示：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 例如，`rangeSpecifier`參數會指定為 「 位元組 」`from`參數便是 0，和`to`參數便是 99。  
  
 HTTP 伺服器表示接受範圍標頭會在回應中的範圍標頭的支援。 從支援位元組範圍的伺服器接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 接受範圍標頭中指定的字串是會藉由指定的範圍規範`rangeSpecifier`，此方法的參數。  
  
 如果接受範圍標頭未收到來自伺服器的回應標頭中，伺服器不支援範圍標頭。 將伺服器不支援的範圍，但可辨識的接受範圍標頭的接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時收到來自 「 範圍 」 要求的回應，被剖析，並透過屬性提供<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> 大於 <paramref name="to" />  -或-   <paramref name="from" /> 或 <paramref name="to" /> 小於 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">範圍的描述。</param>
        <param name="from">要開始傳送資料的位置。</param>
        <param name="to">要停止傳送資料的位置。</param>
        <summary>將範圍標頭加入至特定範圍的要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法會將範圍標頭加入要求。  
  
 因為所有的 HTTP 實體會表示為位元組序列的 HTTP 訊息，位元組範圍的概念是對任何 HTTP 實體有意義的。 不過，並非所有的用戶端和伺服器需要支援位元組範圍作業。  
  
 要求的範圍標頭可讓用戶端要求，它只想要在 HTTP 實體中接收指定的位元組範圍的某些部分。 伺服器不需要支援範圍標頭的要求。  
  
 `rangeSpecifier`參數會通常指定為"bytes"，因為這是唯一可辨識大部分的 HTTP 伺服器的範圍規範。 設定`rangeSpecifier`某些其他字串的參數允許支援位元組 （由 IETF RFC 2616 中定義的位元組範圍規範） 以外的自訂範圍規範。  
  
 在 HTTP 通訊協定的要求會要求前 100 個位元組的範圍標頭的範例應如下所示：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 例如，`rangeSpecifier`參數會指定為 「 位元組 」`from`參數便是 0，和`to`參數便是 99。  
  
 HTTP 伺服器表示接受範圍標頭會在回應中的範圍標頭的支援。 從支援位元組範圍的伺服器接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 接受範圍標頭中指定的字串是會藉由指定的範圍規範`rangeSpecifier`，此方法的參數。  
  
 如果接受範圍標頭未收到來自伺服器的回應標頭中，伺服器不支援範圍標頭。 將伺服器不支援的範圍，但可辨識的接受範圍標頭的接受範圍標頭的範例應如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 只有 HTTP 標頭與整個要求相關聯時收到來自 「 範圍 」 要求的回應，被剖析，並透過屬性提供<xref:System.Net.HttpWebResponse>類別。 在回應中傳回的每個範圍相關聯的標頭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> 大於 <paramref name="to" />  -或-   <paramref name="from" /> 或 <paramref name="to" /> 小於 0。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">無法加入範圍標頭。</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得實際回應要求的網際網路資源統一資源識別元 (URI)。</summary>
        <value><see cref="T:System.Uri" />，識別實際回應要求的網際網路資源。 預設值為 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 方法用來初始化要求的 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A>屬性設定為 URI 要求期間發生任何重新導向完成後。  
  
 原始要求的 URI 會保留在<xref:System.Net.HttpWebRequest.RequestUri%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會檢查是否<xref:System.Net.HttpWebRequest>物件`req`已重新導向至另一個位置來完成要求，並將值設定`hasChanged`變數設為`true`如果要求已重新導向; 否則`hasChanged`設`false`。  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值指出要求是否應該緊接在重新導向回應之後。</summary>
        <value>如果要求應該自動追蹤來自網際網路資源的重新導向回應，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基於效能考量，您不應該新增用戶端憑證，<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>除非您知道它會要求伺服器。 若要遵循重新導向的最大數目由所設定<xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>屬性。  
  
 程式碼範例示範如何列舉中的用戶端憑證存放區的憑證，請參閱<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>類別。  
  
 要求會傳送<xref:System.Net.HttpWebRequest>屬性做為與網際網路資源HTTP 標頭。 在實務上，這表示如果它是可能發生的重新導向應用程式無法將自訂驗證的授權標頭資訊。 相反地，應用程式必須實作並註冊自訂驗證模組。 如果值<xref:System.Net.AuthenticationManager?displayProperty=nameWithType>屬性是，「 保持運作 」 的值附加至結尾標頭。 變更<xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType>屬性之後要求已藉由呼叫， ， ，或方法會擲回。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>屬性來設定連線 HTTP 標頭的值。  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否要緩衝處理從網際網路資源接收的資料。</summary>
        <value><see langword="true" /> 表示要對從網際網路資源接收的資料啟用緩衝處理，<see langword="false" /> 則表示要停用緩衝處理。 預設值為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要緩衝傳送至網際網路資源的資料。</summary>
        <value><see langword="true" /> 表示要對傳送至網際網路資源的資料啟用緩衝處理，<see langword="false" /> 則表示要停用緩衝處理。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A>屬性可讓您將要求與連接群組產生關聯。  
  
   
  
## Examples  
 當您的應用程式提出要求到一部伺服器不同的使用者，例如資料庫伺服器中擷取客戶資訊的網站時，這非常有用。  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>下列程式碼範例示範如何使用使用者資訊，以形成連接群組，但前提變數<para>， <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />，和<see langword="true" />這段程式碼會在呼叫之前由應用程式中設定。</para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定使用的解壓縮類型。</summary>
        <value>每個連接群組建立其他連接的伺服器。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">此物件的目前狀態不允許設定這個屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">這個要求的狀態物件。</param>
        <summary>開始用來寫入資料之 <see cref="T:System.IO.Stream" /> 物件的非同步要求。</summary>
        <returns>參考非同步要求的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這可能會導致超過所設定的連接數目<xref:System.Net.HttpWebRequest>該伺服器的屬性。 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>屬性包含值，以傳送與要求的 HTTP 標頭。  
  
 中的-1 以外的任何值<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>屬性會指出要求上傳資料，並在中設定允許的資料上傳的方法屬性。 之後屬性設定為值，該位元組數必須寫入要求資料流，藉由呼叫會傳回方法或兩者皆和方法。  
  
 下列程式碼範例會設定[来公佈的字串長度屬性。  
  
> [!NOTE]
>  指派給值屬性取代任何現有的內容，當要求傳送HTTP 標頭。 這個屬性的值儲存在<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 如果<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>已經設定，將會遺失屬性值。  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> 屬性是 GET 或 HEAD。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。</exception>
        <exception cref="T:System.InvalidOperationException">此資料流正由先前對 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 的呼叫所使用，或 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。  -或-  執行緒集區中的執行緒即將用盡。</exception>
        <exception cref="T:System.NotSupportedException">要求快取驗證程式指出，可以從快取處理此要求的回應；不過，寫入資料的要求絕對不能使用快取。 如果您使用實作自訂快取驗證程式不正確，便會發生這個例外狀況。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。</exception>
        <exception cref="T:System.ObjectDisposedException">在 .NET Compact Framework 應用程式中，未取得且未正確關閉內容長度為零的要求資料流。 如需處理零內容長度要求的詳細資訊，請參閱 [.NET Compact Framework 中的網路程式設計] (https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx)。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派</param>
        <param name="state">這個要求的狀態物件。</param>
        <summary>開始對網際網路資源的非同步要求。</summary>
        <returns><see cref="T:System.IAsyncResult" />，參考回應的非同步要求。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這非常有用，如果您想要顯示的狀態資料從網際網路資源接收的用戶端。 如果 100-繼續進行之前逾時過期，可以傳送的實體主體，會接收到回應。  
  
 A <xref:System.Net.ProtocolViolationException> ，其中包含與此要求相關聯的 cookie。 <xref:System.Net.HttpWebRequest.ContentLength%2A>屬性提供的執行個體<xref:System.Net.HttpWebRequest.SendChunked%2A>類別，其中包含與此要求相關聯的 cookie。 是預設。 您必須指派<xref:System.Net.HttpWebRequest.ContentLength%2A>物件屬性中傳回的 cookie<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性`false`傳回<xref:System.Net.HttpWebRequest.KeepAlive%2A>方法。`.`  
  
 如果<xref:System.Net.WebException>會擲回，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>屬性來判斷伺服器的回應例外狀況。  
  
 中的-1 以外的任何值<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>屬性會指出要求上傳資料，並在中設定允許的資料上傳的方法屬性。 之後屬性設定為值，該位元組數必須寫入要求資料流，藉由呼叫會傳回方法或兩者皆和方法。  
  
 下列程式碼範例會將要求傳送至的 URL，並顯示在回應中傳回的 cookie。  
  
> [!NOTE]
>  指派給值屬性取代任何現有的內容，當要求傳送HTTP 標頭。 這個屬性的值儲存在<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)。  
  
   
  
## Examples  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>屬性包含驗證資訊來識別的要求。  
  
> [!NOTE]
>  如果非同步要求，它負責用戶端應用程式，來實作其本身的逾時機制。 屬性可以是、 在哪些情況下使用者、 密碼和網域中所包含的資訊物件用來驗證要求，或它可以是的情況下統一的資源要求的識別碼 (URI) 用來判斷要用於驗證要求使用者、 密碼和網域資訊。  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此資料流已由先前對 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 的呼叫所使用，或 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。  -或-  執行緒集區中的執行緒即將用盡。</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> 是 GET 或 HEAD，而且若不是 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大於零，就是 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 為 <see langword="true" />。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1 或 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 為 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。  -或-  <see cref="T:System.Net.HttpWebRequest" /> 具有實體主體，但 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法在沒有呼叫 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 方法的情況下呼叫。  -或-  <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大於零，但該應用程式不會寫入所有承諾的資料。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個要求關聯的安全憑證集合。</summary>
        <value><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />，包含與這個要求相關的安全憑證。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NTLM 驗證配置不能模擬其他使用者。 Kerberos 必須經過特別設定為支援模擬。  
  
> [!NOTE]
>  架構快取的 SSL 工作階段建立時，並嘗試盡可能重複使用快取的工作階段為新的要求。 當嘗試重複使用的 SSL 工作階段，架構會使用第一個項目<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果有一個），或嘗試重複使用匿名的工作階段，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>是空的。  
  
> [!NOTE]
>  若要限制 HttpWebRequest 一或多個驗證方法，使用<xref:System.Net.HttpWebRequest>類別，並將您的認證繫結至一個或多個驗證配置  
>   
>  支援的驗證配置包含摘要式、 交涉、 Kerberos、 NTLM 及 Basic。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">為設定作業指定的值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Connection" /> HTTP 標頭的值。</summary>
        <value><see langword="Connection" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列程式碼範例會設定為要求的認證。 如果日期標頭<xref:System.Net.HttpWebRequest.KeepAlive%2A>，則傳回值會設為`true`。  
  
 若要清除`Connection`設定 HTTP 標頭，<xref:System.Net.HttpWebRequest.Connection%2A>屬性`null`。  
  
 <xref:System.Net.HttpWebRequest.Connection%2A>屬性是一種標準<xref:System.Net.HttpWebRequest.GetRequestStream%2A>物件，並可以包含<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>欄位<xref:System.Net.HttpWebRequest.GetResponse%2A>， <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>，或<xref:System.InvalidOperationException>。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 使用時，就可以設定任何一種時間<xref:System.Net.HttpWebRequest.Connection%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.Connection" /> 的值已設為 Keep-alive 或 Close。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的連接群組名稱。</summary>
        <value>這個要求的連接群組名稱。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>設定或擷取，假設屬性為（本地時間）。 中的類別命名空間永遠寫出使用 GMT (Utc) 格式的標準表單中的傳輸期間的網路上的屬性。  
  
   
  
## Examples  
 如果`username`屬性設定為`password`，然後在`domain`HTTP 標頭移除屬性和。  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果<para>屬性是，這表示HTTP 標頭未包含在屬性和。如果設定和嘗試傳送<see cref="P:System.Net.ServicePoint.ConnectionLimit" />沒有主體，則</para>會擲回的， ，和方法。</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Content-length" /> HTTP 標頭。</summary>
        <value>資料位元組數，要傳送至網際網路資源。 預設值為 -1，表示還沒有設定屬性且沒有要傳送的要求資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性註冊指定的原則，針對 HTTP 與 HTTPS 配置。  
  
 如果此原則會使用這項要求：  
  
 回應標頭的長度會收到回應的狀態行，並收到 HTTP 通訊協定的一部分的任何額外的控制字元。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 值為-1 表示已接收的回應標頭沒有限制值為 0 表示所有要求會都失敗。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要求已藉由呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法啟動。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">新的 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 值小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Content-type" /> HTTP 標頭的值。</summary>
        <value><see langword="Content-type" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A>屬性包含要求的媒體類型。 這個值也可以變更組態檔中。  
  
 若要清除`Content-type`設定 HTTP 標頭，<xref:System.Net.HttpWebRequest.ContentType%2A>屬性`null`。  
  
> [!NOTE]
>  可以設定的覆寫這個屬性影響<xref:System.Net.WebHeaderCollection>屬性的執行個體上類別。 <xref:System.Net.WebHeaderCollection>方法完成所啟動的資料流的非同步要求方法。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.ContentType%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定從網際網路資源接收 HTTP 100-continue 回應時所呼叫的委派 (Delegate) 方法。</summary>
        <value>委派，實作從網際網路資源傳回 HTTP Continue 回應時所執行的回呼 (Callback) 方法。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之後<xref:System.Net.HttpWebRequest.ContinueDelegate%2A>在傳回物件，您可以使用傳送資料使用方法。  
  
 您必須設定的值<xref:System.Net.HttpWebRequest.ContinueDelegate%2A>屬性，才能將資料寫入至資料流。 您必須呼叫方法來關閉資料流，並釋放以供重複使用的連接。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要在收到伺服器的 100-Continue 以前等候的逾時 (以毫秒為單位)。</summary>
        <value>要在收到 100-Continue 以前等候的逾時 (以毫秒為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 無法關閉資料流就會導致您的應用程式連線用完。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與要求相關的 Cookie。</summary>
        <value><see cref="T:System.Net.CookieContainer" />，包含與這個要求相關的 Cookie。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A>屬性提供的執行個體<xref:System.Net.CookieContainer>類別，其中包含與此要求相關聯的 cookie。  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 是`null`預設。 您必須指派<xref:System.Net.CookieContainer>物件屬性中傳回的 cookie<xref:System.Net.HttpWebResponse.Cookies%2A>屬性<xref:System.Net.HttpWebResponse>傳回<xref:System.Net.HttpWebRequest.GetResponse%2A>方法。  
  
> [!NOTE]
>  基於安全性理由，預設會停用 cookie。 如果您想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>屬性來啟用 cookie。  
  
   
  
## Examples  
 下列程式碼範例會將要求傳送至的 URL，並顯示在回應中傳回的 cookie。  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的驗證資訊。</summary>
        <value><see cref="T:System.Net.ICredentials" />，包含與要求關聯的驗證認證。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A>屬性包含驗證資訊來識別的要求。 <xref:System.Net.HttpWebRequest.Credentials%2A>屬性可以是<xref:System.Net.NetworkCredential>、 在哪些情況下使用者、 密碼和網域中所包含的資訊<xref:System.Net.NetworkCredential>物件用來驗證要求，或它可以是<xref:System.Net.CredentialCache>的情況下統一的資源要求的識別碼 (URI) 用來判斷要用於驗證要求使用者、 密碼和網域資訊。  
  
 在大部分的用戶端情況下，您應該使用<xref:System.Net.CredentialCache.DefaultCredentials%2A>屬性，其中包含目前登入使用者的認證。 若要這樣做，請設定<xref:System.Net.WebClient.UseDefaultCredentials%2A>屬性`true`而不是設定這個屬性。  
  
 如果<xref:System.Net.HttpWebRequest>類別用於中介層應用程式，例如 ASP.NET 應用程式中的認證<xref:System.Net.CredentialCache.DefaultCredentials%2A>屬性隸屬於執行 ASP 網頁 （伺服器端的認證） 的帳戶。 一般而言，您會設定此屬性代表其提出要求的用戶端的認證。  
  
> [!NOTE]
>  NTLM 驗證配置不能模擬其他使用者。 Kerberos 必須經過特別設定為支援模擬。  
  
 若要限制 HttpWebRequest 一或多個驗證方法，使用<xref:System.Net.CredentialCache>類別，並將您的認證繫結至一個或多個驗證配置  
  
 支援的驗證配置包含摘要式、 交涉、 Kerberos、 NTLM 及 Basic。  
  
 基於安全性理由，會自動遵循重新導向時，會儲存您想要包含在中的重新導向的認證<xref:System.Net.CredentialCache>並將它指派給這個屬性。 這個屬性會自動設定為`null`時重新導向，如果它包含以外的項目<xref:System.Net.CredentialCache>。 具有此屬性的值會自動設為`null`在這些情況下不會將認證傳送到任何非預期的目的地。
  
## Examples  
 下列程式碼範例會設定為要求的認證。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要用於 HTTP 要求中的 <see langword="Date" /> HTTP 標頭值。</summary>
        <value>HTTP 要求中的 Date 標頭值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果日期標頭`null`，則傳回值會設為<xref:System.DateTime.MinValue?displayProperty=nameWithType>。  
  
 <xref:System.Net.HttpWebRequest.Date%2A>屬性是一種標準<xref:System.DateTime?displayProperty=nameWithType>物件，並可以包含<xref:System.DateTimeKind?displayProperty=nameWithType>欄位<xref:System.DateTimeKind.Local?displayProperty=nameWithType>， <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 使用時，就可以設定任何一種時間<xref:System.Net.HttpWebRequest.Date%2A>屬性。 如果<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>設定或擷取，<xref:System.Net.HttpWebRequest.Date%2A>假設屬性為<xref:System.DateTimeKind.Local?displayProperty=nameWithType>（本地時間）。  
  
 中的類別<xref:System.Net>命名空間永遠寫出<xref:System.Net.HttpWebRequest.Date%2A>使用 GMT (Utc) 格式的標準表單中的傳輸期間的網路上的屬性。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>屬性設定為<xref:System.DateTime.MinValue?displayProperty=nameWithType>，然後在`Date`HTTP 標頭移除<xref:System.Net.HttpWebRequest.Headers%2A>屬性和<xref:System.Net.WebHeaderCollection>。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>屬性是<xref:System.DateTime.MinValue?displayProperty=nameWithType>，這表示`Date`HTTP 標頭未包含在<xref:System.Net.HttpWebRequest.Headers%2A>屬性和<xref:System.Net.WebHeaderCollection>。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>設定和嘗試傳送<xref:System.Net.HttpWebRequest>沒有主體，則<xref:System.Net.ProtocolViolationException?displayProperty=nameWithType>會擲回的<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，和<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個要求的預設快取原則。</summary>
        <value><see cref="T:System.Net.Cache.HttpRequestCachePolicy" />，在沒有其他適用的原則時，為這個要求指定作用中的快取原則。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性註冊指定的原則，針對 HTTP 與 HTTPS 配置。 如果此原則會使用這項要求：  
  
 沒有任何<xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType>針對這個要求指定的屬性。  
  
 \-或-  
  
 電腦和應用程式組態檔沒有指定用來建立此要求的快取原則適用以統一資源識別元 (URI)。  
  
 快取原則可決定從快取，而不是要求傳送至資源的主機電腦是否可以取得所要求的資源。  
  
 如果資源的回應資料流擷取和讀取資料流末端，則資源的複本只會加入至快取。 讓另一個要求相同的資源無法使用快取的副本，根據此要求的快取原則層級。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">不受限制存取網路資源。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 HTTP 錯誤回應的預設最大長度。</summary>
        <value>HTTP 錯誤回應的預設最大長度。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值小於零且不等於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> 屬性的預設值。</summary>
        <value>收到的回應標頭的預設最大長度 (以 KB (1024 個位元祖) 為單位)。 預設組態檔將這個值設為 64 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 回應標頭的長度會收到回應的狀態行，並收到 HTTP 通訊協定的一部分的任何額外的控制字元。 值為-1 表示已接收的回應標頭沒有限制值為 0 表示所有要求會都失敗。  
  
 這個值也可以變更組態檔中。 可以設定的覆寫這個屬性影響<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>屬性的執行個體上<xref:System.Net.HttpWebRequest>類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值不等於 -1 且小於零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結束用來寫入資料之 <see cref="T:System.IO.Stream" /> 物件的非同步要求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">資料流的暫止要求。</param>
        <summary>結束用來寫入資料之 <see cref="T:System.IO.Stream" /> 物件的非同步要求。</summary>
        <returns>用來寫入要求資料的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法完成所啟動的資料流的非同步要求<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法。 之後<xref:System.IO.Stream>在傳回物件，您可以使用傳送資料<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  您必須設定的值<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性，才能將資料寫入至資料流。  
  
> [!CAUTION]
>  您必須呼叫<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法來關閉資料流，並釋放以供重複使用的連接。 無法關閉資料流就會導致您的應用程式連線用完。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法來中止資料流執行個體的非同步要求。  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">要求未完成，而且沒有可用的資料流。</exception>
        <exception cref="T:System.ArgumentException">呼叫 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 時，目前的執行個體未傳回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前使用 <paramref name="asyncResult" /> 呼叫過這個方法。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  處理這個要求時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">資料流的暫止要求。</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>結束用來寫入資料之 <see cref="T:System.IO.Stream" /> 物件的非同步要求，並輸出與資料流關聯的 <see cref="T:System.Net.TransportContext" />。</summary>
        <returns>用來寫入要求資料的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法完成所啟動的資料流的非同步要求<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法和輸出<xref:System.Net.TransportContext>流相關聯。 之後<xref:System.IO.Stream>在傳回物件，您可以使用傳送資料<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 具有擴充保護使用整合式的 Windows 驗證的某些應用程式可能需要能夠查詢所使用的傳輸層<xref:System.Net.HttpWebRequest>以便擷取基礎 TLS 通道的通道繫結 token (CBT)。 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法提供有要求本文的 HTTP 方法對這項資訊存取 (`POST`和`PUT`要求)。 如果應用程式實作自己的驗證，而且需要存取 CBT 只需要這個動作。  
  
> [!NOTE]
>  如果應用程式需要的值設定<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性，則這必須擷取資料流，並將資料寫入它之前完成。  
  
> [!CAUTION]
>  您必須呼叫<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法來關閉資料流，並釋放以供重複使用的連接。 無法關閉資料流就會導致您的應用程式連線用完。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">呼叫 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 時，目前的執行個體未傳回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前使用 <paramref name="asyncResult" /> 呼叫過這個方法。</exception>
        <exception cref="T:System.IO.IOException">要求未完成，而且沒有可用的資料流。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  處理這個要求時發生錯誤。</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">回應的暫止要求。</param>
        <summary>結束對網際網路資源的非同步要求。</summary>
        <returns>包含來自網際網路資源回應的 <see cref="T:System.Net.WebResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法完成的非同步要求的網際網路資源，藉由呼叫已啟動<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法。  
  
> [!CAUTION]
>  您必須呼叫<xref:System.Net.HttpWebResponse.Close%2A>方法來關閉資料流，並釋放連接。 這樣可能會導致您的應用程式連線用完。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.EndGetResponse%2A>結束對網際網路資源的非同步要求的方法。  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前使用 <paramref name="asyncResult." /> 呼叫過這個方法。-或-  <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 屬性大於 0，但資料尚未寫入要求資料流。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  處理這個要求時發生錯誤。</exception>
        <exception cref="T:System.ArgumentException">呼叫 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 時，目前的執行個體未傳回 <paramref name="asyncResult" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Expect" /> HTTP 標頭的值。</summary>
        <value><see langword="Expect" /> HTTP 標頭的內容。 預設值是 <see langword="null" />。  
  
 <block subset="none" type="note"><para> 這個屬性的值儲存在<see cref="T:System.Net.WebHeaderCollection" />。如果 webheadercollection，將屬性值將會遺失。  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see langword="Expect" /> 設定為含有子字串 "100-continue" 的字串。</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">要以資料填入的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="streamingContext"><see cref="T:System.Runtime.Serialization.StreamingContext" />，指定這個序列化的目的地。</param>
        <summary>將序列化目標物件的所需資料填入 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中所包含的任何物件<xref:System.Runtime.Serialization.SerializationInfo>自動追蹤和序列化格式子。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得用來寫入要求資料的 <see cref="T:System.IO.Stream" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得用來寫入要求資料的 <see cref="T:System.IO.Stream" /> 物件。</summary>
        <returns>用來寫入要求資料的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法會傳回用來傳送資料資料流<xref:System.Net.HttpWebRequest>。 之後<xref:System.IO.Stream>在傳回物件，您可以使用傳送資料<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 如果應用程式需要的值設定<xref:System.Net.HttpWebRequest.ContentLength%2A>之前擷取的資料流，則必須完成屬性，則這。  
  
 您必須呼叫<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法來關閉資料流，並釋放以供重複使用的連接。 無法關閉資料流就會導致您的應用程式連線用完。  
  
> [!NOTE]
>  指派給值屬性取代任何現有的內容，當要求傳送HTTP 標頭。 這個屬性的值儲存在<xref:System.Net.HttpWebRequest.GetRequestStream%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法來傳回資料流執行個體。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> 屬性是 GET 或 HEAD。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法已多次呼叫。  -或-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">要求快取驗證程式指出，可以從快取處理此要求的回應；不過，寫入資料的要求絕對不能使用快取。 如果您使用實作自訂快取驗證程式不正確，便會發生這個例外狀況。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  此要求的逾時期限已過期。  -或-  處理這個要求時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">在 .NET Compact Framework 應用程式中，未取得且未正確關閉內容長度為零的要求資料流。 如需處理零內容長度要求的詳細資訊，請參閱 [.NET Compact Framework 中的網路程式設計] (https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx)。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Net.TransportContext" /> 的 <see cref="T:System.IO.Stream" />。</param>
        <summary>取得 <see cref="T:System.IO.Stream" /> 物件，此物件是用來寫入要求資料和輸出資料流相關聯的 <see cref="T:System.Net.TransportContext" />。</summary>
        <returns>用來寫入要求資料的 <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法會傳回用來傳送資料資料流<xref:System.Net.HttpWebRequest>，並將輸出<xref:System.Net.TransportContext>流相關聯。 之後<xref:System.IO.Stream>在傳回物件，您可以使用傳送資料<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 具有擴充保護使用整合式的 Windows 驗證的某些應用程式可能需要能夠查詢所使用的傳輸層<xref:System.Net.HttpWebRequest>以便擷取基礎 TLS 通道的通道繫結 token (CBT)。 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法提供有要求本文的 HTTP 方法對這項資訊存取 (`POST`和`PUT`要求)。 如果應用程式實作自己的驗證，而且需要存取 CBT 只需要這個動作。  
  
 如果應用程式需要的值設定<xref:System.Net.HttpWebRequest.ContentLength%2A>之前擷取的資料流，則必須完成屬性，則這。  
  
 您必須呼叫<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法來關閉資料流，並釋放以供重複使用的連接。 無法關閉資料流就會導致您的應用程式連線用完。  
  
> [!NOTE]
>  指派給值屬性取代任何現有的內容，當要求傳送HTTP 標頭。 這個屬性的值儲存在<xref:System.Net.HttpWebRequest.GetRequestStream%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法無法取得 <see cref="T:System.IO.Stream" />。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法已多次呼叫。  -或-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">要求快取驗證程式指出，可以從快取處理此要求的回應；不過，寫入資料的要求絕對不能使用快取。 如果您使用未正確實作的自訂快取驗證程式，便會發生這個例外狀況。</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> 屬性是 GET 或 HEAD。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  此要求的逾時期限已過期。  -或-  處理這個要求時發生錯誤。</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回來自網際網路資源的回應。</summary>
        <returns>包含來自網際網路資源回應的 <see cref="T:System.Net.WebResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A>方法會傳回<xref:System.Net.WebResponse>物件，其中包含來自網際網路資源的回應。 實際的執行個體傳回為<xref:System.Net.HttpWebResponse>，並可以而該類別來存取 HTTP 特定屬性。  
  
 A <xref:System.Net.ProtocolViolationException> ，其中包含與此要求相關聯的 cookie。 <xref:System.Net.HttpWebRequest.ContentLength%2A>屬性提供的執行個體<xref:System.Net.HttpWebRequest.SendChunked%2A>類別，其中包含與此要求相關聯的 cookie。 是預設。 您必須指派<xref:System.Net.HttpWebRequest.ContentLength%2A>物件屬性中傳回的 cookie<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性`false`傳回<xref:System.Net.HttpWebRequest.KeepAlive%2A>方法。`.`  
  
> [!CAUTION]
>  您必須呼叫<xref:System.Net.HttpWebResponse.Close%2A>方法來關閉資料流，並釋放連接。 這樣可能會導致您的應用程式連線用完。  
  
 使用 POST 方法時，您必須取得要求資料流、 寫入資料發佈，和關閉資料流。 這個方法會封鎖，等待回傳; 的內容如果沒有逾時設定，而且您未提供內容，則呼叫執行緒會封鎖無限期。  
  
> [!NOTE]
>  多個呼叫<xref:System.Net.HttpWebRequest.GetResponse%2A>傳回相同的回應物件; 不會重新發出要求。  
  
> [!NOTE]
>  指派給值屬性取代任何現有的內容，當要求傳送HTTP 標頭。 這個屬性的值儲存在<xref:System.Net.HttpWebRequest.GetRequestStream%2A>。  
  
> [!NOTE]
>  如果<xref:System.Net.WebException>會擲回，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>屬性來判斷伺服器的回應例外狀況。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  基於安全性理由，預設會停用 cookie。 如果您想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>屬性來啟用 cookie。  
  
   
  
## Examples  
 下列程式碼範例將取得要求的回應。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">資料流已經由先前對 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 的呼叫所使用。  -或-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值，且 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />。</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> 是 GET 或 HEAD，而且若不是 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大於等於零，就是 <see cref="P:System.Net.HttpWebRequest.SendChunked" /> 為 <see langword="true" />。  -或-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> 是 <see langword="true" />，<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> 是 <see langword="false" />，<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 為 -1，<see cref="P:System.Net.HttpWebRequest.SendChunked" /> 是 <see langword="false" />，且 <see cref="P:System.Net.HttpWebRequest.Method" /> 為 POST 或 PUT。  -或-  <see cref="T:System.Net.HttpWebRequest" /> 具有實體主體，但 <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 方法在沒有呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法的情況下呼叫。  -或-  <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 大於零，但該應用程式不會寫入所有承諾的資料。</exception>
        <exception cref="T:System.NotSupportedException">要求快取驗證程式指出，此要求的回應可以由快取服務；不過，此要求包含要傳送到此伺服器的資料。 傳送資料的要求不得使用此快取。 如果您使用不正確實作的自訂快取驗證程式，便會發生這個例外狀況。</exception>
        <exception cref="T:System.Net.WebException">之前已呼叫過 <see cref="M:System.Net.HttpWebRequest.Abort" />。  -或-  此要求的逾時期限已過期。  -或-  處理這個要求時發生錯誤。</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否已經接收到來自網際網路資源的回應。</summary>
        <value>如果已經接收到回應，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會檢查<xref:System.Net.HttpWebRequest.HaveResponse%2A>屬性來判斷是否已從網際網路資源接收的回應。  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定組成 HTTP 標頭的名稱/值組集合。</summary>
        <value><see cref="T:System.Net.WebHeaderCollection" />，包含組成 HTTP 要求標頭的名稱/值組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A>集合包含與要求相關聯的通訊協定標頭。 下表列出的 HTTP 標頭不會儲存在<xref:System.Net.HttpWebRequest.Headers%2A>集合，而是由系統設定或設定屬性或方法。  
  
|頁首|設定|  
|------------|------------|  
|接受|設定<xref:System.Net.HttpWebRequest.Accept%2A>屬性。|  
|連線|設定<xref:System.Net.HttpWebRequest.Connection%2A>屬性和<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性。|  
|內容長度|設定<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性。|  
|Content-Type|設定<xref:System.Net.HttpWebRequest.ContentType%2A>屬性。|  
|預期|設定<xref:System.Net.HttpWebRequest.Expect%2A>屬性。|  
|日期|設定<xref:System.Net.HttpWebRequest.Date%2A>屬性。|  
|主機|設定<xref:System.Net.HttpWebRequest.Host%2A>屬性。|  
|如果修改自|設定<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性。|  
|範圍|設定<xref:System.Net.HttpWebRequest.AddRange%2A>方法。|  
|推薦者|設定<xref:System.Net.HttpWebRequest.Referer%2A>屬性。|  
|傳輸編碼|設定<xref:System.Net.HttpWebRequest.TransferEncoding%2A>屬性 (<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性必須為 true)。|  
|使用者代理程式|設定<xref:System.Net.HttpWebRequest.UserAgent%2A>屬性。|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A>方法會擲回<xref:System.ArgumentException>如果您嘗試設定其中一個這些受保護的標頭。  
  
 變更<xref:System.Net.HttpWebRequest.Headers%2A>屬性之後要求已藉由呼叫<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法會擲回<xref:System.InvalidOperationException>。  
  
 您不應該假設的標頭值會維持不變，因為 Web 伺服器和快取可能會變更或加入至 Web 要求的標頭。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.Headers%2A>屬性列印到主控台的 HTTP 標頭名稱/值組。  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要求已藉由呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法啟動。</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Host 標頭值，此標頭可用於獨立於要求 URI 的 HTTP 要求中。</summary>
        <value>HTTP 要求中的 Host 標頭值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A>屬性可以用來設定主機標頭值可用於獨立於要求 URI 的 HTTP 要求中。 <xref:System.Net.HttpWebRequest.Host%2A>屬性可包含主機名稱和選擇性的連接埠號碼。 如果沒有連接埠資訊的主機標頭表示要求的服務 （連接埠 80 的 HTTP URL，例如） 的預設通訊埠。  
  
 指定主機和連接埠的格式必須遵循 IETF 所發行的 RFC2616 14.23 區段中的規則。 指定的通訊埠 8080 的使用範例符合這些需求會為下列值<xref:System.Net.HttpWebRequest.Host%2A>屬性：  
  
 `www.contoso.com:8080`  
  
 使用<xref:System.Net.HttpWebRequest.Host%2A>屬性來明確指定自訂主機標頭值也會影響快取的區域、 cookie 和驗證。 當應用程式特定的 URI 前置詞中提供認證時，應用程式需要請務必使用包含值的主機標頭，而不是在 URI 中的目標伺服器的 URI。 主機標頭值，而不是在要求 URI，則會使用快取資源時所用的索引鍵。 Cookie 會儲存在<xref:System.Net.CookieContainer>與邏輯上群組伺服器的網域名稱。 如果應用程式指定主機標頭，則會使用此值做為網域。  
  
 如果<xref:System.Net.HttpWebRequest.Host%2A>屬性未設定，然後在要求 URI 為基礎的 HTTP 要求中要使用的主機標頭值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">主機標頭不能設定為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">主機標頭無法設定為無效值。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.HttpWebRequest" /> 啟動待傳送之後，不能設定主機標頭。</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="If-Modified-Since" /> HTTP 標頭的值。</summary>
        <value><see cref="T:System.DateTime" />，包含 <see langword="If-Modified-Since" /> HTTP 標頭的內容。 預設值為目前的日期和時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性是一種標準<xref:System.DateTime?displayProperty=nameWithType>物件，並可以包含<xref:System.DateTimeKind?displayProperty=nameWithType>欄位<xref:System.DateTimeKind.Local?displayProperty=nameWithType>， <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 使用時，就可以設定任何一種時間<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性。 如果<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>設定或擷取，<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>假設屬性為<xref:System.DateTimeKind.Local?displayProperty=nameWithType>（本地時間）。  
  
 中的類別<xref:System.Net>命名空間永遠寫出<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>使用 GMT (Utc) 格式的標準表單中的傳輸期間的網路上的屬性。  
  
 如果<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性設定為<xref:System.DateTime.MinValue?displayProperty=nameWithType>，然後在`If-Modified-Since`HTTP 標頭移除<xref:System.Net.HttpWebRequest.Headers%2A>屬性和<xref:System.Net.WebHeaderCollection>。  
  
 如果<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性是<xref:System.DateTime.MinValue?displayProperty=nameWithType>，這表示`If-Modified-Since`HTTP 標頭未包含在<xref:System.Net.HttpWebRequest.Headers%2A>屬性和<xref:System.Net.WebHeaderCollection>。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例會檢查<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要與網際網路資源建立持續連線。</summary>
        <value>如果對網際網路資源的要求應該包含具有值 Keep-alive 的 <see langword="true" /> HTTP 標頭，則為 <see langword="Connection" />；<see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將此屬性設定為`true`傳送`Connection`具有值 keep-alive 的 HTTP 標頭。 應用程式使用<xref:System.Net.HttpWebRequest.KeepAlive%2A>可指出持續連線喜好設定。 當<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性是`true`，應用程式會持續連線到支援它們的伺服器。  
  
> [!NOTE]
>  當使用 HTTP/1.1，保持預設為開啟。 設定<xref:System.Net.HttpWebRequest.KeepAlive%2A>至`false`可能會導致傳送`Connection: Close`到伺服器的標頭。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性`false`以避免建立持續連線與網際網路資源。  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求追蹤的最大重新導向數目。</summary>
        <value>要求追蹤的最大重新導向回應數目。 預設值為 50。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>屬性會設定為遵循如果要求的重新導向次數上限<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>屬性是`true`。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性的值。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">此值設定為 0 或更小的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定回應標頭的最大允許長度。</summary>
        <value>回應標頭的長度，以 KB (1024 位元組) 為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 回應標頭的長度包含回應狀態行和任何收到的 HTTP 通訊協定的一部分的額外控制字元。 值為-1 表示沒有限制的回應標頭;值為 0 表示所有要求會都失敗。  
  
 如果<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>未明確設定屬性，則預設值為<xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A>屬性。  
  
 如果收到的回應標頭的長度超過值<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>屬性，<xref:System.Net.HttpWebRequest.EndGetResponse%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>方法會擲回<xref:System.Net.WebException>與<xref:System.Net.WebException.Status%2A>屬性設定為<xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性的值。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此屬性已在送出要求後設定。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值小於零且不等於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的媒體類型。</summary>
        <value>要求的媒體類型。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Net.HttpWebRequest.MediaType%2A>屬性會影響<xref:System.Net.HttpWebResponse.CharacterSet%2A>屬性。 當您將<xref:System.Net.HttpWebRequest.MediaType%2A>在要求中，對應的媒體類型從回應中傳回的字集的清單中選擇`Content-type`HTTP 標頭。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的方法。</summary>
        <value>用來連繫網際網路資源的要求方法。 預設值為 GET。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A>屬性可以設定為任何 HTTP 1.1 通訊協定動詞命令： GET、 HEAD、 POST、 PUT、 刪除，TRACE 或選項。  
  
 如果<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性設定為-1，以外的任何值<xref:System.Net.HttpWebRequest.Method%2A>屬性必須設定為上傳資料通訊協定屬性。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.Method%2A>POST 的屬性。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未提供任何方法。  -或-  方法字串含有無效字元。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否將要求導送至網際網路資源。</summary>
        <value>如果要求應該要導送，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式使用<xref:System.Net.HttpWebRequest.Pipelined%2A>可指出以管線連接喜好設定的屬性。 當<xref:System.Net.HttpWebRequest.Pipelined%2A>是`true`，應用程式建立的伺服器上支援這些以管線的連接。  
  
 以管線的連接時，才進行<xref:System.Net.HttpWebRequest.KeepAlive%2A>屬性也是`true`。  
  
   
  
## Examples  
 下列程式碼範例會列印值<xref:System.Net.HttpWebRequest.Pipelined%2A>屬性至主控台。  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否隨著要求傳送驗證標頭。</summary>
        <value><see langword="true" /> 表示在進行驗證後隨同要求傳送 HTTP 驗證標頭，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在特定的用戶端要求之後<xref:System.Uri>驗證成功，如果<xref:System.Net.HttpWebRequest.PreAuthenticate%2A>是`true`並提供認證，與每個要求傳送授權標頭至任何<xref:System.Uri>符合特定<xref:System.Uri>到最後一個斜線。 因此，如果用戶端要求已成功驗證特定<xref:System.Uri>，其中包含下列：  
  
 `http://www.contoso.com/firstpath/`  
  
 然後進行預先驗證的授權標頭與每個要求傳送至下列任一<xref:System.Uri>執行個體：  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 不過，授權標頭不會傳送要求到下列任何一個<xref:System.Uri>執行個體：  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 如果用戶端要求在特定<xref:System.Uri>是驗證不成功，要求會使用標準驗證程序。  
  
 第一個要求中，除了<xref:System.Net.WebRequest.PreAuthenticate%2A>屬性會指出是否要傳送的後續要求使用的驗證資訊<xref:System.Uri>符合特定<xref:System.Uri>到而不想要等到最後一個斜線伺服器挑戰。  
  
 用戶端與伺服器之間的下列對話方塊說明這個屬性的效果。 對話方塊會假設該基本驗證是使用中。  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 是`false`:  
  
 用戶端： GET someUrl  
  
 伺服器： 401 Www-authenticate Basic  
  
 取得與授權標頭的用戶端：  
  
 伺服器： 200 [確定]  
  
 用戶端： GET someUrl  
  
 伺服器： 401 Www-authenticate Basic  
  
 取得與授權標頭的用戶端：  
  
 伺服器： 200 [確定]  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 是`true`:  
  
 用戶端： GET someUrl  
  
 伺服器： 401 Www-authenticate Basic  
  
 取得與授權標頭的用戶端：  
  
 伺服器： 200 [確定]  
  
 用戶端： 取得 someUrl 與授權標頭  
  
 如果不支援預先驗證的驗證配置，則會忽略這個屬性的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求所使用的 HTTP 版本。</summary>
        <value>要求所使用的 HTTP 版本。 預設值為 <see cref="F:System.Net.HttpVersion.Version11" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest>類別支援只有版本 1.0 和 1.1 版的 HTTP。 設定<xref:System.Net.HttpWebRequest.ProtocolVersion%2A>到另一個版本就會擲回例外狀況。  
  
> [!NOTE]
>  若要設定的目前要求的 HTTP 版本，請使用<xref:System.Net.HttpVersion.Version10>和<xref:System.Net.HttpVersion.Version11>欄位<xref:System.Net.HttpVersion>類別。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.ProtocolVersion%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">HTTP 版本設定為 1.0 或 1.1 以外的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的 Proxy 資訊。</summary>
        <value><see cref="T:System.Net.IWebProxy" /> 物件，用來代理 (Proxy) 要求。 呼叫 <see cref="P:System.Net.GlobalProxySelection.Select" /> 屬性可以設定預設值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A>屬性會識別<xref:System.Net.WebProxy>物件用來處理對網際網路資源要求。 指定應沒有任何 proxy，請設定<xref:System.Net.HttpWebRequest.Proxy%2A>proxy 執行個體所傳回的屬性<xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType>方法。  
  
 在本機電腦或應用程式組態檔，可以指定使用預設 proxy。 如果<xref:System.Net.HttpWebRequest.Proxy%2A>指定屬性，然後從的 proxy 設定<xref:System.Net.HttpWebRequest.Proxy%2A>屬性覆寫在本機電腦或應用程式組態檔和<xref:System.Net.HttpWebRequest>執行個體會使用指定的 proxy 設定。 如果沒有任何 proxy 在組態檔中指定了和<xref:System.Net.HttpWebRequest.Proxy%2A>屬性並未指定，<xref:System.Net.HttpWebRequest>類別會使用繼承自 Internet Explorer，在本機電腦上的 proxy 設定。 如果沒有在 Internet Explorer proxy 設定，會將要求傳送到伺服器。  
  
 <xref:System.Net.HttpWebRequest>類別剖析包含萬用字元的 proxy 略過清單繼承自 Internet Explorer 相同時略過清單會剖析直接由 Internet Explorer。 例如，<xref:System.Net.HttpWebRequest>類別將會剖析的"nt *"與 Internet Explorer 略過清單做為規則運算式的 「 nt。\*"。 因此的 URL"`http://nt.com`」 會略過 proxy 使用<xref:System.Net.HttpWebRequest>類別和使用 Internet Explorer。  
  
 <xref:System.Net.HttpWebRequest>類別支援本機 proxy 略過。 類別會考量目的地是本機如果符合下列任何一個狀況：  
  
-   目的地中含有一般名稱 （在 URL 中沒有點）。  
  
-   目的地包含回送位址 (<xref:System.Net.IPAddress.Loopback>或<xref:System.Net.IPAddress.IPv6Loopback>) 或目的地包含<xref:System.Net.IPAddress>指派給本機電腦。  
  
-   目的地的網域尾碼符合本機電腦的網域尾碼 (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>)。  
  
 <xref:System.Net.HttpWebRequest.Proxy%2A>屬性是一種標準<xref:System.Net.HttpWebRequest.GetRequestStream%2A>物件，並可以包含<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>欄位<xref:System.Net.HttpWebRequest.GetResponse%2A>， <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>，或<xref:System.InvalidOperationException>。 Proxy 項目上的資訊，請參閱[ \&lt; defaultProxy\&gt;項目 （網路設定）](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpWebRequest.Proxy%2A>方法來取得要求的 proxy 資訊。  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.HttpWebRequest.Proxy" /> 設定為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">要求已經藉由呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 啟動。</exception>
        <exception cref="T:System.Security.SecurityException">此呼叫端沒有要求的作業之權限。</exception>
        <permission cref="T:System.Net.WebPermission">取得或設定<see cref="P:System.Net.HttpWebRequest.Proxy" />屬性。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定寫入或讀取資料流時的逾時 (以毫秒為單位)。</summary>
        <value>寫入或讀取逾時前的毫秒數。預設值為 300,000 毫秒 (5 分鐘)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>屬性寫入至所傳回的資料流時使用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法或從傳回的資料流讀取<xref:System.Net.HttpWebResponse.GetResponseStream%2A>方法。  
  
 具體來說，<xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>屬性控制的逾時值<xref:System.IO.Stream.Read%2A>方法，用來讀取傳回之資料流<xref:System.Net.HttpWebResponse.GetResponseStream%2A>方法，以及<xref:System.IO.Stream.Write%2A>方法，用來寫入資料流傳回<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法。  
  
 若要指定要完成之要求的等待時間，請使用<xref:System.Net.HttpWebRequest.Timeout%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會示範如何設定 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 屬性。  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已傳送此要求。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定給設定作業的值小於或等於零，並且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Referer" /> HTTP 標頭的值。</summary>
        <value><see langword="Referer" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>屬性是`true`、<xref:System.Net.HttpWebRequest.Referer%2A>要求重新導向至其他站台時自動設定屬性。  
  
 若要清除`Referer`設定 HTTP 標頭，<xref:System.Net.HttpWebRequest.Referer%2A>屬性`null`。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.Referer%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求的原始統一資源識別元 (URI)。</summary>
        <value><see cref="T:System.Uri" />，包含傳遞到 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 方法的網際網路資源 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri>物件傳遞至<xref:System.Net.HttpWebRequest>的呼叫所<xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>。  
  
 遵循重新導向標頭不會變更<xref:System.Net.HttpWebRequest.RequestUri%2A>屬性。 若要取得實際回應要求的 URI，檢查<xref:System.Net.HttpWebRequest.Address%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會檢查是否<xref:System.Net.HttpWebRequest>物件`req`已重新導向至另一個位置來完成要求，並將值設定`hasChanged`變數設為`true`如果要求重新導向，否則`hasChanged`設`false`。  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要分區段傳送資料至網際網路資源。</summary>
        <value>若要分區段傳送資料至網際網路資源，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Net.HttpWebRequest.SendChunked%2A>是`true`，要求將資料傳送至網際網路資源區段中。 網際網路資源必須支援接收區塊的資料。  
  
 <xref:System.Net.HttpWebRequest.SendChunked%2A>屬性是一種標準<xref:System.Net.HttpWebRequest.GetRequestStream%2A>物件，並可以包含<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>欄位<xref:System.Net.HttpWebRequest.GetResponse%2A>， <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>，或<xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性`true`以便可將資料傳送至網際網路資源的區段中。  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要求已藉由呼叫 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />、<see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />、<see cref="M:System.Net.HttpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 方法啟動。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來驗證伺服器憑證的回呼函式。</summary>
        <value>用來驗證伺服器憑證的回呼函式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設值是沒有回呼函式，設定和<xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A>屬性是`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求所使用的服務點。</summary>
        <value><see cref="T:System.Net.ServicePoint" />，表示網際網路資源的網路連線。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType>屬性可能會與不同<xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType>如果將要求重新導向。  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出要求是否提供對 <see cref="T:System.Net.CookieContainer" /> 的支援。</summary>
        <value><see langword="true" /> 如果要求提供的支援<see cref="T:System.Net.CookieContainer" />，否則<see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">要以資料填入的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="streamingContext"><see cref="T:System.Runtime.Serialization.StreamingContext" />，指定這個序列化的目的地。</param>
        <summary>將序列化目標物件所需的資料填入 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中所包含的任何物件<xref:System.Runtime.Serialization.SerializationInfo>自動追蹤和序列化格式子。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 和 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 方法的逾時值 (以毫秒為單位)。</summary>
        <value>等待要求逾時之前的毫秒數。預設值為 100,000 毫秒 (100 秒)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 會提出後續的同步要求的毫秒數<xref:System.Net.HttpWebRequest.GetResponse%2A>方法等候回應，而<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法會等候資料流。 <xref:System.Net.HttpWebRequest.Timeout%2A>適用於整個要求和回應時，無法個別<xref:System.Net.HttpWebRequest.GetRequestStream%2A>和<xref:System.Net.HttpWebRequest.GetResponse%2A>方法呼叫。 如果資源不會逾時期間內傳回，要求會擲回<xref:System.Net.WebException>與<xref:System.Net.WebException.Status%2A>屬性設定為<xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>。  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A>之前必須先設定屬性<xref:System.Net.HttpWebRequest.GetRequestStream%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>方法呼叫。 變更<xref:System.Net.HttpWebRequest.Timeout%2A>屬性之後呼叫<xref:System.Net.HttpWebRequest.GetRequestStream%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>方法沒有任何作用  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A>屬性具有不會影響以提出的非同步要求<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>或<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法。  
  
> [!CAUTION]
>  如果非同步要求，是用戶端應用程式會實作其本身的逾時機制。 中的範例，請參閱<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法。  
  
 若要指定等待讀取或寫入作業逾時的時間量，使用<xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>屬性。  
  
 最多為 15 秒才傳回或逾時，可能需要網域名稱系統 (DNS) 查詢。如果您的要求包含需要解析主機名稱，而且設定<xref:System.Net.FileWebRequest.Timeout%2A>的值小於 15 秒，可能需要 15 秒以上才能<xref:System.Net.WebException>就會擲回，表示您的要求逾時。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.Timeout%2A>屬性<xref:System.Net.HttpWebRequest>物件。  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的值小於零，而且不是 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="Transfer-encoding" /> HTTP 標頭的值。</summary>
        <value><see langword="Transfer-encoding" /> HTTP 標頭的值。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然後您才能設定<xref:System.Net.HttpWebRequest.TransferEncoding%2A>屬性，您必須先設定<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性`true`。 清除<xref:System.Net.HttpWebRequest.TransferEncoding%2A>設定為`null`的值不影響<xref:System.Net.HttpWebRequest.SendChunked%2A>。  
  
 指派給值<xref:System.Net.HttpWebRequest.TransferEncoding%2A>屬性取代任何現有的內容。  
  
> [!NOTE]
>  這個屬性的值儲存在 <xref:System.Net.WebHeaderCollection> 中。 如果有設定 WebHeaderCollection，將會遺失屬性值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">當 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 為 <see langword="false" /> 時，會設定 <see cref="P:System.Net.HttpWebRequest.SendChunked" />。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> 設定為值「Chunked」。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否允許高速 NTLM 驗證連接共用。</summary>
        <value>保持已驗證連接於開啟的狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的預設值是`false`，因而導致的要求完成之後關閉目前的連接。 您的應用程式必須經過驗證順序，每一次，就會發出新的要求。  
  
 如果這個屬性設定為`true`，在執行驗證之後用來擷取回應的連接仍為開啟。 在此情況下，其他要求，將此屬性設定為`true`可能使用的連接，而不需重新驗證。 換句話說，如果使用者已經過驗證的連接，使用者 B 可能重複使用的連接。根據使用者 a 的認證可滿足使用者 B 的要求  
  
> [!CAUTION]
>  由於應用程式使用未經驗證的連接，您必須確定沒有系統管理的弱點可能會在您的系統時將此屬性設定為`true`。 如果您的應用程式將要求傳送多個使用者 （會模擬多個使用者帳戶） 需要驗證來保護資源，請勿將這個屬性設`true`除非您使用連線群組，如下所述。  
  
 您可能要考慮啟用這項機制，如果您有效能問題，並使用整合式 Windows 驗證的 Web 伺服器上執行應用程式。  
  
 啟用此設定會使系統的安全性風險。 如果您設定<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>屬性`true`務必採取下列預防措施：  
  
-   使用<xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>屬性，管理不同使用者的連線。 這可避免未經驗證的應用程式可能使用的連接。 例如，使用者 A 應該有唯一的連接群組名稱不同於使用者 b。這提供每個使用者帳戶的隔離的層。  
  
-   為了避免可能的連接利用受保護的環境中執行應用程式。  
  
 如果您要控制後端伺服器，或者您可以考慮關閉驗證持續性機制。 這會增加效能，以刻度更小，但是比較安全。 如需詳細資訊，搜尋在 MSDN library 中的 AuthPersistence [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)。  
  
> [!NOTE]
>  如果兩個<xref:System.Net.WebRequest.PreAuthenticate%2A>和<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>設為`true`，每個要求會傳送來自不安全的集區，但具有 Authorization 標頭使用的連接。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">不受限制的 Web 權限，才能設定這個屬性。</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，控制是否隨著要求傳送預設認證。</summary>
        <value>如果使用預設認證，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將此屬性設定為`true`當要求所做的變更<xref:System.Net.HttpWebRequest>物件應該如果伺服器要求進行驗證使用目前登入使用者的認證。 用戶端應用程式，這是所要的行為，在大部分情況下。 對於中介層應用程式，例如 ASP.NET 應用程式，而不是使用這個屬性，您需要設定<xref:System.Net.HttpWebRequest.Credentials%2A>代表其提出要求的用戶端認證的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您嘗試在送出要求之後設定這個屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="User-agent" /> HTTP 標頭的值。</summary>
        <value><see langword="User-agent" /> HTTP 標頭的值。 預設值是 <see langword="null" />。  
  
 <block subset="none" type="note"><para> 這個屬性的值儲存在<see cref="T:System.Net.WebHeaderCollection" />。如果 webheadercollection，將屬性值將會遺失。  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.HttpWebRequest.UserAgent%2A>屬性。  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>