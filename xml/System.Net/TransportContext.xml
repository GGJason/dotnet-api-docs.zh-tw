<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TransportContext.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac578cee78fbf0e0bca41c4d5a9c54a8f864293ed2f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">78cee78fbf0e0bca41c4d5a9c54a8f864293ed2f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.TransportContext">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.TransportContext" /&gt;</ph> class provides additional context about the underlying transport layer.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.TransportContext" /&gt;</ph> 類別，提供有關基礎傳輸層的其他內容。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>The <ph id="ph1">&lt;xref:System.Net.TransportContext&gt;</ph> class is used with classes in the <ph id="ph2">&lt;xref:System.Security.Authentication.ExtendedProtection&gt;</ph> namespace to provide support for authentication using extended protection for applications.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.TransportContext&gt;</ph>類別中的類別一起用<ph id="ph2">&lt;xref:System.Security.Authentication.ExtendedProtection&gt;</ph>命名空間提供支援驗證擴充保護的應用程式。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>The design of integrated Windows authentication allows for some credential challenge responses to be universal, meaning they can be re-used or forwarded.</source>
          <target state="translated">整合式 Windows 驗證的設計可讓某些認證的挑戰回應成為通用的，這表示可以重複使用或轉寄它們。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>If this particular design feature is not needed then the challenge responses should be constructed with, at minimum, target specific information and, at best, also some channel specific information.</source>
          <target state="translated">如果不需要此特定的設計功能的挑戰回應必須是所建構，最小值，目標的特定資訊，然後，在最佳情況下也某些通道的特定資訊。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>Services can then provide extended protection to ensure that credential challenge responses contain service specific information (a Service Provider Name or SPN) and, if necessary, channel specific information (a channel binding token or CBT).</source>
          <target state="translated">服務隨後即可提供延伸的保護，以確保認證挑戰回應會包含服務特有資訊 （服務提供者名稱或 SPN），並，必要時，通道特定資訊 （通道繫結 token 或 CBT）。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>With this information in the credential exchanges, services are able to better protect against malicious use of credential challenge responses that might have been improperly obtained.</source>
          <target state="translated">利用此資訊的認證交換中，服務就能進一步保護惡意使用的認證可能未正確取得的挑戰回應。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source><ph id="ph1">&lt;xref:System.Net.HttpWebRequest&gt;</ph> is the only class derived from <ph id="ph2">&lt;xref:System.Net.WebRequest&gt;</ph> class that can potentially use IWA.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.HttpWebRequest&gt;</ph> 只有類別衍生自<ph id="ph2">&lt;xref:System.Net.WebRequest&gt;</ph>可能可以使用 IWA 的類別。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>The <ph id="ph1">&lt;xref:System.Net.FtpWebRequest&gt;</ph> class does only FTP clear text authentication.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.FtpWebRequest&gt;</ph>類別沒有唯一的 FTP 純文字驗證。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>The <ph id="ph1">&lt;xref:System.Net.FileWebRequest&gt;</ph> class doesn't perform any authentication.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.FileWebRequest&gt;</ph>類別不會執行任何驗證。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>There are several ways an application may get a <ph id="ph1">&lt;xref:System.Net.TransportContext&gt;</ph> instance.</source>
          <target state="translated">有數種方式，應用程式可能會收到<ph id="ph1">&lt;xref:System.Net.TransportContext&gt;</ph>執行個體。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>An application that uses <ph id="ph1">&lt;xref:System.Net.Security.SslStream&gt;</ph> can get the <ph id="ph2">&lt;xref:System.Net.TransportContext&gt;</ph> using the <ph id="ph3">&lt;xref:System.Net.Security.SslStream.TransportContext%2A&gt;</ph> property.</source>
          <target state="translated">使用的應用程式<ph id="ph1">&lt;xref:System.Net.Security.SslStream&gt;</ph>可以取得<ph id="ph2">&lt;xref:System.Net.TransportContext&gt;</ph>使用<ph id="ph3">&lt;xref:System.Net.Security.SslStream.TransportContext%2A&gt;</ph>屬性。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.TransportContext">
          <source>An application that uses <ph id="ph1">&lt;xref:System.Net.HttpWebRequest&gt;</ph> can get a <ph id="ph2">&lt;xref:System.Net.TransportContext&gt;</ph> using the <ph id="ph3">&lt;xref:System.Net.HttpWebRequest.GetRequestStream%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Net.HttpWebRequest.EndGetRequestStream%2A&gt;</ph> methods.</source>
          <target state="translated">使用的應用程式<ph id="ph1">&lt;xref:System.Net.HttpWebRequest&gt;</ph>可以取得<ph id="ph2">&lt;xref:System.Net.TransportContext&gt;</ph>使用<ph id="ph3">&lt;xref:System.Net.HttpWebRequest.GetRequestStream%2A&gt;</ph>或<ph id="ph4">&lt;xref:System.Net.HttpWebRequest.EndGetRequestStream%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Net.TransportContext.#ctor">
          <source>Creates a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.TransportContext" /&gt;</ph> class</source>
          <target state="translated">建立 <ph id="ph1">&lt;see cref="T:System.Net.TransportContext" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)">
          <source>The type of channel binding to retrieve.</source>
          <target state="translated">要擷取之通道繫結的型別。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)">
          <source>Retrieves the requested channel binding.</source>
          <target state="translated">擷取要求的通道繫結。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the channel binding is not supported by the current transport or by the operating system.</source>
          <target state="translated">要求的 <ph id="ph1">&lt;see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /&gt;</ph>，如果目前的傳輸或作業系統不支援通道繫結，則為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)">
          <source>The possible values for the <ph id="ph1">`kind`</ph> parameter are <ph id="ph2">&lt;xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint&gt;</ph> or <ph id="ph3">&lt;xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Unique&gt;</ph>.</source>
          <target state="translated">可能值<ph id="ph1">`kind`</ph>參數<ph id="ph2">&lt;xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint&gt;</ph>或<ph id="ph3">&lt;xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Unique&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)">
          <source>If an application attempts to retrieve the channel binding token (CBT) from the <ph id="ph1">&lt;xref:System.Net.HttpListenerRequest.TransportContext%2A&gt;</ph> property using the <ph id="ph2">&lt;xref:System.Net.TransportContext.GetChannelBinding%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind&gt;</ph> is not <ph id="ph4">&lt;xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint&gt;</ph>, then the <ph id="ph5">&lt;xref:System.Net.HttpListenerRequest&gt;</ph> will throw <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">如果應用程式嘗試擷取通道的繫結 token (CBT) 從<ph id="ph1">&lt;xref:System.Net.HttpListenerRequest.TransportContext%2A&gt;</ph>屬性使用<ph id="ph2">&lt;xref:System.Net.TransportContext.GetChannelBinding%2A&gt;</ph>方法和<ph id="ph3">&lt;xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind&gt;</ph>不<ph id="ph4">&lt;xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint&gt;</ph>，然後在<ph id="ph5">&lt;xref:System.Net.HttpListenerRequest&gt;</ph>將會擲回<ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)">
          <source>The <ph id="ph1">&lt;xref:System.Net.HttpListenerRequest&gt;</ph> overrides the <ph id="ph2">&lt;xref:System.Net.TransportContext.GetChannelBinding%2A&gt;</ph> method with an internal implementation</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.HttpListenerRequest&gt;</ph>會覆寫<ph id="ph2">&lt;xref:System.Net.TransportContext.GetChannelBinding%2A&gt;</ph>具有內部實作的方法</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)">
          <source><ph id="ph1">&lt;paramref name="kind" /&gt;</ph> is must be <ph id="ph2">&lt;see cref="F:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint" /&gt;</ph> for use with the <ph id="ph3">&lt;see cref="T:System.Net.TransportContext" /&gt;</ph> retrieved from the <ph id="ph4">&lt;see cref="P:System.Net.HttpListenerRequest.TransportContext" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="kind" /&gt;</ph> 必須是 <ph id="ph2">&lt;see cref="F:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint" /&gt;</ph> 以搭配擷取自 <ph id="ph3">&lt;see cref="T:System.Net.TransportContext" /&gt;</ph> 屬性的 <ph id="ph4">&lt;see cref="P:System.Net.HttpListenerRequest.TransportContext" /&gt;</ph> 使用。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Net.TransportContext.GetTlsTokenBindings">
          <source>Gets the transport security layer token bindings.</source>
          <target state="translated">取得傳輸安全性層級語彙基元繫結。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Net.TransportContext.GetTlsTokenBindings">
          <source>The transport security layer token bindings.</source>
          <target state="translated">傳輸安全性層級語彙基元繫結。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>