<Type Name="HttpListenerRequest" FullName="System.Net.HttpListenerRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76dca6c03fa9c47eb67a205952892b5fbc50e8a0" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683766" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListenerRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListenerRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListenerRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerRequest sealed" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>描述 <see cref="T:System.Net.HttpListener" /> 物件的連入 HTTP 要求。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當用戶端提出要求時統一資源識別元 (URI) 由<xref:System.Net.HttpListener>物件<xref:System.Net.HttpListener>提供<xref:System.Net.HttpListenerContext>物件，其中包含寄件者、 要求和回應已傳送至用戶端的相關資訊。 <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType>屬性會傳回<xref:System.Net.HttpListenerRequest>描述要求的物件。  
  
 <xref:System.Net.HttpListenerRequest>物件包含要求資訊，例如要求<xref:System.Net.HttpListenerRequest.HttpMethod%2A>字串<xref:System.Net.HttpListenerRequest.UserAgent%2A>字串，並要求本文資料 (請參閱<xref:System.Net.HttpListenerRequest.InputStream%2A>屬性)。  
  
 若要回覆的要求，您必須取得相關聯的回應使用<xref:System.Net.HttpListenerContext.Response%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何接收並回應程式<xref:System.Net.HttpListenerRequest>。  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.HttpListener" />
    <altmember cref="T:System.Net.HttpListenerContext" />
    <altmember cref="T:System.Net.HttpListenerResponse" />
  </Docs>
  <Members>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端接受的 MIME 類型。</summary>
        <value>
          <see cref="T:System.String" /> 陣列，包含要求的 <see langword="Accept" /> 標頭中所指定的類型名稱，如果用戶端要求沒有包含 <see langword="null" /> 標頭，則為 <see langword="Accept" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Accept`標頭是以空格分隔的多用途網際網路郵件延伸標準 (MIME) 類型名稱的字串 (例如， `image/jpeg`)，表示用戶端已準備好接受和處理在回應中的 MIME 類型。 `*/*`項目會指出用戶端會接受任何 MIME 類型。 如需詳細的說明`Accept`標頭，請參閱 RFC 2616，可在[ https://www.rfc-editor.org ](https://www.rfc-editor.org/)。  
  
 如需完整的要求標頭清單，請參閱<xref:System.Net.HttpRequestHeader>列舉型別。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetClientCertificate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetClientCertificate (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetClientCertificate(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetClientCertificate (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetClientCertificate(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義物件，包含作業的相關資訊。 作業完成時，這個物件會傳遞給回呼委派。</param>
        <summary>開始用戶端之 X.509 v.3 憑證的非同步要求。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，表示作業的狀態。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificateError">
      <MemberSignature Language="C#" Value="public int ClientCertificateError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ClientCertificateError" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ClientCertificateError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificateError As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ClientCertificateError { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得錯誤碼，識別用戶端所提供之 <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> 的問題。</summary>
        <value>
          <see cref="T:System.Int32" /> 值，包含 Windows 錯誤碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性會包含 Windows 錯誤的程式碼，傳回透過安全通道 (Schannel) 安全性支援提供者介面 (SSPI)，用來驗證憑證。 多個安全通道的 SSPI 支援的詳細資訊，請參閱 「 建立安全連線使用安全通道 」，在安全性文件中[ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)。  
  
   
  
## Examples  
 下列程式碼範例會檢查這個屬性來判斷要求是否包含有效的用戶端憑證。  
  
 [!code-csharp[NCLListener#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#3)]
 [!code-vb[NCLListener#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">用戶端憑證尚未透過呼叫 <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /> 或 <see cref="M:System.Net.HttpListenerRequest.GetClientCertificate" /> 方法初始化。  
  
 -或-  
  
 作業仍在進行。</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可用於隨要求所傳送之資料的內容編碼方式。</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> 物件，適用於 <see cref="P:System.Net.HttpListenerRequest.InputStream" /> 屬性中的資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding>物件可以用來將位元組序列轉換成字元集 （字碼頁） 和成位元組序列的字元。 這個屬性會使用的字元集值`Content-Type`標頭來判斷的編碼方式。 如果該資訊不是可用的則這個屬性會傳回<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.HttpListenerRequest.ContentEncoding%2A>屬性。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength64">
      <MemberSignature Language="C#" Value="public long ContentLength64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength64" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentLength64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentLength64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求中所包含之主體資料的長度。</summary>
        <value>要求之 <see langword="Content-Length" /> 標頭的值。 如果內容長度未知，則這個值是 -1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Content-Length`標頭表示隨附於要求主體資料的長度，單位為位元組。  
  
 如需完整的要求標頭清單，請參閱<xref:System.Net.HttpRequestHeader>列舉型別。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.HttpListenerRequest.ContentLength64%2A>處理本文資料時的屬性。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求中所包含之主體資料的 MIME 類型。</summary>
        <value>
          <see cref="T:System.String" />，包含要求之 <see langword="Content-Type" /> 標頭的文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果用戶端在要求中包含內容資料，它會宣告中的主體資料的多用途網際網路郵件延伸標準 (MIME) 類型`Content-Type`標頭。 例如，資料的預設 MIME 類型傳回 Web 表單使用`POST`方法`application/x-www-form-urlencoded`。  
  
 如需完整的要求標頭清單，請參閱<xref:System.Net.HttpRequestHeader>列舉型別和 RFC 2616，可在[ https://www.rfc-editor.org ](https://www.rfc-editor.org/)。  
  
 <xref:System.Net.HttpListenerRequest.ContentType%2A>為 null 時沒有任何`Content-Type`要求標頭。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Net.CookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As CookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieCollection ^ Cookies { System::Net::CookieCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得隨要求傳送的 Cookie。</summary>
        <value>
          <see cref="T:System.Net.CookieCollection" />，包含要求所隨附的 Cookie。 如果要求沒有包含 Cookie，則這個屬性會傳回空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cookie 是儲存在本機 （用戶端） 電腦的網頁伺服器名稱/值的文字資料。  
  
   
  
## Examples  
 下列程式碼範例會顯示與要求送出的 cookie 值。  
  
 [!code-csharp[Net_Listener_Basic#18](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="EndGetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.EndGetClientCertificate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetClientCertificate (asyncResult As IAsyncResult) As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ EndGetClientCertificate(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">憑證的暫止要求。</param>
        <summary>結束用戶端之 X.509 v.3 憑證的非同步要求。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，作業啟動時所傳回。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          未呼叫 <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /><paramref name="e." /> 來取得 <paramref name="asyncResult" /></exception>
        <exception cref="T:System.InvalidOperationException">已針對 <paramref name="asyncResult" /> 所識別的作業，呼叫這個方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificate () As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ GetClientCertificate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取用戶端的 X.509 v.3 憑證。</summary>
        <returns>
          <see cref="N:System.Security.Cryptography.X509Certificates" /> 物件，包含用戶端的 X.509 v.3 憑證。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖直到擷取憑證。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">呼叫這個擷取用戶端 X.509 v.3 憑證的方法正在進行中，因此不可再次呼叫這個方法。</exception>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificateAsync () As Task(Of X509Certificate2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Security::Cryptography::X509Certificates::X509Certificate2 ^&gt; ^ GetClientCertificateAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步作業的方式，擷取用戶端的 X.509 v.3 憑證。</summary>
        <returns>傳回 <see cref="T:System.Threading.Tasks.Task`1" />。  
  
 工作物件，表示非同步作業。 工作物件上的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 屬性傳回包含用戶端之 X.509 v.3 憑證的 <see cref="N:System.Security.Cryptography.X509Certificates" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這項作業不會封鎖。 傳回<xref:System.Threading.Tasks.Task%601>物件將會完成時在擷取的憑證。  
  
 如果呼叫這個方法，以擷取用戶端的 X.509 v.3 憑證的正在進行中，無法建立另一個呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="HasEntityBody">
      <MemberSignature Language="C#" Value="public bool HasEntityBody { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEntityBody" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HasEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasEntityBody As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasEntityBody { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Boolean" /> 值，指出要求是否有關聯的主體資料。</summary>
        <value>
          如果要求有關聯的主體資料，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將資料傳送到伺服器時使用的要求`POST`方法，例如，應具有實體主體。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在要求中所傳送之標頭名稱/值組的集合。</summary>
        <value>
          <see cref="T:System.Net.WebHeaderCollection" />，含有要求中所包含的 HTTP 標頭。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求標頭包含中繼資料資訊。 例如，標頭可以包含參考用戶端到伺服器的資源統一資源識別元 (URI)，使用者代理程式的身分識別供用戶端，並可接受的 MIME 的回應主體中的資料類型。  
  
 如需完整的要求標頭清單，請參閱<xref:System.Net.HttpRequestHeader>列舉型別。  
  
   
  
## Examples  
 下列程式碼範例顯示中的所有資訊指定<xref:System.Net.WebHeaderCollection>物件。  
  
 [!code-csharp[Net_Listener_Basic#21](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#21)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端指定的 HTTP 方法。</summary>
        <value>
          <see cref="T:System.String" />，包含要求中使用的方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTTP 方法通常是 GET 或 POST，根據用戶端所需的動作。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含用戶端所傳送之主體資料的資料流。</summary>
        <value>可讀取的 <see cref="T:System.IO.Stream" /> 物件，包含用戶端在要求的主體中所傳送的位元組。 如果沒有資料隨要求傳送，則這個屬性會傳回 <see cref="F:System.IO.Stream.Null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果用戶端會將資料傳輸 (例如，使用 HTTP`POST`方法)，這個方法所傳回的資料流包含該資料。  
  
> [!NOTE]
>  關閉要求時，不會關閉這個屬性所傳回的資料流。 當您不再需要資料流時，您應該關閉它藉由呼叫<xref:System.IO.Stream.Close%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性來讀取與要求一起傳送的資料。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。</para>
        </block>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns false")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Boolean" /> 值，指出傳送這個要求的用戶端是否已經過驗證。</summary>
        <value>
          如果用戶端已驗證，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您的應用程式要求用戶端驗證使用<xref:System.Net.HttpListener.AuthenticationSchemes%2A>或<xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>屬性。  
  
 您的應用程式不會收到<xref:System.Net.HttpListenerContext>未成功驗證的用戶端要求。  
  
   
  
## Examples  
 下列程式碼範例顯示的值<xref:System.Net.HttpListenerRequest.IsAuthenticated%2A>屬性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Boolean" /> 值，指出要求是否從本機電腦送出。</summary>
        <value>
          如果要求和提供此要求的 <see cref="T:System.Net.HttpListener" /> 物件都來自相同的電腦，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行特殊處理，當要求來自本機電腦時，應用程式可以使用這個屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.HttpListenerRequest.IsLocal%2A>屬性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Boolean" /> 值，指出用來傳送要求的 TCP 連線是否使用 Secure Sockets Layer (SSL) 通訊協定。</summary>
        <value>
          如果 TCP 連線使用 SSL，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要要求安全連接，用戶端要求會使用<xref:System.Uri.UriSchemeHttps>而不是<xref:System.Uri.UriSchemeHttp>。 如果無法使用 SSL 建立的連線，用戶端收到<xref:System.Net.WebException>提供錯誤的相關資訊。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.HttpListenerRequest.IsSecureConnection%2A>屬性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Boolean" /> 值，指出 TCP 連接是否為 WebSocket 要求。</summary>
        <value>傳回 <see cref="T:System.Boolean" />。  
  
 如果 TCP 連接是 WebSocket 要求則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Boolean" /> 值，指出用戶端是否要求持續性連線。</summary>
        <value>
          如果連線應該保持開啟，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 HTTP 用戶端和伺服器預期在短時間內多次交換資料，持續連線會加快其通訊，讓它們能夠避免開啟和關閉每個訊息的 TCP 連線所需的額外負荷。 這個屬性的預設值是使用 HTTP/1.1 的用戶端， `true`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ LocalEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求所導向到的伺服器 IP 位址和連接埠編號。</summary>
        <value>
          <see cref="T:System.Net.IPEndPoint" />，表示要求傳送至的 IP 位址。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您想要根據的方式處理這些要求回應，這個屬性是很有用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求的用戶端所使用的 HTTP 版本。</summary>
        <value>
          <see cref="T:System.Version" />，識別用戶端的 HTTP 版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在可用的文件中指定不同的 HTTP 版本的功能[ https://www.rfc-editor.org ](https://www.rfc-editor.org/)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求中所包含的查詢字串。</summary>
        <value>
          <see cref="T:System.Collections.Specialized.NameValueCollection" /> 物件，含有要求 <see cref="P:System.Net.HttpListenerRequest.Url" /> 中所含的查詢資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 URL 中，查詢資訊是由問號 （？） 分隔路徑資訊。 名稱/值組必須以等號 （=） 分隔。 若要存取以單一字串形式的查詢資料，取得<xref:System.Uri.Query%2A>屬性值從<xref:System.Uri>所傳回物件<xref:System.Net.HttpListenerRequest.Url%2A>。  
  
> [!NOTE]
>  查詢不包含等號 (範例： [ http://www.contoso.com/query.htm?Name ](http://www.contoso.com/query.htm?Name) ) 加入至`null`中的索引鍵<xref:System.Collections.Specialized.NameValueCollection>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.HttpListenerRequest.QueryString%2A>屬性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端所要求的 URL 資訊 (不含主機和連接埠)。</summary>
        <value>
          <see cref="T:System.String" />，包含這個要求的原始 URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 原始 URL 定義為下列網域資訊的 URL 的一部分。 URL 字串中`http://www.contoso.com/articles/recent.aspx`，原始的 URL 是`/articles/recent.aspx`。 如果有的話，原始 URL 會包含查詢字串。  
  
 若要取得主機和連接埠資訊，請使用<xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.HttpListenerRequest.RawUrl%2A>屬性。  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ RemoteEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得起始要求的用戶端 IP 位址和連接埠編號。</summary>
        <value>
          <see cref="T:System.Net.IPEndPoint" />，表示起始要求的 IP 位址和連接埠編號。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequestTraceIdentifier">
      <MemberSignature Language="C#" Value="public Guid RequestTraceIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid RequestTraceIdentifier" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RequestTraceIdentifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestTraceIdentifier As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid RequestTraceIdentifier { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns Guid.Empty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得連入之 HTTP 要求的要求識別項。</summary>
        <value>
          <see cref="T:System.Guid" /> 物件，含有 HTTP 要求的識別項。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端透過要求傳送的服務提供者名稱 (SPN)。</summary>
        <value>
          <see cref="T:System.String" />，包含用戶端透過要求傳送的 SPN。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可以使用<xref:System.Net.HttpListenerRequest.ServiceName%2A>屬性來執行自訂服務提供名稱 (SPN) 驗證。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.TransportContext" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端要求的 <see cref="T:System.Net.TransportContext" />。</summary>
        <value>用戶端要求的 <see cref="T:System.Net.TransportContext" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.TransportContext>屬性可用來擷取通道的繫結 token (CBT)<xref:System.Net.HttpListenerRequest>送出使用 HTTPS。  
  
 應用程式可以使用<xref:System.Net.TransportContext>屬性來執行自訂驗證使用呼叫至原生 Win32 [AcceptSecurityContext](http://go.microsoft.com/fwlink/?LinkId=147021)函式。  
  
 如果應用程式嘗試擷取此通道繫結 token (CBT)<xref:System.Net.HttpListenerRequest.TransportContext%2A>屬性使用<xref:System.Net.TransportContext.GetChannelBinding%2A>方法和<xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind>不<xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint>，然後在<xref:System.Net.HttpListenerRequest>將會擲回<xref:System.NotSupportedException>。 <xref:System.Net.HttpListenerRequest>會覆寫<xref:System.Net.TransportContext.GetChannelBinding%2A>具有內部實作的方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.ServiceName" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端所要求的 <see cref="T:System.Uri" /> 物件。</summary>
        <value>
          <see cref="T:System.Uri" /> 物件，識別用戶端所要求的資源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListenerRequest.Url%2A>屬性可讓您取得所有的可用資訊<xref:System.Uri>物件。 如果您需要知道 URI 要求的原始文字，請考慮使用<xref:System.Net.HttpListenerRequest.RawUrl%2A>屬性改為。  
  
 <xref:System.Net.HttpListenerRequest.Url%2A>屬性為 null 如果<xref:System.Uri>從用戶端無法剖析。  
  
 <xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A>屬性會指出如果<xref:System.Net.HttpListener>而不是轉換後的 URI 轉換百分比編碼的任何值，會採取其他的正規化步驟會使用原始的未逸出的 URI。  
  
 當<xref:System.Net.HttpListener>執行個體收到要求時透過`http.sys`服務，它會建立所提供的 URI 字串的執行個體`http.sys`，並公開其為<xref:System.Net.HttpListenerRequest.Url%2A?displayProperty=nameWithType>屬性。  
  
 `http.sys`服務會公開兩個要求 URI 字串：  
  
-   未經處理的 URI  
  
-   已轉換的 URI  
  
 未經處理的 URI 是<xref:System.Uri?displayProperty=nameWithType>提供 HTTP 要求的要求行中：  
  
 `GET /path/`  
  
 `Host: www.contoso.com`  
  
 所提供的原始 URI`http.sys`上面所提的要求是"/ 路徑 /"。 這表示它已透過網路傳送接下來的 HTTP 動詞命令的字串。  
  
 `http.sys`服務要求使用 HTTP 要求行中所提供的 URI 中所提供的資訊建立轉換的 URI 和主機標頭，以判斷原始伺服器的要求應該會轉送到。 這是藉由比較一組已註冊的 URI 前置詞的要求中的資訊。 為了能夠比較這些值，需要完成一些正規化的要求。 轉換 URI 上述範例應如下：  
  
 `http://www.contoso.com/path/`  
  
 `http.sys`服務結合<xref:System.Uri.Host%2A?displayProperty=nameWithType>屬性值，並要求條線建立轉換的 URI 中的字串。 此外，`http.sys`和<xref:System.Uri?displayProperty=nameWithType>類別也會執行下列動作：  
  
-   取消-逸出所有百分比編碼值。  
  
-   轉換百分比編碼為 utf-16 字元表示法的非 ASCII 字元。 請注意，utf-8 與 ANSI/DBCS 字元支援以及 Unicode 字元 （Unicode 編碼使用 %uxxxx 格式）。  
  
-   執行其他的正規化步驟，例如路徑壓縮。  
  
 要求不包含任何百分比編碼值使用的編碼方式相關資訊，因為它可能無法判斷正確的編碼方式只是藉由剖析的百分比編碼值。  
  
 因此`http.sys`提供修改程序的兩個登錄機碼：  
  
|登錄機碼|預設值|描述|  
|------------------|-------------------|-----------------|  
|EnableNonUTF8|1|如果是零，`http.sys`接受只有 UTF 8 編碼的 Url。<br /><br /> 如果不是零，`http.sys`也接受 ANSI 編碼或 DBCS 編碼在要求中的 Url。|  
|FavorUTF8|1|如果不是零，`http.sys`一律會嘗試解碼 URL 為 utf-8 第一次。 如果該轉換失敗，而且 EnableNonUTF8 為非零，Http.sys，然後嘗試將它解碼為 ANSI 或依 DBCS。<br /><br /> 如果是零 （和 EnableNonUTF8 為非零），`http.sys`嘗試將它解碼為 ANSI 或依 DBCS; 如果不成功，它會嘗試 utf-8 轉換。|  
  
 當<xref:System.Net.HttpListener>收到要求時，它會使用轉換的 URI 從`http.sys`來作為輸入<xref:System.Net.HttpListenerRequest.Url%2A>屬性。  
  
 沒有需要支援在 Uri 中的字元和數字以外的字元。 範例是下列的 URI 用來擷取客戶的客戶資訊數字"1/3812":  
  
 `http://www.contoso.com/Customer('1%2F3812')/`  
  
 請注意百分比編碼中的斜線的 Uri (%2f)。 必須這樣做，因為在此情況下的斜線字元表示的資料，不是路徑分隔符號。  
  
 將字串傳遞至 Uri 建構函式會導致下列 URI:  
  
 `http://www.contoso.com/Customer('1/3812')/`  
  
 分割為其區段路徑會產生下列項目：  
  
 `Customer('1`  
  
 `3812')`  
  
 這不是寄件者要求的意圖。  
  
 如果<xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A>屬性設定為 false，則當<xref:System.Net.HttpListener>收到要求時，它會使用原始 URI，而不是從轉換過的 URI`http.sys`來作為輸入<xref:System.Net.HttpListenerRequest.Url%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.HttpListenerRequest.Url%2A>屬性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Configuration.HttpListenerElement" />
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端用來參考伺服器之資源的統一資源識別元 (URI)。</summary>
        <value>
          <see cref="T:System.Uri" /> 物件，包含要求之 <see cref="F:System.Net.HttpRequestHeader.Referer" /> 標頭的文字，如果要求中不包含此標頭，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果用戶端已要求的 uri 後面超連結，可能會包含其要求`Referrer`識別包含超連結的資源 URI 的標頭。  
  
 用戶端可以假造或選擇不呈現<xref:System.Net.HttpRequestHeader.Referer>標頭。 因此，雖然<xref:System.Net.HttpListenerRequest.UrlReferrer%2A>可用於識別網路流量的基本趨勢屬性; 您不應使用它做為授權配置的一部分來控制資料的存取權。  
  
 如需完整的要求標頭清單，請參閱<xref:System.Net.HttpRequestHeader>列舉型別。  
  
 <xref:System.Net.HttpListenerRequest.UrlReferrer%2A>為 null 時沒有任何`Referrer`要求標頭或當`Referrer`標頭在要求中存在，但是不會剖析為有效<xref:System.Uri>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端所表示的使用者代理程式。</summary>
        <value>
          <see cref="T:System.String" /> 物件，包含要求之 <see langword="User-Agent" /> 標頭的文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `User-Agent`頁首通常會包含用來識別用來產生要求的軟體名稱和版本號碼文字。  
  
 如需完整的要求標頭清單，請參閱<xref:System.Net.HttpRequestHeader>列舉型別。  
  
 <xref:System.Net.HttpListenerRequest.UserAgent%2A>為 null 時沒有任何`User-Agent`要求標頭。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求所導向到的伺服器 IP 位址和連接埠編號。</summary>
        <value>
          <see cref="T:System.String" />，包含主機位址資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的資訊也會提供<xref:System.Net.HttpListenerRequest.LocalEndPoint%2A>屬性值。  
  
   
  
## Examples  
 下列程式碼範例會顯示這個屬性的值。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 DNS 名稱和用戶端所指定的連接埠編號 (如果有提供的話)。</summary>
        <value>
          <see cref="T:System.String" /> 值，包含要求之 <see langword="Host" /> 標頭的文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Host`標頭包含要求的伺服器主機名稱和通訊埠編號，如果指定，以冒號分隔 (例如， `www.contoso.com:8080`)。  
  
 您可以使用這個屬性傳回不同的回應，根據要求中指定的主機名稱。  
  
 如需完整的要求標頭清單，請參閱<xref:System.Net.HttpRequestHeader>列舉型別。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個屬性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得回應慣用的自然語言。</summary>
        <value>
          <see cref="T:System.String" /> 陣列，包含要求的 <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> 標頭中所指定的語言，如果用戶端要求沒有包含 <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> 標頭，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細的說明`Accept-Language`標頭，請參閱 RFC 2616 區段位於 14.4 [ https://www.rfc-editor.org ](https://www.rfc-editor.org/)。  
  
 如需完整的要求標頭清單，請參閱<xref:System.Net.HttpRequestHeader>列舉型別。  
  
   
  
## Examples  
 下列程式碼範例會顯示從要求的語言`Accept-Language`標頭。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
  </Members>
</Type>