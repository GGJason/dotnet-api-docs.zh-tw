<Type Name="IPAddress" FullName="System.Net.IPAddress">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ded3e78bb400015dbcba3211273b67d9ed529a14" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36472067" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IPAddress" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPAddress extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPAddress" />
  <TypeSignature Language="VB.NET" Value="Public Class IPAddress" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPAddress" />
  <TypeSignature Language="F#" Value="type IPAddress = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="0a299-101">提供網際網路通訊協定 (IP) 位址。</span>
      <span class="sxs-lookup">
        <span data-stu-id="0a299-101">Provides an Internet Protocol (IP) address.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-102"><xref:System.Net.IPAddress>類別包含位址的 IP 網路上的電腦。</span><span class="sxs-lookup"><span data-stu-id="0a299-102">The <xref:System.Net.IPAddress> class contains the address of a computer on an IP network.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-103">下列程式碼範例示範如何查詢伺服器以取得家族的位址和 IP 位址與它支援。</span><span class="sxs-lookup"><span data-stu-id="0a299-103">The following code example shows how to query a server to obtain the family addresses and the IP addresses it supports.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#1)]
 [!code-csharp[System.Net.IPAddress#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#1)]
 [!code-vb[System.Net.IPAddress#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-104">初始化 <see cref="T:System.Net.IPAddress" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-104">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0a299-105">IP 位址的位元組陣列值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-105">The byte array value of the IP address.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-106">使用指定為 <see cref="T:System.Net.IPAddress" /> 陣列的位址，初始化 <see cref="T:System.Byte" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-106">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-107"><xref:System.Net.IPAddress>會透過<xref:System.Net.IPAddress.Address%2A>屬性設定為`address`。</span><span class="sxs-lookup"><span data-stu-id="0a299-107">The <xref:System.Net.IPAddress> is created with the <xref:System.Net.IPAddress.Address%2A> property set to `address`.</span></span>  
  
 <span data-ttu-id="0a299-108">如果長度`address`為 4，<xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29>建構 IPv4 位址; 否則建構的範圍為 0 的 IPv6 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-108">If the length of `address` is 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> constructs an IPv4 address; otherwise, an IPv6 address with a scope of 0 is constructed.</span></span>  
  
 <span data-ttu-id="0a299-109"><xref:System.Byte>假設為以網路位元組順序的索引位置 0 中的第一個最重要的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="0a299-109">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a299-110">
            <paramref name="address" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-110">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a299-111">
            <paramref name="address" /> 包含錯誤的 IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-111">
              <paramref name="address" /> contains a bad IP address.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (long newAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 newAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newAddress As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(long newAddress);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress newAddress" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newAddress" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newAddress">
          <span data-ttu-id="0a299-112">IP 位址的長整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-112">The long value of the IP address.</span>
          </span>
          <span data-ttu-id="0a299-113">例如，位元組由大到小格式的 0x2414188f 值將為 IP 位址 "143.24.20.36"。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-113">For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-114">使用指定為 <see cref="T:System.Net.IPAddress" /> 的位址，初始化 <see cref="T:System.Int64" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-114">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as an <see cref="T:System.Int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-115"><xref:System.Net.IPAddress>使用建立執行個體<xref:System.Net.IPAddress.Address%2A>屬性設定為`newAddress`。</span><span class="sxs-lookup"><span data-stu-id="0a299-115">The <xref:System.Net.IPAddress> instance is created with the <xref:System.Net.IPAddress.Address%2A> property set to `newAddress`.</span></span>  
  
 <span data-ttu-id="0a299-116"><xref:System.Int64>值會被假設為以網路位元組順序。</span><span class="sxs-lookup"><span data-stu-id="0a299-116">The <xref:System.Int64> value is assumed to be in network byte order.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a299-117">
            <paramref name="newAddress" /> &lt; 0 或  <paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-117">
              <paramref name="newAddress" /> &lt; 0 or  <paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte(), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0a299-118">IP 位址的位元組陣列值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-118">The byte array value of the IP address.</span>
          </span>
        </param>
        <param name="scopeid">
          <span data-ttu-id="0a299-119">範圍識別項的長整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-119">The long value of the scope identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-120">使用指定為 <see cref="T:System.Net.IPAddress" /> 陣列且具有指定之範圍識別項的位址，初始化 <see cref="T:System.Byte" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-120">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array and the specified scope identifier.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-121">這個建構函式具現化的 IPv6 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-121">This constructor instantiates an IPv6 address.</span></span> <span data-ttu-id="0a299-122">`scopeid`識別在連結-本機位址的網路介面。</span><span class="sxs-lookup"><span data-stu-id="0a299-122">The `scopeid` identifies a network interface in the case of a link-local address.</span></span> <span data-ttu-id="0a299-123">範圍是僅適用於本機連結和網站-本機位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-123">The scope is valid only for link-local and site-local addresses.</span></span>  
  
 <span data-ttu-id="0a299-124"><xref:System.Byte>假設為以網路位元組順序的索引位置 0 中的第一個最重要的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="0a299-124">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a299-125">
            <paramref name="address" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-125">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a299-126">
            <paramref name="address" /> 包含錯誤的 IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-126">
              <paramref name="address" /> contains a bad IP address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a299-127">
            <paramref name="scopeid" /> &lt; 0 或  <paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-127">
              <paramref name="scopeid" /> &lt; 0 or  <paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <param name="scopeid">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Address { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Address : int64 with get, set" Usage="System.Net.IPAddress.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-128">網際網路通訊協定 (IP) 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-128">An Internet Protocol (IP) address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a299-129">IP 位址的長整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-129">The long value of the IP address.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-130">這個屬性已經過時。</span><span class="sxs-lookup"><span data-stu-id="0a299-130">This property is obsolete.</span></span> <span data-ttu-id="0a299-131">使用 <xref:System.Net.IPAddress.GetAddressBytes%2A>。</span><span class="sxs-lookup"><span data-stu-id="0a299-131">Use <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span></span>  
  
 <span data-ttu-id="0a299-132">要轉換<xref:System.Net.IPAddress.Address%2A>四點標記法，如果要使用<xref:System.Net.IPAddress.ToString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0a299-132">To convert <xref:System.Net.IPAddress.Address%2A> to dotted-quad notation, use the <xref:System.Net.IPAddress.ToString%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="0a299-133">位址家族是 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-133">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.IPAddress.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-134">取得 IP 位址的位址家族。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-134">Gets the address family of the IP address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a299-135">傳回 IPv4 的 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />，或傳回 IPv6 的 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-135">Returns <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> for IPv4 or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> for IPv6.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a299-136">中的範例，請參閱<xref:System.Net.IPAddress>類別主題。</span><span class="sxs-lookup"><span data-stu-id="0a299-136">Refer to the example in the <xref:System.Net.IPAddress> class topic.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Any : System.Net.IPAddress" Usage="System.Net.IPAddress.Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-137">提供指示伺服器必須在所有網路介面上接聽用戶端活動的 IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-137">Provides an IP address that indicates that the server must listen for client activity on all network interfaces.</span>
          </span>
          <span data-ttu-id="0a299-138">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-138">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-139"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>方法會使用<xref:System.Net.IPAddress.Any>欄位，指出<xref:System.Net.Sockets.Socket>必須接聽所有網路介面上的用戶端活動的執行個體。</span><span class="sxs-lookup"><span data-stu-id="0a299-139">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.Any> field to indicate that a <xref:System.Net.Sockets.Socket> instance must listen for client activity on all network interfaces.</span></span>  
  
 <span data-ttu-id="0a299-140"><xref:System.Net.IPAddress.Any>欄位相當於 0.0.0.0 四點表示法。</span><span class="sxs-lookup"><span data-stu-id="0a299-140">The <xref:System.Net.IPAddress.Any> field is equivalent to 0.0.0.0 in dotted-quad notation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Broadcast;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Broadcast" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Broadcast" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Broadcast As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Broadcast;" />
      <MemberSignature Language="F#" Value=" staticval mutable Broadcast : System.Net.IPAddress" Usage="System.Net.IPAddress.Broadcast" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-141">提供 IP 廣播位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-141">Provides the IP broadcast address.</span>
          </span>
          <span data-ttu-id="0a299-142">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-142">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-143"><xref:System.Net.IPAddress.Broadcast>欄位相當於 255.255.255.255 四點表示法。</span><span class="sxs-lookup"><span data-stu-id="0a299-143">The <xref:System.Net.IPAddress.Broadcast> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-144">下列範例會列印<xref:System.Net.IPAddress.Broadcast>位址到主控台。</span><span class="sxs-lookup"><span data-stu-id="0a299-144">The following example prints the <xref:System.Net.IPAddress.Broadcast> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#2)]
 [!code-csharp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#2)]
 [!code-vb[IPAddress_Broadcast_Loopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="iPAddress.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">
          <span data-ttu-id="0a299-145">要與目前執行個體比較的 <see cref="T:System.Net.IPAddress" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-145">An <see cref="T:System.Net.IPAddress" /> instance to compare to the current instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-146">比較兩個 IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-146">Compares two IP addresses.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-147">如果兩個位址相等，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-147">
              <see langword="true" /> if the two addresses are equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-148"><xref:System.Net.IPAddress.Equals%2A>方法會比較目前<xref:System.Net.IPAddress>執行個體，其`comparand`參數，並傳回`true`如果兩個執行個體包含相同的 IP 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-148">The <xref:System.Net.IPAddress.Equals%2A> method compares the current <xref:System.Net.IPAddress> instance with the `comparand` parameter and returns `true` if the two instances contain the same IP address.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAddressBytes">
      <MemberSignature Language="C#" Value="public byte[] GetAddressBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetAddressBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetAddressBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddressBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetAddressBytes();" />
      <MemberSignature Language="F#" Value="member this.GetAddressBytes : unit -&gt; byte[]" Usage="iPAddress.GetAddressBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a299-149">提供做為位元組陣列之 <see cref="T:System.Net.IPAddress" /> 的複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-149">Provides a copy of the <see cref="T:System.Net.IPAddress" /> as an array of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-150">
            <see cref="T:System.Byte" /> 陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-150">A <see cref="T:System.Byte" /> array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a299-151">下列程式碼範例示範如何取得伺服器 IP 位址，以位元組格式。</span><span class="sxs-lookup"><span data-stu-id="0a299-151">The following code example shows how to get a server IP address in byte format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#2)]
 [!code-csharp[System.Net.IPAddress#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#2)]
 [!code-vb[System.Net.IPAddress#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="iPAddress.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a299-152">傳回 IP 位址的雜湊值 (Hash Value)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-152">Returns a hash value for an IP address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-153">整數雜湊值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-153">An integer hash value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-154"><xref:System.Net.IPAddress.GetHashCode%2A>方法傳回的 IP 位址的雜湊程式碼。</span><span class="sxs-lookup"><span data-stu-id="0a299-154">The <xref:System.Net.IPAddress.GetHashCode%2A> method returns a hash code of the IP address.</span></span> <span data-ttu-id="0a299-155">這個值可以當做雜湊表中的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="0a299-155">This value can be used as a key in hash tables.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HostToNetworkOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-156">將值從主機位元組順序轉換為網路位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-156">Converts a value from host byte order to network byte order.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static short HostToNetworkOrder (short host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 HostToNetworkOrder(int16 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short HostToNetworkOrder(short host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="0a299-157">以主機位元組順序表示之要轉換的數字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-157">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-158">將短整數 (Short) 值從主機位元組順序轉換為網路位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-158">Converts a short value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-159">以網路位元組順序表示的短整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-159">A short value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-160">不同的電腦會使用不同的慣例來排序中的多位元組的整數值的位元組。</span><span class="sxs-lookup"><span data-stu-id="0a299-160">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="0a299-161">某些電腦先放置最大顯著性位元組 （亦即位元組由大到小順序） 和其他人先放置最小顯著性位元組 （又稱為 little-endian 順序）。</span><span class="sxs-lookup"><span data-stu-id="0a299-161">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="0a299-162">若要使用不同的位元組順序的電腦使用，會透過網路傳送的所有整數值會以網路位元組順序先具有最大顯著性位元組都傳送。</span><span class="sxs-lookup"><span data-stu-id="0a299-162">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="0a299-163"><xref:System.Net.IPAddress.HostToNetworkOrder%2A>方法會將轉換從主機網路所使用的位元組順序使用的位元組順序的主機系統所儲存的多位元組的整數值。</span><span class="sxs-lookup"><span data-stu-id="0a299-163">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static int HostToNetworkOrder (int host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HostToNetworkOrder(int32 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int HostToNetworkOrder(int host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int -&gt; int" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="0a299-164">以主機位元組順序表示之要轉換的數字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-164">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-165">將整數值從主機位元組順序轉換為網路位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-165">Converts an integer value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-166">以網路位元組順序表示的整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-166">An integer value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-167">不同的電腦會使用不同的慣例來排序中的多位元組的整數值的位元組。</span><span class="sxs-lookup"><span data-stu-id="0a299-167">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="0a299-168">某些電腦先放置最大顯著性位元組 （亦即位元組由大到小順序） 和其他人先放置最小顯著性位元組 （又稱為 little-endian 順序）。</span><span class="sxs-lookup"><span data-stu-id="0a299-168">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="0a299-169">若要使用不同的位元組順序的電腦使用，會透過網路傳送的所有整數值會以網路位元組順序先具有最大顯著性位元組都傳送。</span><span class="sxs-lookup"><span data-stu-id="0a299-169">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="0a299-170"><xref:System.Net.IPAddress.HostToNetworkOrder%2A>方法會將轉換從主機網路所使用的位元組順序使用的位元組順序的主機系統所儲存的多位元組的整數值。</span><span class="sxs-lookup"><span data-stu-id="0a299-170">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static long HostToNetworkOrder (long host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HostToNetworkOrder(int64 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long HostToNetworkOrder(long host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="0a299-171">以主機位元組順序表示之要轉換的數字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-171">The number to convert, expressed in host byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-172">將長整數 (Long) 值從主機位元組順序轉換為網路位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-172">Converts a long value from host byte order to network byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-173">以網路位元組順序表示的長整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-173">A long value, expressed in network byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-174">不同的電腦會使用不同的慣例來排序中的多位元組的整數值的位元組。</span><span class="sxs-lookup"><span data-stu-id="0a299-174">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="0a299-175">某些電腦先放置最大顯著性位元組 （亦即位元組由大到小順序） 和其他人先放置最小顯著性位元組 （又稱為 little-endian 順序）。</span><span class="sxs-lookup"><span data-stu-id="0a299-175">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="0a299-176">若要使用不同的位元組順序的電腦使用，會透過網路傳送的所有整數值會以網路位元組順序先具有最大顯著性位元組都傳送。</span><span class="sxs-lookup"><span data-stu-id="0a299-176">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="0a299-177"><xref:System.Net.IPAddress.HostToNetworkOrder%2A>方法會將轉換從主機網路所使用的位元組順序使用的位元組順序的主機系統所儲存的多位元組的整數值。</span><span class="sxs-lookup"><span data-stu-id="0a299-177">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="IPv6Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Any : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-178">
            <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 方法使用 <see cref="F:System.Net.IPAddress.IPv6Any" /> 欄位來表示 <see cref="T:System.Net.Sockets.Socket" /> 必須在所有網路介面上接聽用戶端活動。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-178">The <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method uses the <see cref="F:System.Net.IPAddress.IPv6Any" /> field to indicate that a <see cref="T:System.Net.Sockets.Socket" /> must listen for client activity on all network interfaces.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-179"><xref:System.Net.IPAddress.IPv6Any>欄位相當於 0:0:0:0:0:0:0:0 以冒號十六進位標記法，或:: compact 的表示法。</span><span class="sxs-lookup"><span data-stu-id="0a299-179">The <xref:System.Net.IPAddress.IPv6Any> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to :: in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-180">下列程式碼範例顯示標準的壓縮格式的目前值主機的任何位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-180">The following code example displays the value of the current host's Any address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#2)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#2)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-181">提供 IP 回送位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-181">Provides the IP loopback address.</span>
          </span>
          <span data-ttu-id="0a299-182">這個屬性是唯讀的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-182">This property is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-183"><xref:System.Net.IPAddress.IPv6Loopback>欄位相當於 0:0:0:0:0:0:0:1 以冒號十六進位標記法，或:: compact 標記法中的為 1。</span><span class="sxs-lookup"><span data-stu-id="0a299-183">The <xref:System.Net.IPAddress.IPv6Loopback> field is equivalent to 0:0:0:0:0:0:0:1 in colon-hexadecimal notation, or to ::1 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-184">下列程式碼範例顯示標準的壓縮格式的目前主機的回送位址的值。</span><span class="sxs-lookup"><span data-stu-id="0a299-184">The following code example displays the value of the current host's loopback address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6None;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6None : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-185">提供 IP 位址，表示不可使用網路介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-185">Provides an IP address that indicates that no network interface should be used.</span>
          </span>
          <span data-ttu-id="0a299-186">這個屬性是唯讀的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-186">This property is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-187"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>方法會使用<xref:System.Net.IPAddress.IPv6None>欄位，指出<xref:System.Net.Sockets.Socket>必須接聽用戶端活動。</span><span class="sxs-lookup"><span data-stu-id="0a299-187">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.IPv6None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="0a299-188"><xref:System.Net.IPAddress.IPv6None>欄位相當於 0:0:0:0:0:0:0:0 以冒號十六進位標記法，或:: compact 標記法中的為 0。</span><span class="sxs-lookup"><span data-stu-id="0a299-188">The <xref:System.Net.IPAddress.IPv6None> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to ::0 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-189">下列程式碼範例會顯示標準的壓縮格式的目前主機的任何位址的值。</span><span class="sxs-lookup"><span data-stu-id="0a299-189">The following code example displays the value of the current host's None address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#3)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#3)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv4MappedToIPv6">
      <MemberSignature Language="C#" Value="public bool IsIPv4MappedToIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv4MappedToIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv4MappedToIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv4MappedToIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv4MappedToIPv6 : bool" Usage="System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-190">取得 IP 位址是否為對應 IPv4 的 IPv6 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-190">Gets whether the IP address is an IPv4-mapped IPv6 address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a299-191">傳回 <see cref="T:System.Boolean" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-191">Returns <see cref="T:System.Boolean" />.</span>
          </span>
          <span data-ttu-id="0a299-192">如果 IP 位址是對應 IPv4 的 IPv6 位址，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-192">
              <see langword="true" /> if the IP address is an IPv4-mapped IPv6 address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-193">雙重堆疊通訊端一定需要 IPv6 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-193">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="0a299-194">IPv4 位址互動的功能需要使用 IPv4 對應的 IPv6 位址格式。</span><span class="sxs-lookup"><span data-stu-id="0a299-194">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="0a299-195">IPv4 對應的 IPv6 位址格式讓 IPv6 只有應用程式進行通訊與 IPv4 節點必須代表任何 IPv4 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-195">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="0a299-196">IPv4 對應的 IPv6 位址格式可讓以 IPv6 位址表示 IPv4 節點的 IPv4 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-196">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="0a299-197">IPv4 位址會編碼為低位 32 位元的 IPv6 位址，高序位 96 位元會保留固定的前置詞 0:0:0:0:0:FFFF。</span><span class="sxs-lookup"><span data-stu-id="0a299-197">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="0a299-198">RFC 4291 中指定的 IPv4 對應的 IPv6 位址的格式。</span><span class="sxs-lookup"><span data-stu-id="0a299-198">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="0a299-199">如需詳細資訊，請參閱[www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231)。</span><span class="sxs-lookup"><span data-stu-id="0a299-199">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6LinkLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6LinkLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6LinkLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6LinkLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6LinkLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6LinkLocal : bool" Usage="System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-200">取得位址是否為 IPv6 連結本機位址的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-200">Gets whether the address is an IPv6 link local address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a299-201">如果 IP 位址是 IPv6 連結本機位址，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-201">
              <see langword="true" /> if the IP address is an IPv6 link local address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Multicast">
      <MemberSignature Language="C#" Value="public bool IsIPv6Multicast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Multicast" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Multicast" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Multicast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Multicast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Multicast : bool" Usage="System.Net.IPAddress.IsIPv6Multicast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-202">取得位址是否為 IPv6 多點傳送全域位址的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-202">Gets whether the address is an IPv6 multicast global address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a299-203">如果 IP 位址是 IPv6 多點傳送全域位址，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-203">
              <see langword="true" /> if the IP address is an IPv6 multicast global address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6SiteLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6SiteLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6SiteLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6SiteLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6SiteLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6SiteLocal : bool" Usage="System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-204">取得位址是否為 IPv6 站台本機位址的資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-204">Gets whether the address is an IPv6 site local address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a299-205">如果 IP 位址是 IPv6 站台本機位址，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-205">
              <see langword="true" /> if the IP address is an IPv6 site local address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Teredo">
      <MemberSignature Language="C#" Value="public bool IsIPv6Teredo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Teredo" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Teredo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Teredo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Teredo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Teredo : bool" Usage="System.Net.IPAddress.IsIPv6Teredo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-206">取得值，這個值指出位址是否為 IPv6 Teredo 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-206">Gets whether the address is an IPv6 Teredo address.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a299-207">如果 IP 位址為 IPv6 Teredo 位址則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-207">
              <see langword="true" /> if the IP address is an IPv6 Teredo address; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-208">Teredo 位址是 IPv6 位址首碼為 2001年:: / 32。</span><span class="sxs-lookup"><span data-stu-id="0a299-208">A Teredo address is an IPv6 address with the prefix of 2001::/32.</span></span> <span data-ttu-id="0a299-209">Teredo 位址可透過一般的 DNS 名稱解析傳回或列舉為指派給本機介面的 IPv6 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-209">Teredo addresses can be returned through normal DNS name resolution or enumerated as an IPv6 address assigned to a local interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.BeginGetUnicastAddresses(System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.EndGetUnicastAddresses(System.IAsyncResult)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetUnicastAddresses" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public static bool IsLoopback (System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLoopback(class System.Net.IPAddress address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLoopback (address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLoopback(System::Net::IPAddress ^ address);" />
      <MemberSignature Language="F#" Value="static member IsLoopback : System.Net.IPAddress -&gt; bool" Usage="System.Net.IPAddress.IsLoopback address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="0a299-210">IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-210">An IP address.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-211">指示指定的 IP 位址是否為回送位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-211">Indicates whether the specified IP address is the loopback address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-212">如果 <paramref name="address" /> 是回送位址，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-212">
              <see langword="true" /> if <paramref name="address" /> is the loopback address; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-213"><xref:System.Net.IPAddress.IsLoopback%2A>方法會比較`address`至<xref:System.Net.IPAddress.Loopback>並傳回`true`如果兩個 IP 位址相同。</span><span class="sxs-lookup"><span data-stu-id="0a299-213">The <xref:System.Net.IPAddress.IsLoopback%2A> method compares `address` to <xref:System.Net.IPAddress.Loopback> and returns `true` if the two IP addresses are the same.</span></span>  
  
 <span data-ttu-id="0a299-214">在 [IPv4]，<xref:System.Net.IPAddress.IsLoopback%2A>方法會傳回`true`表單的任何 IP 位址 （其中 X、 Y 和 Z 位於範圍 0-255） 127.X.Y.Z，不只<xref:System.Net.IPAddress.Loopback>(127.0.0.1)。</span><span class="sxs-lookup"><span data-stu-id="0a299-214">In the case of IPv4, that the <xref:System.Net.IPAddress.IsLoopback%2A> method returns `true` for any IP address of the form 127.X.Y.Z (where X, Y, and Z are in the range 0-255), not just <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-215">下列程式碼範例使用<xref:System.Net.IPAddress.IsLoopback%2A>方法，以判斷指定的位址是回送位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-215">The following code example uses the <xref:System.Net.IPAddress.IsLoopback%2A> method to determine whether the specified address is a loopback address.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CPP/isloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CS/isloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/VB/isloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-216">提供 IP 回送位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-216">Provides the IP loopback address.</span>
          </span>
          <span data-ttu-id="0a299-217">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-217">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-218"><xref:System.Net.IPAddress.Loopback>欄位相當於 127.0.0.1 四點表示法。</span><span class="sxs-lookup"><span data-stu-id="0a299-218">The <xref:System.Net.IPAddress.Loopback> field is equivalent to 127.0.0.1 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-219">下列範例會列印<xref:System.Net.IPAddress.Loopback>位址到主控台。</span><span class="sxs-lookup"><span data-stu-id="0a299-219">The following example prints the <xref:System.Net.IPAddress.Loopback> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#1)]
 [!code-csharp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#1)]
 [!code-vb[IPAddress_Broadcast_Loopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv4">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv4 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv4() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv4 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv4();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv4 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv4 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a299-220">將 <see cref="T:System.Net.IPAddress" /> 物件對應至 IPv4 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-220">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv4 address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-221">傳回 <see cref="T:System.Net.IPAddress" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-221">Returns <see cref="T:System.Net.IPAddress" />.</span>
          </span>
          <span data-ttu-id="0a299-222">IPv4 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-222">An IPv4 address.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-223">雙重堆疊通訊端一定需要 IPv6 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-223">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="0a299-224">IPv4 位址互動的功能需要使用 IPv4 對應的 IPv6 位址格式。</span><span class="sxs-lookup"><span data-stu-id="0a299-224">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="0a299-225">IPv4 對應的 IPv6 位址格式讓 IPv6 只有應用程式進行通訊與 IPv4 節點必須代表任何 IPv4 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-225">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="0a299-226">IPv4 對應的 IPv6 位址格式可讓以 IPv6 位址表示 IPv4 節點的 IPv4 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-226">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="0a299-227">IPv4 位址會編碼為低位 32 位元的 IPv6 位址，高序位 96 位元會保留固定的前置詞 0:0:0:0:0:FFFF。</span><span class="sxs-lookup"><span data-stu-id="0a299-227">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="0a299-228">RFC 4291 中指定的 IPv4 對應的 IPv6 位址的格式。</span><span class="sxs-lookup"><span data-stu-id="0a299-228">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="0a299-229">如需詳細資訊，請參閱[www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231)。</span><span class="sxs-lookup"><span data-stu-id="0a299-229">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 <span data-ttu-id="0a299-230">如果您想要使用<xref:System.Net.IPAddress.MapToIPv4%2A>IPv4 位址從 IPv6 格式轉換成 IPv4 格式，您必須先確定您已取得 IPv4 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-230">If you want to use <xref:System.Net.IPAddress.MapToIPv4%2A> to convert an IPv4 address from IPv6 format to IPv4 format, you must first ensure that you've got an IPv4 address.</span></span> <span data-ttu-id="0a299-231">呼叫<xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>，這會傳回`true`IP 位址是否原本 IPv4 IPv6，以寫入或`false`否則。</span><span class="sxs-lookup"><span data-stu-id="0a299-231">Call <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, which will return `true` if the IP address is originally IPv4 written as IPv6, or `false` otherwise.</span></span> <span data-ttu-id="0a299-232">如果<xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>傳回`true`，使用<xref:System.Net.IPAddress.MapToIPv4%2A>進行轉換。</span><span class="sxs-lookup"><span data-stu-id="0a299-232">If <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> returns `true`, use <xref:System.Net.IPAddress.MapToIPv4%2A> to make the conversion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv6">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv6 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv6() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv6 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv6();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv6 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv6 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a299-233">將 <see cref="T:System.Net.IPAddress" /> 物件對應至 IPv6 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-233">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv6 address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-234">傳回 <see cref="T:System.Net.IPAddress" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-234">Returns <see cref="T:System.Net.IPAddress" />.</span>
          </span>
          <span data-ttu-id="0a299-235">IPv6 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-235">An IPv6 address.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-236">雙重堆疊通訊端一定需要 IPv6 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-236">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="0a299-237">IPv4 位址互動的功能需要使用 IPv4 對應的 IPv6 位址格式。</span><span class="sxs-lookup"><span data-stu-id="0a299-237">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="0a299-238">IPv4 對應的 IPv6 位址格式讓 IPv6 只有應用程式進行通訊與 IPv4 節點必須代表任何 IPv4 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-238">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="0a299-239">IPv4 對應的 IPv6 位址格式可讓以 IPv6 位址表示 IPv4 節點的 IPv4 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-239">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="0a299-240">IPv4 位址會編碼為低位 32 位元的 IPv6 位址，高序位 96 位元會保留固定的前置詞 0:0:0:0:0:FFFF。</span><span class="sxs-lookup"><span data-stu-id="0a299-240">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="0a299-241">RFC 4291 中指定的 IPv4 對應的 IPv6 位址的格式。</span><span class="sxs-lookup"><span data-stu-id="0a299-241">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="0a299-242">如需詳細資訊，請參閱[www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231)。</span><span class="sxs-lookup"><span data-stu-id="0a299-242">For more information, see [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="NetworkToHostOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-243">將數字從網路位元組順序轉換為主機位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-243">Converts a number from network byte order to host byte order.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static short NetworkToHostOrder (short network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 NetworkToHostOrder(int16 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short NetworkToHostOrder(short network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="0a299-244">以網路位元組順序表示之要轉換的數字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-244">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-245">將短整數值從網路位元組順序轉換為主機位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-245">Converts a short value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-246">以主機位元組順序表示的短整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-246">A short value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-247">不同的電腦會使用不同的慣例來排序中的多位元組的整數值的位元組。</span><span class="sxs-lookup"><span data-stu-id="0a299-247">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="0a299-248">某些電腦先放置最大顯著性位元組 （亦即位元組由大到小順序） 和其他人先放置最小顯著性位元組 （又稱為 little-endian 順序）。</span><span class="sxs-lookup"><span data-stu-id="0a299-248">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="0a299-249">若要使用不同的位元組順序的電腦使用，會透過網路傳送的所有整數值會以網路位元組順序先具有最大顯著性位元組都傳送。</span><span class="sxs-lookup"><span data-stu-id="0a299-249">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="0a299-250"><xref:System.Net.IPAddress.NetworkToHostOrder%2A>方法會將轉換從主機所使用的位元組順序網路所使用的位元組順序的主機系統所儲存的多位元組的整數值。</span><span class="sxs-lookup"><span data-stu-id="0a299-250">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-251">下列範例會使用<xref:System.Net.IPAddress.NetworkToHostOrder%2A>方法，以將網路位元組順序的短整數值轉換為主機位元組順序。</span><span class="sxs-lookup"><span data-stu-id="0a299-251">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a short value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#1)]
 [!code-csharp[IPAddress_NetworkToHost#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#1)]
 [!code-vb[IPAddress_NetworkToHost#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static int NetworkToHostOrder (int network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NetworkToHostOrder(int32 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NetworkToHostOrder(int network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int -&gt; int" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="0a299-252">以網路位元組順序表示之要轉換的數字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-252">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-253">將整數值從網路位元組順序轉換為主機位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-253">Converts an integer value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-254">以主機位元組順序表示的整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-254">An integer value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-255">不同的電腦會使用不同的慣例來排序中的多位元組的整數值的位元組。</span><span class="sxs-lookup"><span data-stu-id="0a299-255">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="0a299-256">某些電腦先放置最大顯著性位元組 （亦即位元組由大到小順序） 和其他人先放置最小顯著性位元組 （又稱為 little-endian 順序）。</span><span class="sxs-lookup"><span data-stu-id="0a299-256">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="0a299-257">若要使用不同的位元組順序的電腦使用，會透過網路傳送的所有整數值會以網路位元組順序先具有最大顯著性位元組都傳送。</span><span class="sxs-lookup"><span data-stu-id="0a299-257">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="0a299-258"><xref:System.Net.IPAddress.NetworkToHostOrder%2A>方法會將轉換從主機所使用的位元組順序網路所使用的位元組順序的主機系統所儲存的多位元組的整數值。</span><span class="sxs-lookup"><span data-stu-id="0a299-258">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-259">下列範例會使用<xref:System.Net.IPAddress.NetworkToHostOrder%2A>從網路位元組順序的整數值轉換為主機位元組順序的方法。</span><span class="sxs-lookup"><span data-stu-id="0a299-259">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert an integer value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#2)]
 [!code-csharp[IPAddress_NetworkToHost#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#2)]
 [!code-vb[IPAddress_NetworkToHost#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static long NetworkToHostOrder (long network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 NetworkToHostOrder(int64 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long NetworkToHostOrder(long network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="network">
          <span data-ttu-id="0a299-260">以網路位元組順序表示之要轉換的數字。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-260">The number to convert, expressed in network byte order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-261">將長整數值從網路位元組順序轉換為主機位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-261">Converts a long value from network byte order to host byte order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-262">以主機位元組順序表示的長整數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-262">A long value, expressed in host byte order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-263">不同的電腦會使用不同的慣例來排序中的多位元組的整數值的位元組。</span><span class="sxs-lookup"><span data-stu-id="0a299-263">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="0a299-264">某些電腦先放置最大顯著性位元組 （亦即位元組由大到小順序） 和其他人先放置最小顯著性位元組 （又稱為 little-endian 順序）。</span><span class="sxs-lookup"><span data-stu-id="0a299-264">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="0a299-265">若要使用不同的位元組順序的電腦使用，會透過網路傳送的所有整數值會以網路位元組順序先具有最大顯著性位元組都傳送。</span><span class="sxs-lookup"><span data-stu-id="0a299-265">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="0a299-266"><xref:System.Net.IPAddress.NetworkToHostOrder%2A>方法會將轉換從主機所使用的位元組順序網路所使用的位元組順序的主機系統所儲存的多位元組的整數值。</span><span class="sxs-lookup"><span data-stu-id="0a299-266">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-267">下列範例會使用<xref:System.Net.IPAddress.NetworkToHostOrder%2A>從網路位元組順序的長整數值轉換為主機位元組順序的方法。</span><span class="sxs-lookup"><span data-stu-id="0a299-267">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a long value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#3)]
 [!code-csharp[IPAddress_NetworkToHost#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#3)]
 [!code-vb[IPAddress_NetworkToHost#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ None;" />
      <MemberSignature Language="F#" Value=" staticval mutable None : System.Net.IPAddress" Usage="System.Net.IPAddress.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-268">提供 IP 位址，表示不可使用網路介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-268">Provides an IP address that indicates that no network interface should be used.</span>
          </span>
          <span data-ttu-id="0a299-269">此欄位為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-269">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-270"><xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>方法會使用<xref:System.Net.IPAddress.None>欄位，指出<xref:System.Net.Sockets.Socket>必須接聽用戶端活動。</span><span class="sxs-lookup"><span data-stu-id="0a299-270">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="0a299-271"><xref:System.Net.IPAddress.None>欄位相當於 255.255.255.255 四點表示法。</span><span class="sxs-lookup"><span data-stu-id="0a299-271">The <xref:System.Net.IPAddress.None> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a299-272">下列範例會使用<xref:System.Net.IPAddress.None>以指出應該使用任何網路介面的屬性。</span><span class="sxs-lookup"><span data-stu-id="0a299-272">The following example uses the <xref:System.Net.IPAddress.None> property to indicate that no network interface should be used.</span></span>  
  
 [!code-cpp[IPAddress_None#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_None/CPP/ipaddress_none.cpp#1)]
 [!code-csharp[IPAddress_None#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_None/CS/ipaddress_none.cs#1)]
 [!code-vb[IPAddress_None#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_None/VB/ipaddress_none.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As ReadOnlySpan(Of Char)) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (string ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(string ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As String) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(System::String ^ ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ipString">
          <span data-ttu-id="0a299-273">字串，包含使用 IPv4 點分隔四組數字標記法和 IPv6 冒號分隔十六進位標記法的 IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-273">A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-274">將 IP 位址字串轉換為 <see cref="T:System.Net.IPAddress" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-274">Converts an IP address string to an <see cref="T:System.Net.IPAddress" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-275">
            <see cref="T:System.Net.IPAddress" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-275">An <see cref="T:System.Net.IPAddress" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-276">靜態<xref:System.Net.IPAddress.Parse%2A>方法會建立<xref:System.Net.IPAddress>來自 IP 位址和 IPv6 的冒號十六進位標記法中 ipv4 以點分隔四標記法來表示的執行個體。</span><span class="sxs-lookup"><span data-stu-id="0a299-276">The static <xref:System.Net.IPAddress.Parse%2A> method creates an <xref:System.Net.IPAddress> instance from an IP address expressed in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span>  
  
 <span data-ttu-id="0a299-277">中的部分數目 （以逗號分隔每個部分）`ipString`決定如何建構的 IP 位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-277">The number of parts (each part is separated by a period) in `ipString` determines how the IP address is constructed.</span></span> <span data-ttu-id="0a299-278">一個部分的位址是直接儲存在網路位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-278">A one part address is stored directly in the network address.</span></span> <span data-ttu-id="0a299-279">兩個部分的位址，為便於指定類別 A 位址，會將的前置部分放在第一個位元組和網路位址中最右邊的三個位元組的尾端部分。</span><span class="sxs-lookup"><span data-stu-id="0a299-279">A two part address, convenient for specifying a class A address, puts the leading part in the first byte and the trailing part in the right-most three bytes of the network address.</span></span> <span data-ttu-id="0a299-280">三個部分的位址，為便於指定類別 B 位址，將第一個部分中的第一個位元組、 第二個部分中的第二個位元組和網路位址的最後一個部分中最右邊的兩個位元組。</span><span class="sxs-lookup"><span data-stu-id="0a299-280">A three part address, convenient for specifying a class B address, puts the first part in the first byte, the second part in the second byte, and the final part in the right-most two bytes of the network address.</span></span> <span data-ttu-id="0a299-281">例如: </span><span class="sxs-lookup"><span data-stu-id="0a299-281">For example:</span></span>  
  
|<span data-ttu-id="0a299-282">組件和範例的數目 `ipString`</span><span class="sxs-lookup"><span data-stu-id="0a299-282">Number of parts and example `ipString`</span></span>|<span data-ttu-id="0a299-283">IPAddress 的 IPv4 位址</span><span class="sxs-lookup"><span data-stu-id="0a299-283">IPv4 address for IPAddress</span></span>|  
|--------------------------------------------|--------------------------------|  
|<span data-ttu-id="0a299-284">1 -- "65535"</span><span class="sxs-lookup"><span data-stu-id="0a299-284">1 -- "65535"</span></span>|<span data-ttu-id="0a299-285">0.0.255.255</span><span class="sxs-lookup"><span data-stu-id="0a299-285">0.0.255.255</span></span>|  
|<span data-ttu-id="0a299-286">2 -- "20.2"</span><span class="sxs-lookup"><span data-stu-id="0a299-286">2 -- "20.2"</span></span>|<span data-ttu-id="0a299-287">20.0.0.2</span><span class="sxs-lookup"><span data-stu-id="0a299-287">20.0.0.2</span></span>|  
|<span data-ttu-id="0a299-288">2 -- "20.65535"</span><span class="sxs-lookup"><span data-stu-id="0a299-288">2 -- "20.65535"</span></span>|<span data-ttu-id="0a299-289">20.0.255.255</span><span class="sxs-lookup"><span data-stu-id="0a299-289">20.0.255.255</span></span>|  
|<span data-ttu-id="0a299-290">3 -- "128.1.2"</span><span class="sxs-lookup"><span data-stu-id="0a299-290">3 -- "128.1.2"</span></span>|<span data-ttu-id="0a299-291">128.1.0.2</span><span class="sxs-lookup"><span data-stu-id="0a299-291">128.1.0.2</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="0a299-292">下列程式碼將會包含一個 IP 位址在點線四標記法中 ipv4 或 ipv6 的執行個體的冒號十六進位標記法的字串轉換<xref:System.Net.IPAddress>類別。</span><span class="sxs-lookup"><span data-stu-id="0a299-292">The following code converts a string that contains an IP address, in dotted-quad notation for IPv4 or in colon-hexadecimal notation for IPv6, into an instance of the <xref:System.Net.IPAddress> class.</span></span> <span data-ttu-id="0a299-293">然後它會使用多載<xref:System.Net.IPAddress.ToString%2A>方法，以顯示在標準標記法的位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-293">Then it uses the overloaded <xref:System.Net.IPAddress.ToString%2A> method to display the address in standard notation.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.Parse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CPP/parse.cpp#1)]
 [!code-csharp[System.Net.IPAddress.Parse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CS/parse.cs#1)]
 [!code-vb[System.Net.IPAddress.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a299-294">
            <paramref name="ipString" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-294">
              <paramref name="ipString" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="0a299-295">
            <paramref name="ipString" /> 不是有效的 IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-295">
              <paramref name="ipString" /> is not a valid IP address.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeId">
      <MemberSignature Language="C#" Value="public long ScopeId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ScopeId" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.ScopeId" />
      <MemberSignature Language="VB.NET" Value="Public Property ScopeId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ScopeId { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ScopeId : int64 with get, set" Usage="System.Net.IPAddress.ScopeId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0a299-296">取得或設定 IPv6 位址範圍識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-296">Gets or sets the IPv6 address scope identifier.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0a299-297">指定位址範圍的長整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-297">A long integer that specifies the scope of the address.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-298">意義<xref:System.Net.IPAddress.ScopeId%2A>使用它的內容而有所不同。</span><span class="sxs-lookup"><span data-stu-id="0a299-298">The meaning of <xref:System.Net.IPAddress.ScopeId%2A> changes depending on the context in which it is used.</span></span>  
  
-   <span data-ttu-id="0a299-299">連結-本機位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-299">Link-local address.</span></span> <span data-ttu-id="0a299-300">在主機上具有多個介面連接到不同的連結，相同的連結-本機位址可以指派給多個介面。</span><span class="sxs-lookup"><span data-stu-id="0a299-300">On a host with multiple interfaces connected to separate links, the same link-local address can be assigned to multiple interfaces.</span></span> <span data-ttu-id="0a299-301">若要消除此模稜兩可，範圍識別項用來指定哪些訊息交換的介面。</span><span class="sxs-lookup"><span data-stu-id="0a299-301">To eliminate this ambiguity, a scope identifier is used to specify the interface over which messages are exchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a299-302">連結-本機位址，格式首碼 (FP) FE80 所識別節點時使用的相同連結上的相鄰節點通訊。</span><span class="sxs-lookup"><span data-stu-id="0a299-302">Link-local addresses, identified by the Format Prefix (FP) FE80, are used by nodes when communicating with neighboring nodes on the same link.</span></span>  
  
-   <span data-ttu-id="0a299-303">網站-本機位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-303">Site-local addresses.</span></span> <span data-ttu-id="0a299-304">主機可以連接到多個站台。</span><span class="sxs-lookup"><span data-stu-id="0a299-304">A host can be connected to multiple sites.</span></span> <span data-ttu-id="0a299-305">在此情況下，範圍識別項會表示特定站台彼此通訊。</span><span class="sxs-lookup"><span data-stu-id="0a299-305">In this case, a scope identifier is used to indicate a specific site to communicate with.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a299-306">私人內部網路上通訊時，節點會使用格式首碼 (FP) FEC0 中，以識別的網站-本機位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-306">Site-local addresses, identified by the Format Prefix (FP) FEC0, are used by nodes when communicating on private intranets.</span></span>  
  
 <span data-ttu-id="0a299-307">用來指定的標記法`ScopeId`的位址是`Address%ScopeId`。</span><span class="sxs-lookup"><span data-stu-id="0a299-307">The notation that is used to specify the `ScopeId` with an address is `Address%ScopeId`.</span></span> <span data-ttu-id="0a299-308">例如：`FE80::5EFE:192.168.41.30%2.`</span><span class="sxs-lookup"><span data-stu-id="0a299-308">For example, `FE80::5EFE:192.168.41.30%2.`</span></span>  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="0a299-309">
            <see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-309">
              <see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a299-310">
            <paramref name="scopeId" /> &lt; 0  \- 或 -  -   <paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-310">
              <paramref name="scopeId" /> &lt; 0  \- or -  -   <paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="iPAddress.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0a299-311">將網際網路位址轉換為其標準標記法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-311">Converts an Internet address to its standard notation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-312">字串，包含使用 IPv4 點分隔四組數字和 IPv6 冒號分隔十六進位之其中一種標記法的 IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-312">A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-313"><xref:System.Net.IPAddress.ToString%2A>方法會將轉換的 IP 位址，儲存在<xref:System.Net.IPAddress.Address%2A>IPv4 以點分隔四或 IPv6 冒號十六進位標記法的屬性。</span><span class="sxs-lookup"><span data-stu-id="0a299-313">The <xref:System.Net.IPAddress.ToString%2A> method converts the IP address that is stored in the <xref:System.Net.IPAddress.Address%2A> property to either IPv4 dotted-quad or IPv6 colon-hexadecimal notation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="0a299-314">位址家族是 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />，而且位址是錯誤的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-314">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> and the address is bad.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryFormat(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  -&gt; bool" Usage="iPAddress.TryFormat (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As String, ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">
          <span data-ttu-id="0a299-315">要驗證的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-315">The string to validate.</span>
          </span>
        </param>
        <param name="address">
          <span data-ttu-id="0a299-316">字串的 <see cref="T:System.Net.IPAddress" /> 版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-316">The <see cref="T:System.Net.IPAddress" /> version of the string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0a299-317">判斷字串是否為有效的 IP 位址。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-317">Determines whether a string is a valid IP address.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0a299-318">如果 <paramref name="ipString" /> 可以剖析為 IP 位址，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="0a299-318">
              <see langword="true" /> if <paramref name="ipString" /> was able to be parsed as an IP address; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a299-319">請注意，這個方法會接受為有效可以剖析為 ipString 值<xref:System.Int64>，，然後將該 Int64 視為以網路位元組順序，其方式類似於 IP 位址的長整數值，<xref:System.Net.IPAddress.%23ctor%2A>建構函式會。</span><span class="sxs-lookup"><span data-stu-id="0a299-319">Note that this method accepts as valid an ipString value that can be parsed as an <xref:System.Int64>, and then treats that Int64 as the long value of an IP address in network byte order, similar to the way that the <xref:System.Net.IPAddress.%23ctor%2A> constructor does.</span></span> <span data-ttu-id="0a299-320">這表示此方法傳回如果 Int64 會剖析成功，則為 true，即使它代表不是有效的 IP 位址的位址。</span><span class="sxs-lookup"><span data-stu-id="0a299-320">This means that this method returns true if the Int64 is parsed successfully, even if it represents an address that's not a valid IP address.</span></span> <span data-ttu-id="0a299-321">例如，如果 ipString"1"，這個方法會傳回 true 即使"1"（或 0.0.0.1） 不是有效的 IP 位址，以及您可能會希望此方法以傳回 false。</span><span class="sxs-lookup"><span data-stu-id="0a299-321">For example, if ipString is "1", this method returns true even though "1" (or 0.0.0.1) is not a valid IP address and you might expect this method to return false.</span></span> <span data-ttu-id="0a299-322">修正這個 bug 會破壞現有的應用程式，因此不會變更目前的行為。</span><span class="sxs-lookup"><span data-stu-id="0a299-322">Fixing this bug would break existing apps, so the current behavior will not be changed.</span></span> <span data-ttu-id="0a299-323">您的程式碼可以確保它只使用這個方法來剖析十進位格式的 IP 位址，以避免這種行為。</span><span class="sxs-lookup"><span data-stu-id="0a299-323">Your code can avoid this behavior by ensuring that it only uses this method to parse IP addresses in dotted-decimal format.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryWriteBytes(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  -&gt; bool" Usage="iPAddress.TryWriteBytes (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>