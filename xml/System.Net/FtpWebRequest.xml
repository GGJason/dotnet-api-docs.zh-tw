<Type Name="FtpWebRequest" FullName="System.Net.FtpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="312c655538f5166618b06e175da06b027f982ad3" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51905050" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FtpWebRequest : System.Net.WebRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FtpWebRequest extends System.Net.WebRequest" />
  <TypeSignature Language="DocId" Value="T:System.Net.FtpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FtpWebRequest&#xA;Inherits WebRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class FtpWebRequest sealed : System::Net::WebRequest" />
  <TypeSignature Language="F#" Value="type FtpWebRequest = class&#xA;    inherit WebRequest" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>實作檔案傳輸通訊協定 (FTP) 用戶端。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

>  [!IMPORTANT]
>  我們不建議您改用`FtpWebRequest`開發新的類別。 如需詳細資訊和替代項目`FtpWebRequest`，請參閱 < [WebRequest 不應使用](https://github.com/dotnet/platform-compat/blob/master/docs/DE0003.md)GitHub 上。

 若要取得的執行個體<xref:System.Net.FtpWebRequest>，使用<xref:System.Net.WebRequest.Create%2A>方法。 您也可以使用<xref:System.Net.WebClient>上傳和下載資訊從 FTP 伺服器的類別。 使用任一種方法，當您指定使用 FTP 配置網路資源 (例如`"ftp://contoso.com"`)<xref:System.Net.FtpWebRequest>類別讓您能夠以程式設計方式與 FTP 伺服器互動。  
  
 URI 可以是相對或絕對。 如果 URI 的形式`"ftp://contoso.com/%2fpath"`(%2f 是逸出 '/')，然後 URI 是絕對的目前的目錄是`/path`。 如果，不過，URI 的格式是`"ftp://contoso.com/path"`，.NET Framework 第一次登入 FTP 伺服器 (使用使用者名稱和密碼設定<xref:System.Net.FtpWebRequest.Credentials%2A>屬性)，則目前的目錄設為`<UserLoginDirectory>/path`。  
  
 您必須擁有有效的使用者名稱和密碼的伺服器或伺服器必須允許匿名登入。 您可以指定用來設定連線到伺服器的認證<xref:System.Net.FtpWebRequest.Credentials%2A>屬性，或者您可以將其併入<xref:System.Uri.UserInfo%2A>URI 的一部分傳遞至<xref:System.Net.WebRequest.Create%2A>方法。 如果您納入<xref:System.Uri.UserInfo%2A>URI 中的資訊<xref:System.Net.FtpWebRequest.Credentials%2A>屬性設定為新的網路認證，使用指定的使用者名稱和密碼資訊。  
  
> [!CAUTION]
>  除非<xref:System.Net.FtpWebRequest.EnableSsl%2A>屬性是`true`，所有資料和命令，包括您的使用者名稱和密碼資訊，都傳送到伺服器以純文字。 監視網路流量的任何人都可以檢視您的認證，並使用它們來連線到伺服器。 如果您要連接到 FTP 伺服器需要認證，並支援 Secure Sockets Layer (SSL)，您應該設定<xref:System.Net.FtpWebRequest.EnableSsl%2A>至`true`。  
  
 您必須擁有<xref:System.Net.WebPermission>來存取 FTP 資源; 否則<xref:System.Security.SecurityException>擲回例外狀況。  
  
 指定要傳送至伺服器所設定的 FTP 命令<xref:System.Net.FtpWebRequest.Method%2A>屬性中定義的值為<xref:System.Net.WebRequestMethods.Ftp>結構。 若要傳輸的文字資料，變更<xref:System.Net.FtpWebRequest.UseBinary%2A>從其預設值的屬性 (`true`) 以`false`。 如需詳細資訊和限制，請參閱<xref:System.Net.FtpWebRequest.Method%2A>。  
  
 使用時<xref:System.Net.FtpWebRequest>物件，將檔案上傳至伺服器，您必須將檔案內容寫入要求資料流取得藉由呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法或其非同步對應項目<xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>方法。 您必須寫入資料流，並傳送要求之前關閉資料流。  
  
 要求時，會傳送到伺服器上，藉由呼叫<xref:System.Net.FtpWebRequest.GetResponse%2A>方法或其非同步對應項目<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>和<xref:System.Net.FtpWebRequest.EndGetResponse%2A>方法。 要求的作業完成時，<xref:System.Net.FtpWebResponse>會傳回物件。 <xref:System.Net.FtpWebResponse>物件提供的作業，以及從伺服器下載的任何資料的狀態。  
  
 您可以設定的讀取或寫入使用的伺服器逾時值<xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A>屬性。 如果超過逾時期限時，呼叫的方法會擲回<xref:System.Net.WebException>具有<xref:System.Net.WebExceptionStatus>設定為<xref:System.Net.WebExceptionStatus.Timeout>。  
  
 如果命令成功，請從 FTP 伺服器下載檔案，回應物件的資料流中會提供 要求檔案的內容。 您可以藉由呼叫來存取這個資料流<xref:System.Net.FtpWebResponse.GetResponseStream%2A>方法。 如需詳細資訊，請參閱<xref:System.Net.FtpWebResponse>。  
  
 如果<xref:System.Net.FtpWebRequest.Proxy%2A>屬性，請直接設定或組態檔中，與 FTP 伺服器通訊都會經過指定的 proxy。 如果指定的 proxy 是 HTTP proxy，只有<xref:System.Net.WebRequestMethods.Ftp.DownloadFile>， <xref:System.Net.WebRequestMethods.Ftp.ListDirectory>，和<xref:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails>支援命令。  
  
 下載的二進位內容只會快取;也就是使用所接收的內容<xref:System.Net.WebRequestMethods.Ftp.DownloadFile>命令搭配<xref:System.Net.FtpWebRequest.UseBinary%2A>屬性設定為`true`。  
  
 多個<xref:System.Net.FtpWebRequest>s 盡可能重複使用現有的連線。  
  
 如需有關 FTP 通訊協定的詳細資訊，請參閱[RFC 959： 檔案傳輸通訊協定](https://www.ietf.org/rfc/rfc959.txt)。  
  
   
  
## Examples  
 下列程式碼範例示範如何從 FTP 伺服器刪除檔案。  
  
 [!code-cpp[NCLFtpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#4)]
 [!code-csharp[NCLFtpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#4)]  
  
 下列程式碼範例示範如何從 FTP 伺服器下載檔案，使用<xref:System.Net.WebClient>類別。  
  
 [!code-cpp[NCLFtpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#5)]
 [!code-csharp[NCLFtpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#5)]  
  
 下列程式碼範例示範如何使用非同步作業的檔案上傳至 FTP 伺服器。  
  
 [!code-cpp[NCLFtpAsync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#1)]
 [!code-csharp[NCLFtpAsync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">用來存取這項要求所參考的資源。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Connect" />。</permission>
    <altmember cref="T:System.Net.FtpWebResponse" />
    <altmember cref="T:System.Net.FtpStatusCode" />
    <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
    <altmember cref="T:System.Net.WebRequest" />
    <altmember cref="T:System.Net.WebResponse" />
    <altmember cref="T:System.Net.WebClient" />
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="ftpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束非同步 FTP 作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有進行中的作業，這個方法沒有任何作用。 如果正在進行中的檔案傳輸，這個方法會結束此傳輸。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範使用者可以列印文件的終止，請從本機目錄的檔案伺服器的非同步上傳。  
  
 [!code-cpp[NCLFtpClient#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#10)]
 [!code-csharp[NCLFtpClient#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="ftpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義物件，包含作業的相關資訊。 作業完成時，這個物件會傳遞給「回呼」<c></c>委派。</param>
        <summary>開始非同步開啟要求的內容資料流，以進行寫入。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 執行個體，指出作業的狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須完成的非同步作業，藉由呼叫<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>方法。 通常<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>所參考的方法會呼叫`callback`。 若要判斷作業的狀態，請檢查屬性<xref:System.IAsyncResult>這個方法所傳回的物件。  
  
 這個方法不會封鎖等待資料流。 若要封鎖，請呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>取代此方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱 < [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例將示範如何開始非同步作業以取得要求的資料流。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Net.FtpWebRequest>類別概觀。  
  
 [!code-cpp[NCLFtpAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#4)]
 [!code-csharp[NCLFtpAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">對這個方法的上一個呼叫或 <see cref="M:System.Net.FtpWebRequest.GetRequestStream" /> 尚未完成。</exception>
        <exception cref="T:System.Net.WebException">無法建立與 FTP 伺服器的連接。</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.FtpWebRequest.Method" /> 屬性未設定為 <see cref="F:System.Net.WebRequestMethods.Ftp.UploadFile" />。</exception>
        <block subset="none" type="usage">
          <para>這個方法會產生網路流量。</para>
        </block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="ftpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義物件，包含作業的相關資訊。 作業完成時，這個物件會傳遞給「回呼」<c></c>委派。</param>
        <summary>開始以非同步的方式傳送要求，並且接收來自 FTP 伺服器的回應。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 執行個體，指出作業的狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須完成的非同步作業，藉由呼叫<xref:System.Net.FtpWebRequest.EndGetResponse%2A>方法。 通常<xref:System.Net.FtpWebRequest.EndGetResponse%2A>所參考的方法會呼叫`callback`。 若要判斷作業的狀態，請檢查屬性<xref:System.IAsyncResult>所傳回的物件<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法。  
  
 如果<xref:System.Net.FtpWebRequest.Proxy%2A>屬性，請直接設定或組態檔中，與 FTP 伺服器通訊都會經過指定的 proxy。  
  
 <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 不會封鎖在等候伺服器回應時。 若要封鎖，請呼叫<xref:System.Net.FtpWebRequest.GetResponse%2A>方法取代<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱 < [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
 在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  如果<xref:System.Net.WebException>會擲回，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>要決定從伺服器回應的例外狀況的屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何結束非同步作業，以取得要求的資料流，然後再啟動 取得回應的要求。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Net.FtpWebRequest>類別概觀。  
  
 [!code-cpp[NCLFtpAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#5)]
 [!code-csharp[NCLFtpAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">針對這個執行個體，已經呼叫 <see cref="M:System.Net.FtpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />。</exception>
        <block subset="none" type="usage">
          <para>這個方法會產生網路流量。</para>
        </block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.FtpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來建立與 FTP 伺服器之加密連接的憑證。</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> 物件，包含用戶端憑證。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端憑證用來驗證用戶端在初始的 SSL 連線交涉期間。 如需詳細資訊，請參閱<xref:System.Net.FtpWebRequest.EnableSsl%2A>。  
  
> [!NOTE]
>  .NET Framework 在建立快取的 SSL 工作階段，並嘗試盡可能重複使用快取的工作階段，對新的要求。 嘗試將重複使用的 SSL 工作階段時，.NET Framework 使用的第一個元素<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果有一個），或嘗試重複使用 「 匿名 」 工作階段，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>是空的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">為設定作業指定的值為 <see langword="null" />。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.FtpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定連接群組的名稱，這個連接群組包含用來傳送目前要求的服務點。</summary>
        <value>
          <see cref="T:System.String" /> 值，包含連接群組名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 連接群組關聯至一組要求特定連接或連接集合。 可以重複使用的連接群組中的連線，只有起始的要求在相同的應用程式網域中，當要求的認證相同，而且要求指定的連接群組名稱。 當要求未指定連接群組名稱時，可以使用所要求的伺服器不被使用連接群組相關聯的任何現有連線。 認證不相同時，現有的連接已關閉，且必須重新驗證新的要求。  
  
 使用連接群組可以改善效能，因為這可讓所有使用者重複使用連線使用者的認證通過驗證的要求。  
  
 變更<xref:System.Net.FtpWebRequest.ConnectionGroupName%2A>屬性之後呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法會使<xref:System.InvalidOperationException>例外狀況。  
  
   
  
## Examples  
 下列程式碼範例會擷取這個屬性的值。  
  
 [!code-cpp[NCLFtpClient#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#16)]
 [!code-csharp[NCLFtpClient#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <related type="Article" href="~/docs/framework/network-programming/managing-connections.md">管理連接</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.FtpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Net.FtpWebRequest" /> 類別忽略的值。</summary>
        <value>應忽略的 <see cref="T:System.Int64" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ContentLength%2A>屬性只為了與的其他實作相容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>類別。 若要使用沒有理由<xref:System.Net.FtpWebRequest.ContentLength%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentOffset">
      <MemberSignature Language="C#" Value="public long ContentOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentOffset" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentOffset As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentOffset { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentOffset : int64 with get, set" Usage="System.Net.FtpWebRequest.ContentOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個要求所下載之檔案的位元組位移。</summary>
        <value>
          <see cref="T:System.Int64" /> 執行個體，指定檔案位移 (以位元組為單位)。 預設值是零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.Net.FtpWebRequest.ContentOffset%2A>從 FTP 伺服器下載檔案時的屬性。 此位移表示標記的下載資料開始的伺服器的檔案中的位置。 從檔案開頭的位元組數目為指定的位移第一個位元組的位移為零。  
  
 設定<xref:System.Net.FtpWebRequest.ContentOffset%2A>會導致<xref:System.Net.FtpWebRequest>將重新啟動 (`REST`) 命令至伺服器。 如果您要將資料上傳到伺服器，則大多數的 FTP 伺服器實作會忽略此命令。  
  
 變更<xref:System.Net.FtpWebRequest.ContentOffset%2A>之後呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法會使<xref:System.InvalidOperationException>例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範從一部伺服器和將已下載的資料附加到本機檔案的下載檔的一部分。  
  
 [!code-cpp[NclFtpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#7)]
 [!code-csharp[NclFtpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">這個屬性的指定值小於零。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.FtpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>永遠擲回 <see cref="T:System.NotSupportedException" />。</summary>
        <value>永遠擲回 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ContentType%2A>屬性只為了與的其他實作相容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>類別。 若要使用沒有理由<xref:System.Net.FtpWebRequest.ContentType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支援內容類型資訊。</exception>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.FtpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來與 FTP 伺服器通訊的認證。</summary>
        <value>
          <see cref="T:System.Net.ICredentials" /> 執行個體；如果屬性尚未設定，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要使用匿名登入進行連接時指定的認證。 您必須設定<xref:System.Net.FtpWebRequest.Credentials%2A>屬性所使用的認證類型<xref:System.Net.NetworkCredential>; 這可確保該使用者名稱和密碼可以讀取及傳送至伺服器。  
  
> [!CAUTION]
>  除非伺服器傳輸到伺服器時，不會加密認證資訊<xref:System.Net.FtpWebRequest.EnableSsl%2A>屬性設定為`true`。  
  
 變更<xref:System.Net.FtpWebRequest.Credentials%2A>之後呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法會使<xref:System.InvalidOperationException>例外狀況。  
  
   
  
## Examples  
 下列程式碼範例會擷取這個屬性的值，並用它來顯示使用者名稱。  
  
 [!code-cpp[NCLFtpClient#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#14)]
 [!code-csharp[NCLFtpClient#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">為設定作業指定的值為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">為設定作業，指定 <see cref="T:System.Net.ICredentials" /> 型別以外的 <see cref="T:System.Net.NetworkCredential" />。</exception>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.FtpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>為所有 FTP 要求，定義預設的快取原則。</summary>
        <value>
          <see cref="T:System.Net.Cache.RequestCachePolicy" />，定義 FTP 要求的快取原則。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用所接收的內容<xref:System.Net.WebRequestMethods.Ftp.DownloadFile>命令會快取。  
  
 下表描述的快取原則上的 FTP 影響<xref:System.Net.FtpWebRequest>。  
  
|原則|作用|  
|------------|------------|  
|<xref:System.Net.Cache.RequestCacheLevel.Default>|如果資源是新的、 內容長度正確無誤，且到期、 修改和內容長度屬性都存在，則會傳回快取的資源。|  
|<xref:System.Net.Cache.RequestCacheLevel.BypassCache>|從伺服器傳回的資源。|  
|<xref:System.Net.Cache.RequestCacheLevel.CacheOnly>|如果內容長度，且符合項目大小; 會傳回快取的資源否則，會擲回<xref:System.Net.WebException>。|  
|<xref:System.Net.Cache.RequestCacheLevel.CacheIfAvailable>|如果內容長度提供，且符合項目大小; 會傳回快取的資源否則，資源從伺服器下載，並傳回給呼叫者。|  
|<xref:System.Net.Cache.RequestCacheLevel.Revalidate>|如果時間戳記的快取的資源是與伺服器上資源的時間戳記相同，會傳回快取的資源否則為資源是從伺服器下載、 儲存在快取，並傳回給呼叫端。|  
|<xref:System.Net.Cache.RequestCacheLevel.Reload>|從伺服器下載的資源、 將它儲存在快取，並傳回給呼叫端。|  
|<xref:System.Net.Cache.RequestCacheLevel.NoCacheNoStore>|如果快取的資源存在，則會將它刪除。 資源從伺服器下載，並傳回給呼叫者。|  
  
> [!NOTE]
>  設定<xref:System.Net.FtpWebRequest.DefaultCachePolicy%2A>會覆寫任何組態設定。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">呼叫端嘗試將這個屬性設為 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/0eb0c5cb-dd97-484d-8614-785e88877abb">defaultFtpCachePolicy （網路設定）</related>
      </Docs>
    </Member>
    <Member MemberName="EnableSsl">
      <MemberSignature Language="C#" Value="public bool EnableSsl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSsl" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.EnableSsl" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSsl As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSsl { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSsl : bool with get, set" Usage="System.Net.FtpWebRequest.EnableSsl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" />，指定是否應使用 SSL 連線。</summary>
        <value>如果控制和資料傳輸已加密，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  除非<xref:System.Net.FtpWebRequest.EnableSsl%2A>屬性是`true`，所有資料和命令，包括您的使用者名稱和密碼資訊，都傳送到伺服器以純文字。 監視網路流量的任何人都可以檢視您的認證，並使用它們來連線到伺服器。 如果您要連接到 FTP 伺服器需要認證，並支援 SSL，您應該設定<xref:System.Net.FtpWebRequest.EnableSsl%2A>至`true`。  
  
 `"AUTH TLS"`命令時，會傳送到伺服器上，若要要求加密工作階段。 如果伺服器無法辨識此命令，您會收到<xref:System.Net.WebException>例外狀況。  
  
   
  
## Examples  
 下列的程式碼範例會使用加密的連線，若要下載的目錄清單從 FTP 伺服器。  
  
 [!code-cpp[NCLFtpClient#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#8)]
 [!code-csharp[NCLFtpClient#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已建立與 FTP 伺服器的連接。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="ftpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">作業啟動時所傳回的 <see cref="T:System.IAsyncResult" /> 物件。</param>
        <summary>結束由 <see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 所啟動的暫止非同步作業。</summary>
        <returns>與這個執行個體關聯的可寫入 <see cref="T:System.IO.Stream" /> 執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果作業尚未完成，<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>方法會封鎖直到作業完成為止。 若要判斷作業是否已經完成，請檢查<xref:System.IAsyncResult.IsCompleted%2A>屬性，然後再呼叫<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>。  
  
 除了 < 例外狀況 > 中所述的例外狀況<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>開啟供寫入資料流時所擲回的例外狀況重新擲回。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例將示範如何結束非同步作業以取得要求的資料流。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Net.FtpWebRequest>類別概觀。  
  
 [!code-cpp[NCLFtpAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#5)]
 [!code-csharp[NCLFtpAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">未呼叫 <see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />，取得 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">已針對 <paramref name="asyncResult" /> 所識別的作業，呼叫這個方法。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="ftpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">作業啟動時所傳回的 <see cref="T:System.IAsyncResult" />。</param>
        <summary>結束由 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 所啟動的暫止非同步作業。</summary>
        <returns>
          <see cref="T:System.Net.WebResponse" /> 參考，包含 <see cref="T:System.Net.FtpWebResponse" /> 執行個體。 這個物件包含 FTP 伺服器對要求的回應。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果作業尚未完成當時<xref:System.Net.FtpWebRequest.EndGetResponse%2A>呼叫方法時，<xref:System.Net.FtpWebRequest.EndGetResponse%2A>封鎖直到作業完成為止。 若要防止封鎖，請檢查<xref:System.IAsyncResult.IsCompleted%2A>屬性，然後再呼叫<xref:System.Net.FtpWebRequest.EndGetResponse%2A>。  
  
 除了 < 例外狀況 > 中所述的例外狀況<xref:System.Net.FtpWebRequest.EndGetResponse%2A>與伺服器通訊時所擲回的例外狀況重新擲回。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例將示範如何結束非同步作業以取得回應。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Net.FtpWebRequest>類別概觀。  
  
 [!code-cpp[NCLFtpAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#6)]
 [!code-csharp[NCLFtpAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">未呼叫 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />，取得 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">已針對 <paramref name="asyncResult" /> 所識別的作業，呼叫這個方法。</exception>
        <exception cref="T:System.Net.WebException">使用 HTTP Proxy 時發生錯誤。</exception>
        <block subset="none" type="usage">
          <para>這個方法會產生網路流量。</para>
        </block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <altmember cref="M:System.Net.FtpWebRequest.GetResponse" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="ftpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>擷取用來上載資料至 FTP 伺服器的資料流。</summary>
        <returns>可寫入的 <see cref="T:System.IO.Stream" /> 資料流，目前的要求會用它來儲存要傳送至伺服器的資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定要求屬性，才能呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法。 之後將資料寫入資料流中，您必須關閉再傳送要求資料流。  
  
 如果您未設定<xref:System.Net.FtpWebRequest.Method%2A>屬性，以<xref:System.Net.WebRequestMethods.Ftp.UploadFile>或<xref:System.Net.WebRequestMethods.Ftp.AppendFile>，您無法取得資料流。  
  
 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 等候資料流的區塊。 若要避免這個問題，呼叫<xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>方法取代<xref:System.Net.FtpWebRequest.GetRequestStream%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何將檔案複製到要求的資料流，並將要求傳送至伺服器，以將資料上傳，並將其附加至檔案。  
  
 [!code-cpp[NCLFtpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#3)]
 [!code-csharp[NCLFtpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 已呼叫，但尚未完成。  
  
\-或- 
HTTP Proxy 已啟用，但您嘗試使用 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />、<see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectory" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails" /> 以外的 FTP 命令。</exception>
        <exception cref="T:System.Net.WebException">無法建立與 FTP 伺服器的連接。</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.FtpWebRequest.Method" /> 屬性未設定為 <see cref="F:System.Net.WebRequestMethods.Ftp.UploadFile" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.AppendFile" />。</exception>
        <block subset="none" type="usage">
          <para>這個方法會產生網路流量。</para>
        </block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="ftpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 FTP 伺服器回應。</summary>
        <returns>
          <see cref="T:System.Net.WebResponse" /> 參考，包含 <see cref="T:System.Net.FtpWebResponse" /> 執行個體。 這個物件包含 FTP 伺服器對要求的回應。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要存取的 FTP 特定屬性，您必須轉型<xref:System.Net.WebResponse>至這個方法所傳回的物件<xref:System.Net.FtpWebResponse>。  
  
 <xref:System.Net.FtpWebRequest.GetResponse%2A> 會導致控制連線建立，可能也會建立資料連接。 <xref:System.Net.FtpWebRequest.GetResponse%2A> 封鎖，直到收到回應。 若要避免這個問題，您可以執行這項作業以非同步方式呼叫<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>並<xref:System.Net.FtpWebRequest.EndGetResponse%2A>方法，取代<xref:System.Net.FtpWebRequest.GetResponse%2A>。  
  
 如果<xref:System.Net.FtpWebRequest.Proxy%2A>屬性，請直接設定或組態檔中，與 FTP 伺服器通訊都會經過 proxy。  
  
 如果<xref:System.Net.WebException>會擲回，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>要決定從伺服器回應的例外狀況的屬性。  
  
 在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  多次呼叫<xref:System.Net.FtpWebRequest.GetResponse%2A>傳回相同的回應物件中; 要求不會重新發出。  
  
   
  
## Examples  
 下列程式碼範例示範如何將檔案複製到要求的資料流，並傳送要求，以將資料附加至伺服器的檔案。 此範例會呼叫<xref:System.Net.FtpWebRequest.GetResponse%2A>傳送要求，並封鎖，直到伺服器所傳回的回應。  
  
 [!code-cpp[NCLFtpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#3)]
 [!code-csharp[NCLFtpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">針對這個執行個體，已經呼叫 <see cref="M:System.Net.FtpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />。  
  
\-或- 
HTTP Proxy 已啟用，但您嘗試使用 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />、<see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectory" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails" /> 以外的 FTP 命令。</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="P:System.Net.FtpWebRequest.EnableSsl" /> 設為 <see langword="true" />，但伺服器不支援這項功能。  
  
\-或- 
<see cref="P:System.Net.FtpWebRequest.Timeout" /> 已指定且已經逾時。</exception>
        <block subset="none" type="usage">
          <para>這個方法會產生網路流量。</para>
        </block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.FtpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得空的 <see cref="T:System.Net.WebHeaderCollection" /> 物件。</summary>
        <value>空的 <see cref="T:System.Net.WebHeaderCollection" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.Headers%2A>屬性只為了與的其他實作相容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>類別。 若要使用沒有理由<xref:System.Net.FtpWebRequest.Headers%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.FtpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("We don't support KeepAlive = true")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定在要求完成之後，與 FTP 伺服器的控制連接是否關閉。</summary>
        <value>如果與伺服器的連接不應終結，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Net.FtpWebRequest.KeepAlive%2A>屬性設定為`false`，當您呼叫關閉控制連接<xref:System.Net.FtpWebResponse.Close%2A>方法。  
  
 變更<xref:System.Net.FtpWebRequest.KeepAlive%2A>之後呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法會使<xref:System.InvalidOperationException>例外狀況。  
  
   
  
## Examples  
 下列程式碼範例擷取並顯示針對指定的屬性值<xref:System.Net.FtpWebRequest>物件。  
  
 [!code-cpp[NCLFtpClient#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#15)]
 [!code-csharp[NCLFtpClient#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.FtpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要傳送至 FTP 伺服器的命令。</summary>
        <value>
          <see cref="T:System.String" /> 值，包含要傳送至伺服器的 FTP 命令。 預設值是 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.Method%2A>屬性會決定哪一個命令傳送至伺服器。 您設定<xref:System.Net.FtpWebRequest.Method%2A>使用的公用欄位成員中定義的字串<xref:System.Net.WebRequestMethods.Ftp>類別。 請注意，字串中定義<xref:System.Net.WebRequestMethods.Ftp>類別是唯一支援的選項，如<xref:System.Net.FtpWebRequest.Method%2A>屬性。 設定<xref:System.Net.FtpWebRequest.Method%2A>屬性設為任何其他值將會導致<xref:System.ArgumentException>例外狀況。  
  
 設定時<xref:System.Net.FtpWebRequest.Method%2A>要<xref:System.Net.WebRequestMethods.Ftp.UploadFile>，您必須先呼叫進行<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法。 無法正確的順序會導致呼叫這些成員<xref:System.Net.ProtocolViolationException>例外狀況，當您嘗試取得要求資料流。  
  
 認證提供給<xref:System.Net.FtpWebRequest>物件必須具有權限可以執行指定的方法。 如果沒有，則 FTP 命令會失敗。  
  
 若要判斷成功或失敗的命令，檢查<xref:System.Net.FtpWebResponse.StatusCode%2A>和<xref:System.Net.FtpWebResponse.StatusDescription%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會將這個屬性設定為<xref:System.Net.WebRequestMethods.Ftp.DeleteFile>。  
  
 [!code-cpp[NCLFtpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#4)]
 [!code-csharp[NCLFtpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <exception cref="T:System.ArgumentException">此方法無效。  
  
\-或- 
這個方法不受支援。  
  
\-或- 
指定多個方法。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.FtpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>永遠擲回 <see cref="T:System.NotSupportedException" />。</summary>
        <value>永遠擲回 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.PreAuthenticate%2A>屬性只為了與的其他實作相容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支援預先驗證。</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.FtpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來與 FTP 伺服器通訊的 Proxy。</summary>
        <value>負責與 FTP 伺服器通訊的 <see cref="T:System.Net.IWebProxy" /> 執行個體。 其值是在.NET Core 上<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

### <a name="on-net-framework"></a>在.NET Framework

 <xref:System.Net.FtpWebRequest.Proxy%2A>屬性會識別<xref:System.Net.IWebProxy>與 FTP 伺服器通訊的執行個體。 Proxy 是由系統設定，藉由使用組態檔和 Internet Explorer 區域網路設定。 若要指定任何 proxy，應使用，請設定<xref:System.Net.FtpWebRequest.Proxy%2A>所傳回的 proxy 執行個體<xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType>方法。 如需有關自動 proxy 偵測的詳細資訊，請參閱 <<c0> [ 自動 Proxy 偵測](~/docs/framework/network-programming/automatic-proxy-detection.md)。  
  
 您必須設定<xref:System.Net.FtpWebRequest.Proxy%2A>之前將資料寫入至要求的資料流，或取得回應。 變更<xref:System.Net.FtpWebRequest.Proxy%2A>之後呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法會使<xref:System.InvalidOperationException>例外狀況。  
  
 <xref:System.Net.FtpWebRequest>類別支援 HTTP 和 ISA 防火牆用戶端 proxy。  
  
 如果指定的 proxy 是 HTTP proxy，只有<xref:System.Net.WebRequestMethods.Ftp.DownloadFile>， <xref:System.Net.WebRequestMethods.Ftp.ListDirectory>，和<xref:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails>支援命令。  
  
### <a name="on-net-core"></a>在.NET Core   

`FtpWebRequest.Proxy`不支援屬性。 設定屬性沒有任何作用。 取得此屬性值傳回`null`。 


## Examples  
 下列程式碼範例會顯示這個屬性值。  
  
 [!code-cpp[NCLFtpClient#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#16)]
 [!code-csharp[NCLFtpClient#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">這個屬性不可設為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <altmember cref="T:System.Net.WebProxy" />
        <altmember cref="T:System.Net.GlobalProxySelection" />
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.FtpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定讀取或寫入資料流的逾時。</summary>
        <value>讀取或寫入逾時前的毫秒數。預設值為 300,000 毫秒 (5 分鐘)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A>寫入至所傳回的資料流時使用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法或從傳回的資料流讀取<xref:System.Net.FtpWebResponse.GetResponseStream%2A>方法。  
  
 具體而言，<xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A>屬性控制的逾時值<xref:System.IO.Stream.Read%2A>方法，用來讀取傳回之資料流<xref:System.Net.FtpWebResponse.GetResponseStream%2A>方法，以及<xref:System.IO.Stream.Write%2A>方法，用來寫入資料流由<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法。 如果超過逾時期限時，呼叫的方法會擲回<xref:System.Net.WebException>具有<xref:System.Net.WebExceptionStatus>設定為<xref:System.Net.WebExceptionStatus.Timeout>。  
  
 若要指定的等候要求完成的時間量，請使用<xref:System.Net.FtpWebRequest.Timeout%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已傳送此要求。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定給設定作業的值小於或等於零，並且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RenameTo">
      <MemberSignature Language="C#" Value="public string RenameTo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RenameTo" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.RenameTo" />
      <MemberSignature Language="VB.NET" Value="Public Property RenameTo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RenameTo { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenameTo : string with get, set" Usage="System.Net.FtpWebRequest.RenameTo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定重新命名檔案的新名稱。</summary>
        <value>要重新命名之檔案的新名稱。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">為設定作業所指定的值為 <see langword="null" /> 或空字串。</exception>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.FtpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個執行個體所要求的 URI。</summary>
        <value>
          <see cref="T:System.Uri" /> 執行個體，識別使用檔案傳輸通訊協定所存取的資源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Net.FtpWebRequest.RequestUri%2A>屬性是 URI 時指定<xref:System.Net.WebRequest.Create%2A>方法呼叫來取得這個執行個體。  
  
   
  
## Examples  
 下列程式碼範例會顯示這個屬性值。  
  
 [!code-cpp[NCLFtpClient#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#14)]
 [!code-csharp[NCLFtpClient#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.FtpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來連接到 FTP 伺服器的 <see cref="T:System.Net.ServicePoint" /> 物件。</summary>
        <value>可以用來自訂連接行為的 <see cref="T:System.Net.ServicePoint" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有<xref:System.Net.ServicePoint>物件存在，一個建立 FTP 伺服器。 若要設定的 FTP 伺服器開啟的連線數目上限，將<xref:System.Net.ServicePoint.ConnectionLimit%2A>屬性<xref:System.Net.ServicePoint>這個屬性所傳回的執行個體。  
  
   
  
## Examples  
 下列程式碼範例會擷取要求的服務點和其中一個設定的連線數目上限。  
  
 [!code-cpp[NCLFtpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#1)]
 [!code-csharp[NCLFtpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.FtpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定等待要求的毫秒數。</summary>
        <value>
          <see cref="T:System.Int32" /> 值，包含要求逾時之前等待的毫秒數。預設值是 <see cref="F:System.Threading.Timeout.Infinite" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定無限值，設定<xref:System.Net.FtpWebRequest.Timeout%2A>屬性設<xref:System.Threading.Timeout.Infinite>(-1)。 這是預設值。  
  
 <xref:System.Net.FtpWebRequest.Timeout%2A> 會提出同步要求的毫秒數<xref:System.Net.FtpWebRequest.GetResponse%2A>方法會等候回應且<xref:System.Net.FtpWebRequest.GetRequestStream%2A>; 方法等候資料流。 如果資源沒有回應的逾時期限內，要求會擲回<xref:System.Net.WebException>具有<xref:System.Net.WebException.Status%2A>屬性設定為<xref:System.Net.WebExceptionStatus.Timeout>。  
  
 變更<xref:System.Net.FtpWebRequest.Timeout%2A>之後呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法會使<xref:System.InvalidOperationException>例外狀況。  
  
 網域名稱系統 (DNS) 查詢可能需要最多 15 秒鐘傳回或逾時。如果您的要求包含需要解析的主機名稱，而且您設定<xref:System.Net.FtpWebRequest.Timeout%2A>的值小於 15 秒，可能需要 15 秒以上之前<xref:System.Net.WebException>就會擲回以指出您的要求逾時。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[NCLFtpClient#23](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#23)]
 [!code-csharp[NCLFtpClient#23](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的值小於零且不是 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="UseBinary">
      <MemberSignature Language="C#" Value="public bool UseBinary { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseBinary" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UseBinary" />
      <MemberSignature Language="VB.NET" Value="Public Property UseBinary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseBinary { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseBinary : bool with get, set" Usage="System.Net.FtpWebRequest.UseBinary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定檔案傳輸的資料型別。</summary>
        <value>
          <see langword="true" /> 向伺服器表示，要傳輸的資料是二進位資料； <see langword="false" /> 則表示資料是文字。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您傳送二進位資料，例如影像，會將此屬性設定為`true`。 如果您要傳送的文字，將屬性設定為`false`。 指定`true`會導致<xref:System.Net.FtpWebRequest>傳送`"TYPE I"`命令至伺服器。 指定`false`會導致<xref:System.Net.FtpWebRequest>傳送`"Type A"`命令至伺服器。 FTP 伺服器可以忽略這些命令。  
  
 變更<xref:System.Net.FtpWebRequest.UseBinary%2A>之後呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法會使<xref:System.InvalidOperationException>例外狀況。  
  
   
  
## Examples  
 下列程式碼範例擷取並顯示針對指定的屬性值<xref:System.Net.FtpWebRequest>物件。  
  
 [!code-cpp[NCLFtpClient#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#15)]
 [!code-csharp[NCLFtpClient#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.FtpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>永遠擲回 <see cref="T:System.NotSupportedException" />。</summary>
        <value>永遠擲回 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.UseDefaultCredentials%2A>屬性只為了與的其他實作相容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>類別。 若要使用沒有理由<xref:System.Net.FtpWebRequest.UseDefaultCredentials%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支援預設認證。</exception>
      </Docs>
    </Member>
    <Member MemberName="UsePassive">
      <MemberSignature Language="C#" Value="public bool UsePassive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UsePassive" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UsePassive" />
      <MemberSignature Language="VB.NET" Value="Public Property UsePassive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UsePassive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UsePassive : bool with get, set" Usage="System.Net.FtpWebRequest.UsePassive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用戶端應用程式之資料傳輸處理序的行為。</summary>
        <value>如果用戶端應用程式的資料傳輸處理序會接聽資料連接埠上的連接，則為 <see langword="false" />；如果用戶端應該在資料連接埠上啟始連接，則為 <see langword="true" />。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.Net.FtpWebRequest.UsePassive%2A>屬性，以`true`會傳送 「`PASV"`命令至伺服器。 此命令會要求伺服器資料連接埠上接聽並等候連接，而不是起始一個收到傳送命令。  
  
 如需描述使用指定的行為<xref:System.Net.FtpWebRequest.UsePassive%2A>，請參閱 < [RFC 959: 「 檔案傳輸通訊協定 」，第 3.2 節: 「 建立資料連線 」 和區段 4.1.2: 「 傳送參數命令 」](https://www.ietf.org/rfc/rfc959.txt)。  
  
 變更<xref:System.Net.FtpWebRequest.UsePassive%2A>之後呼叫<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法會使<xref:System.InvalidOperationException>例外狀況。  
  
 如果<xref:System.Net.FtpWebRequest.UsePassive%2A>設為`true`、 FTP 伺服器可能不會傳送檔案的大小和下載進度可以永遠是零。 如果<xref:System.Net.FtpWebRequest.UsePassive%2A>設為`false`，防火牆可以發出警示，並封鎖檔案下載。  
  
   
  
## Examples  
 下列程式碼範例擷取並顯示針對指定的屬性值<xref:System.Net.FtpWebRequest>物件。  
  
 [!code-cpp[NCLFtpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#6)]
 [!code-csharp[NCLFtpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">由於已經在進行的要求，已為這個屬性指定新的值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
  </Members>
</Type>