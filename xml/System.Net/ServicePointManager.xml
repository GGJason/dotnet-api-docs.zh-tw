<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f72344dcdd86e1e2513d198545e7195049d4ea26" />
    <Meta Name="ms.sourcegitcommit" Value="3507e865a3613c00760f25ad1045aaa11bae4dd8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/23/2018" />
    <Meta Name="ms.locfileid" Value="31779843" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>管理 <see cref="T:System.Net.ServicePoint" /> 物件的集合。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> 是用來建立、 維護及刪除的執行個體的靜態類別<xref:System.Net.ServicePoint>類別。  
  
 當應用程式要求對網際網路資源統一資源識別元 (URI) 連接透過<xref:System.Net.ServicePointManager>物件<xref:System.Net.ServicePointManager>傳回<xref:System.Net.ServicePoint>包含在主機與識別配置的連接資訊的物件URI。 如果沒有現有<xref:System.Net.ServicePoint>物件，該主機和配置，<xref:System.Net.ServicePointManager>物件會傳回現有<xref:System.Net.ServicePoint>物件; 否則<xref:System.Net.ServicePointManager>物件建立新<xref:System.Net.ServicePoint>物件。  
  
 .NET Framework 4.6 包含新的安全性功能會封鎖不安全的加密與雜湊演算法的連線。 例如，使用 TLS/SSL 透過 Api 的應用程式<xref:System.Net.Http.HttpClient>， <xref:System.Net.HttpWebRequest>， <xref:System.Net.FtpWebRequest>， <xref:System.Net.Mail.SmtpClient>，<xref:System.Net.Security.SslStream>等等，目標為.NET Framework 4.6 預設以取得更安全的行為。  
  
 開發人員可能想要取消這個行為，以維護 RC4 服務以使用其現有 SSL3 服務或 TLS 的互通性。 [這篇文章](https://support.microsoft.com/kb/3069494)說明如何修改您的程式碼，讓新的行為會停用。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Net.ServicePoint>連接至 URI www.contoso.com 的物件。  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定伺服器憑證原則。</summary>
        <value>實作 <see cref="T:System.Net.ICertificatePolicy" /> 介面的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Net.ServicePointManager.CertificatePolicy%2A>屬性設定為<xref:System.Net.ICertificatePolicy>介面物件<xref:System.Net.ServicePointManager>物件會使用該執行個體，而不是預設的憑證原則中定義的憑證原則。  
  
 預設的憑證原則允許有效的憑證和有效的憑證已過期。  
  
   
  
## Examples  
 下列程式碼範例示範如何攔截憑證原則例外狀況的自訂憑證原則。 它會假設已定義憑證原則物件時，Web 資源的統一資源識別元 (URI) 會包含在變數中`myUri`，而且沒有方法，名為`ProcessResponse`，以執行應用程式的工作。  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要設定<see cref="P:System.Net.ServicePointManager.CertificatePolicy" />屬性。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指出是否根據憑證授權撤銷清單檢查憑證。</summary>
        <value>
          如果檢查憑證撤銷清單，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A>是`true`，根據憑證授權撤銷清單中，檢查憑證的憑證驗證程序的一部分。 預設值是`false`。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要設定此屬性。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Net.ServicePoint" /> 物件所允許的同時連線最大數。</summary>
        <value>
          <see cref="T:System.Net.ServicePoint" /> 物件所允許的同時連線最大數。 預設值為 2。 如果將 autoConfig property 設定為 <see langword="true" />，當應用程式以 ASP.NET 主機執行時，就無法透過設定檔修改此屬性的值。 不過，當 autoConfig 屬性是 <see langword="true" /> 時，您可以透過程式設計方式來變更該值。 當 AppDomain 載入時，設定一次慣用值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A>屬性會設定預設的並行連線數目上限，<xref:System.Net.ServicePointManager>物件指派給<xref:System.Net.ServicePoint.ConnectionLimit%2A>屬性建立時<xref:System.Net.ServicePoint>物件。  
  
 變更<xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A>屬性具有不會影響現有<xref:System.Net.ServicePoint>物件; 它只會影響<xref:System.Net.ServicePoint>初始化之後變更的物件。 如果直接或透過組態尚未設定此屬性的值，則值預設為常數<xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>。  
  
> [!NOTE]
>  任何變更<xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A>屬性會影響 HTTP 1.0 和 HTTP 1.1 的連線。 不是個別修改連接限制 HTTP 1.0 和 HTTP 1.1 通訊協定。 當用於伺服器環境 (ASP.NET)<xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A>預設為更高版本的連接數目，也就是 10。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> 小於或等於 0。</exception>
        <permission cref="T:System.Net.WebPermission">不受限制的 Web 權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>預設的非持續連線數目 (4)，是連接至 HTTP/1.0 (含) 以後版本伺服器之 <see cref="T:System.Net.ServicePoint" /> 物件上所允許的連線數目。 這個欄位是常數，但在 .NET Framework 2.0 中已停止使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>預設的持續連線數目 (2)，是連接至 HTTP/1.1 (含) 以後版本伺服器之 <see cref="T:System.Net.ServicePoint" /> 物件上所允許的連線數目。 這個欄位是常數，如果尚未直接或透過組態設定 <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> 屬性的值，則會使用此欄位初始化 <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> 屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A>使用此欄位的屬性。  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出有效的網域名稱服務 (DNS) 解析時間長度。</summary>
        <value>逾時值 (以毫秒為單位)。 -1 值表示無限逾時期間。 預設值為 120,000 毫秒 (兩分鐘)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出網域名稱服務 (DNS) 解析是否會在適用的網際網路通訊協定 (IP) 位址間循環。</summary>
        <value>
          如果 DNS 解析永遠傳回特定主機的第一個 IP 位址，則為 <see langword="false" />；否則為 <see langword="true" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多個 IP 位址與主機名稱相關聯時，DNS 解析通常會傳回第一個 IP 位址。 如果您將此屬性設定為`true`，則後續的 DNS 解決方案會循環顯示所有可用的 IP 位址之特定主控件。 此選項時，服務會使用 DNS 與負載平衡伺服器或伺服器叢集之間的機制。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 <see cref="T:System.Net.ServicePointManager" /> 執行個體的 <see cref="T:System.Net.Security.EncryptionPolicy" />。</summary>
        <value>要用於這個 <see cref="T:System.Net.ServicePointManager" /> 執行個體的加密原則。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果組態檔中未指定值<xref:System.Net.ServicePointManager.EncryptionPolicy%2A>屬性預設為<xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>。 這套用至 SSL/TLS 工作階段上<xref:System.Net.ServicePointManager>執行個體。  
  
 使用 Null 編碼器時，需要加密原則設為<xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，用以判斷是否有使用 100-Continue 行為。</summary>
        <value>
          <see langword="true" /> 表示啟用 100-Continue 行為。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個屬性設定為`true`、 100-繼續使用行為。 用戶端會要求使用`PUT`和`POST`方法會將 Expect 標頭加入要求如果<xref:System.Net.ServicePointManager.Expect100Continue%2A>屬性是`true`和<xref:System.Net.HttpWebRequest.ContentLength%2A>屬性大於零或<xref:System.Net.HttpWebRequest.SendChunked%2A>屬性為 true。 用戶端會預期收到 100-繼續回應的伺服器，表示用戶端應該傳送的回傳資料。 此機制可讓用戶端，以避免透過網路傳送大量資料時的伺服器會根據要求的標頭，想要拒絕的要求。  
  
 例如，假設<xref:System.Net.ServicePointManager.Expect100Continue%2A>屬性是`false`。 當要求傳送到伺服器時，它包含的資料。 如果在讀取之後的要求標頭，伺服器需要驗證，且必須傳送 401 回應，用戶端必須重新傳送適當驗證標頭的資料。  
  
 如果這個屬性是`true`，要求標頭傳送到伺服器。 如果伺服器已拒絕該要求，它會傳送 100-繼續回應信號資料可以傳輸。 如果，就如同上述範例中，伺服器需要驗證，它會傳送 401 回應和用戶端已經傳送的資料。  
  
 變更這個屬性的值不會影響現有<xref:System.Net.ServicePoint>物件。 只新增<xref:System.Net.ServicePoint>受影響的變更之後所建立的物件。  
  
 100-繼續行為不會用於 HTTP 1.0 要求即使這個屬性設定為`true`。  
  
 預期 100-繼續行為完全 IETF RFC 2616 一節所述 10.1.1。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尋找現有 <see cref="T:System.Net.ServicePoint" /> 物件或建立新的 <see cref="T:System.Net.ServicePoint" /> 物件，以管理這個要求的通訊。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">要聯繫的網際網路資源 <see cref="T:System.Uri" /> 物件。</param>
        <summary>尋找現有 <see cref="T:System.Net.ServicePoint" /> 物件或建立新的 <see cref="T:System.Net.ServicePoint" /> 物件，以管理對指定之 <see cref="T:System.Uri" /> 物件的通訊。</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> 物件，管理要求的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A>方法會傳回<xref:System.Net.ServicePoint>與指定的網際網路主機名稱相關聯的物件。 如果沒有<xref:System.Net.ServicePoint>物件存在該主機，<xref:System.Net.ServicePointManager>物件會建立一個。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">已經達到 <see cref="T:System.Net.ServicePoint" /> 中所定義的 <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> 物件最大數。</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">要聯繫的網際網路資源 URI。</param>
        <param name="proxy">這個要求的 Proxy 資料。</param>
        <summary>尋找現有 <see cref="T:System.Net.ServicePoint" /> 物件或建立新的 <see cref="T:System.Net.ServicePoint" /> 物件，以管理對指定之統一資源識別元 (URI) 的通訊。</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> 物件，管理要求的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A>方法會傳回<xref:System.Net.ServicePoint>與指定的網際網路主機名稱相關聯的物件。 如果沒有<xref:System.Net.ServicePoint>物件存在該主機，<xref:System.Net.ServicePointManager>物件會建立一個。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫這個方法，以存取<xref:System.Net.ServicePoint>物件。  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" /> 中指定的 URI 無效。</exception>
        <exception cref="T:System.InvalidOperationException">已經達到 <see cref="T:System.Net.ServicePoint" /> 中所定義的 <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> 物件最大數。</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Uri" /> 物件，包含要聯繫的網際網路資源位址。</param>
        <param name="proxy">這個要求的 Proxy 資料。</param>
        <summary>尋找現有 <see cref="T:System.Net.ServicePoint" /> 物件或建立新的 <see cref="T:System.Net.ServicePoint" /> 物件，以管理對指定之 <see cref="T:System.Uri" /> 物件的通訊。</summary>
        <returns>
          <see cref="T:System.Net.ServicePoint" /> 物件，管理要求的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A>方法會傳回<xref:System.Net.ServicePoint>與指定的網際網路主機名稱相關聯的物件。 如果沒有<xref:System.Net.ServicePoint>物件存在該主機，<xref:System.Net.ServicePointManager>物件會建立一個。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">已經達到 <see cref="T:System.Net.ServicePoint" /> 中所定義的 <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> 物件最大數。</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Net.ServicePoint" /> 物件的最大閒置時間。</summary>
        <value>
          <see cref="T:System.Net.ServicePoint" /> 物件的最大閒置時間，以毫秒為單位。 預設值為 100,000 毫秒 (100 秒)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A>屬性會設定最大閒置時間的<xref:System.Net.ServicePointManager>物件指派給<xref:System.Net.ServicePoint.MaxIdleTime%2A>屬性建立時<xref:System.Net.ServicePoint>物件。 變更此值只會影響<xref:System.Net.ServicePoint>值變更之後，會初始化的物件。  
  
 之後<xref:System.Net.ServicePoint>物件已閒置中指定的時間<xref:System.Net.ServicePoint.MaxIdleTime%2A>，則適合進行記憶體回收。 A<xref:System.Net.ServicePoint>物件處於閒置狀態時與相關聯的連接清單<xref:System.Net.ServicePoint>物件是空的。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" /> 小於 <see cref="F:System.Threading.Timeout.Infinite" /> 或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <permission cref="T:System.Net.WebPermission">不受限制的 Web 權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要在任何時間維護 <see cref="T:System.Net.ServicePoint" /> 物件的最大數。</summary>
        <value>要維護的 <see cref="T:System.Net.ServicePoint" /> 物件最大數。 預設值為 0，這表示 <see cref="T:System.Net.ServicePoint" /> 物件數沒有限制。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您減少<xref:System.Net.ServicePointManager.MaxServicePoints%2A>屬性下方的數字<xref:System.Net.ServicePoint>中是否存在，目前的物件<xref:System.Net.ServicePointManager>刪除<xref:System.Net.ServicePoint>物件的最長閒置的時間。 如果數目<xref:System.Net.ServicePoint>具有使用中連接物件的值大於<xref:System.Net.ServicePointManager.MaxServicePoints%2A>、<xref:System.Net.ServicePointManager>物件刪除<xref:System.Net.ServicePoint>它們變成閒置狀態的物件。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> 小於 0 或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <permission cref="T:System.Net.WebPermission">不受限制的 Web 權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將這個屬性值設定為 <see langword="true" /> 將會讓來自 HttpWebRequest 的所有連出 TCP 連線使用通訊端上的原生通訊端選項 SO_REUSE_UNICASTPORT。 這會導致共用底層連出連接埠。 對於短時間內有大量連出連線的案例，這非常實用，但應用程式可能會遇到連接埠耗盡的問題。</summary>
        <value>傳回 <see cref="T:System.Boolean" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設值是 `false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定由 <see cref="T:System.Net.ServicePointManager" /> 物件管理的 <see cref="T:System.Net.ServicePoint" /> 物件所使用的安全性通訊協定。</summary>
        <value>
          <see cref="T:System.Net.SecurityProtocolType" /> 列舉型別中定義的一個值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
這個屬性會選取要用於新連線的安全通訊端層 (SSL) 或傳輸層安全性 (TLS) 通訊協定的版本不變更現有的連線。  
  
從.NET Framework 4.7 開始，這個屬性的預設值是<xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>。 這可讓網路為基礎的應用程式開發介面的.NET Framework <xref:System.Net.Security.SslStream> （例如 FTP、 HTTP 和 SMTP） 繼承的預設安全性通訊協定，從作業系統或系統管理員執行任何自訂設定。 關於 SSL/TLS 通訊協定預設會啟用在每個版本的 Windows 作業系統的資訊，請參閱[中 TLS/SSL (安全通道 SSP) 的通訊協定](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx)。
 
如需透過.NET Framework 4.6.2 的.NET framework 版本，沒有預設值會列出這個屬性。 安全性橫向一直在改變，變更預設通訊協定和保護層級會隨時間改變以避免已知弱點的攻擊。 預設值是依個別電腦設定、 已安裝的軟體和套用修補程式而有所不同。  
  
 使用特定的保護層級，或假設預設會使用指定的安全性層級上，您的程式碼應該永遠不會以隱含方式而定。 如果您的應用程式相依於特定的安全性層級使用，您必須明確指定的層級，然後檢查以確定它實際上是在已建立的連接上使用。 此外，您的程式碼應該設計成可承受支援通訊協定的變更，因此通常變更小事先通知與以降低新興的威脅。  
  
 .NET Framework 4.6 包含新的安全性功能會封鎖不安全的加密與雜湊演算法的連線。 使用 TLS/SSL 透過例如 HttpClient、 HttpWebRequest、 FTPClient、 SmtpClient、 SslStream 」 等的 Api，並以.NET Framework 4.6 為目標的應用程式預設會取得更安全的行為。  
  
 開發人員可能想要取消這個行為，以維護與 RC4 服務以其現有 SSL3 服務或 TLS 的互通性。 [這篇文章](https://support.microsoft.com/kb/3069494)說明如何修改您的程式碼，讓新的行為會停用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">指定用來設定屬性的值不是一個有效的 <see cref="T:System.Net.SecurityProtocolType" /> 列舉值。</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來驗證伺服器憑證的回呼。</summary>
        <value>
          <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />。 預設值是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
應用程式可以設定<xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>用於用戶端的伺服器憑證的自訂驗證方法的屬性。 執行自訂驗證時`sender`參數傳遞至<xref:System.Net.Security.RemoteCertificateValidationCallback>可以是主機名稱的字串或物件衍生自<xref:System.Net.WebRequest>(<xref:System.Net.HttpWebRequest>，例如) 取決於<xref:System.Net.ServicePointManager.CertificatePolicy%2A>屬性。  
  
不使用自訂驗證時，憑證名稱是用來建立要求的主機名稱比較。 例如，如果<xref:System.Net.WebRequest.Create%28System.String%29>已傳遞的參數"https://www.contoso.com/default.html"，預設行為是讓用戶端檢查的憑證對 www.contoso.com。  

雖然多點傳送的委派，只能從上次執行的事件處理常式傳回的值都會被視為優先。 換句話說，您可以將多個委派，附加和所有他們取得從回呼<xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>。 每個回呼的傳回值，這個值，指出憑證是否已接受或不過，遵守從最後一個委派的值。
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要設定<see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />屬性。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />。</permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="keepAliveTime" Type="System.Int32" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enabled">如果設定為 True，表示會使用指定的 <c>keepAliveTime</c> 和 <c>keepAliveInterval</c> 值啟用 TCP 連線的 TCP 保持連線選項。  
  
 如果設定為 False，則表示會停用 TCP 保持連線選項，並忽略其餘的參數。  
  
 預設值為 false。</param>
        <param name="keepAliveTime">指定第一個 Keep-Alive 封包傳送之前的無活動逾時 (以毫秒為單位)。  
  
 這個值必須大於 0。  如果傳遞的值小於或等於零，則擲回 <see cref="T:System.ArgumentOutOfRangeException" />。</param>
        <param name="keepAliveInterval">指定若未接收認可，後續 Keep-Alive 封包傳送的間隔 (以毫秒為單位)。  
  
 這個值必須大於 0。  如果傳遞的值小於或等於零，則擲回 <see cref="T:System.ArgumentOutOfRangeException" />。</param>
        <summary>啟用或停用 TCP 連線的 Keep-Alive 選項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可以要求 TCP/IP 提供者使用的 TCP 連線的 keep-alive 封包。 預設為使用 TCP 連線的 keep-alive 封包會停用。  
  
 TCP 通訊端時的預設設定初始化 2 小時的設定保持逾時和保持連接間隔為 1 秒。 `keepAliveTime`參數指定以毫秒為單位，與第一個 keep-alive 封包傳送之前的無活動逾時。 `keepAliveInterval`參數指定的間隔，以毫秒為單位，介於時如果未收到收條，後續 keep-alive 封包會傳送。 保持運作的探查數目不能變更，並設為 10。  
  
 如果 TCP 連線中斷時持續作用，因為<xref:System.Net.Sockets.SocketError>的<xref:System.Net.Sockets.SocketError.NetworkReset>會傳回到任何呼叫正在進行中通訊端，而且任何後續呼叫都會失敗並<xref:System.Net.Sockets.SocketError>的<xref:System.Net.Sockets.SocketError.NotConnected>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="keepAliveTime" /> 或 <paramref name="keepAliveInterval" /> 參數的指定值會小於或等於 0。</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>判斷由這個 <see cref="T:System.Net.ServicePointManager" /> 物件所管理的服務點是否使用 Nagle 演算法。</summary>
        <value>
          <see langword="true" /> 表示使用 Nagle 演算法；否則為 <see langword="false" />。 預設值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 演算法用來減少網路流量，緩衝處理小型資料封包，並將它們以單一封包傳輸。 此程序也稱為 「 nagling";它廣泛使用，因為它可以減少傳送的封包數目，並降低每個封包的額外負荷。  
  
 變更這個屬性的值不會影響現有<xref:System.Net.ServicePoint>物件。 只有新服務點建立之後變更會受到影響。  
  
 IETF RFC 896 的完整說明 Nagle 演算法。  
  
   
  
## Examples  
 下列程式碼範例會設定這個屬性。  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>