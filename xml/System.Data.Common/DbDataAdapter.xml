<Type Name="DbDataAdapter" FullName="System.Data.Common.DbDataAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3826e6f3e20f9dbc94d47c3d958b6e469e8cfe76" />
    <Meta Name="ms.sourcegitcommit" Value="e7865e39826e7aaf54da4c7042975153813a31c7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/16/2018" />
    <Meta Name="ms.locfileid" Value="31044258" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DbDataAdapter : System.Data.Common.DataAdapter, ICloneable, System.Data.IDbDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DbDataAdapter extends System.Data.Common.DataAdapter implements class System.Data.IDataAdapter, class System.Data.IDbDataAdapter, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.DbDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DbDataAdapter&#xA;Inherits DataAdapter&#xA;Implements ICloneable, IDbDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbDataAdapter abstract : System::Data::Common::DataAdapter, ICloneable, System::Data::IDbDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DataAdapter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.IDbDataAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>可協助實作 <see cref="T:System.Data.IDbDataAdapter" /> 介面。 <see cref="T:System.Data.Common.DbDataAdapter" /> 繼承者實作一組函式以提供強型別，但繼承大多數完整實作 **DataAdapter** 所需的功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter>類別繼承自<xref:System.Data.Common.DataAdapter>類別，並且實作<xref:System.Data.IDbDataAdapter>介面。 它可協助實作類別**DataAdapter**設計用於關聯式資料庫。  
  
 應用程式不會建立的執行個體<xref:System.Data.Common.DbDataAdapter>類別直接，但是會建立繼承自該類別的執行個體。  
  
 繼承的類別<xref:System.Data.Common.DbDataAdapter>必須實作繼承的成員，和通常用來定義其他成員將提供者特有的功能。 例如，<xref:System.Data.Common.DbDataAdapter>類別會定義<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性，而<xref:System.Data.Common.DbDataAdapter>類別定義的八個多載<xref:System.Data.IDataAdapter.Fill%2A>方法。 接著，<xref:System.Data.OleDb.OleDbDataAdapter>類別會繼承<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法，而且也會定義兩個其他多載<xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A>可接受的 ADO 資料錄集物件做為參數。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>當您繼承自<see cref="T:System.Data.Common.DbDataAdapter" />類別，建議您實作下列建構函式：  
  
 <list type="table"><listheader><term> 項目  
  
 </term><description> 描述  
  
 </description></listheader><item><term> *Prv*DataAdapter()  
  
 </term><description> 初始化的新執行個體*Prv*資料配接器類別。  
  
 </description></item><item><term> *Prv*DataAdapter (*Prv*命令*selectCommand*)  
  
 </term><description> 初始化的新執行個體*Prv*資料配接器類別，以指定的 SQL SELECT 陳述式。  
  
 </description></item><item><term> *Prv*DataAdapter (字串*selectCommandText*，字串*selectConnectionString*)  
  
 </term><description> 初始化的新執行個體*Prv*SQL SELECT 陳述式與連接字串的資料配接器類別。  
  
 </description></item><item><term> *Prv*DataAdapter (字串*selectCommandText*， *Prv*連接*selectConnection*)  
  
 </term><description> 初始化的新執行個體*Prv*資料配接器類別，以 SQL SELECT 陳述式和*Prv*連接物件。  
  
 </description></item></list>  
  
 若要提升在.NET Framework 資料提供者之間的一致性，表單中的繼承類別應該命名*Prv*資料配接器，其中*Prv*是提供給特定的.NET 中的所有類別的統一前置詞Framework 資料提供者命名空間。 例如，"Sql"這是前置詞<see cref="T:System.Data.SqlClient.SqlDataAdapter" />類別**System.Data.SqlClient**命名空間。</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see langword="DataAdapter" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 **DataAdapter** 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您建立的執行個體<xref:System.Data.Common.DbDataAdapter>，下列的讀取/寫入屬性設定為下列的初始值。  
  
|屬性|Initial value|  
|----------------|-------------------|  
|<xref:System.Data.IDbDataAdapter.SelectCommand%2A>|新的 <xref:System.Data.IDbCommand>。|  
|<xref:System.Data.IDbDataAdapter.InsertCommand%2A>|新的 <xref:System.Data.IDbCommand>。|  
|<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>|新的 <xref:System.Data.IDbCommand>。|  
|<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>|新的 <xref:System.Data.IDbCommand>。|  
|<xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>|`MissingMappingAction.Passthrough`|  
|<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>|`MissingSchemaAction.Add`|  
  
 您可以變更任何這些屬性，透過呼叫另一個屬性的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter (System.Data.Common.DbDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.Common.DbDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (adapter As DbDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter(System::Data::Common::DbDataAdapter ^ adapter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.Common.DbDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter">
          <see langword="DataAdapter" /> 物件，用來建立新的 <see langword="DataAdapter" />。</param>
        <summary>從相同類型的現有物件，初始化 <see langword="DataAdapter" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Data.Common.DbDataAdapter>建構函式適用於.NET Framework 資料提供者實作 clone 實作中使用類似的建構函式時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToBatch">
      <MemberSignature Language="C#" Value="protected virtual int AddToBatch (System.Data.IDbCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 AddToBatch(class System.Data.IDbCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function AddToBatch (command As IDbCommand) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int AddToBatch(System::Data::IDbCommand ^ command);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.IDbCommand" />
      </Parameters>
      <Docs>
        <param name="command">要加入至批次的 <see cref="T:System.Data.IDbCommand" />。</param>
        <summary>加入 <see cref="T:System.Data.IDbCommand" /> 至目前批次。</summary>
        <returns>加入 <see cref="T:System.Data.IDbCommand" /> 之前，批次中的命令數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>。 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">配置器不支援批次。</exception>
        <block subset="none" type="overrides">
          <para>這個方法受到保護，可供使用的.NET Framework 資料提供者。  
  
 如果類別繼承自<see cref="T:System.Data.Common.DbDataAdapter" />支援批次，該類別會覆寫此方法可讓使用者將命令加入至批次。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ClearBatch">
      <MemberSignature Language="C#" Value="protected virtual void ClearBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ClearBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearBatch ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將所有的 <see cref="T:System.Data.IDbCommand" /> 物件從批次中移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>。 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">配置器不支援批次。</exception>
        <block subset="none" type="overrides">
          <para>這個方法受到保護，可供使用的.NET Framework 資料提供者。  
  
 如果類別繼承自<see cref="T:System.Data.Common.DbDataAdapter" />支援批次，該類別會覆寫此方法可讓使用者從批次移除所有的命令。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatedEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatedEventArgs ^ CreateRowUpdatedEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatedEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow">用來更新資料來源的 <see cref="T:System.Data.DataRow" />。</param>
        <param name="command">在 <see cref="T:System.Data.IDbCommand" /> 期間執行的 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />。</param>
        <param name="statementType">命令為 UPDATE、INSERT、DELETE 或 SELECT 陳述式。</param>
        <param name="tableMapping">
          <see cref="T:System.Data.Common.DataTableMapping" /> 物件。</param>
        <summary>初始化 <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> 類別的新執行個體。</summary>
        <returns>
          <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> 類別的新執行個體。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatingEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatingEventArgs ^ CreateRowUpdatingEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatingEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow">更新資料來源的 <see cref="T:System.Data.DataRow" />。</param>
        <param name="command">要在 <see cref="T:System.Data.IDbCommand" /> 期間執行的 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />。</param>
        <param name="statementType">命令為 UPDATE、INSERT、DELETE 或 SELECT 陳述式。</param>
        <param name="tableMapping">
          <see cref="T:System.Data.Common.DataTableMapping" /> 物件。</param>
        <summary>初始化 <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> 類別的新執行個體。</summary>
        <returns>
          <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> 類別的新執行個體。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSourceTableName">
      <MemberSignature Language="C#" Value="public const string DefaultSourceTableName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultSourceTableName" />
      <MemberSignature Language="DocId" Value="F:System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultSourceTableName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ DefaultSourceTableName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>資料表對應之 <see cref="T:System.Data.Common.DataAdapter" /> 物件所使用的預設名稱。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 「 資料表 」 是所使用的預設名稱<xref:System.Data.Common.DataAdapter>資料表對應的物件。  
  
 <xref:System.Data.Common.DbDataAdapter.DefaultSourceTableName> 當應用程式加入資料表對應搭配使用時<xref:System.Data.Common.DbDataAdapter.Fill%2A>，但未指定<xref:System.Data.DataTable>名稱。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property DeleteCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ DeleteCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定命令，以從資料集刪除資料錄。</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" />，在 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> 期間用來為資料集中所刪除的資料列刪除在資料來源中的資料錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 期間<xref:System.Data.Common.DbDataAdapter.Update%2A>，如果沒有設定這個屬性，並且出現在主索引鍵資訊<xref:System.Data.DataSet>、<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>自動產生。  
  
   
  
## Examples  
 下列範例會建立衍生的類別<xref:System.Data.OleDb.OleDbDataAdapter>並設定其屬性的某些。  
  
 [!code-csharp[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.Data.Common.DbDataAdapter" /> 所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteBatch">
      <MemberSignature Language="C#" Value="protected virtual int ExecuteBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 ExecuteBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ExecuteBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ExecuteBatch () As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int ExecuteBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>執行目前批次。</summary>
        <returns>批次中上一個命令的傳回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>。 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個方法受到保護，可供使用的.NET Framework 資料提供者。  
  
 如果類別繼承自<see cref="T:System.Data.Common.DbDataAdapter" />支援批次，該類別會覆寫此方法可讓使用者執行批次。 這個方法的實作將配接器中的命令結合成一個批次，然後執行批次並傳回批次的傳回值。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fill">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>填入 <see cref="T:System.Data.DataSet" /> 或 <see cref="T:System.Data.DataTable" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public override int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Fill(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">要填入資料錄和結構描述 (如果必要的話) 的 <see cref="T:System.Data.DataSet" />。</param>
        <summary>在 <see cref="T:System.Data.DataSet" /> 中加入或重新整理資料列。</summary>
        <returns>成功加入至 <see cref="T:System.Data.DataSet" /> 或在其中重新整理的資料列數目。 這不包含被不傳回資料列之陳述式所影響的資料列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式的資料來源擷取資料。 <xref:System.Data.IDbConnection> Select 命令相關聯的物件必須有效，但它不需要開啟。 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料並關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。  
  
 如果錯誤或例外狀況時發生填入資料的資料表，在發生錯誤之前所加入的資料列會保留在資料的資料表。 已中止運算的餘數。  
  
 如果命令未傳回任何資料列，將資料表加入至<xref:System.Data.DataSet>，並會引發任何例外狀況。  
  
 如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續使用模式的資料行名稱"*columnname*1"，"*columnname*2"，"*columnname*3"等等。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。  
  
 當指定的查詢傳回多個結果時，結果集傳回查詢的每個資料列位於個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等等） 的整數值。 不會建立資料表查詢不會傳回資料列，如果您在處理 insert 查詢後面的 select 查詢，因為資料表建立選取查詢的名稱為"Table"因為它是建立的第一個資料表。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 當 SELECT 陳述式用來填入<xref:System.Data.DataSet>傳回多個結果，例如批次 SQL 陳述式，如果其中一個結果包含錯誤，會略過所有後續的結果並不會加入至<xref:System.Data.DataSet>。  
  
 當使用後續<xref:System.Data.Common.DbDataAdapter.Fill%2A>對更新的內容呼叫<xref:System.Data.DataSet>，必須符合兩個條件：  
  
1.  SQL 陳述式應該符合最初用來填入<xref:System.Data.DataSet>。  
  
2.  **金鑰**必須存在的資料行資訊。  
  
 如果主索引鍵資訊存在時，任何重複的資料列和一致，而且只能出現一次在<xref:System.Data.DataTable>對應於<xref:System.Data.DataSet>。 主索引鍵資訊可能會設定透過<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，藉由指定<xref:System.Data.DataTable.PrimaryKey%2A>屬性<xref:System.Data.DataTable>，或藉由設定<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>屬性`AddWithKey`。  
  
 如果 `SelectCommand` 傳回 OUTER JOIN 的結果，則 `DataAdapter` 便不會為產生的 <xref:System.Data.DataTable.PrimaryKey%2A> 設定 <xref:System.Data.DataTable> 值。 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataTable ^ dataTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">用於資料表對應的 <see cref="T:System.Data.DataTable" /> 名稱。</param>
        <summary>使用 <see cref="T:System.Data.DataSet" /> 名稱，加入或重新整理 <see cref="T:System.Data.DataTable" /> 中指定範圍內的資料列，以符合那些在資料來源中的資料列。</summary>
        <returns>成功加入至 <see cref="T:System.Data.DataSet" /> 或在其中重新整理的資料列數目。 這不包含被不傳回資料列之陳述式所影響的資料列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式指定由相關聯的資料來源擷取資料列<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性。 SELECT 陳述式相關聯的連接物件必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>作業接著會將資料列加入到目的地<xref:System.Data.DataTable>中的物件<xref:System.Data.DataSet>、 建立<xref:System.Data.DataTable>如果它們尚不存在的物件。 建立時<xref:System.Data.DataTable>物件<xref:System.Data.Common.DbDataAdapter.Fill%2A>作業通常會建立只有資料行名稱中繼資料。 不過，如果<xref:System.Data.IDataAdapter.MissingSchemaAction%2A>屬性設定為`AddWithKey`，也會建立適當的主索引鍵和條件約束。  
  
 如果<xref:System.Data.Common.DbDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3"等等。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。  
  
 多載<xref:System.Data.Common.DbDataAdapter.Fill%2A>採用`DataTable`如參數只會取得第一個結果。 使用的多載<xref:System.Data.Common.DbDataAdapter.Fill%2A>採用`DataSet`做為參數來取得多個結果。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
 dataset.Tables.Add("AAA");  
 adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
    adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 您可以使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>上多次相同的方法<xref:System.Data.DataTable>。 如果主索引鍵存在，內送資料列會合併具有相符的資料列已經存在。 如果沒有主索引鍵存在，將內送資料列附加至<xref:System.Data.DataTable>。  
  
 如果 `SelectCommand` 傳回 OUTER JOIN 的結果，則 `DataAdapter` 便不會為產生的 <xref:System.Data.DataTable.PrimaryKey%2A> 設定 <xref:System.Data.DataTable> 值。 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.Fill%2A>和<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>對於.NET Framework 資料提供者擷取結構描述資訊，只有第一個結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。</exception>
        <block subset="none" type="overrides">
          <para>這個多載<see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />被保護的設計為使用.NET Framework 資料提供者方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">要填入資料錄和結構描述 (如果必要的話) 的 <see cref="T:System.Data.DataSet" />。</param>
        <param name="srcTable">用於資料表對應的來源資料表名稱。</param>
        <summary>使用 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.Data.DataSet" /> 名稱，加入或重新整理 <see cref="T:System.Data.DataTable" /> 中的資料列，以符合那些在資料來源中的資料列。</summary>
        <returns>成功加入至 <see cref="T:System.Data.DataSet" /> 或在其中重新整理的資料列數目。 這不包含被不傳回資料列之陳述式所影響的資料列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式的資料來源擷取資料。 <xref:System.Data.IDbConnection> Select 命令相關聯的物件必須有效，但它不需要開啟。 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。  
  
 如果命令未傳回任何資料列，將資料表加入至<xref:System.Data.DataSet>，並會引發任何例外狀況。  
  
 如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式 」 columnname1"、"columnname2"、"columnname3 」 和等等的名稱。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。  
  
 當指定的查詢傳回多個結果時，每個結果集被放在個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等等） 的整數值。 不會建立資料表查詢不會傳回資料列，如果您要處理插入查詢後面的 select 查詢，因為建立選取查詢的資料表就會命名為"Table"，因為它是建立的第一個資料表。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 如果錯誤或例外狀況時發生填入資料的資料表，在發生錯誤之前所加入的資料列會保留在資料的資料表。 已中止運算的餘數。  
  
 當 SELECT 陳述式用來填入<xref:System.Data.DataSet>會傳回多個結果，例如批次 SQL 陳述式，可注意下列事項：  
  
-   如果其中一個結果包含錯誤時，會略過所有後續的結果，且未新增到<xref:System.Data.DataSet>。  
  
 當使用後續<xref:System.Data.Common.DbDataAdapter.Fill%2A>對更新的內容呼叫<xref:System.Data.DataSet>，必須符合兩個條件：  
  
1.  SQL 陳述式應該符合最初用來填入<xref:System.Data.DataSet>。  
  
2.  **金鑰**必須存在的資料行資訊。 如果主索引鍵資訊存在時，任何重複的資料列和一致，而且只能出現一次在<xref:System.Data.DataTable>對應於<xref:System.Data.DataSet>。 主索引鍵資訊可能會設定透過<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，藉由指定<xref:System.Data.DataTable.PrimaryKey%2A>屬性<xref:System.Data.DataTable>，或藉由設定<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>屬性`AddWithKey`。  
  
 如果 `SelectCommand` 傳回 OUTER JOIN 的結果，則 `DataAdapter` 便不會為產生的 <xref:System.Data.DataTable.PrimaryKey%2A> 設定 <xref:System.Data.DataTable> 值。 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.OleDb.OleDbDataAdapter>，以填滿<xref:System.Data.DataSet>從 categories 資料表的資料列。 這個範例假設您已建立<xref:System.Data.OleDb.OleDbDataAdapter>和<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">來源資料表無效。</exception>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable">要填入資料錄和結構描述 (如果必要的話) 的 <see cref="T:System.Data.DataTable" />。</param>
        <param name="command">用來從資料來源擷取資料列的 SQL SELECT 陳述式。</param>
        <param name="behavior">其中一個 <see cref="T:System.Data.CommandBehavior" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataTable" />、<see cref="T:System.Data.DataTable" /> 和 <see cref="T:System.Data.IDbCommand" />，加入或重新整理 <see cref="T:System.Data.CommandBehavior" /> 中的資料列，以符合那些在資料來源中的資料列。</summary>
        <returns>成功加入至 <see cref="T:System.Data.DataTable" /> 或在其中重新整理的資料列數目。 這不包含被不傳回資料列之陳述式所影響的資料列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式指定由相關聯的資料來源擷取資料列<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性。 SELECT 陳述式相關聯的連接物件必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料並關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>作業接著會將資料列加入到指定的目的地<xref:System.Data.DataTable>物件存放至<xref:System.Data.DataSet>、 建立<xref:System.Data.DataTable>如果它不存在的物件。 建立時<xref:System.Data.DataTable>物件<xref:System.Data.Common.DbDataAdapter.Fill%2A>作業通常會建立只有資料行名稱中繼資料。 不過，如果<xref:System.Data.IDataAdapter.MissingSchemaAction%2A>屬性設定為`AddWithKey`，也會建立適當的主索引鍵和條件約束。  
  
 如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3 」，依此類推。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。  
  
 多載<xref:System.Data.Common.DbDataAdapter.Fill%2A>採用`DataTable`如參數只會取得第一個結果。 使用的多載<xref:System.Data.Common.DbDataAdapter.Fill%2A>採用`DataSet`做為參數來取得多個結果。  
  
 您可以使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>上多次相同的方法<xref:System.Data.DataTable>。 如果主索引鍵存在，內送資料列會合併具有相符的資料列已經存在。 如果沒有主索引鍵存在，將內送資料列附加至<xref:System.Data.DataTable>。  
  
 如果 `SelectCommand` 傳回 OUTER JOIN 的結果，則 `DataAdapter` 便不會為產生的 <xref:System.Data.DataTable.PrimaryKey%2A> 設定 <xref:System.Data.DataTable> 值。 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這個多載<see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />被保護的設計為使用.NET Framework 資料提供者方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (int startRecord, int maxRecords, params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(int32 startRecord, int32 maxRecords, class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Fill (startRecord As Integer, maxRecords As Integer, ParamArray dataTables As DataTable()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(int startRecord, int maxRecords, ... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startRecord">要起始之以零為起始的資料錄編號。</param>
        <param name="maxRecords">要擷取之資料錄的最大數目。</param>
        <param name="dataTables">要從資料來源填入的 <see cref="T:System.Data.DataTable" /> 物件。</param>
        <summary>從指定的記錄開始擷取直到指定的記錄最大數目為止，加入或重新整理 <see cref="T:System.Data.DataTable" /> 中的資料列，以符合那些在資料來源中的資料列。</summary>
        <returns>成功加入至 <see cref="T:System.Data.DataTable" /> 或在其中重新整理的資料列數目。 這個值不包含受未傳回資料列之陳述式所影響的資料列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DataAdapter.Fill%2A>方法會從使用 SELECT 陳述式指定由相關聯的資料來源擷取資料列<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性。 SELECT 陳述式相關聯的連接物件必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DataAdapter.Fill%2A>是呼叫，來擷取資料，開啟和關閉然後。 如果連接為開啟之前<xref:System.Data.Common.DataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。  
  
 <xref:System.Data.Common.DataAdapter.Fill%2A>作業接著會將資料列加入到目的地<xref:System.Data.DataTable>中的物件<xref:System.Data.DataSet>、 建立<xref:System.Data.DataTable>如果它們尚不存在的物件。 建立時<xref:System.Data.DataTable>物件<xref:System.Data.Common.DataAdapter.Fill%2A>作業通常會建立只有資料行名稱中繼資料。 不過，如果<xref:System.Data.IDataAdapter.MissingSchemaAction%2A>屬性設定為`AddWithKey`，也會建立適當的主索引鍵和條件約束。  
  
 如果 `SelectCommand` 傳回 OUTER JOIN 的結果，則 `DataAdapter` 便不會為產生的 <xref:System.Data.DataTable.PrimaryKey%2A> 設定 <xref:System.Data.DataTable> 值。 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)。  
  
 如果資料配接器遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式 」 columnname1"、"columnname2"、"columnname3 」 和等等的名稱。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。 當多個結果集加入至<xref:System.Data.DataSet>，每個結果集放在個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等等） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 當 SELECT 陳述式用來填入<xref:System.Data.DataSet>傳回多個結果，例如批次 SQL 陳述式中，如果其中一個結果包含錯誤，所有後續的結果會略過且未新增到<xref:System.Data.DataSet>。  
  
 您可以使用<xref:System.Data.Common.DataAdapter.Fill%2A>上多次相同的方法<xref:System.Data.DataTable>。 如果主索引鍵存在，內送資料列會合併具有相符的資料列已經存在。 如果沒有主索引鍵存在，將內送資料列附加至<xref:System.Data.DataTable>。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">要填入資料錄和結構描述 (如果必要的話) 的 <see cref="T:System.Data.DataSet" />。</param>
        <param name="startRecord">要起始之以零為起始的資料錄編號。</param>
        <param name="maxRecords">要擷取之資料錄的最大數目。</param>
        <param name="srcTable">用於資料表對應的來源資料表名稱。</param>
        <summary>使用 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.Data.DataSet" /> 名稱，加入或重新整理 <see cref="T:System.Data.DataTable" /> 中指定範圍內的資料列，以符合那些在資料來源中的資料列。</summary>
        <returns>成功加入至 <see cref="T:System.Data.DataSet" /> 或在其中重新整理的資料列數目。 這不包含被不傳回資料列之陳述式所影響的資料列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `maxRecords` 0 的值取得開始記錄後，仍找到的所有記錄。 如果`maxRecords`大於剩餘的資料列數目只會傳回其餘的資料列，並不會發出錯誤。  
  
 如果對應的 select 命令的陳述式傳回多個結果，<xref:System.Data.Common.DbDataAdapter.Fill%2A>只適用於`maxRecords`至第一個結果。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式的資料來源擷取資料。 <xref:System.Data.IDbConnection> SELECT 陳述式相關聯的物件必須有效，但它不需要開啟。 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料並關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。  
  
 如果命令未傳回任何資料列，將資料表加入至<xref:System.Data.DataSet>，但會引發任何例外狀況。  
  
 如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3 」，依此類推。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。  
  
 當指定的查詢傳回多個結果時，每個結果集被放在個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等等） 的整數值。 因為不會建立資料表查詢不會傳回資料列，如果您在處理 insert 查詢後面的 select 查詢，針對 select 查詢所建立的資料表是名為"Table"，因為它是建立的第一個資料表。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 如果錯誤或例外狀況時發生填入資料的資料表，在發生錯誤之前所加入的資料列會保留在資料的資料表。 已中止運算的餘數。  
  
 當 SELECT 陳述式用來填入<xref:System.Data.DataSet>傳回多個結果，例如批次 SQL 陳述式，可注意下列事項：  
  
-   處理批次 SQL 陳述式，從多個結果時`maxRecords`只適用於第一個結果。 也適用於包含章節化的結果 (.NET Framework Data Provider for OLE DB 只) 的資料列。 最上層結果會受到`maxRecords`，但是所有的子資料列會加入。  
  
-   如果其中一個結果包含錯誤時，會略過所有後續的結果，且未新增到<xref:System.Data.DataSet>。  
  
 當使用後續<xref:System.Data.Common.DbDataAdapter.Fill%2A>對更新的內容呼叫<xref:System.Data.DataSet>，必須符合兩個條件：  
  
1.  SQL 陳述式應該符合最初用來填入<xref:System.Data.DataSet>。  
  
2.  **金鑰**必須存在的資料行資訊。  
  
 如果主索引鍵資訊存在時，任何重複的資料列會調解並只能出現一次在<xref:System.Data.DataTable>對應於<xref:System.Data.DataSet>。 主索引鍵資訊可能會設定透過<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，藉由指定<xref:System.Data.DataTable.PrimaryKey%2A>屬性<xref:System.Data.DataTable>，或藉由設定<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>屬性`AddWithKey`。  
  
 如果 `SelectCommand` 傳回 OUTER JOIN 的結果，則 `DataAdapter` 便不會為產生的 <xref:System.Data.DataTable.PrimaryKey%2A> 設定 <xref:System.Data.DataTable> 值。 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
> [!NOTE]
>  `DataSet`不會包含在所指定的記錄數目超過`maxRecords`。 不過，從伺服器仍會傳回查詢所產生的整個結果集。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.OleDb.OleDbDataAdapter>，以填滿<xref:System.Data.DataSet>具有 15 個資料列，從資料列 10，開始從**類別**資料表。 這個範例假設您已建立<xref:System.Data.OleDb.OleDbDataAdapter>和<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">
          <see cref="T:System.Data.DataSet" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。  
  
 -或-  
  
 連接無效。</exception>
        <exception cref="T:System.InvalidCastException">找不到連線。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startRecord" /> 參數小於 0。  
  
 -或-  
  
 <paramref name="maxRecords" /> 參數小於 0。</exception>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable[] dataTables, int startRecord, int maxRecords, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable[] dataTables, int32 startRecord, int32 maxRecords, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Fill (dataTables As DataTable(), startRecord As Integer, maxRecords As Integer, command As IDbCommand, behavior As CommandBehavior) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables, int startRecord, int maxRecords, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTables">要從資料來源填入的 <see cref="T:System.Data.DataTable" /> 物件。</param>
        <param name="startRecord">要起始之以零為起始的資料錄編號。</param>
        <param name="maxRecords">要擷取之資料錄的最大數目。</param>
        <param name="command">
          <see cref="T:System.Data.IDbCommand" />，執行其以填入 <see cref="T:System.Data.DataTable" /> 物件。</param>
        <param name="behavior">其中一個 <see cref="T:System.Data.CommandBehavior" /> 值。</param>
        <summary>使用 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.Data.DataSet" /> 名稱，加入或重新整理 <see cref="T:System.Data.DataTable" /> 中指定範圍內的資料列，以符合那些在資料來源中的資料列。</summary>
        <returns>加入至資料的資料表 (Data Table) 或在其中重新整理的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `maxRecords` 0 的值取得開始記錄後，仍找到的所有記錄。 如果`maxRecords`大於剩餘的資料列數目只會傳回其餘的資料列，不會發出錯誤。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式的資料來源擷取資料。 <xref:System.Data.IDbConnection> SELECT 陳述式相關聯的物件必須有效，但它不需要開啟。 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。  
  
 如果命令未傳回任何資料列，將資料表加入至<xref:System.Data.DataSet>，但會引發任何例外狀況。  
  
 如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3 」，依此類推。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。  
  
 當指定的查詢傳回多個結果時，每個結果集被放在個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等等） 的整數值。 不會建立資料表查詢不會傳回資料列，如果您要處理插入查詢後面的 select 查詢，因為建立選取查詢的資料表就會命名為"Table"，因為它是建立的第一個資料表。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 如果錯誤或例外狀況時發生填入資料的資料表，在發生錯誤之前所加入的資料列會保留在資料的資料表。 已中止運算的餘數。  
  
 當 SELECT 陳述式用來填入<xref:System.Data.DataTable>物件會傳回多個結果，例如批次 SQL 陳述式，可注意下列事項：  
  
-   處理批次 SQL 陳述式，從多個結果時`maxRecords`只適用於第一個結果。 也適用於包含章節化的結果 (.NET Framework Data Provider for OLE DB 只) 的資料列。 最上層結果會受到`maxRecords`，但是所有的子資料列會加入。  
  
-   如果其中一個結果包含錯誤時，會略過所有後續的結果。  
  
> [!NOTE]
>  `DataSet`不會包含在所指定的記錄數目超過`maxRecords`。 不過，從伺服器仍會傳回整個查詢所產生的結果集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">
          <see cref="T:System.Data.DataSet" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。  
  
 -或-  
  
 連接無效。</exception>
        <exception cref="T:System.InvalidCastException">找不到連線。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startRecord" /> 參數小於 0。  
  
 -或-  
  
 <paramref name="maxRecords" /> 參數小於 0。</exception>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet">要填入資料錄和結構描述 (如果必要的話) 的 <see cref="T:System.Data.DataSet" />。</param>
        <param name="startRecord">要起始之以零為起始的資料錄編號。</param>
        <param name="maxRecords">要擷取之資料錄的最大數目。</param>
        <param name="srcTable">用於資料表對應的來源資料表名稱。</param>
        <param name="command">用來從資料來源擷取資料列的 SQL SELECT 陳述式。</param>
        <param name="behavior">其中一個 <see cref="T:System.Data.CommandBehavior" /> 值。</param>
        <summary>使用 <see cref="T:System.Data.DataSet" />、來源資料表名稱、命令字串和命令行為，加入或重新整理 <see cref="T:System.Data.DataSet" /> 中指定範圍內的資料列，以符合那些在資料來源中的資料列。</summary>
        <returns>成功加入至 <see cref="T:System.Data.DataSet" /> 或在其中重新整理的資料列數目。 這不包含被不傳回資料列之陳述式所影響的資料列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式指定由相關聯的資料來源擷取資料列<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性。 SELECT 陳述式相關聯的連接物件必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>作業接著會將資料列加入到目的地<xref:System.Data.DataTable>中的物件<xref:System.Data.DataSet>、 建立<xref:System.Data.DataTable>如果它們尚不存在的物件。 建立時<xref:System.Data.DataTable>物件<xref:System.Data.Common.DbDataAdapter.Fill%2A>作業通常會建立只有資料行名稱中繼資料。 不過，如果<xref:System.Data.IDataAdapter.MissingSchemaAction%2A>屬性設定為`AddWithKey`，也會建立適當的主索引鍵和條件約束。  
  
 如果<xref:System.Data.Common.DbDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3"等等。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等等） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 您可以使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>上多次相同的方法<xref:System.Data.DataTable>。 如果主索引鍵存在，內送資料列會合併具有相符的資料列已經存在。 如果沒有主索引鍵存在，將內送資料列附加至<xref:System.Data.DataTable>。  
  
 如果 `SelectCommand` 傳回 OUTER JOIN 的結果，則 `DataAdapter` 便不會為產生的 <xref:System.Data.DataTable.PrimaryKey%2A> 設定 <xref:System.Data.DataTable> 值。 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md)。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.Fill%2A>和<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>對於.NET Framework 資料提供者擷取結構描述資訊，只有第一個結果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startRecord" /> 參數小於 0。  
  
 -或-  
  
 <paramref name="maxRecords" /> 參數小於 0。</exception>
        <block subset="none" type="overrides">
          <para>這個多載<see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />被保護的設計為使用.NET Framework 資料提供者方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillCommandBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Data.CommandBehavior FillCommandBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.CommandBehavior FillCommandBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property FillCommandBehavior As CommandBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Data::CommandBehavior FillCommandBehavior { System::Data::CommandBehavior get(); void set(System::Data::CommandBehavior value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.CommandBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來填入資料配接器 (Adapter) 之命令的行為。</summary>
        <value>命令的 <see cref="T:System.Data.CommandBehavior" />，用於填入資料配接器。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加入 <see cref="T:System.Data.DataTable" /> 至 <see cref="T:System.Data.DataSet" />，並且設定結構描述，以符合資料來源中的資料表。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">要插入結構描述的 <see cref="T:System.Data.DataSet" />。</param>
        <param name="schemaType">其中一個 <see cref="T:System.Data.SchemaType" /> 值，指定插入結構描述的方法。</param>
        <summary>將名稱為 "Table" 的 <see cref="T:System.Data.DataTable" /> 加入至指定的 <see cref="T:System.Data.DataSet" />，並根據指定的 <see cref="T:System.Data.SchemaType" />，設定結構描述以符合資料來源中的資料表。</summary>
        <returns>已加入至 <see cref="T:System.Data.DataTable" /> 之 <see cref="T:System.Data.DataSet" /> 物件集合的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會擷取從資料來源使用的結構描述資訊<xref:System.Data.IDbDataAdapter.SelectCommand%2A>。  
  
 A<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會將<xref:System.Data.DataTable>目的地<xref:System.Data.DataSet>。 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>如果存在於資料來源的屬性：  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>。 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>分開。  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則：  
  
-   如果一或多個主索引鍵資料行所傳回<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會做為主要索引鍵資料行<xref:System.Data.DataTable>。  
  
-   如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但<xref:System.Data.DataTable.PrimaryKey%2A>屬性未設定。  
  
-   如果傳回主要索引鍵資料行，唯一的資料行，將主索引鍵資料行做為主要索引鍵資料行<xref:System.Data.DataTable>。  
  
 請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。  
  
 如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。  
  
 主索引鍵資訊會使用於<xref:System.Data.Common.DbDataAdapter.Fill%2A>來尋找和取代其索引鍵資料行符合任何資料列。 如果這不是所要的行為，使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>但未要求結構描述資訊。  
  
 如果<xref:System.Data.IDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3"等等。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.IDbConnection> Select 命令相關聯的物件必須有效，但不需要開啟。 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它仍然為開啟狀態。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
 使用 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 時，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加到正要執行的陳述式。 使用者應注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱《SQL Server 線上叢書》。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.SqlClient.SqlDataAdapter>，以填滿<xref:System.Data.DataSet>與結構描述，以及傳回<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataTable">
          <see cref="T:System.Data.DataTable" />，以資料來源中的結構描述來填入其中。</param>
        <param name="schemaType">其中一個 <see cref="T:System.Data.SchemaType" /> 值。</param>
        <summary>根據指定的 <see cref="T:System.Data.DataTable" />，設定指定 <see cref="T:System.Data.SchemaType" /> 的結構描述。</summary>
        <returns>
          <see cref="T:System.Data.DataTable" />，包含從資料來源傳回的結構描述資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法會擷取從資料來源使用的結構描述<xref:System.Data.IDbDataAdapter.SelectCommand%2A>。 連接物件相關聯<xref:System.Data.IDbDataAdapter.SelectCommand%2A>必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會保持開啟狀態。  
  
 A<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會傳回<xref:System.Data.DataTable>。 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>如果存在於資料來源的屬性：  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>。 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>分開。  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則：  
  
-   如果<xref:System.Data.DataTable.PrimaryKey%2A>已經定義為`DataTable`，或`DataTable`包含資料，`PrimaryKey`未設定屬性。  
  
-   如果一或多個主索引鍵資料行所傳回<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會做為主要索引鍵資料行`DataTable`。  
  
-   如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但`PrimaryKey`屬性未設定。  
  
-   如果傳回主要索引鍵資料行，唯一的資料行，將主索引鍵資料行做為主要索引鍵資料行`DataTable`。  
  
 請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。 此程序可能需要數個往返到伺服器。  
  
 如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。  
  
 如果<xref:System.Data.Common.DbDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3"等等。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 不會傳回任何資料列。 使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法，以將資料列加入<xref:System.Data.DataTable>。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
 使用 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 時，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加到正要執行的陳述式。 使用者應注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱《SQL Server 線上叢書》。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.SqlClient.SqlDataAdapter>，以填滿<xref:System.Data.DataSet>與結構描述，以及傳回<xref:System.Data.DataTable>。  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">要插入結構描述的 <see cref="T:System.Data.DataSet" />。</param>
        <param name="schemaType">其中一個 <see cref="T:System.Data.SchemaType" /> 值，指定插入結構描述的方法。</param>
        <param name="srcTable">用於資料表對應的來源資料表名稱。</param>
        <summary>將 <see cref="T:System.Data.DataTable" /> 加入至指定的 <see cref="T:System.Data.DataSet" />，並且根據指定的 <see cref="T:System.Data.SchemaType" /> 和 <see cref="T:System.Data.DataTable" /> 設定結構描述，以符合資料來源中的資料表。</summary>
        <returns>已加入至 <see cref="T:System.Data.DataTable" /> 之 <see cref="T:System.Data.DataSet" /> 物件集合的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會擷取從資料來源使用的結構描述資訊<xref:System.Data.IDbDataAdapter.SelectCommand%2A>。  
  
 A<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會將<xref:System.Data.DataTable>目的地<xref:System.Data.DataSet>。 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>如果存在於資料來源的屬性：  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>。 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>分開。  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則：  
  
-   如果一或多個主索引鍵資料行所傳回<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會做為主要索引鍵資料行<xref:System.Data.DataTable>。  
  
-   如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但<xref:System.Data.DataTable.PrimaryKey%2A>屬性未設定。  
  
-   如果傳回主要索引鍵資料行，唯一的資料行，將主索引鍵資料行做為主要索引鍵資料行<xref:System.Data.DataTable>。  
  
 請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。  
  
 如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。  
  
 主索引鍵資訊會使用於<xref:System.Data.Common.DbDataAdapter.Fill%2A>來尋找和取代其索引鍵資料行符合任何資料列。 如果這不是所要的行為，使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>但未要求結構描述資訊。  
  
 如果<xref:System.Data.Common.DbDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3"等等。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。 在這種情況下，<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 如果<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.IDbConnection> Select 命令相關聯的物件必須有效，但不需要開啟。 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它仍然為開啟狀態。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
 使用 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 時，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加到正要執行的陳述式。 使用者應注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱《SQL Server 線上叢書》。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.SqlClient.SqlDataAdapter>，以填滿<xref:System.Data.DataSet>與結構描述，以及傳回<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">找不到要從中取得結構描述的來源資料表。</exception>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable">
          <see cref="T:System.Data.DataTable" />，以資料來源中的結構描述來填入其中。</param>
        <param name="schemaType">其中一個 <see cref="T:System.Data.SchemaType" /> 值。</param>
        <param name="command">用來從資料來源擷取資料列的 SQL SELECT 陳述式。</param>
        <param name="behavior">其中一個 <see cref="T:System.Data.CommandBehavior" /> 值。</param>
        <summary>根據指定的 <see cref="T:System.Data.DataTable" />、命令字串和 <see cref="T:System.Data.SchemaType" /> 值，設定指定 <see cref="T:System.Data.CommandBehavior" /> 的結構描述。</summary>
        <returns>
          <see cref="T:System.Data.DataTable" /> 物件，包含從資料來源傳回的結構描述資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法會擷取從資料來源使用的結構描述<xref:System.Data.IDbDataAdapter.SelectCommand%2A>。 連接物件相關聯<xref:System.Data.IDbDataAdapter.SelectCommand%2A>必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會保持開啟狀態。  
  
 A<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會將<xref:System.Data.DataTable>目的地<xref:System.Data.DataSet>。 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>如果存在於資料來源的屬性：  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>。 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>分開。  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則：  
  
-   如果一或多個主索引鍵資料行所傳回<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會做為主要索引鍵資料行<xref:System.Data.DataTable>。  
  
-   如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但<xref:System.Data.DataTable.PrimaryKey%2A>屬性未設定。  
  
-   如果傳回主要索引鍵資料行，唯一的資料行，將主索引鍵資料行做為主要索引鍵資料行<xref:System.Data.DataTable>。  
  
 請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。  
  
 如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。  
  
 如果<xref:System.Data.IDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3"等等。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 不會傳回任何資料列。 使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法，以將資料列加入<xref:System.Data.DataTable>。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
 使用 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 時，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加到正要執行的陳述式。 使用者應注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱《SQL Server 線上叢書》。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這項實作<see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />被保護的設計為使用.NET Framework 資料提供者方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, System.Data.IDbCommand command, string srcTable, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, string srcTable, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::String ^ srcTable, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataSet" />，以資料來源中的結構描述來填入其中。</param>
        <param name="schemaType">其中一個 <see cref="T:System.Data.SchemaType" /> 值。</param>
        <param name="command">用來從資料來源擷取資料列的 SQL SELECT 陳述式。</param>
        <param name="srcTable">用於資料表對應的來源資料表名稱。</param>
        <param name="behavior">其中一個 <see cref="T:System.Data.CommandBehavior" /> 值。</param>
        <summary>將 <see cref="T:System.Data.DataTable" /> 加入至指定的 <see cref="T:System.Data.DataSet" />，並且根據指定的 <see cref="T:System.Data.SchemaType" /> 設定結構描述，以符合資料來源中的資料表。</summary>
        <returns>
          <see cref="T:System.Data.DataTable" /> 物件的陣列，包含從資料來源傳回的結構描述資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法會擷取從資料來源使用的結構描述<xref:System.Data.IDbDataAdapter.SelectCommand%2A>。 連接物件相關聯<xref:System.Data.IDbDataAdapter.SelectCommand%2A>必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會保持開啟狀態。  
  
 A<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會將<xref:System.Data.DataTable>目的地<xref:System.Data.DataSet>。 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>如果存在於資料來源的屬性：  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>。 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>分開。  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則：  
  
-   如果一或多個主索引鍵資料行所傳回<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會做為主要索引鍵資料行<xref:System.Data.DataTable>。  
  
-   如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但<xref:System.Data.DataTable.PrimaryKey%2A>屬性未設定。  
  
-   如果傳回主要索引鍵資料行，唯一的資料行，將主索引鍵資料行做為主要索引鍵資料行<xref:System.Data.DataTable>。  
  
 請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。  
  
 如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。  
  
 如果<xref:System.Data.IDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱"*columnname*1"，"*columnname*2"，"*columnname*3"等等。 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式"Column1"、"Column2"，等等。 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，"Table"、"Table1"、"Table2"等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。 在這種情況下，<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 如果<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 不會傳回任何資料列。 使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法，以將資料列加入<xref:System.Data.DataTable>。  
  
> [!NOTE]
>  處理批次傳回多個結果，實作的 SQL 陳述式時<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取，只有第一個結果的結構描述資訊。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。  
  
 使用 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 時，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加到正要執行的陳述式。 使用者應注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱《SQL Server 線上叢書》。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>這項實作<see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />被保護的設計為使用.NET Framework 資料提供者方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedParameter">
      <MemberSignature Language="C#" Value="protected virtual System.Data.IDataParameter GetBatchedParameter (int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.IDataParameter GetBatchedParameter(int32 commandIdentifier, int32 parameterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedParameter (commandIdentifier As Integer, parameterIndex As Integer) As IDataParameter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::IDataParameter ^ GetBatchedParameter(int commandIdentifier, int parameterIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="parameterIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier">要從其中擷取參數的命令索引。</param>
        <param name="parameterIndex">命令內參數的索引。</param>
        <summary>從目前批次中的其中一個命令傳回 <see cref="T:System.Data.IDataParameter" />。</summary>
        <returns>指定的 <see cref="T:System.Data.IDataParameter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>。 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">配置器不支援批次。</exception>
        <block subset="none" type="overrides">
          <para>這個方法受到保護，可供使用的.NET Framework 資料提供者。  
  
 如果類別繼承自<see cref="T:System.Data.Common.DbDataAdapter" />支援批次，該類別會覆寫此方法可讓使用者執行批次。 實作會使用<paramref name="commandIdentifier" />提供尋找要求的命令，然後使用<paramref name="parameterIndex" />來尋找所要求的參數提供。 例如，<paramref name="commandIdentifier" />的 0 和<paramref name="parameterIndex" />為 0 會傳回第一個參數從批次中第一個命令。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedRecordsAffected">
      <MemberSignature Language="C#" Value="protected virtual bool GetBatchedRecordsAffected (int commandIdentifier, out int recordsAffected, out Exception error);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetBatchedRecordsAffected(int32 commandIdentifier, [out] int32&amp; recordsAffected, [out] class System.Exception&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedRecordsAffected (commandIdentifier As Integer, ByRef recordsAffected As Integer, ByRef error As Exception) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GetBatchedRecordsAffected(int commandIdentifier, [Runtime::InteropServices::Out] int % recordsAffected, [Runtime::InteropServices::Out] Exception ^ % error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="recordsAffected" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="System.Exception&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier">批次中個別命令之以零為基礎的資料行序數。</param>
        <param name="recordsAffected">資料存放區中受批次內指定命令影響的資料行數目。</param>
        <param name="error">在指定命令的執行期間所擲回的 <see cref="T:System.Exception" />。 如果未擲回例外狀況，則傳回 <see langword="null" /> (在 Visual Basic 中為 <see langword="Nothing" />)。</param>
        <summary>傳回在較大之批次更新中嘗試個別更新的相關資訊。</summary>
        <returns>在較大批次更新內個別更新嘗試的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支援批次更新邏輯的資料提供者必須覆寫虛擬方法的一連串<xref:System.Data.Common.DbDataAdapter>類別。 `GetBatchedRecordsAffected` 代表其中一個這些虛擬方法。 `DbDataAdapter`類別會倚賴`GetBatchedRecordsAffected`來判斷成功或失敗的批次內的個別更新嘗試，因此它可以將標記各有一個對應<xref:System.Data.DataRow>據此。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public override System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.GetFillParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得在執行 SQL SELECT 陳述式時由使用者設定的參數。</summary>
        <returns>
          <see cref="T:System.Data.IDataParameter" /> 物件的陣列，含有由使用者設定的參數。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeBatching">
      <MemberSignature Language="C#" Value="protected virtual void InitializeBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.InitializeBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeBatching();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Data.Common.DbDataAdapter" /> 的批次處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>。 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">配置器不支援批次。</exception>
        <block subset="none" type="overrides">
          <para>這個方法受到保護，可供使用的.NET Framework 資料提供者。  
  
 如果類別繼承自<see cref="T:System.Data.Common.DbDataAdapter" />支援批次，該類別會覆寫這個方法。 這個方法可讓類別有機會初始化支援批次處理所需的任何資源。 例如，類別可能會配置來保存命令集的批次中的資料結構。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="InsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property InsertCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ InsertCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來將新的資料錄插入至資料來源的命令。</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" />，在 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> 期間用來為資料集中新的資料列插入在資料來源中的資料錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 期間<xref:System.Data.Common.DbDataAdapter.Update%2A>，如果沒有設定這個屬性，並且出現在主索引鍵資訊<xref:System.Data.DataSet>、<xref:System.Data.IDbDataAdapter.InsertCommand%2A>就會自動產生。  
  
   
  
## Examples  
 下列範例會建立衍生的類別<xref:System.Data.OleDb.OleDbDataAdapter>並設定其屬性的某些。  
  
 [!code-csharp[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdated">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdated (System.Data.Common.RowUpdatedEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdated(class System.Data.Common.RowUpdatedEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdated (value As RowUpdatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdated(System::Data::Common::RowUpdatedEventArgs ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Data.Common.RowUpdatedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 .NET Framework 資料提供者的 <see langword="RowUpdated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需概觀，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdating">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdating (System.Data.Common.RowUpdatingEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdating(class System.Data.Common.RowUpdatingEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdating (value As RowUpdatingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdating(System::Data::Common::RowUpdatingEventArgs ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatingEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">包含事件資料的 <see cref="T:System.Data.Common.RowUpdatingEventArgs" />。</param>
        <summary>引發 .NET Framework 資料提供者的 <see langword="RowUpdating" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需概觀，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SelectCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ SelectCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來在資料來源中選取資料錄的命令。</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" />，在 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> 期間用來為資料集中的位置從資料來源選取資料錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立衍生的類別<xref:System.Data.OleDb.OleDbDataAdapter>並設定其屬性的某些。  
  
 [!code-csharp[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.DeleteCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand" />
      <MemberSignature Language="VB.NET" Value=" Property DeleteCommand As IDbCommand Implements IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.DeleteCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.DeleteCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 SQL 陳述式從資料集刪除資料錄。</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" />，在 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> 期間用來為資料集中所刪除的資料列刪除在資料來源中的資料錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.Common.DbDataAdapter> 執行個體轉換成 <xref:System.Data.IDbDataAdapter> 介面時，才能使用這個成員。  
  
 如需詳細資訊，請參閱<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.InsertCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand" />
      <MemberSignature Language="VB.NET" Value=" Property InsertCommand As IDbCommand Implements IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.InsertCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.InsertCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來將新的資料錄插入至資料來源的 SQL 陳述式。</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" />，在 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> 期間用來為資料集中新的資料列插入在資料來源中的資料錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.Common.DbDataAdapter> 執行個體轉換成 <xref:System.Data.IDbDataAdapter> 介面時，才能使用這個成員。  
  
 如需詳細資訊，請參閱<xref:System.Data.IDbDataAdapter.InsertCommand%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.SelectCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand" />
      <MemberSignature Language="VB.NET" Value=" Property SelectCommand As IDbCommand Implements IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.SelectCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.SelectCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來在資料來源中選取資料錄的 SQL 陳述式。</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" />，在 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> 期間用來為資料集中的位置從資料來源選取資料錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.Common.DbDataAdapter> 執行個體轉換成 <xref:System.Data.IDbDataAdapter> 介面時，才能使用這個成員。  
  
 如需詳細資訊，請參閱<xref:System.Data.IDbDataAdapter.SelectCommand%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.UpdateCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand" />
      <MemberSignature Language="VB.NET" Value=" Property UpdateCommand As IDbCommand Implements IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.UpdateCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.UpdateCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來在資料來源中更新資料錄的 SQL 陳述式。</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" />，在 <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> 期間用來為資料集中所修改的資料列更新在資料來源中的資料錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.Common.DbDataAdapter> 執行個體轉換成 <xref:System.Data.IDbDataAdapter> 介面時，才能使用這個成員。  
  
 如需詳細資訊，請參閱<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立目前執行個體複本的新物件。</summary>
        <returns>這個執行個體複本的新物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.Common.DbDataAdapter> 執行個體轉換成 <xref:System.ICloneable> 介面時，才能使用這個成員。  
  
 如需詳細資訊，請參閱<xref:System.ICloneable.Clone%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TerminateBatching">
      <MemberSignature Language="C#" Value="protected virtual void TerminateBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TerminateBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.TerminateBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TerminateBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TerminateBatching();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束 <see cref="T:System.Data.Common.DbDataAdapter" /> 的批次處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>。 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">配置器不支援批次。</exception>
        <block subset="none" type="overrides">
          <para>這個方法受到保護，可供使用的.NET Framework 資料提供者。  
  
 如果類別繼承自<see cref="T:System.Data.Common.DbDataAdapter" />支援批次，該類別會覆寫這個方法。 這個方法可讓類別 dispose 配置支援批次處理的任何資源。 例如，類別可能會取消配置保存命令批次中的資料結構。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Update">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>針對 <see cref="T:System.Data.DataSet" /> 中的每個插入、更新或刪除的資料列，執行個別的 INSERT、UPDATE 或 DELETE 陳述式，以更新資料庫中的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataRow[] dataRows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataRow[] dataRows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (dataRows As DataRow()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="dataRows">用來更新資料來源的 <see cref="T:System.Data.DataRow" /> 物件陣列。</param>
        <summary>針對 <see cref="T:System.Data.DataSet" /> 的指定陣列中每個插入、更新或刪除的資料列，執行個別的 INSERT、UPDATE 或 DELETE 陳述式，以更新資料庫中的值。</summary>
        <returns>自 <see cref="T:System.Data.DataSet" /> 中成功更新的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據中設定的索引順序<xref:System.Data.DataSet>. 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式，則另一個的 DELETE 陳述式，所以中的資料列的排序<xref:System.Data.DataTable>。  
  
 請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別 （例如，在更新之前插入） 順序的方法。 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)。  
  
 如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要索引鍵資料行資訊會出現在<xref:System.Data.DataSet>。 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)。  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。 <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。 傳回的任何其他資料列都會被忽略。  
  
 任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。 已成功更新資料列之後，會接受該資料列所做的變更。  
  
 當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下所示：  
  
1.  中的值<xref:System.Data.DataRow>移到參數值。  
  
2.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 事件。  
  
3.  執行命令。  
  
4.  如果命令設定為`FirstReturnedRecord`，第一個傳回的結果放在<xref:System.Data.DataRow>。  
  
5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>。  
  
6.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 事件。  
  
7.  呼叫 <xref:System.Data.DataRow.AcceptChanges%2A>。  
  
 每個相關聯的命令<xref:System.Data.Common.DbDataAdapter>通常會有與它關聯的參數集合。 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn` 是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。  
  
 `SourceColumn` 在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。  
  
|列舉值|採取的動作|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|使用中的資料表名稱與來源資料行名稱<xref:System.Data.DataSet>如果不不存在任何對應。|  
|`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。 對應已明確設定，當遺漏對應的輸入參數通常是錯誤的結果。|  
|`MissingMappingAction.Error`|A<xref:System.SystemException>產生。|  
  
 `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。 如果它是指不存在的資料行，會產生例外狀況。  
  
 `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。  
  
> [!NOTE]
>  如果在更新的資料列時發生錯誤，擲回例外狀況，並執行更新已停用。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前先呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>。 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`設定事件，<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>屬性<xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus.Continue>。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.OleDb.OleDbDataAdapter>、 更新資料來源。  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Data.DataSet" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。</exception>
        <exception cref="T:System.SystemException">要更新的 <see cref="T:System.Data.DataRow" /> 不存在。  
  
 -或-  
  
 要更新的 <see cref="T:System.Data.DataTable" /> 不存在。  
  
 -或-  
  
 要用來做為來源的 <see cref="T:System.Data.DataSet" /> 不存在。</exception>
        <exception cref="T:System.Data.DBConcurrencyException">嘗試執行 INSERT、UPDATE 或 DELETE 陳述式會造成沒有資料錄受影響。</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public override int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Update(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Update(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">用來更新資料來源的 <see cref="T:System.Data.DataSet" />。</param>
        <summary>針對指定之 <see cref="T:System.Data.DataSet" /> 中的每個插入、更新或刪除的資料列，執行個別的 INSERT、UPDATE 或 DELETE 陳述式，以更新資料庫中的值。</summary>
        <returns>自 <see cref="T:System.Data.DataSet" /> 中成功更新的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據中設定的索引順序<xref:System.Data.DataSet>. 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式，則另一個的 DELETE 陳述式，所以中的資料列的排序<xref:System.Data.DataTable>。  
  
 請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別 （例如，在更新之前插入） 順序的方法。 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)。  
  
 如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要索引鍵資料行資訊會出現在<xref:System.Data.DataSet>。 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)。  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。 <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。 傳回的任何其他資料列都會被忽略。  
  
 任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。 已成功更新資料列之後，會接受該資料列所做的變更。  
  
 當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下所示：  
  
1.  中的值<xref:System.Data.DataRow>移到參數值。  
  
2.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 事件。  
  
3.  執行命令。  
  
4.  如果命令設定為`FirstReturnedRecord`，則第一個傳回的結果放在<xref:System.Data.DataRow>。  
  
5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>。  
  
6.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 事件。  
  
7.  呼叫 <xref:System.Data.DataRow.AcceptChanges%2A>。  
  
 每個相關聯的命令<xref:System.Data.Common.DbDataAdapter>通常會有與它關聯的參數集合。 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn` 是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。  
  
 `SourceColumn` 在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。  
  
|列舉值|採取的動作|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|使用中的資料表名稱與來源資料行名稱<xref:System.Data.DataSet>如果不不存在任何對應。|  
|`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。 對應已明確設定，當遺漏對應的輸入參數通常是錯誤的結果。|  
|`MissingMappingAction.Error`|A<xref:System.SystemException>產生。|  
  
 `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。 如果它是指不存在的資料行，會產生例外狀況。  
  
 `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。  
  
> [!NOTE]
>  如果在更新的資料列時發生錯誤，擲回例外狀況，並執行更新已停用。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前先呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>。 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`設定事件，<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>屬性<xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus.Continue>。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.OleDb.OleDbDataAdapter>、 更新資料來源。  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。</exception>
        <exception cref="T:System.Data.DBConcurrencyException">嘗試執行 INSERT、UPDATE 或 DELETE 陳述式會造成沒有資料錄受影響。</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataTable ^ dataTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">用來更新資料來源的 <see cref="T:System.Data.DataTable" />。</param>
        <summary>針對指定之 <see cref="T:System.Data.DataTable" /> 中的每個插入、更新或刪除的資料列，執行個別的 INSERT、UPDATE 或 DELETE 陳述式，以更新資料庫中的值。</summary>
        <returns>自 <see cref="T:System.Data.DataTable" /> 中成功更新的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據中設定的索引順序<xref:System.Data.DataSet>. 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式，則另一個的 DELETE 陳述式，所以中的資料列的排序<xref:System.Data.DataTable>。  
  
 請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別 （例如，在更新之前插入） 順序的方法。 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)。  
  
 如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要索引鍵資料行資訊會出現在<xref:System.Data.DataSet>。 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)。  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。 <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。 傳回的任何其他資料列都會被忽略。  
  
 任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。 已成功更新資料列之後，會接受該資料列所做的變更。  
  
 當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下所示：  
  
1.  中的值<xref:System.Data.DataRow>移到參數值。  
  
2.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 事件。  
  
3.  執行命令。  
  
4.  如果命令設定為`FirstReturnedRecord`，則第一個傳回的結果放在<xref:System.Data.DataRow>。  
  
5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>。  
  
6.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 事件。  
  
7.  呼叫 <xref:System.Data.DataRow.AcceptChanges%2A>。  
  
 每個相關聯的命令<xref:System.Data.Common.DbDataAdapter>通常會有與它關聯的參數集合。 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn` 是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。  
  
 `SourceColumn` 在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。  
  
|列舉值|採取的動作|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|使用中的資料表名稱與來源資料行名稱<xref:System.Data.DataSet>如果不不存在任何對應。|  
|`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。 對應已明確設定，當遺漏對應的輸入參數通常是錯誤的結果。|  
|`MissingMappingAction.Error`|A<xref:System.SystemException>產生。|  
  
 `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。 如果它是指不存在的資料行，會產生例外狀況。  
  
 `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。  
  
> [!NOTE]
>  如果在更新的資料列時發生錯誤，擲回例外狀況，並執行更新已停用。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前先呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>。 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`設定事件，<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>屬性<xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus.Continue>。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.OleDb.OleDbDataAdapter>、 更新資料來源。  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Data.DataSet" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。</exception>
        <exception cref="T:System.SystemException">要更新的 <see cref="T:System.Data.DataRow" /> 不存在。  
  
 -或-  
  
 要更新的 <see cref="T:System.Data.DataTable" /> 不存在。  
  
 -或-  
  
 要用來做為來源的 <see cref="T:System.Data.DataSet" /> 不存在。</exception>
        <exception cref="T:System.Data.DBConcurrencyException">嘗試執行 INSERT、UPDATE 或 DELETE 陳述式會造成沒有資料錄受影響。</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="protected virtual int Update (System.Data.DataRow[] dataRows, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Update(class System.Data.DataRow[] dataRows, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Update (dataRows As DataRow(), tableMapping As DataTableMapping) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRows">用來更新資料來源的 <see cref="T:System.Data.DataRow" /> 物件陣列。</param>
        <param name="tableMapping">要使用的 <see cref="P:System.Data.IDataAdapter.TableMappings" /> 集合。</param>
        <summary>針對 <see cref="T:System.Data.DataSet" /> 物件的指定陣列中每個插入、更新或刪除的資料列，執行個別的 INSERT、UPDATE 或 DELETE 陳述式，以更新資料庫中的值。</summary>
        <returns>自 <see cref="T:System.Data.DataSet" /> 中成功更新的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據中設定的索引順序<xref:System.Data.DataSet>. 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式，則另一個的 DELETE 陳述式，所以中的資料列的排序<xref:System.Data.DataTable>。  
  
 請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別 （例如，在更新之前插入） 順序的方法。 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)。  
  
 如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要索引鍵資料行資訊會出現在<xref:System.Data.DataSet>。 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)。  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。 <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。 傳回的任何其他資料列都會被忽略。  
  
 任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。 已成功更新資料列之後，會接受該資料列所做的變更。  
  
 當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下所示：  
  
1.  中的值<xref:System.Data.DataRow>移到參數值。  
  
2.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 事件。  
  
3.  執行命令。  
  
4.  如果命令設定為`FirstReturnedRecord`，則第一個傳回的結果放在<xref:System.Data.DataRow>。  
  
5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>。  
  
6.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 事件。  
  
7.  呼叫 <xref:System.Data.DataRow.AcceptChanges%2A>。  
  
 每個相關聯的命令<xref:System.Data.Common.DbDataAdapter>通常會有與它關聯的參數集合。 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn` 是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。  
  
 `SourceColumn` 在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。  
  
|列舉值|採取的動作|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|使用中的資料表名稱與來源資料行名稱<xref:System.Data.DataSet>如果不不存在任何對應。|  
|`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。 對應已明確設定，當遺漏對應的輸入參數通常是錯誤的結果。|  
|`MissingMappingAction.Error`|A<xref:System.SystemException>產生。|  
  
 `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。 如果它是指不存在的資料行，會產生例外狀況。  
  
 `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。  
  
> [!NOTE]
>  如果在更新的資料列時發生錯誤，擲回例外狀況，並執行更新已停用。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前先呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>。 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`設定事件，<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>屬性<xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus.Continue>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Data.DataSet" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。</exception>
        <exception cref="T:System.SystemException">要更新的 <see cref="T:System.Data.DataRow" /> 不存在。  
  
 -或-  
  
 要更新的 <see cref="T:System.Data.DataTable" /> 不存在。  
  
 -或-  
  
 要用來做為來源的 <see cref="T:System.Data.DataSet" /> 不存在。</exception>
        <exception cref="T:System.Data.DBConcurrencyException">嘗試執行 INSERT、UPDATE 或 DELETE 陳述式會造成沒有資料錄受影響。</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">用來更新資料來源的 <see cref="T:System.Data.DataSet" />。</param>
        <param name="srcTable">用於資料表對應的來源資料表名稱。</param>
        <summary>針對具有指定 <see cref="T:System.Data.DataTable" /> 名稱之 <see cref="T:System.Data.DataSet" /> 中的每個插入、更新或刪除的資料列，執行個別的 INSERT、UPDATE 或 DELETE 陳述式，以更新資料庫中的值。</summary>
        <returns>自 <see cref="T:System.Data.DataSet" /> 中成功更新的資料列數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據中設定的索引順序<xref:System.Data.DataSet>. 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式，則另一個的 DELETE 陳述式，所以中的資料列的排序<xref:System.Data.DataTable>。  
  
 請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別序列中的方法 （例如，更新之前插入）。 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)。  
  
 如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要索引鍵資料行資訊會出現在<xref:System.Data.DataSet>。 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md)。  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。 當多個資料表具有名稱相同但大小寫不同，存在於`DataSet`，<xref:System.Data.Common.DbDataAdapter.Update%2A>執行區分大小寫的比較，來尋找對應的資料表，並產生例外狀況，如果沒有完全相符項目存在。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet ds = new DataSet();  
 ds.Tables.Add("aaa");  
 ds.Tables.Add("AAA");  
 adapter.Update(ds, "aaa"); // Updates "aaa", which already exists in the DataSet.  
 adapter.Update(ds, "AAA"); // Updates "AAA", which already exists in the DataSet.  
    adapter.Update(ds, "Aaa"); // Results in an exception.  
```  
  
 如果<xref:System.Data.Common.DbDataAdapter.Update%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Update(dataset, "AAA"); // Updates table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。 <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。 傳回的任何其他資料列都會被忽略。  
  
 任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。 已成功更新資料列之後，會接受該資料列所做的變更。  
  
 當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下所示：  
  
1.  中的值<xref:System.Data.DataRow>移到參數值。  
  
2.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> 事件。  
  
3.  執行命令。  
  
4.  如果命令設定為`FirstReturnedRecord`，則第一個傳回的結果放在<xref:System.Data.DataRow>。  
  
5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>。  
  
6.  便會引發 <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> 事件。  
  
7.  呼叫 <xref:System.Data.DataRow.AcceptChanges%2A>。  
  
 每個相關聯的命令<xref:System.Data.Common.DbDataAdapter>通常會有與它關聯的參數集合。 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn` 是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。  
  
 `SourceColumn` 在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。  
  
|列舉值|採取的動作|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|使用中的資料表名稱與來源資料行名稱<xref:System.Data.DataSet>如果不不存在任何對應。|  
|`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。 對應已明確設定，當遺漏對應的輸入參數通常是錯誤的結果。|  
|`MissingMappingAction.Error`|A<xref:System.SystemException>產生。|  
  
 `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。 如果它是指不存在的資料行，會產生例外狀況。  
  
 `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。  
  
> [!NOTE]
>  如果在更新的資料列時發生錯誤，擲回例外狀況，並執行更新已停用。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前先呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>。 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`設定事件，<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>屬性<xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus.Continue>。  
  
   
  
## Examples  
 下列範例會使用衍生的類別， <xref:System.Data.OleDb.OleDbDataAdapter>、 更新資料來源。  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Data.DataSet" /> 無效。</exception>
        <exception cref="T:System.InvalidOperationException">來源資料表無效。</exception>
        <exception cref="T:System.Data.DBConcurrencyException">嘗試執行 INSERT、UPDATE 或 DELETE 陳述式會造成沒有資料錄受影響。</exception>
      </Docs>
    </Member>
    <Member MemberName="UpdateBatchSize">
      <MemberSignature Language="C#" Value="public virtual int UpdateBatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 UpdateBatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property UpdateBatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int UpdateBatchSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，其啟用或停用批次處理支援，並指定可於批次中執行的命令數目。</summary>
        <value>每一批次要處理的資料列數目。  
  
 <list type="table"><listheader><term> 值是  
  
 </term><description> 效果  
  
 </description></listheader><item><term> 0  
  
 </term><description> 批次大小沒有任何限制。  
  
 </description></item><item><term> 1  
  
 </term><description> 停用批次更新。  
  
 </description></item><item><term> &gt; 1  
  
 </term><description> 變更使用的批次傳送<see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />一次作業。  
  
 </description></item></list>  
  
 當設定為 1 以外的值，與相關聯的所有命令<see cref="T:System.Data.Common.DbDataAdapter" />必須要有其<see cref="P:System.Data.IDbCommand.UpdatedRowSource" />屬性設定為**無**或**輸出參數**。 否則會擲回例外狀況。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.Common.DbDataAdapter.UpdateBatchSize%2A>屬性來更新資料來源的變更與<xref:System.Data.DataSet>。 如果資料提供者支援批次處理，這可藉由減少伺服器的來回次數來增加應用程式的效能。 在 ADO.NET 2.0 中，這個屬性可支援.NET 資料提供者的 SQL Server (SqlClient) 和 Oracle (OracleClient)。  
  
 執行極大的批次可能會降低效能。 因此，您應該先測試理想的批次大小設定，再實作應用程式。  
  
 <xref:System.ArgumentOutOfRangeException>會擲回此值設為號碼小於零。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ UpdateCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來在資料來源中更新資料錄的命令。</summary>
        <value>
          <see cref="T:System.Data.IDbCommand" />，在 <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> 期間用來為資料集中修改的資料列更新在資料來源中的資料錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 期間<xref:System.Data.Common.DbDataAdapter.Update%2A>，如果沒有設定這個屬性，並且出現在主索引鍵資訊<xref:System.Data.DataSet>、<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>就會自動產生。  
  
   
  
## Examples  
 下列範例會建立衍生的類別<xref:System.Data.OleDb.OleDbDataAdapter>並設定其屬性的某些。  
  
 [!code-csharp[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>