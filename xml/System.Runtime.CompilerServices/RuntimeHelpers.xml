<Type Name="RuntimeHelpers" FullName="System.Runtime.CompilerServices.RuntimeHelpers">
  <TypeSignature Language="C#" Value="public static class RuntimeHelpers" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.RuntimeHelpers" />
  <TypeSignature Language="VB.NET" Value="Public Class RuntimeHelpers" />
  <TypeSignature Language="C++ CLI" Value="public ref class RuntimeHelpers abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="f5dac-101">提供支援編譯器的一組靜態方法和屬性。</span><span class="sxs-lookup"><span data-stu-id="f5dac-101">Provides a set of static methods and properties that provide support for compilers.</span></span> <span data-ttu-id="f5dac-102">這個類別無法被繼承。</span><span class="sxs-lookup"><span data-stu-id="f5dac-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f5dac-103">下列範例示範如何可靠地使用設定控制代碼<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-103">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="f5dac-104">若要可靠地設為指定的既有控制代碼的控制代碼，您必須確保原生控制代碼的配置和後續記錄內的控制代碼的<xref:System.Runtime.InteropServices.SafeHandle>物件是不可部分完成。</span><span class="sxs-lookup"><span data-stu-id="f5dac-104">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="f5dac-105">這些作業 （例如，執行緒中止或記憶體不足例外狀況） 之間的任何失敗會導致外洩的原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-105">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span>  <span data-ttu-id="f5dac-106">您可以使用<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>方法來確保控制代碼不會外洩。</span><span class="sxs-lookup"><span data-stu-id="f5dac-106">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static void EnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsureSufficientExecutionStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnsureSufficientExecutionStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f5dac-107">確保其餘的堆疊空間夠大，足以執行一般的 .NET Framework 功能。</span><span class="sxs-lookup"><span data-stu-id="f5dac-107">Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> 提供相關資訊會保留足夠的空間會引發例外狀況以人為方式限制堆疊與所要採取的修復動作。</span><span class="sxs-lookup"><span data-stu-id="f5dac-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</span></span> <span data-ttu-id="f5dac-109">通用語言執行平台選擇的人為的堆疊限制確保足夠的空間保持安全地擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f5dac-109">The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</span></span>  
  
 <span data-ttu-id="f5dac-110">這個方法是在位置堆疊溢位可能會造成無限遞迴的情況下很有用。</span><span class="sxs-lookup"><span data-stu-id="f5dac-110">This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</span></span> <span data-ttu-id="f5dac-111">它適用於在編譯器服務案例中，雖然它也可安全地在其他開發案例。</span><span class="sxs-lookup"><span data-stu-id="f5dac-111">It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</span></span>  
  
 <span data-ttu-id="f5dac-112">如果堆疊空間不足，才會擲回例外狀況，和大部分的.NET Framework 類型和成員仍然可以呼叫。</span><span class="sxs-lookup"><span data-stu-id="f5dac-112">If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f5dac-113">這個方法不是限制的執行區域 (CER) 支援的一部分，且不能與混淆<xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-113">This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientExecutionStackException"><span data-ttu-id="f5dac-114">可用的堆疊空間不足，無法執行平均 .NET Framework 函式。</span><span class="sxs-lookup"><span data-stu-id="f5dac-114">The available stack space is insufficient to execute the average .NET Framework function.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object o1, object o2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object o1, object o2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (o1 As Object, o2 As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ o1, System::Object ^ o2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o1" Type="System.Object" />
        <Parameter Name="o2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o1"><span data-ttu-id="f5dac-115">要比較的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="f5dac-115">The first object to compare.</span></span></param>
        <param name="o2"><span data-ttu-id="f5dac-116">要比較的第二個物件。</span><span class="sxs-lookup"><span data-stu-id="f5dac-116">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="f5dac-117">判斷指定的 <see cref="T:System.Object" /> 執行個體是否視為相等。</span><span class="sxs-lookup"><span data-stu-id="f5dac-117">Determines whether the specified <see cref="T:System.Object" /> instances are considered equal.</span></span></summary>
        <returns>
          <span data-ttu-id="f5dac-118">如果 <paramref name="o1" /> 參數是與 <paramref name="o2" /> 參數相同的執行個體，或兩者都是 <see langword="null" />，或 <c>o1.Equals(o2)</c> 傳回 <see langword="true" /> 的話，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f5dac-118"><see langword="true" /> if the <paramref name="o1" /> parameter is the same instance as the <paramref name="o2" /> parameter, or if both are <see langword="null" />, or if <c>o1.Equals(o2)</c> returns <see langword="true" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-119">編譯器會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-119">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f5dac-120">下列範例示範如何藉由比較兩個物件<xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-120">The following example demonstrates how to compare two objects by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteCodeWithGuaranteedCleanup">
      <MemberSignature Language="C#" Value="public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExecuteCodeWithGuaranteedCleanup(class System.Runtime.CompilerServices.RuntimeHelpers/TryCode code, class System.Runtime.CompilerServices.RuntimeHelpers/CleanupCode backoutCode, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExecuteCodeWithGuaranteedCleanup (code As RuntimeHelpers.TryCode, backoutCode As RuntimeHelpers.CleanupCode, userData As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExecuteCodeWithGuaranteedCleanup(System::Runtime::CompilerServices::RuntimeHelpers::TryCode ^ code, System::Runtime::CompilerServices::RuntimeHelpers::CleanupCode ^ backoutCode, System::Object ^ userData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Runtime.CompilerServices.RuntimeHelpers+TryCode" />
        <Parameter Name="backoutCode" Type="System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="code"><span data-ttu-id="f5dac-121">要嘗試之程式碼的委派。</span><span class="sxs-lookup"><span data-stu-id="f5dac-121">A delegate to the code to try.</span></span></param>
        <param name="backoutCode"><span data-ttu-id="f5dac-122">在發生例外狀況時執行的程式碼委派。</span><span class="sxs-lookup"><span data-stu-id="f5dac-122">A delegate to the code to run if an exception occurs.</span></span></param>
        <param name="userData"><span data-ttu-id="f5dac-123">資料要傳遞至 <c>code</c> 和 <c>backoutCode</c>。</span><span class="sxs-lookup"><span data-stu-id="f5dac-123">The data to pass to <c>code</c> and <c>backoutCode</c>.</span></span></param>
        <summary><span data-ttu-id="f5dac-124">使用 <see cref="T:System.Delegate" /> 執行程式碼，如果發生例外狀況，則使用另一個 <see cref="T:System.Delegate" /> 執行其他程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-124">Executes code using a <see cref="T:System.Delegate" /> while using another <see cref="T:System.Delegate" /> to execute additional code in case of an exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-125">編譯器會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-125">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f5dac-126">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f5dac-126">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f5dac-127">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-127">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f5dac-128">要為其擷取雜湊程式碼的物件。</span><span class="sxs-lookup"><span data-stu-id="f5dac-128">An object to retrieve the hash code for.</span></span></param>
        <summary><span data-ttu-id="f5dac-129">做為特定物件的雜湊函式，適合在使用雜湊碼之雜湊演算法及資料結構中使用。</span><span class="sxs-lookup"><span data-stu-id="f5dac-129">Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</span></span></summary>
        <returns><span data-ttu-id="f5dac-130">由 <paramref name="o" /> 參數所識別之物件的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-130">A hash code for the object identified by the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-131"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>方法一律會呼叫<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>方法非為虛擬，否則，即使物件的型別已覆寫<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-131">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f5dac-132">因此，使用<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>呼叫可能會與不同`GetHashCode`物件上直接<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-132">Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="f5dac-133">雖然<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>方法會傳回相同的物件參考相同的雜湊程式碼，您不應該使用這個方法來測試物件識別，因為此雜湊程式碼並未唯一識別的物件參考。</span><span class="sxs-lookup"><span data-stu-id="f5dac-133">Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</span></span> <span data-ttu-id="f5dac-134">若要測試的物件識別 （也就是要測試有兩個物件參考相同的物件，在記憶體中），呼叫<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-134">To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f5dac-135">也不應該使用<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A>來測試是否兩個字串代表相等的物件參考，因為實習的字串。</span><span class="sxs-lookup"><span data-stu-id="f5dac-135">Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned.</span></span> <span data-ttu-id="f5dac-136">若要測試的字串拘留，呼叫<xref:System.String.IsInterned%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-136">To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f5dac-137"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>和<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>方法不同，如下所示：</span><span class="sxs-lookup"><span data-stu-id="f5dac-137">The <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods differ as follows:</span></span>  
  
-   <span data-ttu-id="f5dac-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 傳回的物件定義的等號比較為基礎的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that is based on the object's definition of equality.</span></span> <span data-ttu-id="f5dac-139">例如，兩個字串完全相同的內容將會傳回相同的值<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f5dac-139">For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="f5dac-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 傳回表示物件身分識別的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that indicates object identity.</span></span> <span data-ttu-id="f5dac-141">也就兩個字串的變數的內容完全相同，且代表實習的字串 (請參閱[字串拘留](#interning)> 一節) 或的代表記憶體中的單一字串傳回完全相同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-141">That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f5dac-142">請注意，<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A>一律會傳回相同的物件參考相同的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-142">Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references.</span></span> <span data-ttu-id="f5dac-143">不過，反向並不成立： 等於雜湊程式碼並不指示進行相等的物件參考。</span><span class="sxs-lookup"><span data-stu-id="f5dac-143">However, the reverse is not true: equal hash codes do not indicate equal object references.</span></span> <span data-ttu-id="f5dac-144">特定的雜湊碼值不是唯一一個特定的物件參考。不同的物件參考可以產生相同雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-144">A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</span></span>  
  
 <span data-ttu-id="f5dac-145">編譯器會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-145">This method is used by compilers.</span></span>  
  
<a name="interning"></a>   
## <a name="string-interning"></a><span data-ttu-id="f5dac-146">字串拘留</span><span class="sxs-lookup"><span data-stu-id="f5dac-146">String Interning</span></span>  
 <span data-ttu-id="f5dac-147">Common language runtime (CLR) 會維護字串內部集區和儲存集區中的常值。</span><span class="sxs-lookup"><span data-stu-id="f5dac-147">The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</span></span> <span data-ttu-id="f5dac-148">如果兩個字串 (例如，`str1`和`str2`) 會組成相同的字串常值中，CLR 會設定`str1`和`str2`指向相同的位置，以節省記憶體 managed 堆積上。</span><span class="sxs-lookup"><span data-stu-id="f5dac-148">If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory.</span></span> <span data-ttu-id="f5dac-149">呼叫<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>這些兩個字串物件將會產生相同雜湊程式碼，fci 上一節中的第二個項目符號項目。</span><span class="sxs-lookup"><span data-stu-id="f5dac-149">Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</span></span>  
  
 <span data-ttu-id="f5dac-150">CLR 會將只有常值加入至集區。</span><span class="sxs-lookup"><span data-stu-id="f5dac-150">The CLR adds only literals to the pool.</span></span> <span data-ttu-id="f5dac-151">例如串連的字串作業的結果不會加入至集區，除非編譯器會解析成單一字串常值的字串串連。</span><span class="sxs-lookup"><span data-stu-id="f5dac-151">Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</span></span> <span data-ttu-id="f5dac-152">因此，如果`str2`串連作業的結果建立了和`str2`等同於`str1`，並使用<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>這些兩個字串物件將不會產生相同雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-152">Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will not produce the same hash code.</span></span>  
  
 <span data-ttu-id="f5dac-153">如果您想要明確地新增到集區的串連的字串，使用<xref:System.String.Intern%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-153">If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f5dac-154">您也可以使用<xref:System.String.IsInterned%2A?displayProperty=nameWithType>方法檢查字串是否具有實習的參考。</span><span class="sxs-lookup"><span data-stu-id="f5dac-154">You can also use the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method to check whether a string has an interned reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f5dac-155">下列範例示範之間的差異<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>和<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-155">The following example demonstrates the difference between the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f5dac-156">範例輸出說明下列各項：</span><span class="sxs-lookup"><span data-stu-id="f5dac-156">The output from the example illustrates the following:</span></span>  
  
-   <span data-ttu-id="f5dac-157">這兩組的雜湊碼的第一個集合的字串傳遞至`ShowHashCodes`方法都不同，因為是完全不同的字串。</span><span class="sxs-lookup"><span data-stu-id="f5dac-157">Both sets of hash codes for the first set of strings passed to the `ShowHashCodes` method are different, because the strings are completely different.</span></span>  
  
-   <span data-ttu-id="f5dac-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 會產生相同雜湊程式碼的第二組的字串傳遞至`ShowHashCodes`方法，因為字串相等。</span><span class="sxs-lookup"><span data-stu-id="f5dac-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> generates the same hash code for the second set of strings passed to the `ShowHashCodes` method, because the strings are equal.</span></span> <span data-ttu-id="f5dac-159">不過，<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>方法則否。</span><span class="sxs-lookup"><span data-stu-id="f5dac-159">However, the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method does not.</span></span> <span data-ttu-id="f5dac-160">第一個字串是由定義使用字串常值和實習因此。</span><span class="sxs-lookup"><span data-stu-id="f5dac-160">The first string is defined by using a string literal and so is interned.</span></span> <span data-ttu-id="f5dac-161">第二個字串的值都相同，雖然它不實習，因為它由呼叫<xref:System.String.Format%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-161">Although the value of the second string is the same, it is not interned, because it is returned by a call to the <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="f5dac-162">在第三個字串，雜湊程式碼所產生的<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>的這兩個字串完全相同，所產生之雜湊碼的<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f5dac-162">In the case of the third string, the hash codes produced by <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> for both strings are identical, as are the hash codes produced by <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f5dac-163">這是因為編譯器已被視為單一的字串常值，以指派至這兩個字串的值，使其參考相同的實習字串的字串變數。</span><span class="sxs-lookup"><span data-stu-id="f5dac-163">This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectValue">
      <MemberSignature Language="C#" Value="public static object GetObjectValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectValue(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="f5dac-164">要進行 Box 的實值類型。</span><span class="sxs-lookup"><span data-stu-id="f5dac-164">The value type to be boxed.</span></span></param>
        <summary><span data-ttu-id="f5dac-165">對實值類型進行 Box 動作。</span><span class="sxs-lookup"><span data-stu-id="f5dac-165">Boxes a value type.</span></span></summary>
        <returns><span data-ttu-id="f5dac-166">如果是值類別，則為 <paramref name="obj" /> Boxed 複本，否則為 <paramref name="obj" /> 本身。</span><span class="sxs-lookup"><span data-stu-id="f5dac-166">A boxed copy of <paramref name="obj" /> if it is a value class; otherwise, <paramref name="obj" /> itself.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-167">Box 處理實值類型建立的物件，並執行新的物件將指定的值類型欄位的淺層複本。</span><span class="sxs-lookup"><span data-stu-id="f5dac-167">Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</span></span>  
  
 <span data-ttu-id="f5dac-168">這個方法可讓實值類別，它會保留的實值類別別名行為時，做為物件可操作。</span><span class="sxs-lookup"><span data-stu-id="f5dac-168">This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</span></span>  
  
 <span data-ttu-id="f5dac-169">傳回的值取決於實值類別是否處於可變動或不變：</span><span class="sxs-lookup"><span data-stu-id="f5dac-169">The return value depends on whether the value class is mutable or immutable:</span></span>  
  
-   <span data-ttu-id="f5dac-170">如果指派的值是可變動值類別，方法會傳回類別的淺層複本，因為實值類別具有複製語意。</span><span class="sxs-lookup"><span data-stu-id="f5dac-170">If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</span></span>  
  
-   <span data-ttu-id="f5dac-171">如果不可變的實值類別指派的值，則方法會傳回物件本身，而不是類別的複本。</span><span class="sxs-lookup"><span data-stu-id="f5dac-171">If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</span></span>  
  
 <span data-ttu-id="f5dac-172">動態具類型的語言編譯器可以使用這個方法，以確定 boxed 實的值類型相同用於 unboxed 實的值類型。</span><span class="sxs-lookup"><span data-stu-id="f5dac-172">Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</span></span> <span data-ttu-id="f5dac-173">也就是當您傳遞，而且永遠依值傳遞時，取得複製 boxed 實的值類型。</span><span class="sxs-lookup"><span data-stu-id="f5dac-173">That is, boxed value types get cloned when you pass them around, and they are always passed by value.</span></span> <span data-ttu-id="f5dac-174">編譯器可以呼叫<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A>指派實值類型的物件，或傳遞實值類型做為參數的型別物件。</span><span class="sxs-lookup"><span data-stu-id="f5dac-174">The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.</span></span>  
  
 <span data-ttu-id="f5dac-175">編譯器會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-175">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f5dac-176">下列範例示範如何使用方塊實值類別<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-176">The following example demonstrates how to box a value class by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUninitializedObject(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeArray">
      <MemberSignature Language="C#" Value="public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitializeArray(class System.Array array, valuetype System.RuntimeFieldHandle fldHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitializeArray(Array ^ array, RuntimeFieldHandle fldHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="fldHandle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="f5dac-177">要初始化的陣列。</span><span class="sxs-lookup"><span data-stu-id="f5dac-177">The array to be initialized.</span></span></param>
        <param name="fldHandle"><span data-ttu-id="f5dac-178">一種欄位控制代碼，可指定用來初始化陣列的資料位置。</span><span class="sxs-lookup"><span data-stu-id="f5dac-178">A field handle that specifies the location of the data used to initialize the array.</span></span></param>
        <summary><span data-ttu-id="f5dac-179">提供從儲存在模組中的資料初始化陣列的快速方式。</span><span class="sxs-lookup"><span data-stu-id="f5dac-179">Provides a fast way to initialize an array from data that is stored in a module.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-180">編譯器會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-180">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceOrContainsReferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsReferenceOrContainsReferences&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReferenceOrContainsReferences&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsReferenceOrContainsReferences(Of T) () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsReferenceOrContainsReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetToStringData">
      <MemberSignature Language="C#" Value="public static int OffsetToStringData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 OffsetToStringData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OffsetToStringData As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int OffsetToStringData { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f5dac-181">取得指定字串中資料的位移 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="f5dac-181">Gets the offset, in bytes, to the data in the given string.</span></span></summary>
        <value><span data-ttu-id="f5dac-182">從 <see cref="T:System.String" /> 物件開始到字串中之第一個字元的位元組位移。</span><span class="sxs-lookup"><span data-stu-id="f5dac-182">The byte offset, from the start of the <see cref="T:System.String" /> object to the first character in the string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-183">編譯器會使用這個屬性不安全，但有效率的指標上的作業中的 managed 字串的字元。</span><span class="sxs-lookup"><span data-stu-id="f5dac-183">Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</span></span> <span data-ttu-id="f5dac-184">編譯器應該固定使用之前在記憶體回收行程移動對字串。</span><span class="sxs-lookup"><span data-stu-id="f5dac-184">Compilers should pin the string against movement by the garbage collector before use.</span></span> <span data-ttu-id="f5dac-185">請注意，通用語言執行階段字串是不可變的;也就是說，可以讀取但不是會變更其內容。</span><span class="sxs-lookup"><span data-stu-id="f5dac-185">Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegions">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f5dac-186">指定一段程式碼主體做為限制的執行區域 (CER)。</span><span class="sxs-lookup"><span data-stu-id="f5dac-186">Designates a body of code as a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-187">編譯器會使用這個方法來標示`catch`， `finally`，和`fault`為限制的執行區域 (Cer) 的區塊。</span><span class="sxs-lookup"><span data-stu-id="f5dac-187">Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs).</span></span> <span data-ttu-id="f5dac-188">已標示為限制的區域必須只呼叫有充分的可靠性合約的其他程式碼的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-188">Code that is marked as a constrained region must only call other code with strong reliability contracts.</span></span> <span data-ttu-id="f5dac-189">它不應該配置或進行虛擬呼叫或不可靠的方法，除非它已準備好要處理失敗。</span><span class="sxs-lookup"><span data-stu-id="f5dac-189">It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</span></span>  
  
 <span data-ttu-id="f5dac-190">請注意，不對中繼語言 opcode，除了`NOP`，允許呼叫間<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>方法和`try`區塊。</span><span class="sxs-lookup"><span data-stu-id="f5dac-190">Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block.</span></span> <span data-ttu-id="f5dac-191">如需 Cer 的詳細資訊，請參閱中的類別<xref:System.Runtime.ConstrainedExecution>命名空間。</span><span class="sxs-lookup"><span data-stu-id="f5dac-191">For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.</span></span>  
  
 <span data-ttu-id="f5dac-192">使用標示的 Cer<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>方法無法完全運作時<xref:System.StackOverflowException>產生從`try`區塊。</span><span class="sxs-lookup"><span data-stu-id="f5dac-192">CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block.</span></span> <span data-ttu-id="f5dac-193">如需詳細資訊，請參閱 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-193">For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.</span></span>  
  
 <span data-ttu-id="f5dac-194"><xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 方法會呼叫 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-194">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f5dac-195">下列範例示範如何可靠地使用設定控制代碼<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-195">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="f5dac-196">若要可靠地設為指定的既有控制代碼的控制代碼，您必須確保原生控制代碼的配置和後續記錄內的控制代碼的<xref:System.Runtime.InteropServices.SafeHandle>物件是不可部分完成。</span><span class="sxs-lookup"><span data-stu-id="f5dac-196">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="f5dac-197">這些作業 （例如，執行緒中止或記憶體不足例外狀況） 之間的任何失敗會導致外洩的原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-197">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span> <span data-ttu-id="f5dac-198">您可以使用<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>方法來確保控制代碼不會外洩。</span><span class="sxs-lookup"><span data-stu-id="f5dac-198">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f5dac-199">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f5dac-199">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f5dac-200">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-200">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegionsNoOP">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegionsNoOP ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegionsNoOP() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegionsNoOP ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegionsNoOP();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f5dac-201">指定程式碼主體做為限制的執行區域 (CER)，但不執行任何探查。</span><span class="sxs-lookup"><span data-stu-id="f5dac-201">Designates a body of code as a constrained execution region (CER) without performing any probing.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-202">編譯器不應該直接呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-202">Compilers should not call this method directly.</span></span> <span data-ttu-id="f5dac-203">相反地，藉由呼叫定義 CER<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-203">Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f5dac-204">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f5dac-204">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f5dac-205">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-205">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareContractedDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareContractedDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareContractedDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareContractedDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareContractedDelegate(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="f5dac-206">要準備的事件委派。</span><span class="sxs-lookup"><span data-stu-id="f5dac-206">The event delegate to prepare.</span></span></param>
        <summary><span data-ttu-id="f5dac-207">提供讓應用程式動態準備 <see cref="T:System.AppDomain" /> 事件委派的方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-207">Provides a way for applications to dynamically prepare <see cref="T:System.AppDomain" /> event delegates.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-208"><xref:System.AppDomain> 事件的委派例如<xref:System.AppDomain.DomainUnload>， <xref:System.AppDomain.ProcessExit>，和<xref:System.AppDomain.UnhandledException>在啟動時不會自動準備。</span><span class="sxs-lookup"><span data-stu-id="f5dac-208"><xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup.</span></span> <span data-ttu-id="f5dac-209">您可以使用下列方法，以準備：</span><span class="sxs-lookup"><span data-stu-id="f5dac-209">You can use the following methods to prepare them:</span></span>  
  
-   <span data-ttu-id="f5dac-210">使用屬性方法<xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="f5dac-210">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="f5dac-211">使用屬性方法<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="f5dac-211">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="f5dac-212">呼叫<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A>動態準備委派的方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-212">Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.</span></span>  
  
 <span data-ttu-id="f5dac-213">如需詳細資訊，請參閱文章[保持您程式碼執行與.NET Framework 的可靠性功能](http://go.microsoft.com/fwlink/?LinkId=145491)MSDN Magazine 中。</span><span class="sxs-lookup"><span data-stu-id="f5dac-213">For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f5dac-214">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f5dac-214">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f5dac-215">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-215">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareDelegate(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="f5dac-216">要準備的委派類型。</span><span class="sxs-lookup"><span data-stu-id="f5dac-216">The delegate type to prepare.</span></span></param>
        <summary><span data-ttu-id="f5dac-217">表示應該準備指定的委派，以便將該委派加入限制的執行區域 (CER)。</span><span class="sxs-lookup"><span data-stu-id="f5dac-217">Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-218">編譯器會使用此方法準備委派的引動過程的方法，並準備目標的這個引動過程 （和委派以靜態方式判斷呼叫歷程圖） 做為限制的執行區域 (CER)。</span><span class="sxs-lookup"><span data-stu-id="f5dac-218">Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f5dac-219">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f5dac-219">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f5dac-220">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-220">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="PrepareMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f5dac-221">準備要加入至限制的執行區域 (CER) 的方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-221">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="f5dac-222">要準備的方法控制代碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-222">A handle to the method to prepare.</span></span></param>
        <summary><span data-ttu-id="f5dac-223">準備要加入至限制的執行區域 (CER) 的方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-223">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-224">編譯器會使用<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29>方法以處理限制的執行區域 (CER) 內進行虛擬呼叫。</span><span class="sxs-lookup"><span data-stu-id="f5dac-224">Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER).</span></span> <span data-ttu-id="f5dac-225">在 JIT 編譯時期，通用語言執行平台通常沒有足夠資訊虛擬呼叫的目標。</span><span class="sxs-lookup"><span data-stu-id="f5dac-225">At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</span></span> <span data-ttu-id="f5dac-226">因此，執行階段不一開始會準備該區段的呼叫歷程圖。</span><span class="sxs-lookup"><span data-stu-id="f5dac-226">Therefore, the runtime does not initially prepare that segment of the call graph.</span></span> <span data-ttu-id="f5dac-227">如果使用 CER 程式碼有足夠的資訊來判斷在任何時間點目標的 CER 之前的時間實際上在輸入，它可以呼叫<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29>執行相同的執行階段準備通常針對完成 CER 根目錄指定做為引數的方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-227">If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f5dac-228">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f5dac-228">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f5dac-229">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-229">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle[] instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle, instantiation As RuntimeTypeHandle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method, cli::array &lt;RuntimeTypeHandle&gt; ^ instantiation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="instantiation" Type="System.RuntimeTypeHandle[]" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="f5dac-230">要準備的方法控制代碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-230">A handle to the method to prepare.</span></span></param>
        <param name="instantiation"><span data-ttu-id="f5dac-231">要傳遞至方法的執行個體化。</span><span class="sxs-lookup"><span data-stu-id="f5dac-231">The instantiation to pass to the method.</span></span></param>
        <summary><span data-ttu-id="f5dac-232">使用指定的執行個體化 (Instantiation) 準備要加入至限制的執行區域 (CER) 的方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-232">Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-233">您可以使用泛型都支援適用於編譯器<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-233">You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method.</span></span> <span data-ttu-id="f5dac-234">Common language runtime 無法準備限制的執行區域 (Cer) 的方法具有泛型型別參數 （可能是型別參數上的方法或另一個在方法本身包含的類別），在根項目時具現化這些型別參數做為參考型別。</span><span class="sxs-lookup"><span data-stu-id="f5dac-234">The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</span></span>  
  
 <span data-ttu-id="f5dac-235">您可以使用這個多載，將特定的具現化，（例如陣列的型別），第一次指定類別型別參數 （如果有的話），後面接著方法型別參數 （如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="f5dac-235">You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</span></span> <span data-ttu-id="f5dac-236">執行階段準備的具現化的方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-236">The runtime prepares that instantiation of the method.</span></span> <span data-ttu-id="f5dac-237">（這是您使用具現化包含至少一個參考型別參數時，才需要。）因此，您可以使用 CER 樣式`try`泛型方法 （或在泛型類別上的非泛型方法） 中的子句和可靠地運作的具現化與<xref:System.Int32>或其他實值類型。</span><span class="sxs-lookup"><span data-stu-id="f5dac-237">(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types.</span></span> <span data-ttu-id="f5dac-238">具現化參考類型例如<xref:System.String>，您必須使用明確<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29>CER 方法根方法的第一次。</span><span class="sxs-lookup"><span data-stu-id="f5dac-238">To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f5dac-239">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f5dac-239">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f5dac-240">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-240">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ProbeForSufficientStack">
      <MemberSignature Language="C#" Value="public static void ProbeForSufficientStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ProbeForSufficientStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ProbeForSufficientStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ProbeForSufficientStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f5dac-241">探查特定的堆疊空間量，以確保後續的程式碼區塊中不會發生堆疊溢位 (假設您的程式碼只使用有限且適量的堆疊空間)。</span><span class="sxs-lookup"><span data-stu-id="f5dac-241">Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</span></span> <span data-ttu-id="f5dac-242">建議您使用限制的執行區域 (CER) 來取代這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-242">We recommend that you use a constrained execution region (CER) instead of this method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-243">限制的執行區域 (CER) 基礎結構有彈性地堆疊溢位，例如 Microsoft SQL Server 和 Microsoft Exchange Server 的主機中執行時，會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-243">This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</span></span> <span data-ttu-id="f5dac-244">這個方法目前探查 48 KB 的堆疊空間 x86 平台，但確切的容量可能會隨著時間改變，而在其他平台上可能有所不同。</span><span class="sxs-lookup"><span data-stu-id="f5dac-244">This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</span></span>  
  
 <span data-ttu-id="f5dac-245">編譯器也會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-245">This method is also used by compilers.</span></span>  
  
 <span data-ttu-id="f5dac-246">而不是使用<xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A>方法，您應該使用標準的 CER。</span><span class="sxs-lookup"><span data-stu-id="f5dac-246">Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER.</span></span> <span data-ttu-id="f5dac-247">如果您打算使用適量的堆疊空間，也就是呼叫<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType>方法之前，立即您`try` / `finally`或`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="f5dac-247">That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method immediately before your `try`/`finally` or `try`/`catch` block.</span></span> <span data-ttu-id="f5dac-248">如果您將會呼叫遞迴方法或計劃以使用大量的堆疊空間，您必須使用<xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-248">If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f5dac-249">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="f5dac-249">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f5dac-250">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="f5dac-250">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="RunClassConstructor">
      <MemberSignature Language="C#" Value="public static void RunClassConstructor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunClassConstructor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunClassConstructor (type As RuntimeTypeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunClassConstructor(RuntimeTypeHandle type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="f5dac-251">一種類型控制代碼，可指定要執行的類別建構函式方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-251">A type handle that specifies the class constructor method to run.</span></span></param>
        <summary><span data-ttu-id="f5dac-252">執行指定類別建構函式 (Constructor) 方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-252">Runs a specified class constructor method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-253">編譯器會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-253">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="f5dac-254">類別初始設定式擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f5dac-254">The class initializer throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RunModuleConstructor">
      <MemberSignature Language="C#" Value="public static void RunModuleConstructor (ModuleHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunModuleConstructor(valuetype System.ModuleHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunModuleConstructor (module As ModuleHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunModuleConstructor(ModuleHandle module);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.ModuleHandle" />
      </Parameters>
      <Docs>
        <param name="module"><span data-ttu-id="f5dac-255">一種控制代碼，可指定要執行的模組建構函式方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-255">A handle that specifies the module constructor method to run.</span></span></param>
        <summary><span data-ttu-id="f5dac-256">執行指定的模組建構函式方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-256">Runs a specified module constructor method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f5dac-257">編譯器會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f5dac-257">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="f5dac-258">模組建構函式擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f5dac-258">The module constructor throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static bool TryEnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnsureSufficientExecutionStack () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnsureSufficientExecutionStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>