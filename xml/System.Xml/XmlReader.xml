<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="90a6a0facff37d5e17e797e128971423207eeb48" /><Meta Name="ms.sourcegitcommit" Value="2982b8c4cce02c2542285fcaf172f7544d6b80bc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="04/09/2019" /><Meta Name="ms.locfileid" Value="59355133" /></Metadata><TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示提供快速、非快取、順向 (Forward-only) 存取 XML 資料的讀取器 (Reader)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> 提供順向、 唯讀存取文件或資料流中的 XML 資料。 此類別符合 W3C[可延伸標記語言 (XML) 1.0 （第四版）](https://www.w3.org/TR/2006/REC-xml-20060816/)並[Namespaces in XML 1.0 （第三個版本）](https://www.w3.org/TR/REC-xml-names/)建議。  
  
 <xref:System.Xml.XmlReader> 方法可讓您透過 XML 資料移動，並讀取節點的內容。 此類別的屬性會反映目前的節點，也就是將讀取器置於其中的值。<xref:System.Xml.XmlReader.ReadState%2A>屬性值表示 XML 讀取器的目前狀態。 比方說，此屬性設為<xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>所<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>方法並<xref:System.Xml.ReadState.Closed?displayProperty=nameWithType>由<xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType>方法。 <xref:System.Xml.XmlReader> 也提供的資料一致性檢查和針對 DTD 或結構描述進行驗證。  
  
 <xref:System.Xml.XmlReader> 您可以使用提取模型來擷取資料。 此模型中：  
  
-   狀態管理簡化自然、 上下程序的精緻化。  
  
-   支援多個輸入資料流和分層。  
  
-   可讓用戶端給予剖析器到其中的字串會直接寫入，並因此會避免額外的字串複本的緩衝區。  
  
-   支援選擇性處理程序。 用戶端可以略過項目，並處理這些感興趣的應用程式。 您也可以設定屬性，以管理 XML 資料流 （例如正規化） 的處理方式。  
  
 本節內容：  
  
 [建立 XML 讀取器](#xmlreader_create)   
 [驗證 XML 資料](#xmlreader_validate)   
 [資料一致性](#xmlreader_data)   
 [瀏覽節點](#xmlreader_nodes)   
 [讀取 XML 項目](#xmlreader_elements)   
 [讀取 XML 屬性](#xmlreader_attributes)   
 [讀取 XML 內容](#xmlreader_content)   
 [將轉換成 CLR 類型](#xmlreader_clr)   
 [非同步程式設計](#xmlreader_async)   
 [安全性考量](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>建立 XML 讀取器  
 使用<xref:System.Xml.XmlReader.Create%2A>方法用來建立<xref:System.Xml.XmlReader>執行個體。  
  
 雖然.NET Framework 提供的具體實作<xref:System.Xml.XmlReader>類別，例如<xref:System.Xml.XmlTextReader>， <xref:System.Xml.XmlNodeReader>，和<xref:System.Xml.XmlValidatingReader>類別，我們建議您只有在這些情況下，使用特定的類別：  
  
-   當您想要讀取從 XML DOM 樹狀子目錄<xref:System.Xml.XmlNode>物件，請使用<xref:System.Xml.XmlNodeReader>類別。 （不過，此類別不支援 DTD 或結構描述驗證。）  
  
-   如果您必須展開要求的實體，您不想將文字內容正規化，或您不想預設傳回的屬性，請使用<xref:System.Xml.XmlTextReader>類別。  
  
 若要指定您想要的 XML 讀取器上啟用的功能集，請傳遞<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>物件至<xref:System.Xml.XmlReader.Create%2A>方法。 您可以使用單一<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>要使用相同的功能，建立多個讀取器的物件，或修改<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>物件來建立新的讀取器與一組不同的功能。 此外，您也很容易可以將功能加入至現有讀取器。  
  
 如果您未使用<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>物件時，會使用預設設定。 請參閱<xref:System.Xml.XmlReader.Create%2A>參考頁面，如需詳細資訊。  
  
 <xref:System.Xml.XmlReader> 會擲回<xref:System.Xml.XmlException>xml 剖析錯誤。 擲回例外狀況之後，讀取器的狀態不是可預測的。 例如，回報的節點型別可能不同於目前節點的實際節點型別。 使用<xref:System.Xml.XmlReader.ReadState%2A>檢查讀取器是否處於錯誤狀態的屬性。  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>驗證 XML 資料  
 若要定義 XML 文件和其項目關聯性、 資料類型及內容條件約束的結構，您可以使用文件類型定義 (DTD) 或 XML 結構描述定義語言 (XSD) 結構描述。 XML 文件會被視為格式正確符合所定義的所有句法要求時，才[W3C XML 1.0 建議事項](https://www.w3.org/TR/2006/REC-xml-20060816/)。 如果它的格式正確，而且符合其 DTD 或結構描述所定義的條件約束，則被視為有效。 (請參閱[W3C XML 結構描述第 1 部分：結構](https://www.w3.org/TR/xmlschema-1/)而[W3C XML Schema Part 2:資料型別](https://www.w3.org/TR/xmlschema-2/)建議。)因此，雖然所有有效 XML 文件的格式都正確，但是並非所有格式正確的 XML 文件都有效。  
  
 您可以針對驗證資料 DTD 中，內嵌 XSD 結構描述，或 XSD 結構描述儲存在<xref:System.Xml.Schema.XmlSchemaSet>物件 （快取）; 將說明這些情況在<xref:System.Xml.XmlReader.Create%2A>參考頁面。 <xref:System.Xml.XmlReader> 不支援 XML 資料精簡 (XDR) 結構描述驗證。  
  
 您可以使用下列設定上<xref:System.Xml.XmlReaderSettings>類別，以指定哪一種驗證，如果有的話，<xref:System.Xml.XmlReader>執行個體可支援。  
  
|使用此<xref:System.Xml.XmlReaderSettings>成員|若要指定|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 屬性|是否允許 DTD 處理。 預設不允許 DTD 處理。|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 屬性|讀取器是否應該驗證資料，以及要執行 （DTD 或結構描述） 的驗證型別。 預設不進行資料驗證。|  
|<xref:System.Xml.XmlReaderSettings.ValidationEventHandler> Event - 事件|事件處理常式接收驗證事件的相關資訊。 如果未提供事件處理常式，會在第一次發生驗證錯誤時擲回 <xref:System.Xml.XmlException>。|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> 屬性|其他驗證選項，透過<xref:System.Xml.Schema.XmlSchemaValidationFlags>列舉成員：<br /><br /> -   `AllowXmlAttributes`-允許 XML 屬性 (`xml:*`) 即使未定義結構描述中的執行個體文件中。 會根據屬性的資料型別來驗證該屬性。 請參閱<xref:System.Xml.Schema.XmlSchemaValidationFlags>設定在特定案例中使用的參考頁面。 （預設為停用。）<br />-   `ProcessIdentityConstraints` -處理識別條件約束 (`xs:ID`， `xs:IDREF`， `xs:key`， `xs:keyref`， `xs:unique`) 在驗證期間發生。 （依預設啟用）。<br />-   `ProcessSchemaLocation` -處理所指定的結構描述`xsi:schemaLocation`或`xsi:noNamespaceSchemaLocation`屬性。 （依預設啟用）。<br />-   `ProcessInlineSchema`-處理驗證期間的內嵌 XML 結構描述。 （預設為停用。）<br />-   `ReportValidationWarnings`-如果發生驗證警告時，報告事件。 在沒有可以用於驗證特定項目或屬性的 DTD 或 XML 結構描述時，通常會發出警告。 會使用 <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> 來進行通知。 （預設為停用。）|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|用來驗證的 <xref:System.Xml.Schema.XmlSchemaSet>。|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 屬性|<xref:System.Xml.XmlResolver>解析及存取外部資源。 這可以包括外部實體，例如 DTD 和結構描述，以及任何`xs:include`或`xs:import`XML 結構描述中包含的項目。 如果您未指定<xref:System.Xml.XmlResolver>，則<xref:System.Xml.XmlReader>使用的預設值<xref:System.Xml.XmlUrlResolver>與不具使用者認證。|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>資料一致性  
 所建立的 XML 讀取器<xref:System.Xml.XmlReader.Create%2A>方法符合下列的合規性需求的預設值：  
  
-   新行和屬性值根據正規化 W3C [XML 1.0 建議事項](https://www.w3.org/TR/2006/REC-xml-20060816/)。  
  
-   會自動展開所有實體。  
  
-   即使在不會驗證讀取器時，會固定加入文件類型定義中宣告的預設屬性。  
  
-   允許宣告對應至正確的 XML 命名空間 URI 的 XML 前置詞。  
  
-   在單一標記法名稱`NotationType`屬性宣告並`NmTokens`在單一`Enumeration`屬性宣告就會不同。  
  
 使用這些<xref:System.Xml.XmlReaderSettings>屬性，以指定的一致性類型檢查您想要啟用：  
  
|使用此<xref:System.Xml.XmlReaderSettings>屬性|以|預設|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> 屬性|啟用或停用檢查下列項目：<br /><br /> 字元是合法的 XML 字元的範圍內所定義[2.2 字元](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets)W3C XML 1.0 建議事項一節。<br />-所有的 XML 名稱是否有效，如同[2.3 Common Syntactic Constructs](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) W3C XML 1.0 建議事項一節。<br /><br /> 當這個屬性設定為`true`（預設）、<xref:System.Xml.XmlException>擲回例外狀況是 XML 檔案包含不合法的字元或無效的 XML 名稱 （例如，項目名稱以數字開頭）。|字元且名稱檢查已啟用。<br /><br /> 將 <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> 設為 `false` 會關閉字元實體參考的字元檢查。 如果讀取器處理文字資料，它會始終檢查 XML 名稱是否有效，而不論此設定。 **注意：** 存在 DTD 時，XML 1.0 版建議事項會要求文件層級的一致性。 因此，如果讀取器設定為支援<xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>，但 XML 資料包含文件類型定義 (DTD)，<xref:System.Xml.XmlException>就會擲回。|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> 屬性|選擇強制執行的一致性層級：<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. 符合的規則[語式正確的 XML 1.0 文件](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed)。<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. 符合格式正確的文件片段做為可使用的規則[外部剖析實體](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities)。<br />-   <xref:System.Xml.ConformanceLevel.Auto>. 符合層級讀取器所決定。<br /><br /> 如果資料不一致，<xref:System.Xml.XmlException>擲回例外狀況。|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>瀏覽節點  
 目前節點是 XML 讀取器目前所在的 XML 節點。 所有<xref:System.Xml.XmlReader>方法會執行與這個節點及其所有相關的作業<xref:System.Xml.XmlReader>屬性會反映目前節點的值。  
  
 下列方法讓您輕鬆瀏覽節點和剖析資料。  
  
|使用此<xref:System.Xml.XmlReaderSettings>方法|以|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|讀取的第一個節點，並一次前進透過資料流的一個節點。 這類呼叫通常會執行內`while`迴圈。<br /><br /> 使用<xref:System.Xml.XmlReader.NodeType%2A>屬性來取得目前節點的類型 （例如屬性、 註解、 項目，等等）。|  
|<xref:System.Xml.XmlReader.Skip%2A>|略過目前節點的子系，並移至下一個節點。|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> 和 <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|略過非內容節點，並移至下一個內容節點或檔案結尾。<br /><br /> 非內容節點包含<xref:System.Xml.XmlNodeType.ProcessingInstruction>， <xref:System.Xml.XmlNodeType.DocumentType>， <xref:System.Xml.XmlNodeType.Comment>， <xref:System.Xml.XmlNodeType.Whitespace>，和<xref:System.Xml.XmlNodeType.SignificantWhitespace>。<br /><br /> 內容節點包括非泛空白字元文字<xref:System.Xml.XmlNodeType.CDATA>， <xref:System.Xml.XmlNodeType.EntityReference> ，和<xref:System.Xml.XmlNodeType.EndEntity>。|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|讀取項目和其所有子系，並傳回新<xref:System.Xml.XmlReader>設為執行個體<xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>。<br /><br /> 這個方法可用於建立 XML 項目; 周圍的界限例如，如果您想要將資料傳遞至另一個元件進行處理，而且您想要限制您的資料中有多少可以存取元件。|  
  
 請參閱<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>參考頁面巡覽的文字資料流的一個節點，一次，並顯示每個節點類型的範例。  
  
 下列各節說明您可以讀取特定類型的資料，例如元素、 屬性的方式，並具型別資料。  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>讀取 XML 項目  
 下表列出的方法和屬性，<xref:System.Xml.XmlReader>類別提供用於處理項目。 將 <xref:System.Xml.XmlReader> 定位於項目上後，節點屬性 (如 <xref:System.Xml.XmlReader.Name%2A>) 就會反映項目值。 除了下面說明的成員之外，還可以使用 <xref:System.Xml.XmlReader> 類別的任意一般方法及屬性來處理項目。 例如，您可以使用 <xref:System.Xml.XmlReader.ReadInnerXml%2A> 方法讀取項目的內容。  
  
> [!NOTE]
>  請參閱第 3.1 節[W3C XML 1.0 建議事項](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags)定義的開始標記、 結束標記與空項目標記。  
  
|使用此<xref:System.Xml.XmlReader>成員|以|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.IsStartElement%2A> 方法|檢查目前節點是否開始標記或空白項目標記。|  
|<xref:System.Xml.XmlReader.ReadStartElement%2A> 方法|檢查目前節點是項目，並使讀取器前進至下一個節點 (呼叫<xref:System.Xml.XmlReader.IsStartElement%2A>後面接著<xref:System.Xml.XmlReader.Read%2A>)。|  
|<xref:System.Xml.XmlReader.ReadEndElement%2A> 方法|檢查目前節點為結尾標記，並使讀取器前進至下一個節點。|  
|<xref:System.Xml.XmlReader.ReadElementString%2A> 方法|讀取純文字的項目。|  
|<xref:System.Xml.XmlReader.ReadToDescendant%2A> 方法|請前往下一個具有指定的名稱的下階 （子系） 元素中的 XML 讀取器。|  
|<xref:System.Xml.XmlReader.ReadToNextSibling%2A> 方法|前往下一步 的同層級項目具有指定的名稱的 XML 讀取器。|  
|<xref:System.Xml.XmlReader.IsEmptyElement%2A> 屬性|檢查目前的項目是否具有結尾項目標記。 例如：<br /><br /> -   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A>是`true`。)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A>是`false`，不過，此項目的內容是空的。)|  
  
 如需讀取的項目文字內容的範例，請參閱<xref:System.Xml.XmlReader.ReadString%2A>方法。 下列範例會處理項目使用`while`迴圈。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>讀取 XML 屬性  
 XML 屬性最常見於項目，但它們也允許 XML 宣告及文件類型節點上。  
  
 置於項目節點，<xref:System.Xml.XmlReader.MoveToAttribute%2A>方法可讓您瀏覽屬性清單的項目。 請注意，在後<xref:System.Xml.XmlReader.MoveToAttribute%2A>已呼叫節點屬性這類<xref:System.Xml.XmlReader.Name%2A>， <xref:System.Xml.XmlReader.NamespaceURI%2A>，和<xref:System.Xml.XmlReader.Prefix%2A>反映該屬性的屬性、 所屬的項目屬性的屬性。  
  
 <xref:System.Xml.XmlReader>類別會提供這些方法和屬性來讀取和處理項目上的屬性。  
  
|使用此<xref:System.Xml.XmlReader>成員|以|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.HasAttributes%2A> 屬性|檢查目前節點是否具有任何屬性。|  
|<xref:System.Xml.XmlReader.AttributeCount%2A> 屬性|取得目前的項目屬性的數目。|  
|<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A> 方法|移動項目中的第一個屬性。|  
|<xref:System.Xml.XmlReader.MoveToNextAttribute%2A> 方法|移至下一個屬性的項目。|  
|<xref:System.Xml.XmlReader.MoveToAttribute%2A> 方法|移至指定的屬性。|  
|<xref:System.Xml.XmlReader.GetAttribute%2A> 方法或<xref:System.Xml.XmlReader.Item%2A>屬性|取得指定之屬性的值。|  
|<xref:System.Xml.XmlReader.IsDefault%2A> 屬性|檢查目前節點是否為 DTD 或結構描述中定義的預設值所產生的屬性。|  
|<xref:System.Xml.XmlReader.MoveToElement%2A> 方法|移至擁有目前屬性的項目。 使用這個方法傳回的項目之後瀏覽其屬性。|  
|<xref:System.Xml.XmlReader.ReadAttributeValue%2A> 方法|將屬性值剖析成一或多個`Text`， `EntityReference`，或`EndEntity`節點。|  
  
 任何一般 <xref:System.Xml.XmlReader> 方法和屬性都可用於處理屬性 (Attribute)。 例如，將 <xref:System.Xml.XmlReader> 置於屬性 (Attribute) 上之後，<xref:System.Xml.XmlReader.Name%2A> 及 <xref:System.Xml.XmlReader.Value%2A> 屬性會反映屬性 (Attribute) 的值。 您還可使用任何內容 `Read` 方法，以取得屬性的值。  
  
 這個範例會使用<xref:System.Xml.XmlReader.AttributeCount%2A>來瀏覽項目上的所有屬性的屬性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 這個範例會使用<xref:System.Xml.XmlReader.MoveToNextAttribute%2A>方法中的`while`迴圈來瀏覽屬性。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **讀取 XML 宣告節點上的屬性**  
  
 XML 讀取器必須置於 XML 宣告節點<xref:System.Xml.XmlReader.Value%2A>屬性會傳回版本、 獨立及編碼資訊，以單一字串。 <xref:System.Xml.XmlReader> 所建立的物件<xref:System.Xml.XmlReader.Create%2A>方法中，<xref:System.Xml.XmlTextReader>類別，而<xref:System.Xml.XmlValidatingReader>類別公開版本、 獨立及編碼項目，做為屬性。  
  
 **讀取文件類型節點上的屬性**  
  
 XML 讀取器必須置於文件類型節點<xref:System.Xml.XmlReader.GetAttribute%2A>方法和<xref:System.Xml.XmlReader.Item%2A>屬性可以用來傳回 SYSTEM 及 PUBLIC 常值的值。 例如，呼叫 `reader.GetAttribute("PUBLIC")` 會傳回 PUBLIC 值。  
  
 **讀取在處理指示節點上的屬性**  
  
 將 <xref:System.Xml.XmlReader> 置於處理指示節點時，<xref:System.Xml.XmlReader.Value%2A> 屬性會傳回全部文字內容。 處理指示節點中的項目不被視為屬性。 無法與閱讀<xref:System.Xml.XmlReader.GetAttribute%2A>或<xref:System.Xml.XmlReader.MoveToAttribute%2A>方法。  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>讀取 XML 內容  
 XMLReader 類別包含下列成員，可從 XML 檔案讀取內容，然後將內容傳回為字串值。 (若要傳回 CLR 型別，請參閱[下一節](#xmlreader_clr)。)  
  
|使用此<xref:System.Xml.XmlReader>成員|以|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Value%2A> 屬性|取得目前節點的文字內容。 傳回的值取決於節點類型;請參閱<xref:System.Xml.XmlReader.Value%2A>參考頁面，如需詳細資訊。|  
|<xref:System.Xml.XmlReader.ReadString%2A> 方法|取得做為字串的項目或文字節點的內容。 此方法會停止處理指示和註解。<br /><br /> 如需這個方法的特定節點類型的處理方式的詳細資訊，請參閱<xref:System.Xml.XmlReader.ReadString%2A>參考頁面。|  
|<xref:System.Xml.XmlReader.ReadInnerXml%2A> 和<xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>方法|取得目前的節點，包括標記，但不含開始和結束標記的所有內容。 例如，若為：<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> 會傳回：<br /><br /> `this<child id="123"/>`|  
|<xref:System.Xml.XmlReader.ReadOuterXml%2A> 和<xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>方法|取得目前的節點及其子系，包括標記和開始/結束標記的所有內容。 例如，若為：<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> 會傳回：<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>將轉換成 CLR 類型  
 您可以使用的成員<xref:System.Xml.XmlReader>（下表所列） 的類別讀取 XML 資料，並傳回值，做為通用語言執行平台 (CLR) 型別，而不是字串。 這些成員可讓您取得值，而不必手動剖析，或將字串值轉換為最適合您的程式碼撰寫工作的表示法。  
  
-   **ReadElementContentAs**只有元素節點型別上呼叫方法。 這些方法無法用於包含項目子系或混合內容的項目。 呼叫後，<xref:System.Xml.XmlReader> 物件會讀取開始標記、讀取項目內容，然後移動到超過結尾項目標記以後的部分。 處理指示及註解會略過，並且實體會展開。  
  
-   **ReadContentAs**方法讀取的文字內容，目前的讀取器位置，和 XML 資料不需要任何結構描述或資料型別與其建立關聯的資訊時，將文字內容轉換成要求的傳回型別。 文字、泛空白字元、顯著泛空白字元及 CDATA 區段都是串連的。 註解和處理指示會略過，並會自動解析實體參考。  
  
 <xref:System.Xml.XmlReader>類別會使用所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://www.w3.org/TR/xmlschema-2/)建議。  
  
|使用此<xref:System.Xml.XmlReader>方法|傳回這個 CLR 類型|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|您使用指定的型別`returnType`參數|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|所指定最適當的類型<xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType>屬性。 請參閱[System.Xml 類別中的型別支援](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md)對應資訊。|  
  
 如果項目輕鬆無法轉換為 CLR 型別中，但會因為其格式，您可以使用結構描述對應，以確保成功的轉換。 下列範例會使用為.xsd 檔轉換`hire-date`項目`xs:date`類型，然後使用<xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>方法，以傳回此元素作為<xref:System.DateTime>物件。  
  
 **輸入 (hireDate.xml):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **結構描述 (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **程式碼：**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **輸出：**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>非同步程式設計  
 大部分的<xref:System.Xml.XmlReader>方法有非同步對應項目具有"Async"結尾的方法名稱。 例如，非同步的對等<xref:System.Xml.XmlReader.ReadContentAsObject%2A>是<xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>。  
  
 下列方法可以搭配非同步方法呼叫：  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 下列各節說明非同步方法，不需要非同步對應項目使用方式。  
  
 **ReadStartElement 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **ReadEndElement 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **ReadToNextSibling 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **ReadToFollowing 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **ReadToDescendant 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>安全性考量  
 使用時，請考慮下列<xref:System.Xml.XmlReader>類別：  
  
-   從擲回的例外狀況<xref:System.Xml.XmlReader>可能會洩露到您的應用程式的路徑資訊，您可能不想反昇。 您的應用程式必須攔截例外狀況，並適當地處理它們。  
  
-   請勿啟用 DTD 處理，如果您擔心阻絕服務問題，或如果您正在處理不受信任的來源。 預設為停用 DTD 處理<xref:System.Xml.XmlReader>所建立的物件<xref:System.Xml.XmlReader.Create%2A>方法。  
  
     如果已啟用 DTD 處理，則可使用 <xref:System.Xml.XmlSecureResolver> 限制 <xref:System.Xml.XmlReader> 可存取的資源。 您也可以設計您的應用程式，讓 XML 處理具有記憶體和時間限制。 比方說，您可以設定逾時限制在您的 ASP.NET 應用程式。  
  
-   XML 資料可以包括外部資源的參考，如結構描述檔案。 根據預設，使用解析外部資源<xref:System.Xml.XmlUrlResolver>與不具使用者認證的物件。 您可以透過執行下列其中一項作業，進一步保護它：  
  
    -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 物件，限制 <xref:System.Xml.XmlSecureResolver> 可以存取的資源。  
  
    -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>，來禁止 `null` 開啟外部資源。  
  
-   <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>並<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>驗證旗標<xref:System.Xml.XmlReaderSettings>物件不預設設定。 在處理來自不受信任來源的 XML 資料時，這有助於保護 <xref:System.Xml.XmlReader>，防止其遭受以結構描述為基礎的攻擊。 當設定這些旗標時，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 物件的 <xref:System.Xml.XmlReaderSettings> 可用於解析在 <xref:System.Xml.XmlReader> 的執行個體文件中發現的結構描述位置。 如果<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>屬性設定為`null`，結構描述位置不是解析即使<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>設定驗證旗標。  
  
     驗證期間加入的結構描述會加入新型別，並可變更要驗證之物件的驗證結果。 因此，外部結構描述應僅從受信任的來源解析。  
  
     建議您停用<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>驗證高可用性的情況下，針對文件的大部分具有識別條件約束的結構描述中的不受信任、 大型 XML 文件時的旗標。 預設會啟用此旗標。  
  
-   XML 資料可以包含需要相當長時間來處理的大量屬性、命名空間宣告、巢狀項目等。 若要傳送至輸入的大小限制<xref:System.Xml.XmlReader>，您可以：  
  
    -   藉由設定限制的文件大小<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>屬性。  
  
    -   產生自展開實體所設定的字元數目限制<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>屬性。  
  
    -   建立自訂`IStream`實作<xref:System.Xml.XmlReader>。  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A>方法可用來處理大型資料流的資料。 此方法每次會讀取較少數量的字元，而不是為整個值配置單一字串。  
  
-   讀取 XML 文件具有大量唯一本機名稱、 命名空間或前置詞時，會發生問題。 如果您使用的類別，衍生自<xref:System.Xml.XmlReader>，而且您呼叫<xref:System.Xml.XmlReader.LocalName%2A>， <xref:System.Xml.XmlReader.Prefix%2A>，或<xref:System.Xml.XmlReader.NamespaceURI%2A>每個項目的屬性，傳回的字串會新增至<xref:System.Xml.NameTable>。 所持有的集合<xref:System.Xml.NameTable>永遠不會減少的大小，建立字串控制代碼的虛擬記憶體流失。 這一個緩和策略是衍生自<xref:System.Xml.NameTable>類別並強制執行最大的大小配額。 (沒有任何方法可防止使用<xref:System.Xml.NameTable>，或切換<xref:System.Xml.NameTable>配額已滿時)。 另一個的緩和措施是避免使用提到的屬性，改用<xref:System.Xml.XmlReader.MoveToAttribute%2A>方法<xref:System.Xml.XmlReader.IsStartElement%2A>方法這些方法可能; 不傳回字串，並因此避免量問題<xref:System.Xml.NameTable>集合。  
  
-   <xref:System.Xml.XmlReaderSettings> 物件可以包含機密資訊，例如使用者認證。 不受信任的元件可能會使用 <xref:System.Xml.XmlReaderSettings> 物件及其使用者認證，建立 <xref:System.Xml.XmlReader> 物件來讀取資料。 快取時請小心<xref:System.Xml.XmlReaderSettings>物件，或傳遞時<xref:System.Xml.XmlReaderSettings>元件之間的物件。  
  
-   請不要接受來自不受信任來源的支援元件，如 <xref:System.Xml.NameTable>、<xref:System.Xml.XmlNamespaceManager> 及 <xref:System.Xml.XmlResolver> 物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用非同步 API 來剖析 XML。  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/data/xml/index.md">XML 文件和資料</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see langword="XmlReader" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 初始化狀態，在這種類型的衍生的類別建構函式會呼叫這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得目前節點上的屬性數目。</summary>
        <value>目前節點的屬性數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性無關`Element`，`DocumentType`和`XmlDeclaration`僅限節點。 （其他節點型別並沒有屬性。）  
  
   
  
## Examples  
 下列範例會顯示目前的節點上的所有屬性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得目前節點的基底 URI。</summary>
        <value>目前節點的基底 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 網路上的 XML 文件使用不同的 W3C 標準包含機制進行彙總的資料區塊所組成，並因此會包含來自不同位置的節點。 DTD 實體就是一個例子，但這並不限於使用 Dtd。 基底 URI 會告訴您這些節點的來源。 是否要傳回的節點沒有基底 URI （例如，它們已從字串中剖析記憶體中），`String.Empty`會傳回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示 <see cref="T:System.Xml.XmlReader" /> 是否會實作二進位內容讀取方法。</summary>
        <value><see langword="true" /> 如果實作二進位內容讀取的方法;否則<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 二進位內容讀取方法包括<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>， <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>， <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>，和<xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>方法。 如果這個屬性會傳回`false`<xref:System.NotSupportedException>任何二進位檔的讀取時，會傳回呼叫方法。  
  
 所有 Microsoft.NET Framework 實作<xref:System.Xml.XmlReader>類別傳回`true`這個屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示 <see cref="T:System.Xml.XmlReader" /> 是否會實作 <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> 方法。</summary>
        <value><see langword="true" /> 如果<see cref="T:System.Xml.XmlReader" />會實作<see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />方法，否則為<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字剖析<xref:System.Xml.XmlReader>靜態所建立的物件<xref:System.Xml.XmlReader.Create%2A>方法永遠會傳回`true`。 所有其他 Microsoft.NET Framework 實作<xref:System.Xml.XmlReader>類別，包括<xref:System.Xml.XmlTextReader>類別中，傳回`false`。  
  
 如果這個屬性會傳回`false`<xref:System.NotSupportedException>時，會傳回<xref:System.Xml.XmlReader.ReadValueChunk%2A>呼叫方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個讀取器是否可以剖析和解析實體。</summary>
        <value><see langword="true" /> 如果讀取器可以剖析和解析實體，否則， <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性一律傳回`false`實作的<xref:System.Xml.XmlReader>不支援 DTD 資訊。 在此情況下，呼叫<xref:System.Xml.XmlReader.ResolveEntity%2A>會擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，將 <see cref="P:System.Xml.XmlReader.ReadState" /> 變更為 <see cref="F:System.Xml.ReadState.Closed" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法也會釋放讀取期間所保留的任何資源。 如果<xref:System.Xml.XmlReader.Close%2A>已經被呼叫，會執行任何動作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大部分<xref:System.Xml.XmlReader.Create%2A>多載包含`settings`接受參數<xref:System.Xml.XmlReaderSettings>物件。 您可以使用這個物件：  
  
-   指定您想要支援哪些功能<xref:System.Xml.XmlReader>物件。  
  
-   重複使用<xref:System.Xml.XmlReaderSettings>物件來建立多個讀取器。 您可以使用相同設定來建立具有相同功能的多個讀取器。 或者，您可以修改的設定上<xref:System.Xml.XmlReaderSettings>執行個體，並建立新的讀取器與一組不同的功能。  
  
-   將功能加入現有的 XML 讀取器。 <xref:System.Xml.XmlReader.Create%2A> 方法可以接受其他 <xref:System.Xml.XmlReader> 物件。 基礎<xref:System.Xml.XmlReader>物件可以是使用者定義的讀取器<xref:System.Xml.XmlTextReader>物件，或另一個<xref:System.Xml.XmlReader>您想要加入其他功能的執行個體。  
  
-   充分利用功能，例如更好的一致性檢查及合規性[XML 1.0 （第四版）](https://www.w3.org/TR/2006/REC-xml-20060816/)建議僅適用於<xref:System.Xml.XmlReader>建立的靜態物件<xref:System.Xml.XmlReader.Create%2A>方法。  
  
> [!NOTE]
>  雖然.NET Framework 包含的具體實作<xref:System.Xml.XmlReader>類別，例如<xref:System.Xml.XmlTextReader>， <xref:System.Xml.XmlNodeReader>，而<xref:System.Xml.XmlValidatingReader>類別，建議您建立<xref:System.Xml.XmlReader>執行個體使用<xref:System.Xml.XmlReader.Create%2A>方法。  
  
## <a name="default-settings"></a>預設設定  
 如果您使用<xref:System.Xml.XmlReader.Create%2A>不接受多載<xref:System.Xml.XmlReaderSettings>物件時，會使用下列的預設讀取器設定：  
  
|設定|預設|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|空白的 <xref:System.Xml.Schema.XmlSchemaSet> 物件|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> enabled|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|新的 <xref:System.Xml.XmlUrlResolver> 物件。  從.NET Framework 4.5.2 開始，此設定具有預設值是`null`。|  
  
## <a name="settings-for-common-scenarios"></a>設定適用於常見案例  
 以下是<xref:System.Xml.XmlReaderSettings>您應該設定的一些典型的 XML 讀取器案例的屬性。  
  
|需求|設定|  
|-----------------|---------|  
|資料必須是語式正確的 XML 文件。|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> 至 <xref:System.Xml.ConformanceLevel.Document>的唯一值。|  
|資料必須是語式正確的 XML 剖析實體。|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> 至 <xref:System.Xml.ConformanceLevel.Fragment>的唯一值。|  
|資料必須根據 DTD 進行驗證。|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 設為 <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> 至 <xref:System.Xml.ValidationType.DTD>的唯一值。|  
|資料必須根據 XML 結構描述進行驗證。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 設為 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> 若要<xref:System.Xml.Schema.XmlSchemaSet>用來驗證。 請注意，<xref:System.Xml.XmlReader>不支援 XML 資料精簡 (XDR) 結構描述驗證。|  
|資料必須根據內嵌 XML 結構描述進行驗證。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 設為 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> 至 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>的唯一值。|  
|型別支援。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 設為 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> 若要<xref:System.Xml.Schema.XmlSchemaSet>使用。|  
  
 <xref:System.Xml.XmlReader> 不支援 XML 資料精簡 (XDR) 結構描述驗證。  
  
## <a name="asynchronous-programming"></a>非同步程式設計  
 在同步模式中，<xref:System.Xml.XmlReader.Create%2A>方法會讀取檔案、 資料流或文字讀取器的緩衝區中的第一個區塊的資料。 如果 I/O 作業失敗，這可能會擲回例外狀況。 在非同步模式中，第一項 I/O 作業發生在讀取作業，因此讀取的作業發生時，會擲回例外狀況發生。  
  
## <a name="security-considerations"></a>安全性考量  
 根據預設，<xref:System.Xml.XmlReader>使用<xref:System.Xml.XmlUrlResolver>使用沒有使用者認證，若要開啟資源的物件。 這表示根據預設，XML 讀取器可以存取並不需要認證的任何位置。 使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>屬性，來控制資源的存取權：  
  
-   設定<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>至<xref:System.Xml.XmlSecureResolver>物件，以限制 XML 讀取器可以存取的資源。  
  
 -或-  
  
-   設定<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>至`null`以防止開啟的任何外部資源的 XML 讀取器。  
  
   
  
## Examples  
 這個範例會建立 XML 讀取器會去除不顯著泛空白字元、 去除註解，並執行片段層級的一致性檢查。  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 下列範例會使用<xref:System.Xml.XmlUrlResolver>具有預設認證來存取檔案。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 下列程式碼包裝在另一個讀取器讀取器執行個體。  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 此範例中鏈結讀取器以加入 DTD 和 XML 結構描述驗證。  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 資料的資料流。  
  
<see cref="T:System.Xml.XmlReader" /> 會掃描資料流的前幾個位元組，以尋找位元組順序標記或其他編碼符號。 決定編碼後，會使用該編碼繼續讀取資料流，處理流程也會繼續將輸入剖析成 (Unicode) 字元的資料流。</param>
        <summary>使用指定的資料流，以預設設定建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings>物件使用預設設定用來建立讀取器。 如果您想要指定要建立的讀取器上支援的功能，使用採用的多載<xref:System.Xml.XmlReaderSettings>物件做為其引數，其中，並傳入<xref:System.Xml.XmlReaderSettings>具有正確的設定物件。  
  
 預設值<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請指定<xref:System.Xml.XmlResolver>具有必要的認證使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Xml.XmlReader>物件，以讀取來自<xref:System.IO.FileStream>。  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> 沒有足夠的權限可以存取 XML 資料的位置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要從中讀取 XML 資料的文字閱讀器。 因為文字閱讀器會傳回 Unicode 字元的資料流，所以 XML 讀取器不會使用 XML 宣告中所指定的編碼方式，來解碼資料流。</param>
        <summary>使用指定的文字讀取器，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings>物件使用預設設定用來建立讀取器。 如果您想要指定要建立的讀取器上支援的功能，使用採用的多載<xref:System.Xml.XmlReaderSettings>物件做為其引數，其中，並傳入<xref:System.Xml.XmlReaderSettings>具有正確的設定物件。  
  
 預設值<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請指定<xref:System.Xml.XmlResolver>具有必要的認證使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.StringReader>類別以讀取 XML 字串。  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 資料之檔案的 URI。 <see cref="T:System.Xml.XmlUrlResolver" /> 類別可用來將路徑轉換成正式的資料代表。</param>
        <summary>使用指定的 URI，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings>物件使用預設設定用來建立讀取器。 如果您想要指定要建立的讀取器上支援的功能，使用採用的多載<xref:System.Xml.XmlReaderSettings>物件做為其引數，其中，並傳入<xref:System.Xml.XmlReaderSettings>具有正確的設定物件。  
  
 預設值<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請指定<xref:System.Xml.XmlResolver>具有必要的認證使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Xml.XmlReader>讀取 XML 資料檔的 URI 所指定的物件。  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inputUri" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> 沒有足夠的權限可以存取 XML 資料的位置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">URI 所識別的檔案不存在。</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況<see cref="T:System.FormatException" />。  
  
</para>
          </block>  
  
 URI 格式不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 資料的資料流。  
  
<see cref="T:System.Xml.XmlReader" /> 會掃描資料流的前幾個位元組，以尋找位元組順序標記或其他編碼符號。 決定編碼後，會使用該編碼繼續讀取資料流，處理流程也會繼續將輸入剖析成 (Unicode) 字元的資料流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 執行個體的設定。 這個值可以是 <see langword="null" />。</param>
        <summary>使用指定的資料流及設定，建立新的 <see cref="T:System.Xml.XmlReader" />。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性來指定<xref:System.Xml.XmlResolver>具有必要認證。  
  
> [!IMPORTANT]
>  您可以使用其中一種下列方法來控制哪些資源<xref:System.Xml.XmlReader>可以存取：  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 物件，限制 <xref:System.Xml.XmlSecureResolver> 可以存取的資源。  
>   
>  -或-  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，來禁止 `null` 開啟外部資源。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要從中讀取 XML 資料的文字閱讀器。 因為文字閱讀器會傳回 Unicode 字元的資料流，所以 XML 讀取器不會使用 XML 宣告中所指定的編碼方式，來解碼資料流。</param>
        <param name="settings">新的 <see cref="T:System.Xml.XmlReader" /> 的設定。 這個值可以是 <see langword="null" />。</param>
        <summary>使用指定的文字讀取器及設定，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性來指定<xref:System.Xml.XmlResolver>具有必要認證。  
  
> [!IMPORTANT]
>  您可以使用其中一種下列方法來控制哪些資源<xref:System.Xml.XmlReader>可以存取：  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 物件，限制 <xref:System.Xml.XmlSecureResolver> 可以存取的資源。  
>   
>  -或-  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，來禁止 `null` 開啟外部資源。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 資料之檔案的 URI。 <see cref="T:System.Xml.XmlReaderSettings" /> 物件上的 <see cref="T:System.Xml.XmlResolver" /> 物件是用於將路徑轉換成標準資料表示。 如果 <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> 為 <see langword="null" />，則會使用新的 <see cref="T:System.Xml.XmlUrlResolver" /> 物件。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 執行個體的設定。 這個值可以是 <see langword="null" />。</param>
        <summary>使用指定的 URI 和設定，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 這表示<xref:System.Xml.XmlReader>可以存取任何不需要驗證的位置。 如果在需要驗證的網路資源位於外部的資源，請使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性來指定<xref:System.Xml.XmlResolver>具有必要認證。  
  
> [!IMPORTANT]
>  您可以限制的資源，<xref:System.Xml.XmlReader>設定，即可存取<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>屬性設<xref:System.Xml.XmlSecureResolver>物件。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Xml.XmlReader>支援文件類型定義 (DTD) 驗證的物件。  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inputUri" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 URI 指定的檔案。</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況<see cref="T:System.FormatException" />。  
  
</para>
          </block>  
  
 URI 格式不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reader">您想要當做底層 XML 讀取器使用的物件。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 執行個體的設定。  
  
<see cref="T:System.Xml.XmlReaderSettings" /> 物件的一致性層級必須符合基礎讀取器的一致性層級，或是必須設定為 <see cref="F:System.Xml.ConformanceLevel.Auto" />。</param>
        <summary>使用指定的 XML 讀取器和設定，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>包裝在指定 <see cref="T:System.Xml.XmlReader" /> 物件周圍的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓您將其他功能新增至基礎<xref:System.Xml.XmlReader>物件。 基礎<xref:System.Xml.XmlReader>物件可以是另一個<xref:System.Xml.XmlReader>所建立的物件<xref:System.Xml.XmlReader.Create%2A>方法，或有<xref:System.Xml.XmlReader>建立使用其中一個具象物件<xref:System.Xml.XmlReader>實作。  
  
 預設值<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如結構描述。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請指定<xref:System.Xml.XmlResolver>具有必要的認證使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
> [!IMPORTANT]
>  您可以使用其中一種下列方法來控制哪些資源<xref:System.Xml.XmlReader>可以存取：  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 物件，限制 <xref:System.Xml.XmlSecureResolver> 可以存取的資源。  
>   
>  -或-  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，來禁止 `null` 開啟外部資源。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
   
  
## Examples  
 下列範例會建立驗證<xref:System.Xml.XmlReader>物件，包裝著<xref:System.Xml.XmlNodeReader>物件。  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">如果 <see cref="T:System.Xml.XmlReaderSettings" /> 物件所指定的一致性層級與基礎讀取器的一致性層級不一致。  
  
-或- 
基礎 <see cref="T:System.Xml.XmlReader" /> 處於 <see cref="F:System.Xml.ReadState.Error" /> 或 <see cref="F:System.Xml.ReadState.Closed" /> 狀態。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="baseUri" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 資料的資料流。  
  
<see cref="T:System.Xml.XmlReader" /> 會掃描資料流的前幾個位元組，以尋找位元組順序標記或其他編碼符號。 決定編碼後，會使用該編碼繼續讀取資料流，處理流程也會繼續將輸入剖析成 (Unicode) 字元的資料流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 執行個體的設定。 這個值可以是 <see langword="null" />。</param>
        <param name="baseUri">所讀取之實體或文件的基底 URI。 這個值可以是 <see langword="null" />。  
  
 **安全性提示**：系統會使用基底 URI 來解析 XML 文件的相對 URI。 請不要使用來自不受信任來源的基底 URI。</param>
        <summary>使用指定的資料流、基底 URI 和設定，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性來指定<xref:System.Xml.XmlResolver>具有必要認證。  
  
> [!IMPORTANT]
>  您可以使用其中一種下列方法來控制哪些資源<xref:System.Xml.XmlReader>可以存取：  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 物件，限制 <xref:System.Xml.XmlSecureResolver> 可以存取的資源。  
>   
>  -或-  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，來禁止 `null` 開啟外部資源。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 資料的資料流。  
  
<see cref="T:System.Xml.XmlReader" /> 會掃描資料流的前幾個位元組，以尋找位元組順序標記或其他編碼符號。 決定編碼後，會使用該編碼繼續讀取資料流，處理流程也會繼續將輸入剖析成 (Unicode) 字元的資料流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 執行個體的設定。 這個值可以是 <see langword="null" />。</param>
        <param name="inputContext">剖析 XML 片段所需的內容資訊。 內容資訊可包含要使用的 <see cref="T:System.Xml.XmlNameTable" />、編碼方式、命名空間範圍、目前的 <c>xml:lang</c> 和 <c>xml:space</c> 範圍、基底 URI，以及文件類型定義。  
  
這個值可以是 <see langword="null" />。</param>
        <summary>使用剖析用的指定資料流、設定和內容資訊，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性來指定<xref:System.Xml.XmlResolver>具有必要認證。  
  
> [!IMPORTANT]
>  您可以使用其中一種下列方法來控制哪些資源<xref:System.Xml.XmlReader>可以存取：  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 物件，限制 <xref:System.Xml.XmlSecureResolver> 可以存取的資源。  
>   
>  -或-  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，來禁止 `null` 開啟外部資源。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="baseUri" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="input">要從中讀取 XML 資料的文字閱讀器。 因為文字閱讀器會傳回 Unicode 字元的資料流，所以 <see cref="T:System.Xml.XmlReader" /> 不會使用 XML 宣告中所指定的編碼方式將資料流解碼。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 執行個體的設定。 這個值可以是 <see langword="null" />。</param>
        <param name="baseUri">所讀取之實體或文件的基底 URI。 這個值可以是 <see langword="null" />。  
  
 **安全性提示**：系統會使用基底 URI 來解析 XML 文件的相對 URI。 請不要使用來自不受信任來源的基底 URI。</param>
        <summary>使用指定的文字讀取器、設定和基底 URI，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性來指定<xref:System.Xml.XmlResolver>具有必要認證。  
  
> [!IMPORTANT]
>  您可以使用其中一種下列方法來控制哪些資源<xref:System.Xml.XmlReader>可以存取：  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 物件，限制 <xref:System.Xml.XmlSecureResolver> 可以存取的資源。  
>   
>  -或-  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，來禁止 `null` 開啟外部資源。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">要從中讀取 XML 資料的文字閱讀器。 因為文字閱讀器會傳回 Unicode 字元的資料流，所以 XML 讀取器不會使用 XML 宣告中所指定的編碼方式，來解碼資料流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 執行個體的設定。 這個值可以是 <see langword="null" />。</param>
        <param name="inputContext">剖析 XML 片段所需的內容資訊。 內容資訊可包含要使用的 <see cref="T:System.Xml.XmlNameTable" />、編碼方式、命名空間範圍、目前的 <c>xml:lang</c> 和 <c>xml:space</c> 範圍、基底 URI，以及文件類型定義。  
  
這個值可以是 <see langword="null" />。</param>
        <summary>使用指定的文字讀取器、設定和內容資訊進行剖析，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 如果在需要驗證的網路資源位於外部的資源，請使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性來指定<xref:System.Xml.XmlResolver>具有必要認證。  
  
> [!IMPORTANT]
>  您可以使用其中一種下列方法來控制哪些資源<xref:System.Xml.XmlReader>可以存取：  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 物件，限制 <xref:System.Xml.XmlSecureResolver> 可以存取的資源。  
>   
>  -或-  
>   
>  -   藉由將 <xref:System.Xml.XmlReader> 屬性設為 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，來禁止 `null` 開啟外部資源。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Xml.XmlReader>讀取 XML 片段的物件。  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Xml.XmlReaderSettings.NameTable" /> 和 <see cref="P:System.Xml.XmlParserContext.NameTable" /> 屬性都包含值。 (只能設定並使用其中一個 <see langword="NameTable" /> 屬性)。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 資料之檔案的 URI。 <see cref="T:System.Xml.XmlReaderSettings" /> 物件上的 <see cref="T:System.Xml.XmlResolver" /> 物件是用於將路徑轉換成標準資料表示。 如果 <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> 為 <see langword="null" />，則會使用新的 <see cref="T:System.Xml.XmlUrlResolver" /> 物件。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 執行個體的設定。 這個值可以是 <see langword="null" />。</param>
        <param name="inputContext">剖析 XML 片段所需的內容資訊。 內容資訊可包含要使用的 <see cref="T:System.Xml.XmlNameTable" />、編碼方式、命名空間範圍、目前的 <c>xml:lang</c> 和 <c>xml:space</c> 範圍、基底 URI，以及文件類型定義。  
  
這個值可以是 <see langword="null" />。</param>
        <summary>使用剖析用的指定 URI、設定和內容資訊，建立新的 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <returns>用以在資料流中讀取 XML 資料的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設<xref:System.Xml.XmlUrlResolver>以不含認證用來存取任何外部的資源，例如文件類型定義 (DTD)、 實體、 結構描述等等。  
  
> [!IMPORTANT]
>  從.NET Framework 4.5.2，沒有預設值開始<xref:System.Xml.XmlUrlResolver>提供。 如果您的解決方案以目標為.NET Framework 4.5.2 或更新版本，指定<xref:System.Xml.XmlResolver>使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性。  
  
 這表示<xref:System.Xml.XmlReader>可以存取任何不需要驗證的位置。 如果在需要驗證的網路資源位於外部的資源，請使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>屬性來指定<xref:System.Xml.XmlResolver>具有必要認證。  
  
> [!IMPORTANT]
>  您可以限制的資源，<xref:System.Xml.XmlReader>設定，即可存取<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>屬性設<xref:System.Xml.XmlSecureResolver>物件。  
  
 建立<xref:System.Xml.XmlReader>物件展開實體參考，並執行新行字元的 XML 正規化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see langword="inputUri" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> 沒有足夠的權限可以存取 XML 資料的位置。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Xml.XmlReaderSettings.NameTable" /> 和 <see cref="P:System.Xml.XmlParserContext.NameTable" /> 屬性都包含值。 (只能設定並使用其中一個 <see langword="NameTable" /> 屬性)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到由 URI 指定的檔案。</exception>
        <exception cref="T:System.UriFormatException">URI 格式不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得 XML 文件中目前節點的深度。</summary>
        <value>XML 文件中目前節點的深度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 請參閱<xref:System.Xml.XmlTextReader.Depth%2A>(在`XmlTextReader`類別) 如需使用這個屬性的範例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>釋放 <see cref="T:System.Xml.XmlReader" /> 類別所使用的資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Xml.XmlReader" /> 類別目前的執行個體所使用的全部資源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 釋出受控和非受控資源，<see langword="false" /> 表示只釋出非受控資源。</param>
        <summary>釋放 <see cref="T:System.Xml.XmlReader" /> 所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得指出讀取器是否在資料流結尾的值。</summary>
        <value><see langword="true" /> 如果讀取器定位於資料流; 結尾否則， <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>在衍生類別中覆寫時，取得屬性值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">屬性的索引。 索引以零為起始。 (第一個屬性的索引為 0。)</param>
        <summary>在衍生類別中覆寫時，取得具有指定索引的屬性值。</summary>
        <returns>指定的屬性值。 這個方法不會移動讀取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會取得第三個屬性的值。  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="i" /> 超出範圍。 它必須是非負值，而且小於屬性集合的大小。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">屬性的限定名稱 (Qualified Name)。</param>
        <summary>在衍生類別中覆寫時，取得具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的屬性值。</summary>
        <returns>指定的屬性值。 如果找不到該屬性或其值為 <see langword="String.Empty" />，則傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會移動讀取器。  
  
 如果讀取器置於`DocumentType` 節點，這個方法可用來取得的 PUBLIC 和 SYSTEM 常值，例如， `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 下列範例會取得 ISBN 屬性的值。  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">屬性的本機名稱。</param>
        <param name="namespaceURI">屬性的命名空間 URI。</param>
        <summary>在衍生類別中覆寫時，取得具有指定 <see cref="P:System.Xml.XmlReader.LocalName" /> 與 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的屬性值。</summary>
        <returns>指定的屬性值。 如果找不到該屬性或其值為 <see langword="String.Empty" />，則傳回 <see langword="null" />。 這個方法不會移動讀取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列 XML 會包含特定的命名空間中的屬性：  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 您可以查閱`dt:type`屬性使用一個引數 （前置詞和本機名稱） 或兩個引數 （區域名稱和命名空間 URI）：  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 若要查閱`xmlns:dt`屬性，請使用下列引數的其中一個：  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 您也可以取得此資訊使用<xref:System.Xml.XmlReader.Prefix%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同步取得目前節點的值。</summary>
        <returns>目前節點的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，即會擲回 <see cref="T:System.InvalidOperationException" /> 和「非同步作業已在進行中」訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前節點是否具有任何屬性。</summary>
        <value><see langword="true" /> 如果目前的節點屬性;否則， <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示目前的節點上的所有屬性。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得指出目前節點是否具有 <see cref="P:System.Xml.XmlReader.Value" /> 的值。</summary>
        <value><see langword="true" /> 如果讀取器目前所在的節點具有<see langword="Value" />; 否則<see langword="false" />。 如果為 <see langword="false" />，則節點的值為 <see langword="String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出具有傳回值的節點類型。  
  
|節點類型|值|  
|---------------|-----------|  
|`Attribute`|屬性的值。|  
|`CDATA`|CDATA 區段的內容。|  
|`Comment`|註解的內容。|  
|`DocumentType`|內部子集。|  
|`ProcessingInstruction`|全部內容 (目標除外)。|  
|`SignificantWhitespace`|在混合內容模型中標記間的泛空白字元。|  
|`Text`|文字節點的內容。|  
|`Whitespace`|標記之間的泛空白字元。|  
|`XmlDeclaration`|宣告的內容。|  
  
   
  
## Examples  
 請參閱<xref:System.Xml.XmlTextReader.HasValue%2A>(在`XmlTextReader`類別) 如需使用此方法的範例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得值，指出目前節點是否為從 DTD 或結構描述中定義的預設值產生的屬性。</summary>
        <value><see langword="true" /> 如果目前節點是 DTD 或結構描述; 中定義的預設值所產生的屬性<see langword="false" />如果已經明確設定屬性值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` 一律會傳回`false`實作的`XmlReader`不支援結構描述或 DTD 資訊。 這個屬性只適用於屬性節點。  
  
   
  
## Examples  
 下列範例會顯示所有屬性上的根項目。  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 此範例會使用下列的檔案，做為輸入。  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得指出目前節點是否為空項目的值 (例如 <c>&lt;MyElement/&gt;</c>)。</summary>
        <value><see langword="true" /> 如果目前節點是項目 (<see cref="P:System.Xml.XmlReader.NodeType" />等於<see langword="XmlNodeType.Element" />) 結尾<c>/ &gt;</c>否則<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性可讓您判斷下列各項目之間的差異：  
  
 `<item num="123"/>` (`IsEmptyElement`是`true`)。  
  
 `<item num="123"></item>` (`IsEmptyElement`是`false`，不過是空的項目內容)。  
  
 對應`EndElement`節點並不會產生空的項目。  
  
 如果預設的內容已加入的項目，因為結構描述的驗證，所以`IsEmptyElement`仍會傳回`true`。 它具有在項目具有預設值並無任何影響。 換句話說，`IsEmptyElement`只會報告是否在來源文件中的項目具有結尾項目標記。  
  
   
  
## Examples  
 下列範例會顯示每個項目的文字內容。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 此範例會使用該檔案，`elems.xml`作為輸入。  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要驗證的名稱。</param>
        <summary>傳回值，指出字串引數是否為有效的 XML 名稱。</summary>
        <returns><see langword="true" /> 如果名稱有效，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[W3C XML 1.0 建議事項](https://go.microsoft.com/fwlink/?LinkId=49863)判斷名稱是否有效。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要驗證的名稱語彙基元。</param>
        <summary>傳回值，指出字串引數是否為有效的 XML 名稱語彙基元。</summary>
        <returns><see langword="true" /> 如果它是有效的名稱語彙基元，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[W3C XML 1.0 建議事項](https://go.microsoft.com/fwlink/?LinkId=49863)判斷名稱語彙基元是否有效。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>測試目前的內容節點是否為開頭標記。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼叫 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 並測試目前的內容節點為開頭標記或空白項目標記。</summary>
        <returns><see langword="true" /> 如果 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 找到開頭標記或空白項目標記，如果找到的節點類型並非 <see langword="XmlNodeType.Element" />，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法略過空白字元、 註解和處理指示，直到讀取器定位於內容節點上。 如果目前節點是項目，然後測試方法。  
  
   
  
## Examples  
 下列範例會顯示每個項目的文字內容。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 此範例會使用該檔案，`elems.xml`作為輸入。  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在輸入資料流中遇到錯誤的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">字串符合所找到項目的 <see langword="Name" /> 屬性。</param>
        <summary>呼叫 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 並測試目前的內容節點為開頭標記或空白項目標記，以及所找到項目的 <see cref="P:System.Xml.XmlReader.Name" /> 屬性是否符合指定的引數。</summary>
        <returns><see langword="true" /> 如果產生的節點是項目，並且 <see langword="Name" /> 屬性符合指定的字串。 <see langword="false" /> 如果找到的節點類型並非 <see langword="XmlNodeType.Element" />，或如果項目 <see langword="Name" /> 屬性不符合指定字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法略過空白字元、 註解和處理指示，直到讀取器定位於內容節點上。 如果目前節點是項目，然後測試方法。  
  
   
  
## Examples  
 下列範例會顯示每個價格項目。  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在輸入資料流中遇到錯誤的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">要符合所找到項目之 <see langword="LocalName" /> 屬性的字串。</param>
        <param name="ns">要符合所找到項目之 <see langword="NamespaceURI" /> 屬性的字串。</param>
        <summary>呼叫 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 並測試目前的內容節點為開頭標記或空白項目標記，以及所找到項目的 <see cref="P:System.Xml.XmlReader.LocalName" /> 與 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 屬性是否符合指定的字串。</summary>
        <returns><see langword="true" /> 如果產生的節點是項目。 <see langword="false" /> 如果找到的節點類型並非 <see langword="XmlNodeType.Element" />，或如果項目的 <see langword="LocalName" /> 和 <see langword="NamespaceURI" /> 屬性不符合指定字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法略過空白字元、 註解和處理指示，直到讀取器定位於內容節點上。 如果目前節點是項目，然後測試方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在輸入資料流中遇到錯誤的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>在衍生類別中覆寫時，取得屬性值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">屬性的索引。</param>
        <summary>在衍生類別中覆寫時，取得具有指定索引的屬性值。</summary>
        <value>指定的屬性值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性不會移動讀取器。  
  
   
  
## Examples  
 下列範例會顯示目前的節點上的所有屬性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">屬性的限定名稱 (Qualified Name)。</param>
        <summary>在衍生類別中覆寫時，取得具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的屬性值。</summary>
        <value>指定的屬性值。 如果找不到屬性，會傳回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性不會移動讀取器。  
  
 如果讀取器置於`DocumentType` 節點，這個方法可用來取得的 PUBLIC 和 SYSTEM 常值，例如， `reader["PUBLIC"]`  
  
   
  
## Examples  
 下列範例會取得 ISBN 屬性的值。  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">屬性的本機名稱。</param>
        <param name="namespaceURI">屬性的命名空間 URI。</param>
        <summary>在衍生類別中覆寫時，取得具有指定 <see cref="P:System.Xml.XmlReader.LocalName" /> 與 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的屬性值。</summary>
        <value>指定的屬性值。 如果找不到屬性，會傳回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性不會移動讀取器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得目前節點的區域名稱。</summary>
        <value>目前節點名稱的前置詞被移除。 例如，<see langword="LocalName" />已<see langword="book" />項目的<c>&lt;bk: book&amp;gt&gt;</c>。  
  
對於沒有名稱的節點類型 (如 <see langword="Text" />、<see langword="Comment" /> 等)，這個屬性會傳回 <see langword="String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示每個節點的本機名稱，如果它們存在，前置詞和命名空間 URI。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 此範例會使用該檔案，book2.xml，做為輸入。  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">您要解析其命名空間 URI 的前置詞。 若要符合預設命名空間，請傳送空字串。</param>
        <summary>在衍生類別中覆寫時，解析目前項目範圍內的命名空間前置詞。</summary>
        <returns>前置詞對應的命名空間 URI，如果找不到符合的前置詞，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在下列 XML 字串，如果讀取器置於`href`屬性，前置詞`a`藉由呼叫會解析`reader.LookupNamespace("a")`。 傳回的字串是`urn:456`。  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>在衍生類別中覆寫時，移至指定的屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">屬性的索引。</param>
        <summary>在衍生類別中覆寫時，移至具有指定索引的屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示目前的節點上的所有屬性。  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">參數的值是負數。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">屬性的限定名稱 (Qualified Name)。</param>
        <summary>在衍生類別中覆寫時，移至具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的屬性。</summary>
        <returns><see langword="true" /> 如果找到屬性，否則為 <see langword="false" />。 如果為 <see langword="false" />，則不會變更讀取器的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之後呼叫`MoveToAttribute`，則<xref:System.Xml.XmlReader.Name%2A>， <xref:System.Xml.XmlReader.NamespaceURI%2A>，和<xref:System.Xml.XmlReader.Prefix%2A>屬性會反映該屬性的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentException">參數為空字串。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">屬性的本機名稱。</param>
        <param name="ns">屬性的命名空間 URI。</param>
        <summary>在衍生類別中覆寫時，移至具有指定 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的屬性。</summary>
        <returns><see langword="true" /> 如果找到屬性，否則為 <see langword="false" />。 如果為 <see langword="false" />，則不會變更讀取器的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之後呼叫`MoveToAttribute`，則<xref:System.Xml.XmlReader.Name%2A>， <xref:System.Xml.XmlReader.NamespaceURI%2A>，和<xref:System.Xml.XmlReader.Prefix%2A>屬性會反映該屬性的屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentNullException">這兩個參數值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>檢查目前節點是否為內容 (非空白字元文字、<see langword="CDATA" />、<see langword="Element" />、<see langword="EndElement" />、<see langword="EntityReference" /> 或 <see langword="EndEntity" />) 節點。 如果節點並非內容節點，讀取器會先跳至下一個內容節點或檔案結尾。 它會略過下列型別的節點：<see langword="ProcessingInstruction" />、<see langword="DocumentType" />、<see langword="Comment" />、<see langword="Whitespace" /> 或 <see langword="SignificantWhitespace" />。</summary>
        <returns>這個方法所找到的目前節點的 <see cref="P:System.Xml.XmlReader.NodeType" />，如果讀取器已經到達輸入資料流的結尾，則為 <see langword="XmlNodeType.None" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前節點是屬性節點，這個方法會移動讀取器傳回至擁有該屬性的項目。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.MoveToContentAsync%2A>。  
  
   
  
## Examples  
 當您想要撰寫程式碼，可以略過隨機的 XML 標記，而不會中斷，這非常有用。 例如，假設您有下列程式碼：  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 此程式碼可以處理下列輸入，而不會中斷：  
  
```xml  
<price>123.4</price>  
```  
  
 和  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 和  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTITY p  
  "123.4">]><price>&p;</price>  
```  
  
 和  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在輸入資料流中發現不正確的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同步檢查目前節點是否為內容節點。 如果節點並非內容節點，讀取器會先跳至下一個內容節點或檔案結尾。</summary>
        <returns>這個方法所找到的目前節點的 <see cref="P:System.Xml.XmlReader.NodeType" />，如果讀取器已經到達輸入資料流的結尾，則為 <see langword="XmlNodeType.None" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.MoveToContent%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，移至包含目前屬性節點的項目上。</summary>
        <returns><see langword="true" /> 如果讀取器位於屬性 (讀取器移至擁有該屬性的項目) 上，如果讀取器不位於屬性 (不會變更讀取器的位置) 上，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法傳回的項目之後瀏覽其屬性。 這個方法會將讀取器移至下列節點類型的其中一個： `Element`， `DocumentType`，或`XmlDeclaration`。  
  
   
  
## Examples  
 下列範例會顯示目前的節點上的所有屬性。  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，移至第一個屬性。</summary>
        <returns><see langword="true" /> 如果屬性存在 (讀取器移至第一個屬性)，否則為 <see langword="false" /> (不會變更讀取器的位置)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會取得第一個屬性的值。  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，移至下一個屬性。</summary>
        <returns><see langword="true" /> 如果有下一個屬性，如果沒有其他屬性，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的節點是項目節點，這個方法就相當於<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>。 如果`MoveToNextAttribute`傳回`true`，讀取器移至下一個屬性，讀取器位置不會變更的否則為。  
  
   
  
## Examples  
 下列範例會顯示目前的節點上的所有屬性。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得目前節點的限定名稱。</summary>
        <value>目前節點的限定名稱。 例如，<see langword="Name" />已<see langword="bk:book" />項目的<c>&lt;bk: book&amp;gt&gt;</c>。  
  
傳回的名稱需視節點的 <see cref="P:System.Xml.XmlReader.NodeType" /> 而定： 下列節點類型會傳回所列的值。 其他所有節點類型都會傳回空字串。  
  
 <list type="table"><listheader><term> 節點類型 
 </term><description> 名稱 
 </description></listheader><item><term><see langword="Attribute" /></term><description> 屬性的名稱。  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> 文件類型名稱。  
  
 </description></item><item><term><see langword="Element" /></term><description> 標記名稱。  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> 所參考的實體名稱。  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> 處理指示的目標。  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> <see langword="xml" /> 常值 (Literal) 字串。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會讀取 XML 檔案，並顯示每個節點。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 此範例會使用`items.xml`檔案。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得讀取器所在節點的命名空間 URI (如 W3C 命名空間規格中所定義)。</summary>
        <value>目前節點的命名空間 URI，否則為空字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性無關`Element`和`Attribute`僅限節點。  
  
   
  
## Examples  
 下列範例會顯示每個節點的本機名稱，如果它們存在，前置詞和命名空間 URI。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 此範例會使用該檔案，book2.xml，做為輸入。  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得與這個實作相關聯的 <see cref="T:System.Xml.XmlNameTable" />。</summary>
        <value><see langword="XmlNameTable" /> 可讓您取得節點中字串的原子化版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從傳回的所有節點和屬性名稱<xref:System.Xml.XmlReader>不可部分完成的使用`NameTable`。 相同的名稱傳回多次時 (例如`Customer`)，然後相同`String`物件就會傳回該名稱。 這項功能可讓您撰寫有效率的程式碼，進行物件比較，對這些字串，而不是昂貴的字串比較。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得目前節點的型別。</summary>
        <value>其中一個列舉值，指定目前節點的類型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會讀取 XML 檔案，並顯示每個節點。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 此範例會使用`items.xml`檔案。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得與目前節點相關的命名空間前置詞。</summary>
        <value>與目前節點相關聯的命名空間前置詞。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示每個節點的本機名稱，如果它們存在，前置詞和命名空間 URI。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 此範例會使用該檔案，book2.xml，做為輸入。  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得用來括住屬性節點值的引號字元。</summary>
        <value>用來括住屬性節點值的引號字元 (" 或 ')。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性只適用於屬性節點。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，從資料流讀取下一個節點。</summary>
        <returns><see langword="true" /> 如果成功讀取下一個節點，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Xml.XmlReader>這是第一次建立並初始化，沒有可用的資訊。 您必須呼叫<xref:System.Xml.XmlReader.Read%2A>讀取的第一個節點。 <xref:System.Xml.XmlReader.Read%2A>方法會設定狀態的 XML 讀取器，來起始<xref:System.Xml.ReadState>並透過 XML 檔案以循序方式移動，直到它到達的檔案，此時方法會傳回值的結尾`false`。  
  
 這個方法需要從資料流至少四個位元組，才能開始剖析。 如果傳回少於四個位元組，而且資料流中沒有詳細資料，此方法會傳回`false`。 如果資料流中有更多資料，方法會封鎖直到接收第四個位元組的剖析。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadAsync%2A>。  
  
   
  
## Examples  
 下列範例會讀取 XML 檔案，並顯示每個節點：
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 此範例會使用`items.xml`檔案。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **輸出：**  

 [!INCLUDE [xmlreader-read-sample-output](~/includes/xmlreader-read-sample-output.md)] 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">剖析 XML 時發生錯誤。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同步讀取資料流中的下一個節點。</summary>
        <returns><see langword="true" /> 如果成功讀取下一個節點，如果沒有其他節點可讀取，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.Read%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，將屬性值剖析成一或多個 <see langword="Text" />、<see langword="EntityReference" /> 或 <see langword="EndEntity" /> 節點。</summary>
        <returns><see langword="true" /> 如果有節點傳回。  
  
 <see langword="false" /> 如果在初次呼叫時讀取器不位於屬性節點上，或已讀取所有屬性值。  
  
針對含有 <see langword="String.Empty" /> 值的單一節點，空白的屬性 (例如 <c>misc=""</c>) 會傳回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法之後呼叫<xref:System.Xml.XmlReader.MoveToAttribute%2A>閱讀的文字或實體參考節點的屬性值所組成。 <xref:System.Xml.XmlReader.Depth%2A>屬性值的節點是屬性節點的深度加一，它會自動遞增和遞減 1 當您逐步執行和跳離一般實體參考。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要傳回的值型别。  
  
 **注意**：使用 .NET Framework 3.5 的版本時，<paramref name="returnType" /> 參數的值現在可以是 <see cref="T:System.DateTimeOffset" /> 類型。</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> 物件，用來解析任何與型別轉換相關的命名空間前置詞。 例如，將 <see cref="T:System.Xml.XmlQualifiedName" /> 物件轉換為 <c>xs:string</c> 時，可以使用它。  
  
這個值可以是 <see langword="null" />。</param>
        <summary>以指定型别的物件形式讀取內容。</summary>
        <returns>轉換為要求型別的串連文字內容或屬性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取目前的讀取器位置上的文字內容，並將它轉換成要求的傳回型別。 文字、泛空白字元、顯著泛空白字元及 CDATA 區段都是串連的。 註解和處理指示會略過，並且實體參考會自動進行解析。  
  
 這個方法用來讀取、 轉換，如有必要，並傳回從目前節點的不可部份完成值的項目內容。 如果輸入型別是目前的節點包含目前節點的值的目標型別執行個體之類型的有效對應會傳回。 請參閱 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面，如需預設對應的清單。  
  
 例如，如果您有下列的 XML 文字：  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 如果資料型別和字串陣列，提供給<xref:System.Xml.XmlReader.ReadContentAs%2A>從根據有效的 CLR 型別對應的清單的字串轉換方法呼叫，則整數值。  
  
 如果資料是不具型別和字串陣列，提供給<xref:System.Xml.XmlReader.ReadContentAs%2A>方法呼叫，將內容會剖析為個別的字串。 包含兩個字串的陣列會傳回值為"123"和"456 」。 從內容，不會保留空間。  
  
 通常在讀取不具類型的資料內容會剖析根據提供的型別。 例如，如果整數陣列提供給<xref:System.Xml.XmlReader.ReadContentAs%2A>方法呼叫，則字串會剖析為整數的陣列{123,456}。  
  
 在下列範例中的 XML 文字是不以空格分隔  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 如果內容是不具型別和字串陣列，提供給<xref:System.Xml.XmlReader.ReadContentAs%2A>方法然後呼叫包含其中一個值"123456789"會傳回串連的字串的陣列。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadContentAsAsync%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Xml.XmlReader.ReadContentAs%2A>方法來傳回色彩項目的內容到字串物件的陣列。  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 該範例使用 `dataFile_2.xml` 檔案做為輸入。  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">此內容的目標類型格式不正確。</exception>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="returnType" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">目前節點不是受支援的節點型別。 如需詳細資訊，請參閱下表。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.OverflowException">讀取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要傳回的值型别。</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> 物件，用來解析任何與型別轉換相關的命名空間前置詞。</param>
        <summary>以非同步的方式讀取做為指定型别之物件的內容。</summary>
        <returns>轉換為要求型別的串連文字內容或屬性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadContentAs%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">將產生的文字複製到其中的緩衝區。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區中開始複製結果的位移。</param>
        <param name="count">要複製至緩衝區中的最大位元組數目。 從這個方法傳回所複製的實際位元組數目。</param>
        <summary>讀取內容，並傳回 Base64 已解碼的二進位位元組。</summary>
        <returns>寫入緩衝區的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串流處理內容、 解碼`Base64`內容，並傳回已解碼二進位位元組 (例如，內嵌`Base64`編碼的 GIF 影像) 到緩衝區。 可以連續呼叫這個方法來讀取內嵌文字的大量資料流。 如需詳細資訊，請參閱 RFC 1521"MIME （多用途網際網路郵件延伸標準） 第一個：機制來指定及描述網際網路訊息內文的格式 」。 您可以取得從 Rfc[註解的網站要求](https://go.microsoft.com/fwlink/?LinkId=37119)。  
  
> [!NOTE]
>  您不應該存取的任何讀取器屬性呼叫之間<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>方法，這個方法傳回值直到`0`。  
  
 這個方法有下列行為：  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> 傳回值`0`當它到達它正在操作的位元組資料流的結尾。 讀取器定位於第一個非內容節點上。  
  
-   如果您尋求更少，或確切數目，超過會留在讀取器會保留在其目前位置的資料流位元組數目。  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> 不支援下列的 XML 節點類型： `Element`， `XmlDeclaration`， `None`， `Document`， `DocumentType`， `Notation`， `Entity`， `DocumentFragment`。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" /> 目前的節點不支援。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">緩衝區的索引或是索引 + 計數大於所配置的緩衝區大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 實作不支援這個方法。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">將產生的文字複製到其中的緩衝區。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區中開始複製結果的位移。</param>
        <param name="count">要複製至緩衝區中的最大位元組數目。 從這個方法傳回所複製的實際位元組數目。</param>
        <summary>以非同步的方式讀取內容，並傳回 Base64 已解碼的二進位位元組。</summary>
        <returns>寫入緩衝區的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">將產生的文字複製到其中的緩衝區。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區中開始複製結果的位移。</param>
        <param name="count">要複製至緩衝區中的最大位元組數目。 從這個方法傳回所複製的實際位元組數目。</param>
        <summary>讀取內容，並傳回 <see langword="BinHex" /> 已解碼的二進位位元組。</summary>
        <returns>寫入緩衝區的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串流處理內容、 解碼`BinHex`內容，並傳回已解碼二進位位元組 (例如，內嵌`BinHex`編碼的 GIF 影像) 到緩衝區。 可以連續呼叫這個方法來讀取內嵌文字的大量資料流。  
  
> [!NOTE]
>  您不應該存取的任何讀取器屬性呼叫之間<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>方法，這個方法傳回值直到`0`。  
  
 這個方法有下列行為：  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> 傳回值`0`當它到達它正在操作的位元組資料流的結尾。 讀取器定位於第一個非內容節點上。  
  
-   如果您尋求更少，或超過會留在資料流讀取位元組的確切數目，會保留在其目前的位置。  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> 不支援下列的 XML 節點類型： `Element`， `XmlDeclaration`， `None`， `Document`， `DocumentType`， `Notation, Entity`， `DocumentFragment`。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> 目前的節點不支援。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">緩衝區的索引或是索引 + 計數大於所配置的緩衝區大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 實作不支援這個方法。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">將產生的文字複製到其中的緩衝區。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區中開始複製結果的位移。</param>
        <param name="count">要複製至緩衝區中的最大位元組數目。 從這個方法傳回所複製的實際位元組數目。</param>
        <summary>以非同步的方式讀取內容，並傳回 <see langword="BinHex" /> 的解碼二進位位元組。</summary>
        <returns>寫入緩衝區的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see langword="Boolean" /> 的形式，讀取目前位置的文字內容。</summary>
        <returns><see cref="T:System.Boolean" /> 物件形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 如果內容的型別`xsd:boolean`，讀取器傳回 unboxed<xref:System.Boolean>物件。 如果內容不具型別`xsd:boolean`，讀取器會嘗試將它轉換成<xref:System.Boolean>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Xml.XmlReader> 參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A>方法來讀取屬性做為`Boolean`值。  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 該範例使用 `dataFile_2.xml` 檔案做為輸入。  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.DateTime" /> 物件的形式，讀取目前位置的文字內容。</summary>
        <returns><see cref="T:System.DateTime" /> 物件形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 如果內容的型別`xsd:dateTime`，讀取器傳回 unboxed<xref:System.DateTime>物件。 如果內容不具型別`xsd:dateTime`，讀取器會嘗試將它轉換成<xref:System.DateTime>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
> [!NOTE]
>  當內容的型別為 <xref:System.DateTime.Year%2A?displayProperty=nameWithType> 時，無法依賴 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader> 一律設定<xref:System.DateTime.Year%2A?displayProperty=nameWithType>值在此例為 1904年。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Xml.XmlReader> 參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.DateTimeOffset" /> 物件的形式，讀取目前位置的文字內容。</summary>
        <returns><see cref="T:System.DateTimeOffset" /> 物件形式的文字內容。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.Decimal" /> 物件的形式，讀取目前位置的文字內容。</summary>
        <returns><see cref="T:System.Decimal" /> 物件形式的目前位置文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 如果內容的型別`xsd:decimal`，讀取器傳回 unboxed<xref:System.Decimal>物件。 如果內容不具型別`xsd:decimal`，讀取器會嘗試將它轉換成<xref:System.Decimal>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Xml.XmlReader> 參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以雙精確度浮點數的形式讀取目前位置的文字內容。</summary>
        <returns>雙精確度浮點數形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 如果內容的型別`xsd:double`，讀取器傳回的雙精確度浮點數。 如果內容不具型別`xsd:double`，讀取器會嘗試將它轉換為雙精確度浮點數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱 <<c0> <xref:System.Xml.XmlReader> 參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以單精確度浮點數的形式讀取目前位置的文字內容。</summary>
        <returns>單精確度浮點數形式之目前位置的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 如果內容的型別`xsd:float`，讀取器傳回 unboxed 單精確度浮點數。 如果內容不具型別`xsd:float`，讀取器會嘗試將它轉換成單精確度浮點數根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 32 位元帶正負號之整數的形式讀取目前位置的文字內容。</summary>
        <returns>32 位元帶正負號之整數形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 如果內容的型別`xsd:integer`，讀取器傳回的 unboxed 的 32 位元帶正負號的整數。 如果內容不具型別`xsd:integer`，讀取器會嘗試將它轉換成 32 位元帶正負號的整數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 64 位元帶正負號之整數的形式讀取目前位置的文字內容。</summary>
        <returns>64 位元帶正負號之整數形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 如果內容的型別`xsd:long`，讀取器傳回的 unboxed 的 64 位元帶正負號的整數。 如果內容不具型別`xsd:long`，讀取器會嘗試將它轉換成 64 位元帶正負號的整數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 下表描述這個方法會將每個節點類型。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前的位置|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.Object" /> 的形式，讀取目前位置的文字內容。</summary>
        <returns>最合適之 Common Language Runtime (CLR) 物件形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 如果內容的類型，讀取器會傳回所指定的最適當類型的 boxed 的 CLR<xref:System.Xml.XmlReader.ValueType%2A>屬性。 如果內容是清單型別，讀取器就會傳回適當的型別之 boxed 物件的陣列。  
  
> [!NOTE]
>  如果剖析內容時，發生驗證錯誤而讀取器<xref:System.Xml.XmlReader>所建立的物件<xref:System.Xml.XmlReader.Create%2A>方法，讀取器會傳回字串形式的內容。 亦即當發生驗證錯誤或警告，內容會被視為不具型別。  
  
 如果內容不具型別，則讀取器會以字串形式傳回內容。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前的位置|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|如果讀取器驗證讀取器的結構描述元素的值 (<xref:System.Xml.XmlReaderSettings.ValidationType%2A>設為<xref:System.Xml.ValidationType.Schema>)，否則為空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步方式與 <see cref="T:System.Object" /> 的形式，讀取目前位置的文字內容。</summary>
        <returns>最合適之 Common Language Runtime (CLR) 物件形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadContentAsObject%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.String" /> 物件的形式，讀取目前位置的文字內容。</summary>
        <returns><see cref="T:System.String" /> 物件形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會串連文字、 泛空白字元、 顯著泛空白字元和 CDATA 區段，並略過任何註解或處理指示。 會自動解析實體參考。  
  
 可以使用這個方法將具類型的值轉換為字串，或略過註解和處理指示時，讀取的文字內容。  
  
 下表描述這個方法處理每個節點類型的方式。  
  
|XmlNodeType|傳回值|讀取器行為|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|文字、CDATA、泛空白字元及顯著泛空白字元節點的串連內容會轉換為要求的型別。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`Attribute`|與呼叫相同`XmlConvert.ToXxx`屬性值。|讀取器會保持在目前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略處理指示 (PI) 或註解，並讀取 PI 或註解後面的串連文字內容。|移至下一個開始項目或結尾項目標記。 實體參考會自動展開。|  
|`EndElement`|空字串。|讀取器會保持在目前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|擲回 <xref:System.InvalidOperationException>。|未定義 (但讀取器通常會保持在目前位置)。|  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">嘗試的轉換無效。</exception>
        <exception cref="T:System.FormatException">字串格式無效。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步方式與 <see cref="T:System.String" /> 物件的形式，讀取目前位置的文字內容。</summary>
        <returns><see cref="T:System.String" /> 物件形式的文字內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadContentAsString%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>以指定型別之物件的形式，讀取目前的項目並傳回內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要傳回的值型别。  
  
 **注意**：使用 .NET Framework 3.5 的版本時，<paramref name="returnType" /> 參數的值現在可以是 <see cref="T:System.DateTimeOffset" /> 類型。</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> 物件，用來解析任何與型別轉換相關的命名空間前置詞。</param>
        <summary>以要求之型別的形式讀取項目內容。</summary>
        <returns>轉換為要求之型別物件的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Xml.XmlReader.ReadElementContentAs%2A>方法，以讀取內容`date`節點。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 該範例使用 `dataFile.xml` 檔案做為輸入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換成要求的類型。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.OverflowException">讀取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="localName" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要傳回的值型别。  
  
 **注意**：使用 .NET Framework 3.5 的版本時，<paramref name="returnType" /> 參數的值現在可以是 <see cref="T:System.DateTimeOffset" /> 類型。</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> 物件，用來解析任何與型別轉換相關的命名空間前置詞。</param>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以要求之型別的形式讀取項目內容。</summary>
        <returns>轉換為要求之型別物件的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換成要求的類型。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
        <exception cref="T:System.OverflowException">讀取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要傳回的值型别。</param>
        <param name="namespaceResolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> 物件，用來解析任何與型別轉換相關的命名空間前置詞。</param>
        <summary>以要求之型別的形式，非同步讀取項目內容。</summary>
        <returns>轉換為要求之型別物件的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadElementContentAs%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。
-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">將產生的文字複製到其中的緩衝區。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區中開始複製結果的位移。</param>
        <param name="count">要複製至緩衝區中的最大位元組數目。 從這個方法傳回所複製的實際位元組數目。</param>
        <summary>讀取項目，並將 <see langword="Base64" /> 內容解碼。</summary>
        <returns>寫入緩衝區的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法讀取項目內容中，使用將其解碼`Base64`編碼，並傳回已解碼二進位位元組 (例如，內嵌`Base64`-編碼的 GIF 影像) 到緩衝區。 如需詳細資訊，請參閱 RFC 1521"MIME （多用途網際網路郵件延伸標準） 第一個：機制來指定及描述網際網路訊息內文的格式 」。 您可以取得從 Rfc[註解的網站要求](https://go.microsoft.com/fwlink/?LinkId=37119)。  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> 只能讀取簡單內容項目。 元素可以包含文字、 泛空白字元、 顯著泛空白字元、 CDATA 區段中，註解和處理指示。 它也可以包含實體參考，會自動展開。 項目不能有子項目。  
  
 此方式非常類似於<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>方法，但它只能在項目節點型別上呼叫。  
  
 如果`count`值高於在文件中的位元組數目是否等於在文件中的位元組數目或<xref:System.Xml.XmlReader>讀取文件中所有剩餘的位元組，並傳回讀取的位元組數目。 下一步<xref:System.Xml.XmlReader>方法呼叫會傳回零，並將讀取器移至節點下列`EndElement`。  
  
 如果您呼叫<xref:System.Xml.XmlReader.Read%2A>會使用所有的項目內容之前，讀取器可能彷彿已在使用第一次的內容，然後<xref:System.Xml.XmlReader.Read%2A>呼叫方法。 這表示讀取器會讀取所有文字，直到遇到結束的項目。 它接著讀取結束標記節點，讀取下一個節點，並接著將本身置於下一個後續節點。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>。  
  
   
  
## Examples  
 下列範例會讀取內嵌`Base64`編碼的影像。 `Base64`資料內嵌在`<image>`項目。 A<xref:System.IO.BinaryWriter>用來建立新的二進位資料檔案。  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">目前的節點不是項目節點。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">緩衝區的索引或是索引 + 計數大於所配置的緩衝區大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 實作不支援這個方法。</exception>
        <exception cref="T:System.Xml.XmlException">項目包含混合內容。</exception>
        <exception cref="T:System.FormatException">內容無法轉換成要求的類型。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">將產生的文字複製到其中的緩衝區。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區中開始複製結果的位移。</param>
        <param name="count">要複製至緩衝區中的最大位元組數目。 從這個方法傳回所複製的實際位元組數目。</param>
        <summary>以非同步的方式讀取項目，並將 <see langword="Base64" /> 內容解碼。</summary>
        <returns>寫入緩衝區的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">將產生的文字複製到其中的緩衝區。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區中開始複製結果的位移。</param>
        <param name="count">要複製至緩衝區中的最大位元組數目。 從這個方法傳回所複製的實際位元組數目。</param>
        <summary>讀取項目，並將 <see langword="BinHex" /> 內容解碼。</summary>
        <returns>寫入緩衝區的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法讀取項目內容中，使用將其解碼`BinHex`編碼，並傳回已解碼二進位位元組 (例如，內嵌`BinHex`-編碼的 GIF 影像) 到緩衝區。  
  
 這個方法只能讀取簡單內容項目。 元素可以包含文字、 泛空白字元、 顯著泛空白字元、 CDATA 區段中，註解和處理指示。 它也可以包含實體參考，會自動展開。 項目不能有子項目。  
  
 此方式非常類似於<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>方法，但它只能在項目節點型別上呼叫。  
  
 如果`count`值高於在文件中的位元組數目是否等於在文件中的位元組數目或<xref:System.Xml.XmlReader>讀取文件中所有剩餘的位元組，並傳回讀取的位元組數目。 下一步<xref:System.Xml.XmlReader>方法呼叫會傳回零，並將讀取器移至節點下列`EndElement`。  
  
 如果您呼叫<xref:System.Xml.XmlReader.Read%2A>會使用所有的項目內容之前，讀取器可能彷彿已在使用第一次的內容，然後<xref:System.Xml.XmlReader.Read%2A>呼叫方法。 這表示讀取器會讀取所有文字，直到遇到結束的項目。 它接著讀取結束標記節點，讀取下一個節點，並接著將本身置於下一個後續節點。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>。  
  
   
  
## Examples  
 下列範例會讀取內嵌`BinHex`編碼的影像。 `BinHex`資料內嵌在`<image>`項目。 A<xref:System.IO.BinaryWriter>用來建立新的二進位資料檔案。  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">目前的節點不是項目節點。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">緩衝區的索引或是索引 + 計數大於所配置的緩衝區大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 實作不支援這個方法。</exception>
        <exception cref="T:System.Xml.XmlException">項目包含混合內容。</exception>
        <exception cref="T:System.FormatException">內容無法轉換成要求的類型。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">將產生的文字複製到其中的緩衝區。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區中開始複製結果的位移。</param>
        <param name="count">要複製至緩衝區中的最大位元組數目。 從這個方法傳回所複製的實際位元組數目。</param>
        <summary>以非同步的方式讀取項目，並將 <see langword="BinHex" /> 內容解碼。</summary>
        <returns>寫入緩衝區的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>讀取目前的項目值做為<see cref="T:System.Boolean" />物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.Boolean" /> 物件的形式，讀取目前項目並傳回內容。</summary>
        <returns><see cref="T:System.Boolean" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果項目內容的型別`xsd:boolean`，讀取器傳回 unboxed<xref:System.Boolean>物件。 如果內容不具型別`xsd:boolean`，讀取器會嘗試將它轉換成<xref:System.Boolean>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 <see cref="T:System.Boolean" /> 物件。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以 <see cref="T:System.Boolean" /> 物件的形式，讀取目前的項目並傳回內容。</summary>
        <returns><see cref="T:System.Boolean" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:boolean`，讀取器傳回 unboxed<xref:System.Boolean>物件。 如果內容不具型別`xsd:boolean`，讀取器會嘗試將它轉換成<xref:System.Boolean>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換成要求的類型。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>以 <see cref="T:System.DateTime" /> 物件的形式，讀取目前項目並傳回內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.DateTime" /> 物件的形式，讀取目前項目並傳回內容。</summary>
        <returns><see cref="T:System.DateTime" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:dateTime`，讀取器傳回 unboxed<xref:System.DateTime>物件。 如果內容不具型別`xsd:dateTime`，讀取器會嘗試將它轉換成<xref:System.DateTime>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
> [!NOTE]
>  當內容的型別為 <xref:System.DateTime.Year%2A?displayProperty=nameWithType> 時，無法依賴 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader> 一律設定<xref:System.DateTime.Year%2A?displayProperty=nameWithType>值在此例為 1904年。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>方法，以讀取內容`date`項目。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 該範例使用 `dataFile.xml` 檔案做為輸入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 <see cref="T:System.DateTime" /> 物件。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以 <see cref="T:System.DateTime" /> 物件的形式，讀取目前的項目並傳回內容。</summary>
        <returns><see cref="T:System.DateTime" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:dateTime`，讀取器傳回 unboxed<xref:System.DateTime>物件。 如果內容不具型別`xsd:dateTime`，讀取器會嘗試將它轉換成<xref:System.DateTime>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
> [!NOTE]
>  當內容的型別為 <xref:System.DateTime.Year%2A?displayProperty=nameWithType> 時，無法依賴 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader> 一律設定<xref:System.DateTime.Year%2A?displayProperty=nameWithType>值在此例為 1904年。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換成要求的類型。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>讀取目前的項目值做為<see cref="T:System.Decimal" />物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.Decimal" /> 物件的形式，讀取目前項目並傳回內容。</summary>
        <returns><see cref="T:System.Decimal" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 讀取器會嘗試將轉換的項目內容來<xref:System.Decimal>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 <see cref="T:System.Decimal" />。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以 <see cref="T:System.Decimal" /> 物件的形式，讀取目前的項目並傳回內容。</summary>
        <returns><see cref="T:System.Decimal" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 讀取器會嘗試將轉換的項目內容來<xref:System.Decimal>物件所定義的規則根據[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 <see cref="T:System.Decimal" />。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>以雙精確度浮點數的形式，讀取目前的項目並傳回內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以雙精確度浮點數的形式，讀取目前的項目並傳回內容。</summary>
        <returns>雙精確度浮點數形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:double`，讀取器傳回的雙精確度浮點數。 如果內容不具型別`xsd:double`，讀取器會嘗試將它轉換為雙精確度浮點數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
   
  
## Examples  
 下列範例會使用此方法傳回的項目內容，做為雙精確度浮點數。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 該範例使用 `dataFile.xml` 檔案做為輸入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換為雙精確度浮點數。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以雙精確度浮點數的形式，讀取目前的項目並傳回內容。</summary>
        <returns>雙精確度浮點數形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:double`，讀取器傳回的雙精確度浮點數。 如果內容不具型別`xsd:double`，讀取器會嘗試將它轉換為雙精確度浮點數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換成要求的類型。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>以單精確度浮點數的形式讀取目前的項目值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以單精確度浮點數的形式，讀取目前的項目並傳回內容。</summary>
        <returns>單精確度浮點數形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 讀取器會嘗試將項目內容轉換成單精確度浮點數根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換為單精確度浮點數。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以單精確度浮點數的形式，讀取目前的項目並傳回內容。</summary>
        <returns>單精確度浮點數形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 讀取器會嘗試將項目內容轉換成單精確度浮點數根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或- 
在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換為單精確度浮點數。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>以 32 位元帶正負號之整數的形式，讀取目前的項目並傳回內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 32 位元帶正負號之整數的形式，讀取目前的項目並傳回內容。</summary>
        <returns>32 位元帶正負號之整數形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:integer`，讀取器傳回的 unboxed 的 32 位元帶正負號的整數。 如果內容不具型別`xsd:integer`，讀取器會嘗試將它轉換成 32 位元帶正負號的整數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或- 
在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 32 位元帶正負號的整數。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以 32 位元帶正負號之整數的形式，讀取目前的項目並傳回內容。</summary>
        <returns>32 位元帶正負號之整數形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:integer`，讀取器傳回的 unboxed 的 32 位元帶正負號的整數。 如果內容不具型別`xsd:integer`，讀取器會嘗試將它轉換成 32 位元帶正負號的整數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或- 
在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 32 位元帶正負號的整數。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>以 64 位元帶正負號之整數的形式讀取目前的元素並傳回內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 64 位元帶正負號之整數的形式讀取目前的元素並傳回內容。</summary>
        <returns>64 位元帶正負號之整數形式的元素內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:long`，讀取器傳回的 unboxed 的 64 位元帶正負號的整數。 如果內容不具型別`xsd:long`，讀取器會嘗試將它轉換成 64 位元帶正負號的整數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>方法，以讀取內容`longValue`項目。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 該範例使用 `dataFile.xml` 檔案做為輸入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或- 
在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 64 位元帶正負號的整數。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以 64 位元帶正負號之整數的形式讀取目前的元素並傳回內容。</summary>
        <returns>64 位元帶正負號之整數形式的元素內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如果內容的型別`xsd:long`，讀取器傳回的 unboxed 的 64 位元帶正負號的整數。 如果內容不具型別`xsd:long`，讀取器會嘗試將它轉換成 64 位元帶正負號的整數，根據所定義的規則[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 如需詳細資訊，請參閱 <xref:System.Xml.XmlReader> 參考頁面的＜備註＞一節。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或- 
在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 64 位元帶正負號的整數。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>以 <see cref="T:System.Object" /> 的形式，讀取目前項目並傳回內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.Object" /> 的形式，讀取目前項目並傳回內容。</summary>
        <returns>最合適型別的 Boxed Common Language Runtime (CLR) 物件。 <see cref="P:System.Xml.XmlReader.ValueType" /> 屬性會判斷適當的 CLR 類型。 如果內容的型別是清單型別，則這個方法會傳回適當型別之 Boxed 物件的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>。  
  
   
  
## Examples  
 下列範例會使用此方法來讀取的內容`price`節點。 讀取器會使用結構描述中的資訊，以將內容對應至正確的資料類型。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 此範例會使用下列兩個檔案，做為輸入。  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或- 
在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換成要求的類型</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以 <see cref="T:System.Object" /> 的形式，讀取目前的項目並傳回內容。</summary>
        <returns>最合適型別的 Boxed Common Language Runtime (CLR) 物件。 <see cref="P:System.Xml.XmlReader.ValueType" /> 屬性會判斷適當的 CLR 類型。 如果內容的型別是清單型別，則這個方法會傳回適當型別之 Boxed 物件的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或- 
在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容無法轉換成要求的類型。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步方式與 <see cref="T:System.Object" /> 的形式，讀取目前項目並傳回內容。</summary>
        <returns>最合適型別的 Boxed Common Language Runtime (CLR) 物件。 <see cref="P:System.Xml.XmlReader.ValueType" /> 屬性會判斷適當的 CLR 類型。 如果內容的型別是清單型別，則這個方法會傳回適當型別之 Boxed 物件的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>以 <see cref="T:System.String" /> 物件的形式，讀取目前項目並傳回內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以 <see cref="T:System.String" /> 物件的形式，讀取目前項目並傳回內容。</summary>
        <returns><see cref="T:System.String" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>。  
  
   
  
## Examples  
 下列範例會讀取`stringValue`項目，並傳回 （忽略註解和處理指示） 的文字內容。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 該範例使用 `dataFile.xml` 檔案做為輸入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 <see cref="T:System.String" /> 物件。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>檢查指定的區域名稱和命名空間 URI 是否與目前的項目相符，然後以 <see cref="T:System.String" /> 物件的形式，讀取目前的項目並傳回內容。</summary>
        <returns><see cref="T:System.String" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取開始標記，元素的內容，並移動讀取超過結尾項目標記。 它會展開實體，並忽略處理指示與註解。 項目只能包含簡單內容。 也就是說，它不能有子項目。  
  
 如需詳細資訊，請參閱的 < 備註 > 一節<xref:System.Xml.XmlReader>參考頁面和[W3C XML 結構描述第 2 部分：資料型別](https://go.microsoft.com/fwlink/?LinkId=4871)建議。  
  
   
  
## Examples  
 下列範例會讀取`stringValue`項目，並傳回 （忽略註解和處理指示） 的文字內容。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 該範例使用 `dataFile.xml` 檔案做為輸入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 並不是放置在項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.Xml.XmlException">目前的項目包含子項目。  
  
-或- 
項目內容不能轉換為 <see cref="T:System.String" /> 物件。</exception>
        <exception cref="T:System.ArgumentNullException">方法是以 <see langword="null" /> 引數呼叫。</exception>
        <exception cref="T:System.ArgumentException">指定的區域名稱和命名空間 URI，與目前正在讀取的項目不相符。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步方式與 <see cref="T:System.String" /> 物件的形式，讀取目前項目並傳回內容。</summary>
        <returns><see cref="T:System.String" /> 物件形式的項目內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>讀取簡單純文字項目。 不過，我們建議您改用<see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />方法相反地，因為它會提供較簡單的方式來處理這項作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我們建議您改用<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>方法來讀取的文字項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讀取純文字項目。 不過，我們建議您改用<see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />方法相反地，因為它會提供較簡單的方式來處理這項作業。</summary>
        <returns>讀取的項目中所含的文字。 當字串為空白時，則為空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我們建議您改用<xref:System.Xml.XmlReader.ReadElementContentAsString>方法來讀取的文字項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">下一個內容節點不是開始標記。或找到的項目未包含簡單的文字值。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">要進行檢查的名稱。</param>
        <summary>檢查<see cref="P:System.Xml.XmlReader.Name" />屬性找到的項目之前讀取純文字的項目符合指定的字串。 不過，我們建議您改用<see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />方法相反地，因為它會提供較簡單的方式來處理這項作業。</summary>
        <returns>讀取的項目中所含的文字。 當字串為空白時，則為空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我們建議您改用<xref:System.Xml.XmlReader.ReadElementContentAsString>方法來讀取的文字項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">如果下一個內容節點不是開始標記。如果項目<see langword="Name" />不符合指定的引數; 或如果找到的項目不包含簡單的文字值。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ns" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localname">要進行檢查的區域名稱。</param>
        <param name="ns">要進行檢查的命名空間 URI。</param>
        <summary>檢查<see cref="P:System.Xml.XmlReader.LocalName" />和<see cref="P:System.Xml.XmlReader.NamespaceURI" />項目的屬性找到符合的指定的字串之前讀取純文字的項目。 不過，我們建議您改用<see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />方法相反地，因為它會提供較簡單的方式來處理這項作業。</summary>
        <returns>讀取的項目中所含的文字。 當字串為空白時，則為空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我們建議您改用<xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29>方法來讀取的文字項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">如果下一個內容節點不是開始標記。如果項目<see langword="LocalName" />或<see langword="NamespaceURI" />不符合指定的引數; 或如果找到的項目不包含簡單的文字值。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>檢查目前節點為結尾標記，並使讀取器前進至下一個節點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示每個項目的文字內容。  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 此範例會使用`book3.xml`檔案。  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">目前的節點不是結束標記，或如果輸入資料流中遇到不正確的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，將所有的內容當做字串讀取，包括標記。</summary>
        <returns>目前節點中所有的 XML 內容，包括標記。 如果目前節點沒有子節點，則傳回空字串。  
  
如果目前節點既不是項目也不是屬性，則傳回空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回目前的節點，包括標記的所有內容。 不會傳回目前節點 (開始標記) 及對應的結束節點 (結束標記)。 例如，如果您有下列：  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` 傳回 `this <child id="123"/>`  
  
 這個方法會以下列方式處理項目和屬性的節點：  
  
|節點類型|呼叫前的位置|XML 片段|傳回值|在呼叫之後的位置|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|在 `item1` 開始標記上。|\<item1>text1\</item1>\<item2>text2\</item2>|text1|在 `item2` 開始標記上。|  
|`Attribute`|在 `attr1` 屬性節點上。|\<item attr1="val1" attr2="val2">text\</item>|val1|保留在 `attr1` 屬性節點上。|  
  
 如果讀取器定位於分葉節點上，則呼叫 `ReadInnerXml` 相當於呼叫 <xref:System.Xml.XmlReader.Read%2A>。 此方法會傳回`String.Empty`（除非屬性節點屬性的值會傳回在此情況下）。  
  
 這個方法會檢查語式正確的 XML。 如果`ReadInnerXml`會從呼叫<xref:System.Xml.XmlValidatingReader>，這個方法也會驗證傳回的內容。  
  
 中實作<xref:System.Xml.XmlNodeReader>，<xref:System.Xml.XmlTextReader>並`XmlValidatingReader`類別`ReadOuterXml`方法是命名空間感知。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>。  
  
   
  
## Examples  
 下列範例會比較`ReadInnerXml`和<xref:System.Xml.XmlReader.ReadOuterXml%2A>方法。  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 此範例會使用`2books.xml`檔案做為輸入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML 不是語式正確，或剖析 XML 時發生錯誤。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以字串形式非同步讀取所有內容，包括標記。</summary>
        <returns>目前節點中所有的 XML 內容，包括標記。 如果目前節點沒有子節點，則傳回空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadInnerXml%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，讀取代表這個節點及其所有子節點的內容，包括標記。</summary>
        <returns>如果讀取器位於項目或屬性節點上，這個方法會傳回目前節點及其所有子節點的所有 XML 內容，包括標記；否則傳回空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法很類似<xref:System.Xml.XmlReader.ReadInnerXml%2A>但它也會傳回開始和結束標記。  
  
 這個方法會以下列方式處理項目和屬性的節點：  
  
|節點類型|呼叫前的位置|XML 片段|傳回值|在呼叫之後的位置|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|在 `item1` 開始標記上。|\<item1>text1\</item1>\<item2>text2\</item2>|\<item1>text1\</item1>|在 `item2` 開始標記上。|  
|`Attribute`|在 `attr1` 屬性節點上。|\<item attr1="val1" attr2="val2">text\</item>|attr1="val1"|保留在 `attr1` 屬性節點上。|  
  
 如果讀取器定位於分葉節點上，則呼叫 `ReadOuterXml` 相當於呼叫 <xref:System.Xml.XmlReader.Read%2A>。 此方法會傳回`String.Empty`（除非屬性節點的屬性標記會傳回在此情況下）。  
  
 這個方法會檢查語式正確的 XML。 如果`ReadOuterXml`會從呼叫<xref:System.Xml.XmlValidatingReader>，這個方法也會驗證傳回的內容  
  
 中實作<xref:System.Xml.XmlNodeReader>，<xref:System.Xml.XmlTextReader>並`XmlValidatingReader`類別`ReadOuterXml`方法是命名空間感知。 指定下列 XML 文字`<A xmlns:S="urn:1"><S:B>hello</S:B></A>`，如果將讀取器置於上`S:B`開始標記，`ReadOuterXml`傳回`<S:B xmlns:S="urn:1">hello<S:B/>`。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>。  
  
   
  
## Examples  
 下列範例會比較`ReadInnerXml`和`ReadOuterXml`方法。  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 此範例會使用`2books.xml`檔案做為輸入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML 不是語式正確，或剖析 XML 時發生錯誤。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同步讀取表示這個節點及其所有子系的內容，包括標記。</summary>
        <returns>如果讀取器位於項目或屬性節點上，這個方法會傳回目前節點及其所有子節點的所有 XML 內容，包括標記；否則傳回空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadOuterXml%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>檢查目前節點為項目，並使讀取器前進至下一個節點。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>檢查目前節點為項目，並使讀取器前進至下一個節點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Xml.XmlReader.IsStartElement%2A>後面接著<xref:System.Xml.XmlReader.Read%2A>您放置在輸入資料流中找到該項目的內容。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">輸入資料流中遇到不正確的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">項目的限定名稱。</param>
        <summary>檢查目前的內容節點是否具有的項目指定<see cref="P:System.Xml.XmlReader.Name" />並使讀取器前進至下一個節點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫此方法對應於呼叫<xref:System.Xml.XmlReader.IsStartElement%2A>後面接著呼叫<xref:System.Xml.XmlReader.Read%2A>。  
  
   
  
## Examples  
 下列範例會顯示每個項目的文字內容。  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 此範例會使用`book3.xml`檔案。  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">輸入資料流中遇到不正確的 XML。  
  
-或- 
<see cref="P:System.Xml.XmlReader.Name" />的項目不符合給定<paramref name="name" />。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">項目的本機名稱。</param>
        <param name="ns">項目的命名空間 URI。</param>
        <summary>檢查目前的內容節點是否具有的項目指定<see cref="P:System.Xml.XmlReader.LocalName" />和<see cref="P:System.Xml.XmlReader.NamespaceURI" />並使讀取器前進至下一個節點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫此方法對應於呼叫<xref:System.Xml.XmlReader.IsStartElement%2A>後面接著呼叫<xref:System.Xml.XmlReader.Read%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">輸入資料流中遇到不正確的 XML。  
  
-或- 
<see cref="P:System.Xml.XmlReader.LocalName" />和<see cref="P:System.Xml.XmlReader.NamespaceURI" />屬性找到的項目不符合指定的引數。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得讀取器的狀態。</summary>
        <value>其中一個列舉值，這個值指定讀取器的狀態。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadState%2A>屬性具有下列值之一：  
  
-   <xref:System.Xml.ReadState.Initial>當<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>呼叫方法。  
  
-   <xref:System.Xml.ReadState.Interactive>當<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>呼叫的方法，並讀取器上無法呼叫其他方法。  
  
-   <xref:System.Xml.ReadState.EndOfFile>當 XML 文件結尾已經順利到達。  
  
-   <xref:System.Xml.ReadState.Closed>當<xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType>呼叫方法。  
  
-   <xref:System.Xml.ReadState.Error>當發生錯誤，無法讀取的作業無法繼續。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，將項目或文字節點的內容當做字串讀取。 不過，我們建議您改用<see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />方法相反地，因為它會提供較簡單的方式來處理這項作業。</summary>
        <returns>項目的內容或空字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 我們建議您改用<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>方法來讀取項目或文字節點，做為字串的內容。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">剖析 XML 時發生錯誤。</exception>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回新<see langword="XmlReader" />可以用來讀取目前的節點及其所有子系的執行個體。</summary>
        <returns>新的 XML 讀取器執行個體設定為<see cref="F:System.Xml.ReadState.Initial" />。 呼叫<see cref="M:System.Xml.XmlReader.Read" />方法前呼叫的節點上放置新讀取器<see cref="M:System.Xml.XmlReader.ReadSubtree" />方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> 可以呼叫只能在項目節點上。 已讀取整個子樹狀目錄中，呼叫<xref:System.Xml.XmlReader.Read%2A>方法會傳回`false`。 當新的 XML 讀取器已關閉時，原始讀取器位於`EndElement`子樹狀結構的節點。 因此，如果您呼叫<xref:System.Xml.XmlReader.ReadSubtree%2A>book 項目樹狀子目錄已讀取] 和 [新的 XML 讀取器後的開始標記上的方法已關閉，原始的 XML 讀取器定位於結束標記的書籍項目上。  
  
 在關閉新讀取器之前，不應在原始讀取器上執行任何作業。 此動作不受支援，並會導致無法預期的行為。  
  
> [!NOTE]
>  <xref:System.Xml.XmlReader.ReadSubtree%2A>方法不適用於建立 XML 資料，您可以使用獨立的複本。 它被設計來建立 XML 項目周圍的界限。 如果您想要將資料傳遞至另一個元件進行處理，而您想要限制您的元件可以存取的資料中有多少，這非常有用。 當您傳遞所傳回的 XML 讀取器<xref:System.Xml.XmlReader.ReadSubtree%2A>另一個應用程式，應用程式的方法可以存取只有該 XML 項目，不是整個 XML 文件。  
  
   
  
## Examples  
 下列範例會示範如何使用 <xref:System.Xml.XmlReader.ReadSubtree%2A> 方法。  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 您可以使用下列 XML 資料來執行本主題中的範例：  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">呼叫這個方法時，XML 讀取器未位於項目上。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>往前推進<see cref="T:System.Xml.XmlReader" />下一個相符的子系項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">您要移至之項目的限定名稱。</param>
        <summary>往前推進<see cref="T:System.Xml.XmlReader" />下一個子系的項目，具有指定限定名稱。</summary>
        <returns><see langword="true" /> 如果找到相符的子系項目，否則為 <see langword="false" />。 如果找不到相符的子元素，<see cref="T:System.Xml.XmlReader" />位於結束標記 (<see cref="P:System.Xml.XmlReader.NodeType" />是<see langword="XmlNodeType.EndElement" />) 的項目。  
  
如果<see cref="T:System.Xml.XmlReader" />不位於項目上時<see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />呼叫，這個方法會傳回<see langword="false" />和位置<see cref="T:System.Xml.XmlReader" />則不會變更。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會剖析第二個書籍節點。  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 此範例會使用該檔案，`2books.xml`作為輸入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentException">參數為空字串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">您要移至之項目的區域名稱。</param>
        <param name="namespaceURI">您要移至之項目的命名空間 URI。</param>
        <summary>往前推進<see cref="T:System.Xml.XmlReader" />下一個子系的項目，使用指定的區域名稱和命名空間 URI。</summary>
        <returns><see langword="true" /> 如果找到相符的子系項目，否則為 <see langword="false" />。 如果找不到相符的子元素，<see cref="T:System.Xml.XmlReader" />位於結束標記 (<see cref="P:System.Xml.XmlReader.NodeType" />是<see langword="XmlNodeType.EndElement" />) 的項目。  
  
如果<see cref="T:System.Xml.XmlReader" />不位於項目上時<see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />呼叫，這個方法會傳回<see langword="false" />和位置<see cref="T:System.Xml.XmlReader" />則不會變更。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentNullException">這兩個參數值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>在找到具名項目之前讀取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">項目的限定名稱。</param>
        <summary>在找到具有指定限定名稱的項目之前讀取。</summary>
        <returns><see langword="true" /> 如果找到相符的項目，否則為 <see langword="false" />，而且 <see cref="T:System.Xml.XmlReader" /> 處於檔案結尾狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是設定執行的功能上相當`following::name`從目前節點的 XPath 運算式。 它提供快速的方式來尋找 XML 文件中的具名項目。 將讀取器前移至下一步 的下列項目符合指定的名稱，並傳回`true`如果找到相符的項目。 使用下列範例中，讀取器會讀取指定之項目的第一個執行個體同時向前讀取。  
  
```xml  
<!--"sample.xml"-->  
<?xml version="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 可以在所有節點類型上呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentException">參數為空字串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">項目的本機名稱。</param>
        <param name="namespaceURI">項目的命名空間 URI。</param>
        <summary>在找到具有指定區域名稱和命名空間 URI 的項目之前讀取。</summary>
        <returns><see langword="true" /> 如果找到相符的項目，否則為 <see langword="false" />，而且 <see cref="T:System.Xml.XmlReader" /> 處於檔案結尾狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是設定執行的功能上相當`following::name`從目前節點的 XPath 運算式。 它提供快速的方式來尋找 XML 文件中的具名項目。 將讀取器前移至下一步 的下列項目符合指定的名稱，並傳回`true`如果找到相符的項目。  
  
```xml  
<!--"sample.xml"-->  
<?xml version="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 可以在所有節點類型上呼叫這個方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentNullException">這兩個參數值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <summary>往前推進<see langword="XmlReader" />下一個相符的同層級項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">您要移至之同層級項目的限定名稱。</param>
        <summary>往前推進<see langword="XmlReader" />指定限定名稱的下一個同層級項目。</summary>
        <returns><see langword="true" /> 如果找到相符的同層級項目，否則為 <see langword="false" />。 如果找不到相符的同層級項目，則 <see langword="XmlReader" /> 會置於父項目的結束標記上 (<see cref="P:System.Xml.XmlReader.NodeType" /> 為 <see langword="XmlNodeType.EndElement" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  請勿呼叫<xref:System.Xml.XmlReader.ReadToNextSibling%2A>時`XmlReader`為初始狀態 (<xref:System.Xml.XmlReader.ReadState%2A>是<xref:System.Xml.ReadState.Initial>)。 您可以呼叫<xref:System.Xml.XmlReader.Read%2A>前進`XmlReader`，然後呼叫<xref:System.Xml.XmlReader.ReadToNextSibling%2A>方法。  
  
   
  
## Examples  
 下列範例會讀取每個書籍節點上的 ISBN 屬性。  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentException">參數為空字串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">您要移至之同層級項目的本機名稱。</param>
        <param name="namespaceURI">您要移至之同層級項目的命名空間 URI。</param>
        <summary>將 <see langword="XmlReader" /> 前移到下一個具有指定區域名稱和命名空間 URI 的同層級項目。</summary>
        <returns><see langword="true" /> 如果找到相符的同層級項目，否則為 <see langword="false" />。 如果找不到相符的同層級項目，則 <see langword="XmlReader" /> 會置於父項目的結束標記上 (<see cref="P:System.Xml.XmlReader.NodeType" /> 為 <see langword="XmlNodeType.EndElement" />)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  請勿呼叫<xref:System.Xml.XmlReader.ReadToNextSibling%2A>時`XmlReader`為初始狀態 (<xref:System.Xml.XmlReader.ReadState%2A>是<xref:System.Xml.ReadState.Initial>)。 您可以呼叫<xref:System.Xml.XmlReader.Read%2A>前進`XmlReader`，然後呼叫<xref:System.Xml.XmlReader.ReadToNextSibling%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentNullException">這兩個參數值為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">做為寫入文字內容之緩衝區的字元陣列。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區位移位置<see cref="T:System.Xml.XmlReader" />可以開始複製結果。</param>
        <param name="count">要複製至緩衝區中的最大字元數目。 從這個方法傳回所複製的實際字元數目。</param>
        <summary>讀取 XML 文件中內嵌之大量文字資料流。</summary>
        <returns>讀入緩衝區的字元數目。 當不再有文字內容時，會傳回零的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可讓您的非常大型資料流處理方式，也就是在 XML 文件中內嵌的文字資料流讀取一次而不是整個值配置單一字串的字元數少。 可以呼叫這個方法，其值的任何節點上 (<xref:System.Xml.XmlReader.HasValue%2A>是`true`)，但實際的節點值只會進行串流處理時呼叫的文字、 泛空白字元和顯著泛空白字元節點。 其他節點型別值會快取，包括屬性和 CDATA 節點。  
  
 這個方法傳回的內容<xref:System.Xml.XmlReader.Value%2A>屬性並不會移動<xref:System.Xml.XmlReader>。  
  
 這個方法會讀取指定的字元數 (`count`) 的節點值的字元緩衝區 (`buffer`) 中的指定位移 (`index`)，並傳回寫入緩衝區的字元數。 它會傳回`0`當它已達到此值的結尾。 它無法閱讀值重新啟動。  
  
 呼叫之間<xref:System.Xml.XmlReader.ReadValueChunk%2A><xref:System.Xml.XmlReader>屬性進行任何變更，除了<xref:System.Xml.XmlReader.Value%2A>屬性。 當<xref:System.Xml.XmlReader.Value%2A>存取屬性時它可能會傳回部分的值 (尚未所傳回的字元<xref:System.Xml.XmlReader.ReadValueChunk%2A>) 或完整的值，視實作而定。 所有<xref:System.Xml.XmlReader>中的實作<xref:System.Xml>命名空間傳回的部分值<xref:System.Xml.XmlReader.Value%2A>屬性實作。  
  
 任何讀取方法呼叫之間呼叫<xref:System.Xml.XmlReader.ReadValueChunk%2A>。 如果發生這種情況<xref:System.Xml.XmlReader>移至下一個<xref:System.Xml.XmlNodeType>中的資料流和尚不傳回任何字元會略過。  
  
 可能有案例當<xref:System.Xml.XmlReader.ReadValueChunk%2A>傳回少於所要求的字元數目。 例如，如果您有 200 個字元長的值將 surrogate 字組 127 和 128 的位置，而且您呼叫<xref:System.Xml.XmlReader.ReadValueChunk%2A>128 個字元的緩衝區中，使用方法呼叫會傳回 127 個字元，而不是要求 128。 Surrogate 字組則會傳回在下一個<xref:System.Xml.XmlReader.ReadValueChunk%2A>呼叫。 在此情況下，<xref:System.Xml.XmlReader.ReadValueChunk%2A>未傳回要求的 128 個字元，因為這樣做，可能會導致結尾的緩衝區不完整的 surrogate 字組。  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">目前的節點沒有值 (<see cref="P:System.Xml.XmlReader.HasValue" /> 為 <see langword="false" />)。

-或- 
在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">緩衝區索引或索引 + count 大於配置的緩衝區大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 實作不支援這個方法。</exception>
        <exception cref="T:System.Xml.XmlException">XML 資料格式不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">做為寫入文字內容之緩衝區的字元陣列。 這個值不能是 <see langword="null" />。</param>
        <param name="index">緩衝區位移位置<see cref="T:System.Xml.XmlReader" />可以開始複製結果。</param>
        <param name="count">要複製至緩衝區中的最大字元數目。 從這個方法傳回所複製的實際字元數目。</param>
        <summary>以非同步的方式讀取 XML 文件中內嵌之大量文字資料流。</summary>
        <returns>讀入緩衝區的字元數目。 當不再有文字內容時，會傳回零的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.ReadValueChunk%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。
-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>當在衍生類別中覆寫時，會解析實體參考<see langword="EntityReference" />節點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果讀取器置於`EntityReference`節點 (`XmlNodeType.EntityReference`)，如果<xref:System.Xml.XmlReader.Read%2A>之後的呼叫此方法中，實體取代的文字會剖析。 實體取代的文字完成時，`EndEntity`節點會傳回關閉的實體參考的範圍。  
  
> [!NOTE]
>  之後呼叫這個方法，如果實體是組件的屬性值，您必須呼叫<xref:System.Xml.XmlReader.ReadAttributeValue%2A>逐步執行至實體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">讀取器並非位於 <see langword="EntityReference" /> 節點上；這個讀取器實作無法解析實體 (<see cref="P:System.Xml.XmlReader.CanResolveEntity" /> 傳回 <see langword="false" />)。

-或-

在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得在結構描述驗證之後已指派給目前節點的結構描述資訊。</summary>
        <value><see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> 物件，包含目前節點的結構描述資訊。 可以在項目、屬性或具有非 null <see cref="P:System.Xml.XmlReader.ValueType" /> (具型別值) 之文字節點上設定結構描述資訊。  
  
如果目前節點不屬於上述其中一個節點型別，或 <see langword="XmlReader" /> 執行個體不會報告結構描述資訊，則這個屬性會傳回 <see langword="null" />。  
  
如果這個屬性是從 <see cref="T:System.Xml.XmlTextReader" /> 或 <see cref="T:System.Xml.XmlValidatingReader" /> 物件呼叫的，則這個屬性一定會傳回 <see langword="null" />。 這些 <see langword="XmlReader" /> 實作不會透過 <see langword="SchemaInfo" /> 屬性公開結構描述資訊。  
  
 <block subset="none" type="note"><para>  
 如果您需要取得項目的後結構描述驗證資訊集 (PSVI)，請將讀取器置於項目的結束標記，而非開始標記。 您可以透過讀取器的 <see langword="SchemaInfo" /> 屬性取得 PSVI。 如果驗證讀取器是透過將 <see cref="Overload:System.Xml.XmlReader.Create" /> 並將 <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> 屬性設定為 <see cref="F:System.Xml.ValidationType.Schema" /> 所建立，則該讀取器必須置於項目的結束標記，才會具有項目的完整 PSVI。  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Schema.IXmlSchemaInfo>介面會公開的後結構描述驗證 Infoset (PSVI) 相關聯的 XML 節點的子集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Xml.XmlReaderSettings" /> 物件，用於建立這個 <see cref="T:System.Xml.XmlReader" /> 執行個體。</summary>
        <value><see cref="T:System.Xml.XmlReaderSettings" /> 物件，用於建立這個讀取器執行個體。 如果未使用 <see cref="Overload:System.Xml.XmlReader.Create" /> 方法建立這個讀取器，則這個屬性會傳回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlReaderSettings>物件可以包含機密資訊，例如使用者認證。 應用程式必須非常小心，當快取此物件，或將它傳遞到另一個元件。  
  
 <xref:System.Xml.XmlReaderSettings>類別用來指定要建立的讀取器執行個體上支援的功能集。 <xref:System.Xml.XmlReaderSettings>無法修改這個屬性所傳回的物件。 任何嘗試變更個別的設定會造成擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>略過目前節點的子節點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在下列 XML 程式碼中輸入 是否讀取器位於`<a>`節點，或其任意屬性，呼叫`Skip`位置的讀取器`<b>`節點。  
  
 如果讀取器定位於分葉節點上已 (例如`<x>`節點或文字節點`abc`)，則呼叫`Skip`等同於呼叫<xref:System.Xml.XmlReader.Read%2A>。  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 這個方法會檢查語式正確的 XML。  
  
 如果讀取器<xref:System.Xml.XmlValidatingReader>，這個方法也會驗證已略過的內容。  
  
 `XmlReader`實作會判定是否`Skip`方法會展開外部實體。 下表描述各種類型是否會展開外部的實體`XmlReader`物件。  
  
|XmlReader 的型別|展開外部的實體|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|否。|  
|<xref:System.Xml.XmlReader> 所建立的執行個體<xref:System.Xml.XmlReader.Create%2A>讀取的文字資料的方法。|否。|  
|<xref:System.Xml.XmlReader> 所建立的執行個體<xref:System.Xml.XmlReader.Create%2A>讀取二進位資料的方法。|不適用。|  
|結構描述，驗證<xref:System.Xml.XmlReader>所建立的執行個體<xref:System.Xml.XmlReader.Create%2A>方法。|可以。|  
|<xref:System.Xml.XmlValidatingReader>|可以。|  
|<xref:System.Xml.XmlReader> 所傳回的執行個體<xref:System.Xml.XPath.XPathNavigator>物件。|不適用。|  
|<xref:System.Xml.XmlNodeReader>|否。|  
|<xref:System.Xml.XmlReader> 包裝另一個執行個體<xref:System.Xml.XmlReader>執行個體。|取決於基礎實作<xref:System.Xml.XmlReader>。 (`Skip`方法的基礎<xref:System.Xml.XmlReader>稱為)。|  
  
 這個方法的非同步版本，請參閱<xref:System.Xml.XmlReader.SkipAsync%2A>。  
  
   
  
## Examples  
 下列範例會剖析 XML 檔案的第二個書籍節點上啟動。  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 此範例會使用該檔案，`2books.xml`作為輸入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步的方式略過目前節點的子節點。</summary>
        <returns>目前節點。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是非同步的<xref:System.Xml.XmlReader.Skip%2A>，使用相同的功能。 若要使用此方法，您必須設定<xref:System.Xml.XmlReaderSettings.Async%2A>旗標設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。

-或-

在未將 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 旗標設為 <see langword="true" />的情況下呼叫了 <see cref="T:System.Xml.XmlReader" /> 非同步方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「如果您想要使用非同步方法，請將 XmlReaderSettings.Async 設為 true」的訊息。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.IDisposable.Dispose" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

這個成員是明確介面成員實作， 只有在 <xref:System.Xml.XmlReader> 執行個體轉換成 <xref:System.IDisposable> 介面時，才能使用這個成員。

這個成員的行為可能會使用中時[可攜式類別庫](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)專案。 如需詳細資訊，請參閱 <<c0> [ 可攜式類別庫中的 API 差異](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100))。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得目前節點的文字值。</summary>
        <value>傳回值需視節點的 <see cref="P:System.Xml.XmlReader.NodeType" /> 而定。 下表列出具有傳回值的節點類型。 有其他節點類型都會傳回 <see langword="String.Empty" />。  
  
 <list type="table"><listheader><term> 節點類型 
 </term><description> 值 
 </description></listheader><item><term><see langword="Attribute" /></term><description> 屬性的值。  
  
 </description></item><item><term><see langword="CDATA" /></term><description> CDATA 區段的內容。  
  
 </description></item><item><term><see langword="Comment" /></term><description> 註解的內容。  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> 內部子集。  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> 全部內容 (目標除外)。  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> 在混合內容模型中標記間的泛空白字元。  
  
 </description></item><item><term><see langword="Text" /></term><description> 文字節點的內容。  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> 標記之間的泛空白字元。  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> 宣告的內容。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的非同步版本，請參閱<xref:System.Xml.XmlReader.GetValueAsync%2A>方法。  
  
   
  
## Examples  
 下列範例會讀取 XML 檔案，並顯示每個節點。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 此範例會使用`items.xml`檔案。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前節點的 Common Language Runtime (CLR) 型別。</summary>
        <value>CLR 型別，其對應至節點的具型別值。 預設為 <see langword="System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱[System.Xml 類別中的型別支援](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md)如需預設對應的清單。  
  
 類型的元素`xs:int`已經`ValueType`的`System.Int32`預設。 不過，`ValueType`可能是其中一個有效型別可以對應至`xs:int`，例如`System.Int16`或`System.Double`。  
  
 如果節點是不具類型，或如果該節點是項目包含混合的內容，節點的值會對應到`System.String`型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <block subset="none" type="overrides"><para>實作者必須提供<see langword="ValueType" />針對每個節點，即使只是<see langword="System.String" />型別。</para></block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當在衍生類別中覆寫時，取得目前<see langword="xml:lang" />範圍。</summary>
        <value>目前的 <see langword="xml:lang" /> 範圍。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性代表`xml:lang`內目前的節點所在的範圍。 例如，以下是使用 XML 片段`xml:lang`設為 英文 （美國） 的根項目：  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 當讀取器位於`name`項目，您可以使用這個屬性來尋找它位於範圍內的美式英文`xml:lang`屬性。  
  
   
  
## Examples  
 請參閱<xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType>如使用這個屬性的範例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當在衍生類別中覆寫時，取得目前<see langword="xml:space" />範圍。</summary>
        <value>其中一個 <see cref="T:System.Xml.XmlSpace" /> 值。 如果 <see langword="xml:space" /> 範圍不存在，這個屬性預設值為 <see langword="XmlSpace.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 請參閱<xref:System.Xml.XmlTextReader.XmlSpace%2A>(在`XmlTextReader`類別) 如需使用這個屬性的範例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在先前的非同步作業完成前呼叫了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情況下，會擲回 <see cref="T:System.InvalidOperationException" /> 與「非同步作業已經在進行中」的訊息。</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>