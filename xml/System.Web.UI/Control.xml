<Type Name="Control" FullName="System.Web.UI.Control">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="db68cdde80f445a28c9afc5b8c3b9a4fbf51970e" />
    <Meta Name="ms.sourcegitcommit" Value="c902e847cd05ac37d93eca981b0fb009aae0a790" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/28/2018" />
    <Meta Name="ms.locfileid" Value="52455000" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IControlBuilderAccessor, IControlDesignerAccessor, IDataBindingsAccessor, IDisposable, IExpressionsAccessor, IParserAccessor, IUrlResolutionService" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IControlBuilderAccessor, System::Web::UI::IControlDesignerAccessor, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IExpressionsAccessor, System::Web::UI::IParserAccessor, System::Web::UI::IUrlResolutionService" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IParserAccessor&#xA;    interface IUrlResolutionService&#xA;    interface IDataBindingsAccessor&#xA;    interface IControlBuilderAccessor&#xA;    interface IControlDesignerAccessor&#xA;    interface IExpressionsAccessor" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItemFilter</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VSDesigner.WebForms.ControlCodeDomSerializer, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定義所有 ASP.NET 伺服器控制項共用的屬性、方法和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是當您開發自訂 ASP.NET 伺服器控制項衍生自的主要類別。 <xref:System.Web.UI.Control> 沒有任何使用者介面 (UI) 的特定功能。 如果您要撰寫的控制項，並沒有 UI，或結合其他控制項，會呈現其自己的 UI，衍生自<xref:System.Web.UI.Control>。 如果您要撰寫沒有 UI 的控制項，則衍生自<xref:System.Web.UI.WebControls.WebControl>或任何控制在<xref:System.Web.UI.WebControls>命名空間，提供適當的啟動點，以取得您的自訂控制項。  
  
 <xref:System.Web.UI.Control>類別是所有的 ASP.NET 伺服器控制項，包括自訂控制項、 使用者控制項和網頁的基底類別。 ASP.NET 網頁是的執行個體<xref:System.Web.UI.Page>類別，繼承自<xref:System.Web.UI.Control>類別，處理要求的.aspx 副檔名的檔案。  
  
 <xref:System.Web.UI.Control>類別可以直接或間接作為使用者介面的一部分之您的 Web 應用程式，因此應該檢查來撰寫安全程式碼和保護應用程式會接著請確定最佳作法。  
  
 如需這些主題的一般資訊，請參閱[概觀的 Web 應用程式的安全性威脅](https://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a)， [NIB： 安全性原則的最佳作法](https://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05)，並[重要的安全性概念](~/docs/standard/security/key-security-concepts.md)。 如需特定資訊，請參閱 <<c0> [ 保護標準控制項](https://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8)，[如何： 顯示安全的錯誤訊息](https://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa)， [How to： 保護對指令碼會利用所套用的 HTML Web 應用程式中為字串的編碼方式](https://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b)，並[驗證控制項簡介](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.0/2e4hd649(v=vs.85))。  
  
   
  
## Examples  
 下列範例示範衍生自的自訂伺服器控制項<xref:System.Web.UI.Control>類別。 `InnerContent`類別會覆寫<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法，會檢查類別是否有任何子控制項，在頁面上，並判斷控制項的第一個子系是否為常值的控制項。 如果這些條件都符合，覆寫的方法將寫入的 HTML 字串\<H2 > 您的訊息:，常值控制項和一個結束的內容\</H2 > 加入 Web Form 網頁的標記。  
  
> [!IMPORTANT]
>  這個範例有一個可接受使用者輸入的文字方塊，這可能會造成安全性威脅。 根據預設，ASP.NET Web 網頁會驗證使用者輸入未包含指令碼或 HTML 項目。 如需詳細資訊，請參閱 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07) (指令碼攻擊概觀)。  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
    <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">開發自訂 ASP.NET 伺服器控制項</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.Control" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Adapter As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::ControlAdapter ^ Adapter { System::Web::UI::Adapters::ControlAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Adapter : System.Web.UI.Adapters.ControlAdapter" Usage="System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>針對控制項取得瀏覽器的特定配置器。</summary>
        <value>這個控制項的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。 如果目標瀏覽器不需要配置器，則會傳回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web pages 可跨各種不同的裝置和瀏覽器可從 Web 要求的資訊。 <xref:System.Web.UI.Control.Adapter%2A>屬性會傳回<xref:System.Web.UI.Adapters.ControlAdapter>提出要求的裝置或瀏覽器的螢幕呈現控制項的物件。  
  
 如需有關配接器的詳細資訊，請參閱[架構概觀的自動調整控制項行為](https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <related type="Article" href="https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100)">調整控制項行為的架構概觀</related>
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void AddedControl(System::Web::UI::Control ^ control, int index);" />
      <MemberSignature Language="F#" Value="abstract member AddedControl : System.Web.UI.Control * int -&gt; unit&#xA;override this.AddedControl : System.Web.UI.Control * int -&gt; unit" Usage="control.AddedControl (control, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">已加入的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="index">
          <see cref="P:System.Web.UI.Control.Controls" /> 集合中之控制項的索引。</param>
        <summary>在子控制項加入 <see cref="T:System.Web.UI.Control" /> 物件的 <see cref="P:System.Web.UI.Control.Controls" /> 集合後呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.AddedControl%2A>方法在只有在控制項加入之後立即呼叫<xref:System.Web.UI.Control.Controls%2A>集合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" /> 是 <see cref="T:System.Web.UI.WebControls.Substitution" /> 控制項。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddParsedSubObject (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddParsedSubObject(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member AddParsedSubObject : obj -&gt; unit&#xA;override this.AddParsedSubObject : obj -&gt; unit" Usage="control.AddParsedSubObject obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">代表已剖析項目的 <see cref="T:System.Object" />。</param>
        <summary>通知伺服器控制項，XML 或 HTML 項目已剖析，並將項目加入伺服器控制項的 <see cref="T:System.Web.UI.ControlCollection" /> 物件中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除非您覆寫它，這個方法會自動加入<xref:System.Web.UI.LiteralControl>物件至伺服器控制項的<xref:System.Web.UI.ControlCollection>物件。 這個集合是可透過存取<xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType>屬性。  
  
   
  
## Examples  
 下列範例會使用的自訂伺服器控制項<xref:System.Web.UI.Control.AddParsedSubObject%2A>方法來判斷是否項目宣告的開頭和結尾標記，此控制項之間是<xref:System.Web.UI.WebControls.TextBox>Web 伺服器控制項。 如有需要，新增至<xref:System.Collections.ArrayList>物件， `items`。 當覆寫<xref:System.Web.UI.Control.CreateChildControls%2A>呼叫方法時，它會逐一<xref:System.Collections.ArrayList>，並將每個物件來<xref:System.Web.UI.ControlCollection>自訂伺服器控制項。  
  
> [!IMPORTANT]
>  這個範例有一個可接受使用者輸入的文字方塊，這可能會造成安全性威脅。 根據預設，ASP.NET Web 網頁會驗證使用者輸入未包含指令碼或 HTML 項目。 如需詳細資訊，請參閱 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07) (指令碼攻擊概觀)。  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyStyleSheetSkin(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="abstract member ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit&#xA;override this.ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit" Usage="control.ApplyStyleSheetSkin page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">包含控制項的 <see cref="T:System.Web.UI.Page" />。</param>
        <summary>將頁面樣式表中所定義的樣式屬性套用至控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>方法定義的佈景主題目錄中的外觀屬性為基礎的控制項上設定樣式屬性。 套用的面板就是其中一個預設面板控制項或面板中所指定<xref:System.Web.UI.Control.SkinID%2A>屬性。 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>方法由 ASP.NET 呼叫放在頁面中的宣告式控制項。 您必須呼叫<xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>方法，在以程式設計方式建立的任何控制項上執行的時間，樣式表套用至控制項的面板。 會自動套用佈景主題面板。 如需有關佈景主題和階層式樣式表之間的差異的詳細資訊，請參閱[ASP.NET 佈景主題和面板](https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已套用樣式表。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeTemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeTemplateSourceDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeTemplateSourceDirectory : string with get, set" Usage="System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定包含了此控制項之 <see cref="T:System.Web.UI.Page" /> 或 <see cref="T:System.Web.UI.UserControl" /> 物件的相對應用程式虛擬目錄。</summary>
        <value>包含此控制項之網頁或使用者控制項的相對應用程式虛擬目錄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>屬性包含應用程式相對路徑，包含目前控制項之網頁或使用者控制項。 例如，如果網頁位於http://www.contoso.com/application/subdirectory，則<xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>屬性會傳回"~ / 子目錄 」。  
  
 若要傳回的虛擬路徑 （"應用程式/子目錄 」），請使用<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BeginRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BeginRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.BeginRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.BeginRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">寫入追蹤資料的物件。</param>
        <param name="traceObject">追蹤物件。</param>
        <summary>開始進行轉譯資料的設計階段追蹤。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ BindingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含了此控制項之資料繫結的控制項。</summary>
        <value>
          <see cref="T:System.Web.UI.Control" />，包含此控制項的資料繫結。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.BindingContainer%2A>屬性包含參考<xref:System.Web.UI.Control>物件，包含目前控制項的資料繫結資訊。  
  
 <xref:System.Web.UI.Control.BindingContainer%2A>屬性是相同<xref:System.Web.UI.Control.NamingContainer%2A>屬性，但是當控制項是範本的一部分。 在此情況下，<xref:System.Web.UI.Control.BindingContainer%2A>屬性設定為<xref:System.Web.UI.Control>定義範本。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BuildProfileTree (parentId As String, calcViewState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BuildProfileTree(System::String ^ parentId, bool calcViewState);" />
      <MemberSignature Language="F#" Value="member this.BuildProfileTree : string * bool -&gt; unit" Usage="control.BuildProfileTree (parentId, calcViewState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">控制項之父代的識別項。</param>
        <param name="calcViewState">布林值，指出是否計算檢視狀態大小。</param>
        <summary>收集伺服器控制項的相關資訊，並在頁面啟用追蹤時將此資訊傳遞至 <see cref="P:System.Web.UI.Page.Trace" /> 屬性以顯示之。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會收集有關頁面的 UI 階層架構所需的資訊，並將它傳遞至網頁的[&lt;追蹤&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md)屬性。 當您啟用追蹤、 頁面或應用程式，這項資訊會顯示在`Control Tree`追蹤輸出區段。 頁面的追蹤輸出會附加至頁面的結尾雖然可以從追蹤檢視器 （trace.axd 檔案） 儲存在應用程式的根目錄中檢視追蹤輸出的應用程式。 如需有關追蹤的詳細資訊，請參閱 < [ASP.NET 追蹤概觀](https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChildControlsCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChildControlsCreated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ChildControlsCreated : bool with get, set" Usage="System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否已經建立伺服器控制項的子控制項。</summary>
        <value>如果子控制項已經建立，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範的覆寫<xref:System.Web.UI.Control.OnDataBinding%2A>方法的自訂<xref:System.Web.UI.WebControls.Repeater>控制項。 若要確保子控制項都不會建立資料繫結，就會發生一次，直到<xref:System.Web.UI.Control.ChildControlsCreated%2A>屬性設定為`true`之後<xref:System.Web.UI.WebControls.RepeaterItem>所建立的物件，並將其加入控制項的<xref:System.Web.UI.ControlCollection>物件。  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 下列範例示範如何使用自訂的 repeater 控制項在網頁中。  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearCachedClientID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearCachedClientID();" />
      <MemberSignature Language="F#" Value="member this.ClearCachedClientID : unit -&gt; unit" Usage="control.ClearCachedClientID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將快取的 <see cref="P:System.Web.UI.Control.ClientID" /> 值設定為 <see langword="null" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildControlState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildControlState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildControlState : unit -&gt; unit" Usage="control.ClearChildControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刪除伺服器控制項之子控制項的控制項狀態資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildControlState%2A>時建立新的子控制項時，例如在樣板化的資料繫結伺服器控制項中的資料繫結子控制項時，會覆寫子控制項狀態資訊寫入至父控制項的控制項狀態，方法使用。 呼叫<xref:System.Web.UI.Control.ClearChildControlState%2A>方法，以空的子控制項，然後再呼叫<xref:System.Web.UI.Control.SaveControlState%2A>方法可減少控制項狀態資訊必須儲存或傳輸的大小。  
  
 當重新建立的子控制項會<xref:System.Web.UI.Control>物件，請使用<xref:System.Web.UI.Control.ClearChildControlState%2A>方法，以使它不會不會套用到新的控制項不小心清除子控制項狀態。  
  
 若要清除兩者的子控制項的狀態和檢視狀態使用<xref:System.Web.UI.Control.ClearChildState%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildState : unit -&gt; unit" Usage="control.ClearChildState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刪除所有伺服器控制項之子控制項的檢視狀態和控制項狀態資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildState%2A>方法會清除子控制項的所有檢視狀態和控制項狀態資訊。 它相當於呼叫兩者<xref:System.Web.UI.Control.ClearChildViewState%2A>方法和<xref:System.Web.UI.Control.ClearChildControlState%2A>方法。  
  
 當重新建立的子控制項會<xref:System.Web.UI.Control>物件，請使用<xref:System.Web.UI.Control.ClearChildState%2A>方法，以使它不會不會套用到新的控制項不小心清除子狀態。  
  
   
  
## Examples  
 下列程式碼範例示範如何覆寫<xref:System.Web.UI.Control.OnDataBinding%2A>樣板化的資料繫結控制項的方法。 如果已填入資料來源控制項繫結至控制項的<xref:System.Web.UI.ControlCollection>集合會使用清空<xref:System.Web.UI.ControlCollection.Clear%2A>方法，和<xref:System.Web.UI.Control.ClearChildState%2A>方法用來移除任何已儲存的子控制項的狀態資訊。  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildViewState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildViewState : unit -&gt; unit" Usage="control.ClearChildViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刪除所有伺服器控制項之子控制項的檢視狀態資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您覆寫時，通常會使用此方法<xref:System.Web.UI.Control.DataBind%2A>方法開發樣板化的資料繫結伺服器控制項時。 如果您未呼叫這個方法，子控制項檢視狀態資訊寫入父伺服器控制項，但在資料繫結時覆寫。  
  
 當重新建立的子控制項會<xref:System.Web.UI.Control>，使用<xref:System.Web.UI.Control.ClearChildViewState%2A>方法，以使它不會不會套用到新的控制項不小心清除子檢視狀態。  
  
 如需使用此方法的詳細資訊，請參閱[如何： 建立樣板化的 ASP.NET 使用者控制項](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <related type="Article" href="https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2">如何： 建立樣板化的使用者控制項</related>
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearEffectiveClientIDMode ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearEffectiveClientIDMode();" />
      <MemberSignature Language="F#" Value="member this.ClearEffectiveClientIDMode : unit -&gt; unit" Usage="control.ClearEffectiveClientIDMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前的控制項執行個體和任何子控制項的 <see cref="P:System.Web.UI.Control.ClientIDMode" /> 屬性設定為 <see cref="F:System.Web.UI.ClientIDMode.Inherit" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientID : string" Usage="System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 ASP.NET 所產生之 HTML 標記的控制項識別碼。</summary>
        <value>ASP.NET 所產生之 HTML 標記的控制項識別碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當 Web 伺服器控制項轉譯成 HTML 元素， `id` HTML 項目的屬性設定的值為<xref:System.Web.UI.Control.ClientID%2A>屬性。 <xref:System.Web.UI.Control.ClientID%2A>值通常用來存取用戶端指令碼中的 HTML 項目使用`document.getElementById`方法。 識別碼通常也用於 CSS 規則以指定樣式的項目。 例如，下列 CSS 樣式規則會選取所有`span`擁有的項目`id`屬性值`ProductIDLabel`並設定其`background-color`屬性設定為`white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 ASP.NET 提供如何產生多個演算法<xref:System.Web.UI.Control.ClientID%2A>屬性值。 選取要設定控制項使用的演算法及其<xref:System.Web.UI.Control.ClientIDMode%2A>屬性。 演算法的識別方式<xref:System.Web.UI.ClientIDMode>詳列於下表的列舉值。  
  
|值|描述|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 值是透過串連每個父命名容器的 <xref:System.Web.UI.Control.ID%2A> 值與控制項的 <xref:System.Web.UI.Control.ID%2A> 值產生。 在呈現控制項之多個執行個體的資料繫結情節中，遞增值會插入控制項之 <xref:System.Web.UI.Control.ID%2A> 值的前面。 各區段是以底線字元 (_) 分隔。 這個演算法用於比 ASP.NET 4 還舊的版本。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 值設定為 <xref:System.Web.UI.Control.ID%2A> 屬性的值。 如果控制項是命名容器，則對於其包含的所有控制項而言，會用來做為命名容器之階層架構的最上層。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|這個演算法用於資料繫結控制項中的控制項。 <xref:System.Web.UI.Control.ClientID%2A> 值是透過串連父命名容器的 <xref:System.Web.UI.Control.ClientID%2A> 值與控制項的 <xref:System.Web.UI.Control.ID%2A> 值產生。 如果控制項是資料繫結控制項，並且會產生多個資料列，則 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 屬性中指定之資料欄位的值會加入結尾處。 針對 <xref:System.Web.UI.WebControls.GridView> 控制項，可以指定多個資料欄位。 如果<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>屬性空白的循序數字結尾處加入，而不是資料欄位值。 各區段是以底線字元 (_) 分隔。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|此控制項會繼承其 <xref:System.Web.UI.ClientIDMode> 控制項的 <xref:System.Web.UI.Control.NamingContainer%2A> 設定。|  
  
 預設值<xref:System.Web.UI.Control.ClientIDMode%2A>頁面是<xref:System.Web.UI.ClientIDMode.Predictable>。 預設值<xref:System.Web.UI.Control.ClientIDMode%2A>控制項是<xref:System.Web.UI.ClientIDMode.Inherit>。 因為控制項的預設值是<xref:System.Web.UI.ClientIDMode.Inherit>、 模式會預設產生<xref:System.Web.UI.ClientIDMode.Predictable>。 (不過，如果您使用 Visual Studio 將 Web 專案轉換成 ASP.NET 4 中，從較早版本時，Visual Studio 會自動將站台預設值設<xref:System.Web.UI.ClientIDMode.AutoID>Web.config 檔案中。)  
  
 如需詳細資訊，請參閱 [ASP.NET 網頁伺服器控制項識別](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)。  
  
   
  
## Examples  
 下列範例示範位於主版頁面的內容頁面的 Web 使用者控制項。 使用者控制項包含<xref:System.Web.UI.WebControls.DropDownList>控制項和<xref:System.Web.UI.WebControls.Label>控制項。 中所顯示的文字<xref:System.Web.UI.WebControls.Label>控制項由使用者從選取的值決定<xref:System.Web.UI.WebControls.DropDownList>控制項。 文字值是設定透過用戶端指令碼中，使網頁不需要回傳給伺服器，才能設定此值。 若要取得呈現的 HTML 元素的參考<xref:System.Web.UI.WebControls.Label>控制在用戶端指令碼，您必須知道控制項的值<xref:System.Web.UI.Control.ClientID%2A>屬性。 不過，因為使用者控制項可以放在網頁上的任何位置，就無法事先知道哪些命名的容器將包含控制項。 若要確定<xref:System.Web.UI.Control.ClientID%2A>值將會是相同<xref:System.Web.UI.Control.ID%2A>值，程式碼集<xref:System.Web.UI.Control.ClientIDMode%2A>值<xref:System.Web.UI.WebControls.ValidatorDisplay.Static>。  
  
 下列範例會顯示使用者控制項。  
  
  
  
 下列範例會顯示 [內容] 頁面包含使用者控制項。  
  
  
  
 下列範例顯示包含 [內容] 頁面的主版頁面。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">ASP.NET 控制項的識別</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">如何： 從 JavaScript 識別碼的存取控制</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">逐步解說： 建立資料繫結控制項您更輕鬆地從 JavaScript 存取</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">逐步解說： 將控制項設定為位於 Web 使用者控制項更輕鬆地從 JavaScript 存取</related>
        <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">在 ASP.NET Web Pages 中的用戶端指令碼</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClientIDMode As ClientIDMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ClientIDMode ClientIDMode { System::Web::UI::ClientIDMode get(); void set(System::Web::UI::ClientIDMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDMode : System.Web.UI.ClientIDMode with get, set" Usage="System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來產生 <see cref="P:System.Web.UI.Control.ClientID" /> 屬性值的演算法。</summary>
        <value>值，指定如何產生 <see cref="P:System.Web.UI.Control.ClientID" /> 屬性 (Property)。 預設值為 <see cref="F:System.Web.UI.ClientIDMode.Inherit" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 提供如何產生多個演算法<xref:System.Web.UI.Control.ClientID%2A>屬性值。 選取要設定控制項使用的演算法及其<xref:System.Web.UI.Control.ClientIDMode%2A>屬性。 演算法的識別方式<xref:System.Web.UI.ClientIDMode>詳列於下表的列舉值。  
  
|值|描述|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 值是透過串連每個父命名容器的 <xref:System.Web.UI.Control.ID%2A> 值與控制項的 <xref:System.Web.UI.Control.ID%2A> 值產生。 在呈現控制項之多個執行個體的資料繫結情節中，遞增值會插入控制項之 <xref:System.Web.UI.Control.ID%2A> 值的前面。 各區段是以底線字元 (_) 分隔。 這個演算法用於比 ASP.NET 4 還舊的版本。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 值設定為 <xref:System.Web.UI.Control.ID%2A> 屬性的值。 如果控制項是命名容器，則對於其包含的所有控制項而言，會用來做為命名容器之階層架構的最上層。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|這個演算法用於資料繫結控制項中的控制項。 <xref:System.Web.UI.Control.ClientID%2A> 值是透過串連父命名容器的 <xref:System.Web.UI.Control.ClientID%2A> 值與控制項的 <xref:System.Web.UI.Control.ID%2A> 值產生。 如果控制項是資料繫結控制項，並且會產生多個資料列，則 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 屬性中指定之資料欄位的值會加入結尾處。 針對 <xref:System.Web.UI.WebControls.GridView> 控制項，可以指定多個資料欄位。 如果<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>屬性空白的循序數字結尾處加入，而不是資料欄位值。 這個數字在零處開始，並會加 1，每個資料列。 各區段是以底線字元 (_) 分隔。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|此控制項會繼承其 <xref:System.Web.UI.ClientIDMode> 控制項的 <xref:System.Web.UI.Control.NamingContainer%2A> 設定。|  
  
 預設值<xref:System.Web.UI.Control.ClientIDMode%2A>頁面是<xref:System.Web.UI.ClientIDMode.Predictable>。 預設值<xref:System.Web.UI.Control.ClientIDMode%2A>控制項是<xref:System.Web.UI.ClientIDMode.Inherit>。 因為控制項的預設值是<xref:System.Web.UI.ClientIDMode.Inherit>、 模式會預設產生<xref:System.Web.UI.ClientIDMode.Predictable>。 (不過，如果您使用 Visual Studio 將 Web 專案轉換成 ASP.NET 4 中，從較早版本時，Visual Studio 會自動將站台預設值設<xref:System.Web.UI.ClientIDMode.AutoID>Web.config 檔案中。)  
  
 如需詳細資訊，請參閱 [ASP.NET 網頁伺服器控制項識別](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)。  
  
   
  
## Examples  
 下列範例所示<xref:System.Web.UI.WebControls.Label>中所包含的控制項<xref:System.Web.UI.WebControls.ListView>控制項。 上<xref:System.Web.UI.WebControls.ListView>控制項中，<xref:System.Web.UI.Control.ClientIDMode%2A>屬性設定為<xref:System.Web.UI.ClientIDMode.Predictable>並<xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A>屬性設定為`ProductID`。 在轉譯的 HTML，這會建立三個`span`對應至三個元素`ProductIDLabel`控制項。 當頁面執行時，則`id`屬性`span`項目設為下列值：  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">ASP.NET 控制項的識別</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">如何： 從 JavaScript 識別碼的存取控制</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">逐步解說： 建立資料繫結控制項您更輕鬆地從 JavaScript 存取</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">逐步解說： 將控制項設定為位於 Web 使用者控制項更輕鬆地從 JavaScript 存取</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ClientIDSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char ClientIDSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDSeparator : char" Usage="System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得字元值，表示在 <see cref="P:System.Web.UI.Control.ClientID" /> 屬性中所使用的分隔字元。</summary>
        <value>永遠傳回底線字元 (_)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClientID%2A>值會產生藉由串連<xref:System.Web.UI.Control.ID%2A>控制項的值和<xref:System.Web.UI.Control.UniqueID%2A>其父控制項的值。 所產生的每個部分<xref:System.Web.UI.Control.ID%2A>屬性會以分隔<xref:System.Web.UI.Control.ClientIDSeparator%2A>屬性值。 值一律會傳回以底線 (_)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Control.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與目前 Web 要求的伺服器控制項關聯的 <see cref="T:System.Web.HttpContext" /> 物件。</summary>
        <value>與目前要求相關之指定的 <see cref="T:System.Web.HttpContext" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性可讓您存取<xref:System.Web.HttpContext>目前 Web 要求的物件。 物件提供屬性，存取<xref:System.Web.HttpContext.Application%2A>， <xref:System.Web.HttpContext.Session%2A>， <xref:System.Web.HttpContext.Request%2A>，<xref:System.Web.HttpContext.Response%2A>和其他物件，包含目前 HTTP 要求的相關資訊。 它也提供方法，可讓您取得組態資訊，然後設定或清除要求的錯誤。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Web.UI.ControlCollection" /> 物件，表示 UI 階層架構中指定之伺服器控制項的子控制項。</summary>
        <value>指定之伺服器控制項的子控制項集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 ASP.NET 頁面上，控制項的開頭和結尾標記的伺服器控制項之間以宣告方式新增時 ASP.NET 會自動將控制項新增至包含的伺服器控制項<xref:System.Web.UI.ControlCollection>。 任何 HTML 標記或不會在伺服器處理的文字字串會被視為<xref:System.Web.UI.LiteralControl>物件。 會加入至集合，例如其他伺服器控制項。  
  
 <xref:System.Web.UI.Control.Controls%2A>屬性可讓您以程式設計方式存取的執行個體<xref:System.Web.UI.ControlCollection>任何伺服器控制項的類別。 您可以將控制項加入至集合，從集合移除的控制項或逐一查看集合中的伺服器控制項。  
  
   
  
## Examples  
 下列範例示範如何將子控制項加入至伺服器控制項的<xref:System.Web.UI.ControlCollection>物件透過其<xref:System.Web.UI.Control.Controls%2A>屬性。  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>當覆寫<see cref="P:System.Web.UI.Control.Controls" />屬性，請務必呼叫<see cref="M:System.Web.UI.Control.EnsureChildControls" />方法。 此外，如果您打算以程式設計方式將控制項加入至控制項集合，請考慮新增控制項中覆寫<see cref="M:System.Web.UI.Control.CreateChildControls" />方法。</para>
        </block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="control.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>由 ASP.NET 網頁架構呼叫，通知使用組合實作的伺服器控制項來建立所包含的任何子控制項，以準備回傳或呈現。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您開發複合或樣板化的伺服器控制項時，您必須覆寫這個方法。 控制覆寫<xref:System.Web.UI.Control.CreateChildControls%2A>方法應該實作<xref:System.Web.UI.INamingContainer>介面，以避免命名衝突。  
  
 如需詳細資訊，請參閱 < [Web 伺服器控制項樣板](https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae)並[開發自訂 ASP.NET 伺服器控制項](https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef)。  
  
   
  
## Examples  
 下列範例示範如何覆寫的版本的<xref:System.Web.UI.Control.CreateChildControls%2A>方法。 在此實作中，複合控制項顯示<xref:System.Web.UI.WebControls.TextBox>住呈現 HTML 的兩個常值控制項的控制項。  
  
> [!IMPORTANT]
>  這個範例有一個可接受使用者輸入的文字方塊，這可能會造成安全性威脅。 根據預設，ASP.NET Web 網頁會驗證使用者輸入未包含指令碼或 HTML 項目。 如需詳細資訊，請參閱 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07) (指令碼攻擊概觀)。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">開發自訂 ASP.NET 伺服器控制項</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae">ASP.NET Web 伺服器控制項範本</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection&#xA;override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="control.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立新的 <see cref="T:System.Web.UI.ControlCollection" /> 物件來保存伺服器控制項的子控制項 (常值和伺服器)。</summary>
        <returns>
          <see cref="T:System.Web.UI.ControlCollection" /> 物件，包含目前伺服器控制項的子伺服器控制項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫這個方法的自訂伺服器控制項中，如果您已建立一個集合物件，衍生自<xref:System.Web.UI.ControlCollection>類別。 然後，您可以初始化該集合中的類別覆寫這個方法。  
  
   
  
## Examples  
 下列程式碼會覆寫<xref:System.Web.UI.Control.CreateControlCollection%2A>方法用來建立的執行個體`CustomControlCollection`類別，繼承自<xref:System.Web.UI.ControlCollection>類別。  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 下列程式碼範例會使用<xref:System.Web.UI.Control.CreateControlCollection%2A>中的自訂伺服器控制項的方法覆寫的<xref:System.Web.UI.Control.CreateChildControls%2A>方法。 新的集合時建立，並以兩個子控制項，然後填入`firstControl`和`secondControl`。  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將資料來源繫結至所叫用的伺服器控制項及其所有子控制項。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DataBind ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DataBind();" />
      <MemberSignature Language="F#" Value="abstract member DataBind : unit -&gt; unit&#xA;override this.DataBind : unit -&gt; unit" Usage="control.DataBind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將資料來源繫結至所叫用的伺服器控制項及其所有子控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要將資料從來源繫結至伺服器控制項使用這個方法。 擷取透過資料庫查詢的資料集之後，通常使用這個方法。 大部分的控制項執行資料繫結會自動，這表示，您通常不需要明確地呼叫這個方法。  
  
 當您建立自訂的樣板化資料繫結控制項時，通常會覆寫此方法。 如需詳細資訊，請參閱 <<c0> [ 如何： 建立樣板化的 ASP.NET 使用者控制項](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2)並[開發自訂資料繫結的 Web 伺服器控制項](https://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1)。 伺服器控制項上呼叫時，這個方法會解析所有的資料繫結運算式中的伺服器控制項和任何子控制項。  
  
   
  
## Examples  
 下列範例會覆寫<xref:System.Web.UI.Control.DataBind%2A>自訂 ASP.NET 伺服器控制項中的方法。 一開始先呼叫基底<xref:System.Web.UI.Control.OnDataBinding%2A>方法，然後使用<xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType>方法來刪除所有子控制項和<xref:System.Web.UI.Control.ClearChildViewState%2A>方法來都刪除任何儲存的檢視狀態設定為這些子控制項。 最後，<xref:System.Web.UI.Control.ChildControlsCreated%2A>屬性設定為`true`且控制會指示您將追蹤新建立之控制項的檢視狀態的任何變更<xref:System.Web.UI.Control.TrackViewState%2A>方法。 這是常用的技巧，將資料繫結至控制項，以確保該新的資料從先前儲存的資料不會衝突時<xref:System.Web.UI.Control.DataBind%2A>方法呼叫。  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">開發自訂 ASP.NET 伺服器控制項</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期概觀</related>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBind (raiseOnDataBinding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBind(bool raiseOnDataBinding);" />
      <MemberSignature Language="F#" Value="abstract member DataBind : bool -&gt; unit&#xA;override this.DataBind : bool -&gt; unit" Usage="control.DataBind raiseOnDataBinding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding">如果已引發 <see cref="E:System.Web.UI.Control.DataBinding" /> 事件，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>使用會引發 <see cref="E:System.Web.UI.Control.DataBinding" /> 事件的選項，繫結資料來源至叫用的伺服器控制項及其所有子控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>方法的情況下，當您的自訂控制項就會覆寫<xref:System.Web.UI.Control.DataBind%2A>方法，並實作<xref:System.Web.UI.IDataItemContainer>介面。 在此案例中，呼叫自訂控制項<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>方法`raiseOnDataBinding`設為`false`以確保基底類別的<xref:System.Web.UI.Control.DataBind%2A>呼叫方法。  
  
 <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>方法會叫用<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>方法`raiseOnDataBinding`設定為`true`。  
  
> [!NOTE]
>  呼叫<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>方法`raiseOnDataBinding`設為`false`造成任何子控制項，以進行資料繫結與<xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期概觀</related>
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBindChildren ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBindChildren();" />
      <MemberSignature Language="F#" Value="abstract member DataBindChildren : unit -&gt; unit&#xA;override this.DataBindChildren : unit -&gt; unit" Usage="control.DataBindChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>繫結資料來源至伺服器控制項的子控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.Control.DataBindChildren%2A>方法繫結至伺服器控制項的子控制項的資料來源。  
  
> [!NOTE]
>  伺服器控制項上呼叫時，這個方法不會不將資料繫結至控制項。 若要繫結的伺服器控制項及其所有子控制項，呼叫<xref:System.Web.UI.Control.DataBind%2A>方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">開發自訂 ASP.NET 伺服器控制項</related>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataBinding As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataBinding;" />
      <MemberSignature Language="F#" Value="member this.DataBinding : EventHandler " Usage="member this.DataBinding : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於伺服器控制項繫結至資料來源時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件會通知伺服器控制項來執行已撰寫它的任何資料繫結邏輯。  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataItemContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataItemContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataItemContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果命名容器實作 <see cref="T:System.Web.UI.IDataItemContainer" />，則取得命名容器的參考。</summary>
        <value>命名容器。 在實作 <see cref="T:System.Web.UI.IDataItemContainer" /> 的命名容器階層架構中，這個屬性會傳回階層架構中最上層的命名容器，如果目前的 <see cref="T:System.Web.UI.Control" /> 物件不在實作 <see cref="T:System.Web.UI.IDataItemContainer" /> 的命名容器中，則傳回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataKeysContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataKeysContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataKeysContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果命名容器實作 <see cref="T:System.Web.UI.IDataKeysControl" />，則取得命名容器的參考。</summary>
        <value>命名容器。 在實作 <see cref="T:System.Web.UI.IDataKeysControl" /> 的命名容器階層架構中，這個屬性會傳回階層架構中最上層的命名容器，如果目前的 <see cref="T:System.Web.UI.Control" /> 物件不在實作 <see cref="T:System.Web.UI.IDataKeysControl" /> 的命名容器中，則會傳回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected internal bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DesignMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool DesignMode { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DesignMode : bool" Usage="System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出控制項是否正用於設計介面上。</summary>
        <value>如果控制項正用於設計工具，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.DesignMode%2A>屬性會傳回`true`表示控制項用於設計工具的內容。 您的自訂控制項在設計階段行為不同於執行階段行為時，可以使用這個屬性。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/1d5a99d7-0a72-403e-812e-2c1ab595c810">ASP.NET 控制項設計工具概觀</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="control.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟用伺服器控制項，在它從記憶體釋放之前執行最後清除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Dispose%2A> 使用完畢時，請呼叫 <xref:System.Web.UI.Control>。 <xref:System.Web.UI.Control.Dispose%2A> 方法會將 <xref:System.Web.UI.Control> 保留在無法使用的狀態。 之後呼叫這個方法，您必須釋放控制項的所有參考，讓它所佔用的記憶體可以回收記憶體回收。  
  
   
  
## Examples  
 下列程式碼會覆寫<xref:System.Web.UI.Control.Dispose%2A>方法以關閉<xref:System.Web.UI.HtmlTextWriter>控制項，並呼叫相關聯的物件<xref:System.Web.UI.Control.Dispose%2A>方法<xref:System.Web.UI.WebControls.Button>控制項，名為`myButton`。 如果<xref:System.Exception>時擲回這個版本的<xref:System.Web.UI.Control.Dispose%2A>呼叫方法時，控制項將訊息寫入至目前<xref:System.Web.HttpResponse>物件。  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於伺服器控制項從記憶體釋放時，這是在要求 ASP.NET 網頁時，伺服器控制項生命週期的最後階段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 需要大量處理器時間，例如資料庫連線的資源的釋放與這個事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出佈景主題是否套用至此控制項。</summary>
        <value>
          <see langword="true" /> 表示使用主題，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.EnableTheming%2A>屬性會指出是否啟用佈景主題，以供指定的控制項。 當<xref:System.Web.UI.Control.EnableTheming%2A>屬性是`true`，應用程式的佈景主題目錄中搜尋要套用控制面板。 如果任何特定的控制項外觀的佈景主題目錄中，將不會套用面板。  
  
 時<xref:System.Web.UI.Control.EnableTheming%2A>屬性是`false`，則不會搜尋佈景主題目錄及內容<xref:System.Web.UI.Control.SkinID%2A>不使用屬性。  
  
 在頁面、 容器或控制層級，就可以啟用佈景主題。 控制項可以覆寫<xref:System.Web.UI.Control.EnableTheming%2A>值由其父控制項，或包含頁面的設定。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="Page_PreInit" /> 事件已發生。  
  
\-或- 
控制項已加入至 <see langword="Controls" /> 集合。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">ASP.NET 佈景主題概觀</related>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，該值表示伺服器控制項是否對要求的用戶端而言保持其檢視狀態，以及它包含的任何子控制項狀態。</summary>
        <value>如果伺服器控制項保持其檢視狀態，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 檢視狀態可以讓伺服器控制項的 HTTP 要求之間維護其狀態。 如果符合所有下列條件，則會啟用控制項的檢視狀態：  
  
-   <xref:System.Web.UI.Control.EnableViewState%2A>頁面的屬性設定為`true`。  
  
-   <xref:System.Web.UI.Control.EnableViewState%2A>控制項的屬性設定為`true`。  
  
-   <xref:System.Web.UI.Control.ViewStateMode%2A>控制項的屬性設定為<xref:System.Web.UI.ViewStateMode.Enabled>，或繼承<xref:System.Web.UI.ViewStateMode.Enabled>設定。  
  
 如需詳細資訊，請參閱 <xref:System.Web.UI.Control.ViewStateMode%2A> 屬性 (Property)。  
  
 伺服器控制項的檢視狀態是累積的所有屬性值。 為了保留這些值的 HTTP 要求之間，ASP.NET 會使用的執行個體<xref:System.Web.UI.StateBag>類別來儲存屬性值。 值會接著為變數時傳遞至隱藏的欄位會處理後續要求。 如需有關檢視狀態的詳細資訊，請參閱 < [ASP.NET 檢視狀態概觀](https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818)。  
  
 有些的時候適當停用檢視狀態，特別是要改善應用程式的效能。 例如，如果您正在載入資料庫要求至伺服器控制項，再將此屬性設定為`false`。 如果您不這樣做，就會載入只會覆寫資料庫查詢的伺服器控制項的檢視狀態會浪費處理器時間。 如果<xref:System.Web.UI.Control.EnableViewState%2A>是`false`，您可以使用的控制項狀態，以保存特定控制項，而且無法關閉如同檢視狀態屬性的屬性資訊。 如需有關控制狀態與檢視狀態之間的差異的詳細資訊，請參閱[vs 控制項狀態。檢視狀態範例](https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681)。  
  
 如需如何啟用或停用宣告為 ASP.NET 網頁的檢視狀態資訊，請參閱[\@頁](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100))。
  
   
  
## Examples  
 下列範例會設定<xref:System.Web.UI.Control.EnableViewState%2A>屬性設`false`。  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 狀態管理概觀</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681">控制項狀態與檢視狀態範例</related>
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.EndRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.EndRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">寫入追蹤資料的物件。</param>
        <param name="traceObject">追蹤物件。</param>
        <summary>結束轉譯資料的設計階段追蹤。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub EnsureChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void EnsureChildControls();" />
      <MemberSignature Language="F#" Value="abstract member EnsureChildControls : unit -&gt; unit&#xA;override this.EnsureChildControls : unit -&gt; unit" Usage="control.EnsureChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>判斷伺服器控制項是否包含子控制項。 如果不包含，則建立子控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會先檢查目前的值<xref:System.Web.UI.Control.ChildControlsCreated%2A>屬性。 如果這個值是`false`，則<xref:System.Web.UI.Control.CreateChildControls%2A>呼叫方法。  
  
 <xref:System.Web.UI.Control.EnsureChildControls%2A>方法通常會在複合控制項，也就是使用部分的子控制項的控制項或所有其功能。 <xref:System.Web.UI.Control.EnsureChildControls%2A>會呼叫方法，若要確定已建立的子控制項，並已準備好處理輸入，來執行資料繫結，或執行其他工作。  
  
 <xref:System.Web.UI.WebControls.GridView>控制項是複合控制項的範例。 它會建立子控制項這類<xref:System.Web.UI.WebControls.Table>， <xref:System.Web.UI.WebControls.TableRow>， <xref:System.Web.UI.WebControls.TableCell>， <xref:System.Web.UI.WebControls.Label>，並<xref:System.Web.UI.WebControls.TextBox>控制項，用來呈現 HTML 資料表，其中<xref:System.Web.UI.WebControls.GridView>產生。  
  
 在大部分情況下，自訂伺服器控制項開發人員就不必覆寫這個方法。 如果您覆寫這個方法，則會使用預設的行為類似的方式。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.UI.Control.EnsureChildControls%2A>確保目前的伺服器控制項的子控制項的方法。 然後取得或設定<xref:System.Web.UI.WebControls.TextBox.Text%2A>屬性的子<xref:System.Web.UI.WebControls.TextBox>Web 控制項中目前伺服器控制項的<xref:System.Web.UI.ControlCollection>物件。  
  
> [!IMPORTANT]
>  這個範例有一個可接受使用者輸入的文字方塊，這可能會造成安全性威脅。 根據預設，ASP.NET Web 網頁會驗證使用者輸入未包含指令碼或 HTML 項目。 如需詳細資訊，請參閱 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07) (指令碼攻擊概觀)。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureID();" />
      <MemberSignature Language="F#" Value="member this.EnsureID : unit -&gt; unit" Usage="control.EnsureID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為尚未指定識別項的控制項，建立識別項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.EnsureID%2A>方法會產生另一個控制項中的控制項所包含的識別項。 識別項僅針對沒有被指派一個值的控制項產生<xref:System.Web.UI.Control.ID%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Events As EventHandlerList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::EventHandlerList ^ Events { System::ComponentModel::EventHandlerList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Events : System.ComponentModel.EventHandlerList" Usage="System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得控制項事件處理常式委派 (Delegate) 的清單。 這個屬性是唯讀的。</summary>
        <value>事件處理常式委派的清單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性的類型是<xref:System.ComponentModel.EventHandlerList>，這會使用線性搜尋演算法來尋找委派的清單中的項目。 使用大量的項目時，效率不佳的線性搜尋演算法。 因此，當您有大型的清單，尋找與這個屬性的項目可能會變慢。  
  
   
  
## Examples  
 下列範例會建立事件，名為`Click`，它加入，並從控制項移除處理常式<xref:System.ComponentModel.EventHandlerList>事件從網頁呼叫的集合。  
  
 **請注意**如何控制項中新增和移除事件的清單，這些控制項會維護，此範例中會最佳化。 如果您建立自訂控制項，並想要定義的事件，使用程式碼如下所示。 在 C# 中，但不是在 Visual Basic 中，可以使用這項技術。  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在目前的命名容器搜尋指定的伺服器控制項。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string -&gt; System.Web.UI.Control&#xA;override this.FindControl : string -&gt; System.Web.UI.Control" Usage="control.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">所要尋找的控制項識別項。</param>
        <summary>在目前命名容器搜尋具有指定 <paramref name="id" /> 參數的伺服器控制項。</summary>
        <returns>指定的控制項，如果指定的控制項不存在，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.Control.FindControl%2A>從函式在程式碼後置頁面中，若要存取位於另一個容器，控制，或在其他情況下，其中的目標控制項不是直接存取呼叫端存取控制項。 這個方法會找出控制項的控制會直接包含指定的容器; 時，才也就是該方法不會搜尋整個控制項內控制項的階層。 如需如何尋找控制項，當您不知道其立即的容器資訊，請參閱[如何： 存取伺服器控制項的 ID](https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3)。  
  
   
  
## Examples  
 下列範例會定義`Button1_Click`事件處理常式。 叫用時，會使用這個處理常式<xref:System.Web.UI.Control.FindControl%2A>方法，以找出與控制項<xref:System.Web.UI.Control.ID%2A>屬性`TextBox2`包含頁面上。 如果找不到控制項，其父代用來決定<xref:System.Web.UI.Control.Parent%2A>屬性和父控制項的<xref:System.Web.UI.Control.ID%2A>寫入網頁。 如果`TextBox2`找不到，「 找不到控制項"寫入頁面。  
  
> [!IMPORTANT]
>  這個範例有一個可接受使用者輸入的文字方塊，這可能會造成安全性威脅。 根據預設，ASP.NET Web 網頁會驗證使用者輸入未包含指令碼或 HTML 項目。 如需詳細資訊，請參閱 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07) (指令碼攻擊概觀)。  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3">如何： 存取伺服器控制項的 ID</related>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindControl (id As String, pathOffset As Integer) As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id, int pathOffset);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string * int -&gt; System.Web.UI.Control&#xA;override this.FindControl : string * int -&gt; System.Web.UI.Control" Usage="control.FindControl (id, pathOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">所要尋找的控制項識別項。</param>
        <param name="pathOffset">在頁面控制項階層架構中，向上到達命名容器所需的控制項數目。</param>
        <summary>使用指定的 <paramref name="id" /> 和有助於搜尋之 <paramref name="pathOffset" /> 參數中所指定的整數，在目前的命名容器中搜尋伺服器控制項。 您不應該覆寫這個版本的 <see cref="Overload:System.Web.UI.Control.FindControl" /> 方法。</summary>
        <returns>指定的控制項，如果指定的控制項不存在，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; unit&#xA;override this.Focus : unit -&gt; unit" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>設定控制項的輸入焦點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.Control.Focus%2A>方法來設定初始焦點網頁的控制項。 選取的控制項，將瀏覽器中開啟頁面。  
  
 <xref:System.Web.UI.Control.Focus%2A>方法會導致頁面焦點指令碼的呼叫，就會發出在轉譯頁面。 如果頁面不包含控制項之 HTML`ID`符合控制項的屬性，<xref:System.Web.UI.Control.Focus%2A>已叫用方法，則不會設定頁面的焦點。 舉例來說，這種情況時，您將焦點設定在使用者控制項，而不是將焦點設定在使用者控制項的子控制項上。 在此案例中，您可以使用<xref:System.Web.UI.Control.FindControl%2A>方法來尋找使用者控制項的子控制項，並叫用其<xref:System.Web.UI.Control.Focus%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDesignModeState () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IDictionary ^ GetDesignModeState();" />
      <MemberSignature Language="F#" Value="abstract member GetDesignModeState : unit -&gt; System.Collections.IDictionary&#xA;override this.GetDesignModeState : unit -&gt; System.Collections.IDictionary" Usage="control.GetDesignModeState " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得控制項的設計階段資料。</summary>
        <returns>
          <see cref="T:System.Collections.IDictionary" />，包含控制項的設計階段資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.GetDesignModeState%2A>方法會傳回控制項的設計階段資料。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Web.UI.Control.GetDesignModeState" />方法會傳回<see langword="null" />預設。 您必須覆寫此方法以提供您的控制項需要設計階段資料。</para>
        </block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得 URL，此 URL 對應於一組路由參數，而且會選擇性地對應到路由名稱。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : obj -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeParameters">路由參數。</param>
        <summary>取得會對應於一組路由參數的 URL。</summary>
        <returns>對應於指定之路由參數的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>方法。 這個方法會轉換傳入的物件`routeParameters`要<xref:System.Web.Routing.RouteValueDictionary>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。  
  
   
  
## Examples  
 下列範例示範如何呼叫<xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType>方法來取得具有參數名為路由的 URL`productid`和`category`。 這個範例假設您已建立<xref:System.Web.UI.WebControls.HyperLink>控制項，名為`HyperLink1`。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeParameters">路由參數。</param>
        <summary>取得會對應於一組路由參數的 URL。</summary>
        <returns>對應於指定之路由參數的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法來取得具有參數名為路由的 URL`productid`和`category`。 這個範例假設您已建立<xref:System.Web.UI.WebControls.HyperLink>控制項，名為`HyperLink1`。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * obj -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeParameters">路由參數。</param>
        <summary>取得 URL，此 URL 對應於一組路由參數及一個路由名稱。</summary>
        <returns>對應於指定之路由參數及路由名稱的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>方法。 這個方法會轉換傳入的物件`routeParameters`要<xref:System.Web.Routing.RouteValueDictionary>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法來取得名為路由的 URL`Product`且具有名為的參數`productid`和`category`。 這個範例假設您已建立<xref:System.Web.UI.WebControls.HyperLink>控制項，名為`HyperLink1`。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeParameters">路由參數。</param>
        <summary>取得 URL，此 URL 對應於一組路由參數及一個路由名稱。</summary>
        <returns>對應於指定之路由參數及路由名稱的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法來取得名為路由的 URL`Product`且具有名為的參數`productid`和`category`。 這個範例假設您已建立<xref:System.Web.UI.WebControls.HyperLink>控制項，名為`HyperLink1`。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetUniqueIDRelativeTo(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetUniqueIDRelativeTo : System.Web.UI.Control -&gt; string" Usage="control.GetUniqueIDRelativeTo control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">位在命名容器內的控制項。</param>
        <summary>傳回指定之控制項 <see cref="P:System.Web.UI.Control.UniqueID" /> 屬性的前置部分。</summary>
        <returns>指定之控制項 <see cref="P:System.Web.UI.Control.UniqueID" /> 屬性的前置部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.UniqueID%2A>控制項的屬性由前置詞加入至控制項的產生<xref:System.Web.UI.Control.ID%2A>屬性。 前置詞組成<xref:System.Web.UI.Control.UniqueID%2A>控制項屬性的命名容器是分隔符號字元與串連。 如果頁面命名容器，沒有前置詞。 這個方法會傳回前置詞字串。 如果沒有前置詞字串，它會傳回<xref:System.Web.UI.Control.UniqueID%2A>控制項的值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" /> 的 <see cref="P:System.Web.UI.Control.NamingContainer" /> 屬性為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HasChildViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool HasChildViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildViewState : bool" Usage="System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前伺服器控制項的子控制項是否有任何已儲存的檢視狀態設定。</summary>
        <value>如果任何子控制項有儲存的檢視狀態資訊，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以避免不必要的呼叫<xref:System.Web.UI.Control.ClearChildViewState%2A>方法藉由使用這個屬性來驗證伺服器控制項的任何子控制項所儲存的檢視狀態資訊。  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasControls () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasControls();" />
      <MemberSignature Language="F#" Value="abstract member HasControls : unit -&gt; bool&#xA;override this.HasControls : unit -&gt; bool" Usage="control.HasControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>判斷伺服器控制項是否包含任何子控制項。</summary>
        <returns>如果控制項包含其他控制項，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為這個方法只會判斷是否存在任何子控制項，它還可以提升效能，可讓您避免不必要<xref:System.Web.UI.ControlCollection.Count%2A>屬性呼叫。 呼叫這個屬性需要<xref:System.Web.UI.ControlCollection>来具現化的物件。 如果沒有任何子系，建立這個物件會浪費伺服器資源。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.UI.Control.HasControls%2A>方法，以判斷使用之前是否存在的任何控制項<xref:System.Web.UI.ControlCollection.Count%2A>屬性來逐一查看<xref:System.Web.UI.ControlCollection>物件。  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Web.UI.Control.HasControls" />應該覆寫方法，僅適用於這類變更的中繼資料屬性<see cref="T:System.ComponentModel.EditorBrowsableAttribute" />。 如需使用屬性的詳細資訊，請參閱[屬性](~/docs/standard/attributes/index.md)。</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasEvents () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasEvents();" />
      <MemberSignature Language="F#" Value="member this.HasEvents : unit -&gt; bool" Usage="control.HasEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，指出控制項或任何子控制項的事件是否已註冊。</summary>
        <returns>如果事件已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定指派給伺服器控制項的程式設計識別項。</summary>
        <value>指派給控制項的程式設計識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 伺服器控制項上設定這個屬性可以提供以程式設計方式存取伺服器控制項的屬性、 事件和方法。 設定這個屬性可以是 Web 開發人員藉由宣告<xref:System.Web.UI.Control.ID%2A>ASP.NET 伺服器控制項的開頭標記中的屬性。  
  
 如果這個屬性未指定伺服器控制項，以宣告方式或以程式設計方式，您可以取得透過其父控制項的控制項的參考<xref:System.Web.UI.Control.Controls%2A>屬性。  
  
> [!NOTE]
>  唯一的英數字元和底線字元 (_) 的組合是有效的值，這個屬性。 包含空格或其他無效的字元會造成 ASP.NET 頁面剖析器錯誤。  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來分隔控制項識別項的字元。</summary>
        <value>分隔字元。 預設值為 "$"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中所包含的字元<xref:System.Web.UI.Control.IdSeparator%2A>屬性用來分隔控制識別項，子控制項。 ID 分隔符號字元會附加至<xref:System.Web.UI.Control.ID%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Init As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Init;" />
      <MemberSignature Language="F#" Value="member this.Init : EventHandler " Usage="member this.Init : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於初始化伺服器控制項時，是其生命週期中的第一個步驟。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 伺服器控制項應該執行任何初始設定步驟，建立並設定執行個體所需。 您無法使用此事件; 內的檢視狀態資訊它不是尚未填入。 您不應該存取另一個伺服器控制項，在此情況下，無論它是子網域或此控制項的父代。 其他伺服器控制項不一定是已建立並準備好進行存取。 如需有關伺服器控制項事件的詳細資訊，請參閱[ASP.NET Web Form 伺服器控制項事件模型](https://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)。  
  
   
  
## Examples  
 下列範例會將指派的自訂事件處理常式`Calendar_Init`，以`Init`事件的<xref:System.Web.UI.WebControls.Calendar>控制項。  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected internal bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsChildControlStateCleared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsChildControlStateCleared { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsChildControlStateCleared : bool" Usage="System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個控制項中所包含的控制項是否有控制項狀態。</summary>
        <value>如果這個控制項的子系不使用控制項狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsLiteralContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsLiteralContent();" />
      <MemberSignature Language="F#" Value="member this.IsLiteralContent : unit -&gt; bool" Usage="control.IsLiteralContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>判斷伺服器控制項是否只儲存常值內容。</summary>
        <returns>如果伺服器控制項只含有常值內容，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法傳回`true`，伺服器控制項的集合會保存單一常值控制項。  
  
   
  
## Examples  
 下列範例會檢查是否有回傳，包含伺服器控制項的頁面。 如果是，它會呼叫<xref:System.Web.UI.Control.IsLiteralContent%2A>方法，以判斷控制項是否包含只是常值的內容，或是為其他伺服器控制項的父控制項。 如果它包含只常值內容<xref:System.Web.UI.Control.UniqueID%2A>屬性<xref:System.Web.UI.LiteralControl>表示內容寫入至回應。  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsTrackingViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsTrackingViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTrackingViewState : bool" Usage="System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出伺服器控制項是否正在儲存檢視狀態的變更。</summary>
        <value>如果標記控制項以儲存其狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 會使用這個屬性的範例自訂伺服器控制項，請參閱[樣板化的伺服器控制項範例](https://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## Examples  
 下列範例會覆寫<xref:System.Web.UI.Control.DataBind%2A>自訂 ASP.NET 伺服器控制項中的方法。 一開始先呼叫基底<xref:System.Web.UI.Control.OnDataBinding%2A>方法，然後再使用`ControlCollection`物件。 <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> 若要刪除所有子控制項的方法和<xref:System.Web.UI.Control.ClearChildViewState%2A>方法來都刪除任何儲存的檢視狀態設定為這些子控制項。 最後，<xref:System.Web.UI.Control.ChildControlsCreated%2A>屬性設定為`true`。 控制項接著會使用<xref:System.Web.UI.Control.IsTrackingViewState%2A>屬性來判斷是否啟用控制項的檢視狀態變更追蹤。 如果未啟用，<xref:System.Web.UI.Control.TrackViewState%2A>呼叫方法。  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected internal bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsViewStateEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsViewStateEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsViewStateEnabled : bool" Usage="System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個控制項是否已啟用檢視狀態。</summary>
        <value>如果控制項已啟用檢視狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在頁面、 容器或控制層級，就可以啟用檢視狀態。 在頁面或容器層級停用檢視狀態時，網頁或容器所包含的所有控制項的檢視狀態已停都用。 <xref:System.Web.UI.Control.IsViewStateEnabled%2A>屬性會指出是否啟用檢視狀態是由頁面中，容器或控制項。  
  
 可能<xref:System.Web.UI.Control.EnableViewState%2A>屬性和<xref:System.Web.UI.Control.IsViewStateEnabled%2A>不同的屬性。 例如，如果<xref:System.Web.UI.Page>包含控制項的停用的檢視狀態<xref:System.Web.UI.Control.EnableViewState%2A>屬性可以是`true`雖然<xref:System.Web.UI.Control.IsViewStateEnabled%2A>屬性是`false`。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>網頁程式開發人員將會設定<see cref="P:System.Web.UI.Control.EnableViewState" />屬性和<see cref="P:System.Web.UI.Control.ViewStateMode" />屬性，指出是否在使用檢視狀態與您的控制項。 使用<see cref="P:System.Web.UI.Control.IsViewStateEnabled" />屬性和<see cref="P:System.Web.UI.Control.ViewStateMode" />在您的程式碼，以判斷是否已啟用檢視狀態，為您的控制項和所有容器中的屬性。</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : EventHandler " Usage="member this.Load : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於載入伺服器控制項至 <see cref="T:System.Web.UI.Page" /> 物件時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 告知伺服器控制項執行設定為在每個頁面要求上進行任何處理步驟。 您可以從這個事件來存取檢視狀態資訊和 Web 表單張貼資料。 您也可以存取網頁的控制項階層架構內的其他伺服器控制項。  
  
> [!NOTE]
>  如果您在控制項中設定自訂範本`Page_Load`事件，自訂的範本中的子控制項的文字值將會遺失。 這是因為已經載入的表單值。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadControlState : obj -&gt; unit&#xA;override this.LoadControlState : obj -&gt; unit" Usage="control.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">
          <see cref="T:System.Object" />，代表所要還原的控制項狀態。</param>
        <summary>從 <see cref="M:System.Web.UI.Control.SaveControlState" /> 方法所儲存的上一頁要求中，還原控制項狀態資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您需要指定自訂伺服器控制項如何還原其控制項狀態時，請覆寫這個方法。 如需詳細資訊，請參閱 < [ASP.NET 狀態管理概觀](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))。  
  
   
  
## Examples  
 下列程式碼會覆寫<xref:System.Web.UI.Control.LoadControlState%2A>自訂 ASP.NET 控制項中的方法。 叫用這個方法時，它會判斷控制項狀態先前儲存的控制項，如果是的話，設定內部屬性`currentIndex`已儲存的值。  
  
 <xref:System.Web.UI.Control.OnInit%2A>方法會覆寫來呼叫<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>方法<xref:System.Web.UI.Control.Page%2A>來表示自訂控制項使用控制項狀態。  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadViewState : obj -&gt; unit&#xA;override this.LoadViewState : obj -&gt; unit" Usage="control.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">
          <see cref="T:System.Object" />，代表所要還原的控制項狀態。</param>
        <summary>從 <see cref="M:System.Web.UI.Control.SaveViewState" /> 方法所儲存的先前頁面要求來還原檢視狀態資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法主要供.NET Framework 基礎結構，並不是直接從您的程式碼使用。 不過，控制項開發人員可以覆寫這個方法，以指定的自訂伺服器控制項如何還原其檢視狀態。 如需詳細資訊，請參閱 < [ASP.NET 狀態管理概觀](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))。  
  
   
  
## Examples  
 下列範例會覆寫<xref:System.Web.UI.Control.LoadViewState%2A>自訂 ASP.NET 伺服器控制項的方法。 它會建立<xref:System.Object>陣列，包含傳遞中的檢視狀態資訊`savedState`參數，然後再呼叫基底實作<xref:System.Web.UI.Control.LoadViewState%2A>陣列的第一個索引位置的方法。 它會指派給名為的變數，接下來的兩個索引位置所儲存的值`UserText`和`PasswordText`分別。  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property LoadViewStateByID As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool LoadViewStateByID { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadViewStateByID : bool" Usage="System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出控制項是否依 <see cref="P:System.Web.UI.Control.ID" /> (而不是索引) 參與載入其檢視狀態。</summary>
        <value>如果控制項依 <see cref="P:System.Web.UI.Control.ID" /> 載入其檢視狀態，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，當父控制項檢視狀態載入它所建立的子控制項其做法是在父控制項的每個子控制項的位置<xref:System.Web.UI.Control.Controls%2A>集合。 一開始套用檢視狀態時，所有的子控制項可能尚未建立。 在此情況下，尚未建立的控制項檢視狀態儲存，並套用更新版本建立的子控制項時。  
  
 若要將檢視狀態套用至其子控制項的父控制項，必須符合兩個條件：  
  
-   在回傳時，父控制項必須建立子控制項中前一個要求完全相同的順序，讓控制項的順序會保持一致。  
  
-   在回傳後, 建立的任何子控制項必須加入至父控制項的結尾<xref:System.Web.UI.Control.Controls%2A>集合。  
  
 父控制項，如果無法符合這兩項條件，如果是延遲的建立子控制項，可以使用來載入檢視狀態<xref:System.Web.UI.Control.ID%2A>。 若要設定<xref:System.Web.UI.Control.LoadViewStateByID%2A>屬性，以`true`，使用<xref:System.Web.UI.ViewStateModeByIdAttribute>父控制項的中繼資料屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected internal string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function MapPathSecure (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPathSecure : string -&gt; string" Usage="control.MapPathSecure virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">相對的或根相對路徑的 URL。</param>
        <summary>擷取虛擬絕對路徑或相對路徑所對應至的實體路徑。</summary>
        <returns>所要求檔案的實體路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只用於具有讀取檔案的權限、 哪些是完全受信任的.dll 檔案，例如 System.Web.dll 一部分的伺服器控制項。 這有助於防止安全性產生漏洞。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.UI.Control.MapPathSecure%2A>方法，以取得包含虛擬目錄的實體路徑<xref:System.Web.UI.Page>或<xref:System.Web.UI.UserControl>物件。  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="virtualPath" /> 為 <see langword="null" /> 或空字串 ("")。</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ NamingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得伺服器控制項命名容器的參考，其建立唯一命名空間，在具有相同 <see cref="P:System.Web.UI.Control.ID" /> 屬性值的伺服器控制項之間作區別。</summary>
        <value>伺服器控制項的命名容器。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web 應用程式中的每個頁面包含控制項階層的架構。 此階層不相依於控制項是否會產生對使用者顯示的 UI。 指定控制項的命名容器是上面的父控制項實作的階層中<xref:System.Web.UI.INamingContainer>介面。 伺服器控制項來實作此介面會建立唯一命名空間<xref:System.Web.UI.Control.ID%2A>其子伺服器控制項的屬性值。 您可以使用<xref:System.Web.UI.Control.NamingContainer%2A>命名容器的子控制項，以取得其父容器的參考屬性。  
  
 當您繫結的 Web 伺服器控制項的資料，例如建立伺服器控制項的唯一命名空間是特別重要<xref:System.Web.UI.WebControls.Repeater>和<xref:System.Web.UI.WebControls.DataList>伺服器控制項。 當資料來源中的多個項目建立多個重複的控制項的子系的伺服器控制項執行個體時，可確保命名的容器，這些子控制項的每個執行個體有<xref:System.Web.UI.Control.UniqueID%2A>不衝突的屬性值。 頁面的預設命名容器是的執行個體<xref:System.Web.UI.Page>要求該頁面時，會產生的類別。  
  
 <xref:System.Web.UI.Control.ClientID%2A>屬性包含會轉譯為元素的值`id`的 HTML 標記中的屬性。 您將指派給的值而定<xref:System.Web.UI.Control.ClientIDMode%2A>屬性，產生的值<xref:System.Web.UI.Control.ClientID%2A>屬性可能包含的識別碼<xref:System.Web.UI.Control.NamingContainer%2A>物件。 當您設定<xref:System.Web.UI.Control.ClientIDMode%2A>要<xref:System.Web.UI.ClientIDMode.Static>，則<xref:System.Web.UI.Control.ClientID%2A>值不包含識別碼<xref:System.Web.UI.Control.NamingContainer%2A>物件。 當您設定<xref:System.Web.UI.Control.ClientIDMode%2A>設為<xref:System.Web.UI.ClientIDMode.AutoID>或<xref:System.Web.UI.ClientIDMode.Predictable>，則<xref:System.Web.UI.Control.ClientID%2A>值會包含來自識別碼<xref:System.Web.UI.Control.NamingContainer%2A>物件。 如需詳細資訊，請參閱 [ASP.NET 網頁伺服器控制項識別](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Web.UI.Control.NamingContainer%2A>屬性。  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBubbleEvent (source As Object, args As EventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnBubbleEvent : obj * EventArgs -&gt; bool&#xA;override this.OnBubbleEvent : obj * EventArgs -&gt; bool" Usage="control.OnBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件的來源。</param>
        <param name="args">包含事件資料的 <see cref="T:System.EventArgs" /> 物件。</param>
        <summary>決定伺服器控制項的事件是否要在頁面的 UI 伺服器控制項階層架構中向上傳遞。</summary>
        <returns>如果事件已取消，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 伺服器控制項，例如<xref:System.Web.UI.WebControls.Repeater>，<xref:System.Web.UI.WebControls.DataList>和<xref:System.Web.UI.WebControls.GridView>Web 控制項可以包含引發事件的子控制項。 例如，每個資料列<xref:System.Web.UI.WebControls.GridView>控制項可以包含一或多個動態範本所建立的按鈕。 而不是個別引發事件的每個按鈕，讓巢狀控制項的事件 」 反昇 」 — 也就是傳送至命名容器。 命名容器引發泛用事件稱為<xref:System.Web.UI.WebControls.GridView.RowCommand>使用的參數值。 這些值可讓您決定哪一個引發的原始事件的個別控制項。 藉由回應這個單一事件，您可以避免撰寫個別子控制項的事件處理方法。  
  
   
  
## Examples  
 下列範例會覆寫<xref:System.Web.UI.Control.OnBubbleEvent%2A>自訂 ASP.NET 伺服器控制項，方法`ParentControl`。 這個方法會叫用時的子控制項`ParentControl`呼叫<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>方法。 當發生這種情況時，`ParentControl`類別會寫入包含的 ASP.NET 頁面上，第一個說明中的兩個字串，其<xref:System.Web.UI.Control.OnBubbleEvent%2A>已呼叫方法，第二個識別的原始檔控制<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>方法。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataBinding (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataBinding(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataBinding : EventArgs -&gt; unit&#xA;override this.OnDataBinding : EventArgs -&gt; unit" Usage="control.OnDataBinding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" /> 物件。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.DataBinding" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會通知伺服器控制項，以執行與它相關聯的資料繫結的任何邏輯。  
  
 如果您想要處理<xref:System.Web.UI.Control.DataBinding>事件，您應該覆寫這個事件處理方法。 這可確保所有委派都附加至<xref:System.Web.UI.Control.DataBinding>叫用事件。  
  
   
  
## Examples  
 下列範例示範如何覆寫<xref:System.Web.UI.Control.OnDataBinding%2A>方法，以從資料來源加入至父控制項的子控制項。  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期概觀</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="control.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" /> 物件。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.Init" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 會呼叫此方法以引發<xref:System.Web.UI.Control.Init>事件。 如果您正在開發的自訂控制項，您可以覆寫這個方法以提供額外的處理。 如果您覆寫這個方法，呼叫基底控制項的<xref:System.Web.UI.Control.OnInit%2A>方法來通知事件的訂閱者。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="control.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" /> 物件。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.Load" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 會呼叫此方法以引發<xref:System.Web.UI.Control.Load>事件。 如果您正在開發的自訂控制項，您可以覆寫這個方法以提供額外的處理。 如果您覆寫這個方法，呼叫基底控制項的<xref:System.Web.UI.Control.OnLoad%2A>方法來通知事件的訂閱者。  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="control.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" /> 物件。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.PreRender" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 會呼叫此方法以引發<xref:System.Web.UI.Control.PreRender>事件。 如果您正在開發的自訂控制項，您可以覆寫這個方法以提供額外的處理。 如果您覆寫這個方法，呼叫基底控制項的<xref:System.Web.UI.Control.OnPreRender%2A>方法來通知事件的訂閱者。  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="control.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.EventArgs" /> 物件。</param>
        <summary>引發 <see cref="E:System.Web.UI.Control.Unload" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 會呼叫此方法以引發<xref:System.Web.UI.Control.Unload>事件。 如果您正在開發的自訂控制項，您可以覆寫這個方法以提供額外的處理。 如果您覆寫這個方法，呼叫基底控制項的<xref:System.Web.UI.Control.OnUnload%2A>方法來通知事件的訂閱者。  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected internal System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function OpenFile (path As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::IO::Stream ^ OpenFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string -&gt; System.IO.Stream" Usage="control.OpenFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">所需要之檔案的路徑。</param>
        <summary>取得用來讀取檔案的 <see cref="T:System.IO.Stream" />。</summary>
        <returns>
          <see cref="T:System.IO.Stream" />，參考所需要的檔案。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.OpenFile%2A>方法會傳回<xref:System.IO.Stream>物件，可用來讀取檔案中指定的內容`path`參數。 Path 參數可以是相對或根目錄 URL，而不需要通訊協定 (例如"~ / mySite/myFile.txt)，或實體的路徑，本機 (「 c:\mySite\myFile.txt") 或 UNC (「\\\myServer\myFile.txt")。  
  
 <xref:System.Web.UI.Control.OpenFile%2A>方法會使用檔案存取安全性來控制存取指定的檔案。 如果目前的 ASP.NET 使用者並沒有存取檔案，則檔案尚未開啟，而且<xref:System.Web.HttpException>來表示存取被拒擲回例外狀況。 如果`path`參數指定的相對路徑，例外狀況不會包含要求的檔案的實體路徑的相關資訊。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">存取指定的檔案遭拒絕。</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); void set(System::Web::UI::Page ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page with get, set" Usage="System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得含有伺服器控制項的 <see cref="T:System.Web.UI.Page" /> 執行個體的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.Page" /> 執行個體，包含伺服器控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的值會反映在包含伺服器控制項的.aspx 檔案的名稱。  
  
   
  
## Examples  
 下列範例會覆寫 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 方法。 它會使用<xref:System.Web.UI.Page>屬性來存取<xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType>屬性並判斷是否包含此控制項的頁面只是已載入第一次，或者是回傳的結果。  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此控制項為 <see cref="T:System.Web.UI.WebControls.Substitution" /> 控制項。</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ Parent { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Web.UI.Control" Usage="System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在網頁控制階層架構中取得伺服器控制項之父控制項的參考。</summary>
        <value>伺服器控制項父控制項的參考。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求頁面時，只要是建置在該頁面上的伺服器控制項階層架構。 這個屬性可讓您判斷目前的伺服器控制項在該階層中，並針對它進行程式設計的父控制項。  
  
   
  
## Examples  
 下列範例會將新<xref:System.Web.UI.Control>頁面上的物件`myControl1`，在指定的控制項<xref:System.Web.UI.Control.FindControl%2A>方法呼叫。 如果在呼叫傳回的控制項，程式碼會使用<xref:System.Web.UI.Control.Parent%2A>屬性來識別控制項，其中包含`myControl1`。 如果父控制項，則字串 「 文字方塊的父代 」 就會與串連<xref:System.Web.UI.Control.ID%2A>的父控制項的屬性，並且寫入<xref:System.Web.UI.Control.Page%2A>。 如果找不到任何父控制項，將字串"控制項找不到 」 會被寫入。  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRender As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRender;" />
      <MemberSignature Language="F#" Value="member this.PreRender : EventHandler " Usage="member this.PreRender : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.Control" /> 物件載入之後但在呈現之前發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要執行的任何更新，才能在網頁上呈現伺服器控制項是使用這個事件。 在此事件期間，可以儲存伺服器控制項的檢視狀態中的任何變更。 將不會儲存在轉譯階段中進行這類變更。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseBubbleEvent (source As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.RaiseBubbleEvent : obj * EventArgs -&gt; unit" Usage="control.RaiseBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">事件的來源。</param>
        <param name="args">包含事件資料的 <see cref="T:System.EventArgs" /> 物件。</param>
        <summary>指派事件的任何來源和它的資訊至控制項的父控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 伺服器控制項，例如<xref:System.Web.UI.WebControls.Repeater>，<xref:System.Web.UI.WebControls.DataList>和<xref:System.Web.UI.WebControls.GridView>Web 控制項可以包含引發事件的子控制項。 例如，每個資料列<xref:System.Web.UI.WebControls.GridView>控制項可以包含一或多個動態範本所建立的按鈕。 而不是個別引發事件的每個按鈕，讓巢狀控制項的事件 」 反昇 」 — 也就是傳送至控制項的父代。 父代引發泛用事件稱為<xref:System.Web.UI.WebControls.GridView.RowCommand>使用的參數值。 這些值可讓您決定哪一個引發的原始事件的個別控制項。 藉由回應這個單一事件，您可以避免撰寫個別子控制項的事件處理方法。  
  
 雖然您無法覆寫這個方法，您撰寫的控制項可以處理，或藉由覆寫引發事件反昇<xref:System.Web.UI.Control.OnBubbleEvent%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立自訂類別，`ChildControl`覆寫，<xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType>方法來呼叫<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>方法，以將傳送<xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType>與其父系 ASP.NET 伺服器控制項的事件。 當使用者按一下按鈕，以在 ASP.NET 網頁，其中包含的執行個體`ChildControl`，便會產生<xref:System.Web.UI.Control.OnBubbleEvent%2A>包含執行個體的父控制項上的方法`ChildControl`，並將字串寫入 「 ChildControl 類別 OnClick 方法為呼叫 」 頁面。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RemovedControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RemovedControl : System.Web.UI.Control -&gt; unit&#xA;override this.RemovedControl : System.Web.UI.Control -&gt; unit" Usage="control.RemovedControl control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">已移除的 <see cref="T:System.Web.UI.Control" />。</param>
        <summary>從 <see cref="T:System.Web.UI.Control" /> 物件的 <see cref="P:System.Web.UI.Control.Controls" /> 集合中移除子控制項之後呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.RemovedControl%2A>方法從移除控制項之後，立即呼叫<xref:System.Web.UI.Control.Controls%2A>集合。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此控制項為 <see cref="T:System.Web.UI.WebControls.Substitution" /> 控制項。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">接收伺服器控制項內容的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 物件。</param>
        <summary>將伺服器控制項內容傳送到提供的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 物件，以寫入要在用戶端上呈現的內容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在開發自訂伺服器控制項時，您可以覆寫這個方法，以產生 ASP.NET 網頁的內容。  
  
   
  
## Examples  
 下列程式碼範例示範如何覆寫<xref:System.Web.UI.Control.Render%2A>方法。 <xref:System.Web.UI.Control.HasControls%2A>方法用來判斷伺服器控制項是否具有任何子控制項，儲存在其<xref:System.Web.UI.ControlCollection>物件，可透過存取<xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType>屬性。 如果<xref:System.Web.UI.Control.HasControls%2A>傳回 true，而且集合中的第一個伺服器控制項是常值文字，則常值的文字附加至 HTML 字串。  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected internal virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">接收所呈現內容的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 物件。</param>
        <summary>輸出伺服器控制項之子控制項的內容至提供的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 物件，這個物件會寫入用戶端上所要呈現的內容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會通知 ASP.NET 在呈現頁面上的任何 Active Server Pages (ASP) 程式碼。 如果 ASP 程式碼不存在該頁面上，這個方法會呈現任何的子伺服器控制項的控制項。 這個方法會呼叫<xref:System.Web.UI.Control.Render%2A>方法。  
  
   
  
## Examples  
 下列範例會覆寫<xref:System.Web.UI.Control.RenderChildren%2A>自訂伺服器控制項中的方法。 它會判斷目前的控制項是否有任何子控制項，其<xref:System.Web.UI.ControlCollection>物件。 若是如此，它會使用<xref:System.Web.UI.ControlCollection.Count%2A>來逐一查看集合的屬性。 當它遇到每個子控制項，它會使用<xref:System.Web.UI.Control.RenderControl%2A>呈現父控制項，以及所有子控制項，包含頁面的方法。  
  
 覆寫<xref:System.Web.UI.Control.Render%2A>然後方法會呼叫覆寫<xref:System.Web.UI.Control.RenderChildren%2A>方法。  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>輸出伺服器控制項內容，並在啟用追蹤功能的情況下，儲存有關控制項的追蹤資訊。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RenderControl (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderControl writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">接收控制項內容的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 物件。</param>
        <summary>將伺服器控制項內容輸出至提供的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 物件，並在啟用追蹤時儲存控制項的追蹤資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果伺服器控制項的<xref:System.Web.UI.Control.Visible%2A>屬性設定為`true`，這個方法會判斷頁面是否已啟用追蹤。 如果是的話，它會儲存與控制項相關聯的追蹤資訊，並呈現伺服器控制項內容至頁面。  
  
 這個方法會在呈現期間，自動呼叫的頁面，但自訂控制項開發人員可以覆寫。  
  
   
  
## Examples  
 下列範例會覆寫<xref:System.Web.UI.Control.RenderChildren%2A>自訂伺服器控制項中的方法。 它會判斷目前的控制項是否有任何子控制項，其<xref:System.Web.UI.ControlCollection>物件。 若是如此，它會使用<xref:System.Web.UI.ControlCollection.Count%2A>來逐一查看集合的屬性。 當它遇到每個子控制項，它會使用<xref:System.Web.UI.Control.RenderControl%2A>來呈現子控制項，以及所有子控制項，包含頁面的方法。 <xref:System.Web.UI.XhtmlTextWriter>傳遞至這個方法的物件具現化<xref:System.Web.UI.Page.Render%2A>方法。  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RenderControl (writer As HtmlTextWriter, adapter As ControlAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer, System::Web::UI::Adapters::ControlAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="member this.RenderControl : System.Web.UI.HtmlTextWriter * System.Web.UI.Adapters.ControlAdapter -&gt; unit" Usage="control.RenderControl (writer, adapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" />
      </Parameters>
      <Docs>
        <param name="writer">接收控制項內容的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="adapter">定義呈現的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</param>
        <summary>使用提供的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 物件，輸出伺服器控制項內容至提供的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web pages 可跨各種不同的裝置和瀏覽器可從 Web 要求的資訊。 <xref:System.Web.UI.Control.Adapter%2A>屬性會傳回<xref:System.Web.UI.Adapters.ControlAdapter>提出要求的裝置或瀏覽器的螢幕呈現控制項的物件。  
  
 如需有關配接器的詳細資訊，請參閱[架構概觀的自動調整控制項行為](https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100))。  
  
 如果伺服器控制項的<xref:System.Web.UI.Control.Visible%2A>屬性設定為`true`和頁面上，啟用追蹤，則會擷取與控制項關聯的追蹤資訊。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>覆寫時<see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />中自訂控制項，方法呼叫基底類別方法，以確保正確擷取追蹤資訊。</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
        <related type="Article" href="https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100)">調整控制項行為的架構概觀</related>
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RenderingCompatibility As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Version ^ RenderingCompatibility { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingCompatibility : Version with get, set" Usage="System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值會指定將與呈現 HTML 相容的 ASP.NET 版本。</summary>
        <value>將與呈現 HTML 相容的 ASP.NET 版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 會將此屬性設定的值`controlRenderingCompatibilityVersion`屬性的`pages`Web.config 檔案中的項目。 如果`controlRenderingCompatibilityVersion`Web.config 檔案中未設定屬性，預設值為目前的 ASP.NET 版本。  
  
> [!CAUTION]
>  沒有為此屬性，公用 set 存取子，但 set 存取子支援的.NET Framework 基礎結構，並不是直接從您的程式碼使用。 如果您在程式碼中設定此值，結果是無法預測。  
  
 ASP.NET 的每個發行版本可能會以不同的方式呈現 HTML，從較早的版本。 例如，在 ASP.NET 3.5 中，如果<xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A>屬性<xref:System.Web.UI.WebControls.Label>控制項`false`，依預設，ASP.NET 會呈現`span`項目其`disabled`屬性設定為"disabled"。 在 ASP.NET 4 中，根據預設，`span`項目以階層式樣式表 (CSS) 來呈現`class`屬性，而非`disabled`屬性。 這可讓您指定已停用控制項的外觀，並避免將無效的 HTML 呈現。 (在 HTML 4.0 和 XHTML 1.1`span`元素不支援`disabled`屬性。)  
  
 Web 應用程式可能會包含程式碼，就無法正確運作如果 HTML 轉譯變更。 若要避免這個問題，您可以設定`controlRenderingCompatibilityVersion`屬性的`pages`Web.config 檔案，以指出您想要維護與相容性的較早版本中的項目。 例如，如果您設定<xref:System.Web.UI.Control.RenderingCompatibility%2A>屬性，以`3.5`，已停用<xref:System.Web.UI.WebControls.Label>控制項將會呈現`disabled`屬性並不是 CSS 類別。  
  
> [!NOTE]
>  您可以將此屬性設定為最早版本`3.5`。  
  
 為了與舊版相容，當您使用 Visual Studio Web 專案升級至 ASP.NET 4，從較早版本時，Visual Studio 會自動設定`controlRenderingCompatibilityVersion`Web.config 檔案中的屬性`3.5`。 如果您想要呈現 HTML 所使用的演算法，在 ASP.NET 4 中引進的升級的網站時，您可以變更或移除`controlRenderingCompatibilityVersion`屬性。  
  
 大部分的情況下，由這個屬性所控制的行為是自動與您沒有檢查<xref:System.Web.UI.Control.RenderingCompatibility%2A>程式碼中的屬性。 不過，如果您撰寫自訂控制項，您可能必須包含會變更此屬性設定為基礎的控制項的行為的程式碼。 例如，ASP.NET 4 的自訂控制項可能會組成<xref:System.Web.UI.WebControls.Label>控制項和自訂控制項可能會產生改變的 JavaScript 程式碼來指定已停用控制項的外觀`aspNetDisabled`類別。 這適用於預期 if<xref:System.Web.UI.Control.RenderingCompatibility%2A>是`4.0`或更新版本。 但若要取得相同時生效<xref:System.Web.UI.Control.RenderingCompatibility%2A>已`3.5`，自訂控制項的程式碼必須將控制項的`CssClass`屬性為"aspNetDisabled"時<xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A>屬性是`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ResolveAdapter () As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Adapters::ControlAdapter ^ ResolveAdapter();" />
      <MemberSignature Language="F#" Value="abstract member ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter&#xA;override this.ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter" Usage="control.ResolveAdapter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得負責呈現指定之控制項的控制項配置器。</summary>
        <returns>負責呈現控制項的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 網頁都可檢視各種不同的裝置可以從 Web 要求的頁面。 <xref:System.Web.UI.Control.ResolveAdapter%2A>方法傳回的控制項配接器負責轉譯特定的瀏覽器或裝置上的控制項，要求 ASP.NET 網頁。  
  
 傳回特定的配接器類型的子系的型別而定<xref:System.Web.UI.Control>所呈現的類別。  
  
 如需有關配接器的詳細資訊，請參閱[架構概觀的自動調整控制項行為](https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveClientUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveClientUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="abstract member ResolveClientUrl : string -&gt; string&#xA;override this.ResolveClientUrl : string -&gt; string" Usage="control.ResolveClientUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IUrlResolutionService.ResolveClientUrl(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">相對於目前頁面的 URL。</param>
        <summary>取得瀏覽器可使用的 URL。</summary>
        <returns>適合瀏覽器使用、指定之資源的完整 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.Control.ResolveClientUrl%2A>方法，以傳回 URL 字串適用於用戶端來存取資源的 Web 伺服器上，例如影像檔連結至其他頁面，並依此類推。  
  
> [!NOTE]
>  這個方法所傳回的 URL 會相對於包含控制項具現化的原始程式檔的資料夾。 控制項繼承這個屬性，例如<xref:System.Web.UI.UserControl>和<xref:System.Web.UI.MasterPage>，會傳回相對於控制項的完整的 URL。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relativeUrl" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ResolveUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="member this.ResolveUrl : string -&gt; string" Usage="control.ResolveUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">與 <see cref="P:System.Web.UI.Control.TemplateSourceDirectory" /> 屬性關聯的 URL。</param>
        <summary>將 URL 轉換為要求用戶端可使用的 URL。</summary>
        <returns>已轉換的 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`relativeUrl`參數包含絕對 URL，URL 會原封不動地傳回。 如果`relativeUrl`參數包含相對的 URL，URL 會變成是正確的目前要求路徑中，讓瀏覽器可以解析 URL 的相對 URL。  
  
 例如，請考慮下列案例：  
  
-   用戶端已要求 ASP.NET 網頁，其中包含具有與它相關聯的映像的使用者控制項。  
  
-   ASP.NET 網頁位於 /Store/page1.aspx。  
  
-   使用者控制項位於 /Store/UserControls/UC1.ascx。  
  
-   映像檔是位於 /UserControls/Images/Image1.jpg。  
  
 如果使用者控制項將映像 (也就是 /Store/UserControls/Images/Image1.jpg) 的相對路徑傳遞至<xref:System.Web.UI.Control.ResolveUrl%2A>方法，此方法會傳回值 images/image1.jpg。  
  
 這個方法會使用<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>屬性來解析為絕對 URL。 傳回的 URL 是供用戶端使用。  
  
 如需有關在網站上的資源路徑的詳細資訊，請參閱[ASP.NET Web 專案路徑](https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd)。  
  
> [!NOTE]
>  Mobile Web 網頁，如果您的應用程式依賴無 cookie 工作階段，或可能會接收來自行動瀏覽器需要無 cookie 工作階段的要求，使用波狀符號 ("\~」) 的路徑可能會導致不小心建立新的工作階段和可能會遺失工作階段資料。 若要設定路徑的屬性，例如"\~/*路徑 」*，藉由呼叫解析路徑<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>這類的引數 」\~/*路徑"* 再將它指派給屬性。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Web.UI.WebControls.Image>Web 伺服器控制項物件，並使用<xref:System.Web.UI.Control.ResolveUrl%2A>方法，以將 [路徑] 設定所儲存的映像<xref:System.Web.UI.WebControls.Image.ImageUrl%2A>屬性。  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">發生在 <paramref name="relativeUrl" /> 參數包含 <see langword="null" /> 的情況。</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
        <related type="Article" href="https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd">ASP.NET 網站路徑</related>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveControlState : unit -&gt; obj&#xA;override this.SaveControlState : unit -&gt; obj" Usage="control.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>儲存頁面回傳至伺服器以來，所發生的任何伺服器控制項狀態變更。</summary>
        <returns>傳回伺服器控制項目前的狀態。 如果沒有與控制項關聯的狀態，則這個方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.Control.SaveControlState%2A>方法來儲存所需的特定控制項的作業的狀態資訊。 此控制項狀態資料從控制項的檢視狀態資料分開儲存。  
  
 使用控制項狀態的自訂控制項必須呼叫<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>方法<xref:System.Web.UI.Control.Page%2A>之前儲存控制項狀態。  
  
   
  
## Examples  
 下列程式碼會覆寫<xref:System.Web.UI.Control.SaveControlState%2A>自訂 ASP.NET 控制項中的方法。 當這個方法會叫用時，它會判斷是否內部屬性`currentIndex`設定為非預設值，而且如果是的話，會將值儲存控制項狀態。  
  
 <xref:System.Web.UI.Control.OnInit%2A>方法會覆寫來呼叫<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>方法<xref:System.Web.UI.Control.Page%2A>來表示自訂控制項使用控制項狀態。  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>字串物件儲存控制狀態時，會傳回給用戶端會儲存在 HTML 中的變數<see langword="HIDDEN" />項目。 覆寫這個方法，以擷取要用於您的控制項狀態資訊。  
  
控制項狀態適用於少量的重要資料，例如頁面索引或關鍵字。 用於大量資料的控制項狀態，可能會影響頁面的效能。 如需詳細資訊，請參閱 &lt; [ASP.NET 狀態管理概觀](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 狀態管理概觀</related>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveViewState : unit -&gt; obj&#xA;override this.SaveViewState : unit -&gt; obj" Usage="control.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>儲存自頁面回傳至伺服器以來所發生的任何伺服器控制項檢視狀態變更。</summary>
        <returns>傳回伺服器控制項的目前檢視狀態。 如果沒有與控制項相關聯的檢視狀態，則這個方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 檢視狀態是伺服器控制項的屬性值的累積。 這些值會自動放在伺服器控制項的<xref:System.Web.UI.Control.ViewState%2A>屬性，這是執行個體的<xref:System.Web.UI.StateBag>類別。 儲存狀態的伺服器控制項生命週期的階段之後，這個屬性的值然後會保存到字串物件。 如需詳細資訊，請參閱 < [ASP.NET 網頁生命週期概觀](https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991)。  
  
 儲存檢視狀態時，此字串物件會傳回給用戶端做此變數會儲存在 HTML`HIDDEN`項目。 當您撰寫自訂的檢視狀態的自訂伺服器控制項時，檢視狀態可以明確地利用管理<xref:System.Web.UI.Control.SaveViewState%2A>和<xref:System.Web.UI.Control.LoadViewState%2A>方法。 如需詳細資訊，請參閱 < [ASP.NET 狀態管理概觀](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))。 如需實作自訂的工作階段狀態提供者的資訊，請參閱[實作工作階段狀態存放區提供者](https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66)。  
  
   
  
## Examples  
 下列範例會覆寫<xref:System.Web.UI.Control.SaveViewState%2A>自訂 ASP.NET 伺服器控制項中的方法。 當這個方法會叫用時，它會判斷控制項是否有任何子控制項，以及是否包含<xref:System.Web.UI.Page>物件是回傳的結果。 如果兩者都是 true，它會變更<xref:System.Web.UI.WebControls.Label.Text%2A>的屬性<xref:System.Web.UI.WebControls.Label>Web 伺服器控制項，讀取`Custom Control Has Saved State`。 它接著會將控制項的檢視狀態儲存做為陣列的物件，名為`allStates`。  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 狀態管理概觀</related>
        <related type="Article" href="https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66">實作工作階段狀態存放區提供者</related>
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetDesignModeState (data As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetDesignModeState(System::Collections::IDictionary ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetDesignModeState : System.Collections.IDictionary -&gt; unit&#xA;override this.SetDesignModeState : System.Collections.IDictionary -&gt; unit" Usage="control.SetDesignModeState data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Collections.IDictionary" />，包含控制項的設計階段資料。</param>
        <summary>設定控制項的設計階段資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.SetDesignModeState%2A>方法會將儲存控制項的設計階段資料。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您必須覆寫這個方法，以儲存您的控制項需要設計階段資料。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRenderMethodDelegate(System::Web::UI::RenderMethod ^ renderMethod);" />
      <MemberSignature Language="F#" Value="member this.SetRenderMethodDelegate : System.Web.UI.RenderMethod -&gt; unit" Usage="control.SetRenderMethodDelegate renderMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">要傳給委派的必要資訊，使委派呈現伺服器控制項。</param>
        <summary>指定事件處理常式委派，以呈現伺服器控制項及其內容至其父控制項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法提供實作之用;您應該永遠不會呼叫它直接。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定設計階段期間追蹤產生資料的追蹤資料。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj -&gt; unit" Usage="control.SetTraceData (traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">追蹤資料索引鍵。</param>
        <param name="traceDataValue">追蹤資料值。</param>
        <summary>使用追蹤資料機碼和追蹤資料值，設定設計階段期間追蹤呈現資料的追蹤資料。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (tracedObject As Object, traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ tracedObject, System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj * obj -&gt; unit" Usage="control.SetTraceData (tracedObject, traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" />
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tracedObject">追蹤的物件。</param>
        <param name="traceDataKey">追蹤資料索引鍵。</param>
        <param name="traceDataValue">追蹤資料值。</param>
        <summary>使用追蹤的物體、追蹤資料機碼和追蹤資料值，設定設計階段期間追蹤呈現資料的追蹤資料。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當呈現在設計介面上時，取得裝載目前控制項之容器的資訊。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" />，包含裝載控制項之容器的資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站台繫結<xref:System.ComponentModel.Component>物件至<xref:System.ComponentModel.Container>物件，並可讓兩者之間的通訊。 它也提供方法讓要管理其元件的容器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此控制項為 <see cref="T:System.Web.UI.WebControls.Substitution" /> 控制項。</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要套用至控制項的面板。</summary>
        <value>要套用至控制項之面板的名稱。 預設值為 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 面板控制項可以使用包含在一或多個面板檔案中的佈景主題的目錄。 <xref:System.Web.UI.Control.SkinID%2A>屬性會指定其中一個這些要套用至控制項的面板。 面板是專屬於特定的控制;您無法共用之間的不同類型的控制項的外觀設定。  
  
 如果您未設定<xref:System.Web.UI.Control.SkinID%2A>屬性，控制會使用預設面板如果有定義。 例如，如果沒有面板識別碼定義<xref:System.Web.UI.WebControls.Image>控制項，則該外觀套用至所有<xref:System.Web.UI.WebControls.Image>，未明確參考識別碼的外觀和，未設定為停用的佈景主題的控制項。 如果已定義識別碼的外觀<xref:System.Web.UI.WebControls.Image>控制項，則該面板只適用於<xref:System.Web.UI.WebControls.Image>控制項<xref:System.Web.UI.Control.SkinID%2A>屬性設定為該識別碼。  
  
 如果佈景主題目錄中的面板檔案未包含具有指定的外觀<xref:System.Web.UI.Control.SkinID%2A>屬性，<xref:System.ArgumentException>在執行階段擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已套用樣式表。  
  
\-或- 
<see langword="Page_PreInit" /> 事件已發生。  
  
\-或- 
控制項已加入至 <see langword="Controls" /> 集合。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">ASP.NET 佈景主題概觀</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ControlBuilder As ControlBuilder Implements IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ControlBuilder ^ System::Web::UI::IControlBuilderAccessor::ControlBuilder { System::Web::UI::ControlBuilder ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlBuilderAccessor.ControlBuilder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />。</summary>
        <value>建置控制項的 <see cref="T:System.Web.UI.ControlBuilder" />，如果未使用產生器，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IControlBuilderAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Function GetDesignModeState () As IDictionary Implements IControlDesignerAccessor.GetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.GetDesignModeState() = System::Web::UI::IControlDesignerAccessor::GetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />。</summary>
        <returns>控制項狀態的 <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IControlDesignerAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDesignModeState (data As IDictionary) Implements IControlDesignerAccessor.SetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System::Collections::IDictionary ^ data) = System::Web::UI::IControlDesignerAccessor::SetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Collections.IDictionary" />，包含控制項的設計階段資料。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IControlDesignerAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Sub SetOwnerControl (owner As Control) Implements IControlDesignerAccessor.SetOwnerControl" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System::Web::UI::Control ^ owner) = System::Web::UI::IControlDesignerAccessor::SetOwnerControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="owner">控制項的擁有人。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IControlDesignerAccessor> 介面時，才能使用這個成員。  
  
 <xref:System.Web.UI.IControlDesignerAccessor>介面由控制項設計工具來對控制項執行設計階段動作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" /> 設為目前的控制項。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UserData As IDictionary Implements IControlDesignerAccessor.UserData" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::IDictionary ^ System::Web::UI::IControlDesignerAccessor::UserData { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlDesignerAccessor.UserData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />。</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" />，包含關於控制項的資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IControlDesignerAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DataBindings As DataBindingCollection Implements IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::DataBindingCollection ^ System::Web::UI::IDataBindingsAccessor::DataBindings { System::Web::UI::DataBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />。</summary>
        <value>資料繫結的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IDataBindingsAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasDataBindings As Boolean Implements IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IDataBindingsAccessor::HasDataBindings { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.HasDataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />。</summary>
        <value>如果控制項包含資料繫結邏輯，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IDataBindingsAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expressions As ExpressionBindingCollection Implements IExpressionsAccessor.Expressions" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ExpressionBindingCollection ^ System::Web::UI::IExpressionsAccessor::Expressions { System::Web::UI::ExpressionBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.Expressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />。</summary>
        <value>
          <see cref="T:System.Web.UI.ExpressionBindingCollection" />，包含表示控制項之屬性和運算式的 <see cref="T:System.Web.UI.ExpressionBinding" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IExpressionsAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasExpressions As Boolean Implements IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IExpressionsAccessor::HasExpressions { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.HasExpressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />。</summary>
        <value>如果控制項有屬性透過運算式所設定，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IExpressionsAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddParsedSubObject (obj As Object) Implements IParserAccessor.AddParsedSubObject" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IParserAccessor.AddParsedSubObject(System::Object ^ obj) = System::Web::UI::IParserAccessor::AddParsedSubObject;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要加入的物件。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Web.UI.Control> 執行個體轉換成 <xref:System.Web.UI.IParserAccessor> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberSignature Language="VB.NET" Value="Public Property TemplateControl As TemplateControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::TemplateControl ^ TemplateControl { System::Web::UI::TemplateControl ^ get(); void set(System::Web::UI::TemplateControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TemplateControl : System.Web.UI.TemplateControl with get, set" Usage="System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定包含了此控制項之樣板的參考。</summary>
        <value>
          <see cref="T:System.Web.UI.TemplateControl" /> 執行個體，包含這個控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Web.UI.Control>執行個體是控制項範本的一部分<xref:System.Web.UI.Control.TemplateControl%2A>屬性包含內含控制項的參考。 如需詳細資訊，請參閱<xref:System.Web.UI.TemplateControl?displayProperty=nameWithType>文件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TemplateSourceDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplateSourceDirectory : string" Usage="System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含目前伺服器控制項的 <see cref="T:System.Web.UI.Page" /> 或 <see cref="T:System.Web.UI.UserControl" /> 的虛擬目錄。</summary>
        <value>網頁或使用者控制項的虛擬目錄，包含伺服器控制項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A>屬性指定的路徑，包含目前控制項之網頁或使用者控制項。 例如，如果網頁位於http://www.contoso.com/application/subdirectory，則<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>屬性會傳回 「 應用程式/子目錄 」。  
  
 若要傳回應用程式相對虛擬路徑 ("~ / 子目錄 」)，使用<xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>屬性。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>屬性兩次。 它會在第一次<xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType>方法呼叫來取得控制項所在的目錄路徑。 在第二次<xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType>方法呼叫，以取得包含在該目錄內的所有檔案的清單。  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TrackViewState();" />
      <MemberSignature Language="F#" Value="abstract member TrackViewState : unit -&gt; unit&#xA;override this.TrackViewState : unit -&gt; unit" Usage="control.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>導致對伺服器控制項的檢視狀態變更的追蹤 (Tracking)，以便它們能夠儲存於伺服器控制項的 <see cref="T:System.Web.UI.StateBag" /> 物件。 這個物件可透過 <see cref="P:System.Web.UI.Control.ViewState" /> 屬性存取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在結尾自動呼叫這個方法<xref:System.Web.UI.Control.Init>伺服器控制項的生命週期中的事件。  
  
 當您開發樣板化的資料繫結控制項時，請叫用這個方法。 這個方法的警示來監視伺服器控制項的檢視狀態，也就是必要的當您覆寫變更 ASP.NET<xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列範例會覆寫<xref:System.Web.UI.Control.DataBind%2A>自訂 ASP.NET 伺服器控制項中的方法。 一開始先呼叫基底<xref:System.Web.UI.Control.OnDataBinding%2A>方法，然後使用<xref:System.Web.UI.ControlCollection.Clear%2A>方法來刪除所有子控制項和<xref:System.Web.UI.Control.ClearChildViewState%2A>方法來都刪除任何儲存的檢視狀態設定為這些子控制項。 最後，<xref:System.Web.UI.Control.ChildControlsCreated%2A>屬性設定為`true`。 控制項接著會使用<xref:System.Web.UI.Control.IsTrackingViewState%2A>屬性來判斷是否啟用控制項的檢視狀態變更追蹤。 如果未啟用，<xref:System.Web.UI.Control.TrackViewState%2A>呼叫方法。  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueID : string" Usage="System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得伺服器控制項唯一的、符合階層架構的識別項。</summary>
        <value>伺服器控制項的完整識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性與不同<xref:System.Web.UI.Control.ID%2A>屬性，在於<xref:System.Web.UI.Control.UniqueID%2A>屬性包含伺服器控制項的命名容器的識別碼。 處理網頁要求時，會自動產生這個識別碼。  
  
 這個屬性就特別重要，尤其區別包含重複的資料繫結伺服器控制項中的伺服器控制項。 重複的控制項，也就是<xref:System.Web.UI.WebControls.Repeater>， <xref:System.Web.UI.WebControls.DataList>， <xref:System.Web.UI.WebControls.DetailsView>， <xref:System.Web.UI.WebControls.FormView>，和<xref:System.Web.UI.WebControls.GridView>Web 伺服器控制項 （或任何自訂伺服器控制項，您會建立包含重複的功能，當資料繫結），做為命名容器及其子控制項。 這表示，它會建立唯一的命名空間及其子控制項，讓其<xref:System.Web.UI.Control.ID%2A>屬性值不會衝突。  
  
 比方說，如果您包含 ASP.NET <xref:System.Web.UI.WebControls.Label> Web 伺服器控制項，在<xref:System.Web.UI.WebControls.Repeater>伺服器控制項，並指派<xref:System.Web.UI.WebControls.Label>控制<xref:System.Web.UI.Control.ID%2A>屬性值`MyLabel`，而<xref:System.Web.UI.WebControls.Repeater> <xref:System.Web.UI.Control.ID%2A> 的`MyRepeater`. 如果您要的資料繫結<xref:System.Web.UI.WebControls.Repeater>要<xref:System.Collections.ArrayList>具有三個項目，所產生的物件<xref:System.Web.UI.Control.UniqueID%2A>每個執行個體的屬性<xref:System.Web.UI.WebControls.Label>伺服器控制項都是`MyRepeater$ctl00$MyLabel`， `MyRepeater$ctl01$MyLabel`，和`MyRepeater$ctl02$MyLabel`。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Collections.ArrayList>物件並填入三個文字字串，然後繫結<xref:System.Web.UI.WebControls.Repeater>Web 伺服器控制項中的資料，<xref:System.Collections.ArrayList>頁面載入時。 此程式碼取得<xref:System.Web.UI.Control.UniqueID%2A>每個資料繫結期間所產生的子控制項的屬性。 程式碼會產生三個版本<xref:System.Web.UI.WebControls.Label>控制項和寫入其`UniqueID`至頁面的屬性值。  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : EventHandler " Usage="member this.Unload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於伺服器控制項從記憶體卸載時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 伺服器控制項必須執行任何最後的清除，例如關閉檔案、 資料庫連線和捨棄這個階段的執行個體卸載之前控制項生命週期期間的物件。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 網頁生命週期簡介</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出控制項是否對來自瀏覽器的用戶端輸入檢查潛在的危險值。</summary>
        <value>決定控制項是否檢查用戶端輸入的值。 值可包括 <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />、<see cref="F:System.Web.UI.ValidateRequestMode.Enabled" /> 和 <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />。 預設值是<see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />，這表示控制項會從其父代取得值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關要求驗證的詳細資訊，請參閱<xref:System.Web.UnvalidatedRequestValues>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewState As StateBag" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::StateBag ^ ViewState { System::Web::UI::StateBag ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewState : System.Web.UI.StateBag" Usage="System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得狀態資訊的字典，允許您在相同網頁的多個要求之間，儲存和還原伺服器控制項的檢視狀態。</summary>
        <value>
          <see cref="T:System.Web.UI.StateBag" /> 類別的執行個體，包含伺服器控制項的檢視狀態資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 伺服器控制項的檢視狀態是累積的所有屬性值。 若要保留這些值的 HTTP 要求之間，ASP.NET 伺服器控制項使用這個屬性，這是執行個體的<xref:System.Web.UI.StateBag>類別，來儲存屬性值。 值會接著為變數時傳遞至 HTML 隱藏 input 元素，會處理後續要求。 如需儲存伺服器控制項檢視狀態的詳細資訊，請參閱 < [ASP.NET 狀態管理概觀](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))。  
  
 根據預設，所有的伺服器控制項的啟用檢視狀態，但情況下，您會想要停用它。 如需詳細資訊，請參閱 < [ASP.NET 效能概觀](https://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b)。  
  
 字典，以及如何使用它們的相關資訊，請參閱[集合和資料結構](~/docs/standard/collections/index.md)。  
  
   
  
## Examples  
 下列範例示範實作`Text`屬性來儲存和擷取其值，從其控制<xref:System.Web.UI.Control.ViewState%2A>屬性。  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 狀態管理概觀</related>
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewStateIgnoresCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ViewStateIgnoresCase { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateIgnoresCase : bool" Usage="System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Web.UI.StateBag" /> 物件是否不區分大小寫。</summary>
        <value>如果 <see cref="T:System.Web.UI.StateBag" /> 執行個體不區分大小寫，則為 <see langword="true" />，否則，即為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您建立的自訂伺服器控制項，將其檢視狀態儲存而不考慮大小寫，請覆寫這個方法。 當您執行那麼多個物件，使用相同的金鑰，但大小寫有差異時，可以儲存在<xref:System.Web.UI.StateBag>相關聯<xref:System.Web.UI.Control.ViewState%2A>屬性。  
  
   
  
## Examples  
 下列範例示範如何覆寫<xref:System.Web.UI.Control.ViewStateIgnoresCase%2A>屬性，以傳回`true`。  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ViewStateMode As ViewStateMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ViewStateMode ViewStateMode { System::Web::UI::ViewStateMode get(); void set(System::Web::UI::ViewStateMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateMode : System.Web.UI.ViewStateMode with get, set" Usage="System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個控制項的檢視狀態模式。</summary>
        <value>這個控制項的檢視狀態模式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Web.UI.Control.ViewStateMode%2A>屬性，讓個別控制項的檢視狀態，即使頁面停用檢視狀態。 如需有關檢視狀態和控制項狀態的詳細資訊，請參閱<xref:System.Web.UI.Control.EnableViewState%2A>屬性。  
  
 停用頁面的檢視狀態，並啟用特定控制項的頁面上，設定<xref:System.Web.UI.Control.EnableViewState%2A>頁面和控制項的屬性`true`，將<xref:System.Web.UI.Control.ViewStateMode%2A>屬性頁面，即可<xref:System.Web.UI.ViewStateMode.Disabled>，並設定<xref:System.Web.UI.Control.ViewStateMode%2A>屬性若要控制<xref:System.Web.UI.ViewStateMode.Enabled>。  
  
 預設值<xref:System.Web.UI.Control.ViewStateMode%2A>頁面的屬性是<xref:System.Web.UI.ViewStateMode.Enabled>。 預設值<xref:System.Web.UI.Control.ViewStateMode%2A>頁面中的 Web 伺服器控制項的屬性是<xref:System.Web.UI.ViewStateMode.Inherit>。 如此一來，如果您未在頁面或控制層級的值設定這個屬性<xref:System.Web.UI.Control.EnableViewState%2A>屬性決定檢視狀態的行為。  
  
 <xref:System.Web.UI.Control.ViewStateMode%2A>頁面或控制項的屬性有影響才<xref:System.Web.UI.Control.EnableViewState%2A>屬性設定為`true`。 如果<xref:System.Web.UI.Control.EnableViewState%2A>屬性設定為`false`，檢視狀態將會關閉，即使<xref:System.Web.UI.Control.ViewStateMode%2A>屬性設定為<xref:System.Web.UI.ViewStateMode.Enabled>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">已嘗試將此屬性設定為不屬於 <see cref="T:System.Web.UI.ViewStateMode" /> 列舉中的值。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 狀態管理概觀</related>
        <related type="Article" href="https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818">ASP.NET 檢視狀態概觀</related>
        <related type="Article" href="https://msdn.microsoft.com/en-us/library/C90FA3D7-788A-47D2-A80F-138122A1D8EE">控制檢視狀態</related>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出伺服器控制項是否會轉譯為頁面上的 UI。</summary>
        <value>如果控制項在頁面上可見，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此屬性為`false`，則不會呈現伺服器控制項。 您應該考慮此組織您的頁面的版面配置時。  
  
> [!NOTE]
>  它包含的任何控制項如果容器控制項呈現時，會在即使您將無法呈現<xref:System.Web.UI.Control.Visible%2A>到個別控制項的屬性`true`。 在此情況下，個別的控制項，會傳回`false`for<xref:System.Web.UI.Control.Visible%2A>屬性，即使您已明確地將它設定為`true`。 (亦即，如果`Visible`的父控制項的屬性設定為`false`子控制項繼承該設定，設定會優先於任何本機設定。)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>