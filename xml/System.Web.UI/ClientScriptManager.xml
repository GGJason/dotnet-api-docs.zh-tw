<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="73373c29a93b5ff53507a84d4a623470605a172f" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39875293" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>定義用來管理 Web 應用程式中用戶端指令碼的方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager>類別用來管理用戶端指令碼，並將它們新增至 Web 應用程式。 您可以取得參考<xref:System.Web.UI.ClientScriptManager>類別從<xref:System.Web.UI.Page.ClientScript%2A>屬性<xref:System.Web.UI.Page>物件。  
  
 您可以新增用戶端指令碼至網頁以宣告方式包含在頁面的 HTML 標記中的指令碼。 不過，有些情況需要以動態方式新增用戶端指令碼。 若要以動態方式加入指令碼，使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法中，<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法，<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，或<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法，會根據時間和方式想要新增指令碼。 如需詳細資訊，請參閱 <<c0> [ 如何： 新增用戶端指令碼以動態方式以 ASP.NET Web Pages](http://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666)。  
  
 <xref:System.Web.UI.ClientScriptManager>類別唯一識別索引鍵的指令碼<xref:System.String>和<xref:System.Type>。 具有相同的索引鍵和類型的指令碼會被視為重複。 使用指令碼類型，有助於避免令人困惑的類似指令碼，可能會在頁面上的使用中的不同使用者控制項。  
  
 <xref:System.Web.UI.ClientScriptManager>類別可以用來叫用用戶端回呼的情況下，最好從用戶端執行伺服端程式碼，而不需執行回傳時。 這被指執行的頻外回呼至伺服器。 在用戶端回呼中，用戶端指令碼函式會將非同步要求傳送至 ASP.NET Web 網頁。 網頁會執行其一般生命週期的修改的版本，以處理回呼。 使用<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法，以取得用戶端函式的參考，叫用時，啟始對伺服器事件的用戶端回呼。 如需詳細資訊，請參閱 <<c0> [ 實作用戶端回呼而不需要回傳](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)。  
  
> [!NOTE]
>  指令碼回呼不適用於舊版瀏覽器不支援文件物件模型 (DOM)，且需要在用戶端上，會啟用 ECMAScript。 若要檢查瀏覽器是否支援回呼，請使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>屬性，這是可透過存取<xref:System.Web.HttpRequest.Browser%2A>ASP.NET 內建屬性<xref:System.Web.HttpContext.Request%2A>物件。  
  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法和<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>來定義用戶端回傳事件的方法。 這些方法可讓用戶端指令碼函式，叫用時，會造成伺服器回傳至頁面。 用戶端回傳事件是用戶端回呼不同之處，在於網頁完成用戶端回傳事件的處理序一般生命週期。  
  
> [!NOTE]
>  如果您使用<xref:System.Web.UI.WebControls.Button>控制項和<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性設定為`false`，然後您可以使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法，以傳回用戶端回傳事件<xref:System.Web.UI.WebControls.Button>控制項。  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A>的屬性<xref:System.Web.UI.WebControls.Button>控制<xref:System.Web.UI.WebControls.ImageButton>控制項，和<xref:System.Web.UI.WebControls.LinkButton>控制項可用來執行用戶端指令碼。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法的<xref:System.Web.UI.ClientScriptManager>類別。 兩個用戶端指令碼會定義於頁面中： `PopupScript`，其中會顯示警示訊息，載入頁面時，並`ButtonClickScript`，其定義的 HTML 按鈕的用戶端處理常式`onClick`事件。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">處理用戶端回呼的伺服器 <see cref="T:System.Web.UI.Control" />。 控制項必須實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面並提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">從用戶端指令碼傳遞到伺服器的引數 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">會接收成功的伺服器事件結果的用戶端事件處理常式名稱。</param>
        <param name="context">在啟始回呼 (Callback) 之前，於用戶端上評估的用戶端指令碼。 指令碼的結果會傳回給用戶端事件處理常式。</param>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。 這個多載方法的用戶端函式包含指定的控制項、引數、用戶端指令碼和內容。</summary>
        <returns>叫用用戶端回呼的用戶端函式名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29>方法所執行的頻外回撥，到頁面的一般生命週期的修改的版本的伺服器。 如需詳細資訊，請參閱 <<c0> [ 實作用戶端回呼而不需要回傳](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)。  
  
> [!NOTE]
>  Microsoft Internet Explorer （版本 5.0 或更新版本） 的瀏覽器時，指令碼回呼機制透過 Microsoft.XmlHttp COM 物件實作，而且需要設定為 執行 ActiveX 控制項的瀏覽器。 其他瀏覽器中，會使用 XMLHttpRequest 使用瀏覽器的本機文件物件模型 (DOM)。 若要檢查瀏覽器是否支援用戶端回呼，請使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>屬性。 若要檢查瀏覽器是否支援透過 HTTP 的 XML，請使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A>屬性。 兩個屬性都可透過存取<xref:System.Web.HttpRequest.Browser%2A>屬性的內建的 ASP.NET<xref:System.Web.HttpContext.Request%2A>物件。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法會執行以同步方式使用 XML over HTTP 的回呼。 當回呼案例中，以同步方式傳送資料，同步回呼立即傳回，並不會封鎖瀏覽器。 沒有兩個的同步回呼可以在瀏覽器中同時執行。 如果其中一個目前暫止時引發的第二個同步回呼時，第二個同步回撥會取消第一個和第二個回撥會傳回。  
  
 若要以非同步方式傳送資料，請使用其中一個多載`useAsync`參數，這是布林值，以控制此行為。 在非同步案例中，您可以有多個擱置中回呼;不過，它們傳回的順序不保證符合它們初始化的順序。  
  
 此外，這個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法會指定用戶端函式可處理所產生的錯誤狀況的情況<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法。 若要指定的用戶端錯誤回呼處理常式，請使用其中一個多載`clientErrorCallback`參數。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29>方法會採用選擇性的字串`argument`參數並傳回的字串。 傳遞或接收多個值，串連輸入中的值，或分別傳回字串。  
  
> [!NOTE]
>  請避免使用需要在指令碼回呼作業期間更新的頁面或控制項屬性的實作中的檢視狀態。 如果屬性都能夠維持網頁要求時，您可以使用工作階段狀態。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用兩個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>遞增整數的用戶端回撥案例的方法。  
  
 會顯示這兩個回呼機制;它們之間的差異是使用`context`參數。 A`ReceiveServerData1`用戶端回呼函式使用提供`context`參數。 相反地，`ReceiveServerData2`用戶端回呼函式定義於`<script>`頁面上的區塊。 A<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法是遞增的值傳遞給它的伺服器處理常式和<xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A>方法會傳回遞增後的值做為字串。 如果<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法會傳回錯誤，則`ProcessCallBackError`呼叫用戶端函式。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">處理用戶端回呼的伺服器 <see cref="T:System.Web.UI.Control" />。 控制項必須實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面並提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">從用戶端指令碼傳遞到伺服器的引數 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">會接收成功的伺服器事件結果的用戶端事件處理常式名稱。</param>
        <param name="context">在啟始回呼 (Callback) 之前，於用戶端上評估的用戶端指令碼。 指令碼的結果會傳回給用戶端事件處理常式。</param>
        <param name="useAsync">
          <see langword="true" /> 表示非同步執行回呼，<see langword="false" /> 表示同步執行回呼。</param>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。 這個多載方法的用戶端函式包含指定的控制項、引數、用戶端指令碼、內容和布林值。</summary>
        <returns>叫用用戶端回呼的用戶端函式名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法需要`useAsync`參數，可讓您藉由將值設定為以非同步方式執行用戶端回呼`true`。 這個方法的多載版本，不需要`useAsync`參數的值設定為`false`預設。  
  
 如需有關這個方法的詳細資訊，請參閱的 < 備註 > 的多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">處理用戶端回呼之伺服器 <see cref="T:System.Web.UI.Control" /> 的名稱。 控制項必須實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面並提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">從用戶端指令碼傳遞到伺服器的引數 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">會接收成功的伺服器事件結果的用戶端事件處理常式名稱。</param>
        <param name="context">在啟始回呼 (Callback) 之前，於用戶端上評估的用戶端指令碼。 指令碼的結果會傳回給用戶端事件處理常式。</param>
        <param name="clientErrorCallback">當伺服器事件處理常式發生錯誤時，接收結果之用戶端事件處理常式的名稱。</param>
        <param name="useAsync">
          <see langword="true" /> 表示非同步執行回呼，<see langword="false" /> 表示同步執行回呼。</param>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。 這個多載方法的用戶端函式包含指定的目標、引數、用戶端指令碼、內容、錯誤處理常式和布林值。</summary>
        <returns>叫用用戶端回呼的用戶端函式名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法會採用`target`字串參數，而不是<xref:System.Web.UI.Control>參數。 當您想要回到以外的字串，包含回呼時，請使用此多載<xref:System.Web.UI.Control.UniqueID%2A>的控制項。  
  
 此外，這個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法需要`useAsync`和`clientErrorCallback`參數。 `useAsync`參數可讓您藉由將值設定為以非同步方式執行用戶端回呼`true`。 這個方法的多載版本，不需要`useAsync`參數的值設定為`false`預設。 `clientErrorCallback`參數可讓您定義的用戶端呼叫函式是名稱的伺服器處理常式，<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法，會傳回錯誤。 這個方法的多載版本，不需要`clientErrorCallback`參數將值設定為 null。  
  
 如需有關這個方法的詳細資訊，請參閱的 < 備註 > 的多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用兩個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>遞增整數的用戶端回撥案例的方法。  
  
 會顯示這兩個回呼機制;它們之間的差異是使用`context`參數。 A`ReceiveServerData1`用戶端回呼函式使用提供`context`參數。 相反地，`ReceiveServerData2`用戶端回呼函式定義於`<script>`頁面上的區塊。 A<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法是遞增的值傳遞給它的伺服器處理常式和<xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A>方法會傳回遞增後的值做為字串。 如果<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法會傳回錯誤，則用戶端函式`ProcessCallBackError`呼叫。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">處理用戶端回呼的伺服器 <see cref="T:System.Web.UI.Control" />。 控制項必須實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面並提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">從用戶端指令碼傳遞到伺服器 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法的引數。</param>
        <param name="clientCallback">會接收成功的伺服器事件結果的用戶端事件處理常式名稱。</param>
        <param name="context">在啟始回呼 (Callback) 之前，於用戶端上評估的用戶端指令碼。 指令碼的結果會傳回給用戶端事件處理常式。</param>
        <param name="clientErrorCallback">當伺服器事件處理常式發生錯誤時，接收結果之用戶端事件處理常式的名稱。</param>
        <param name="useAsync">
          <see langword="true" /> 表示非同步執行回呼，<see langword="false" /> 表示同步執行回呼。</param>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。 這個多載方法的用戶端函式包含指定的控制項、引數、用戶端指令碼、內容、錯誤處理常式和布林值。</summary>
        <returns>叫用用戶端回呼的用戶端函式名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法需要`useAsync`和`clientErrorCallback`參數。 `useAsync`參數可讓您藉由將值設定為以非同步方式執行用戶端回呼`true`。 這個方法的多載版本，不需要`useAsync`參數的值設定為`false`預設。 `clientErrorCallback`參數可讓您定義的用戶端呼叫函式是名稱的伺服器處理常式 (<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法) 會傳回錯誤。 這個方法的多載版本，不需要`clientErrorCallback`參數將值設定為 null。  
  
 如需有關這個方法的詳細資訊，請參閱的 < 備註 > 的多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得可用於用戶端事件中的參考 (其開頭附加了 <see langword="javascript:" />)，以回傳給伺服器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">用來處理回傳的伺服器控制項。</param>
        <param name="argument">傳遞給伺服器控制項的參數。</param>
        <summary>取得可用於用戶端事件中的參考，並附加 <see langword="javascript:" /> 至其開頭，針對指定控制項並以指定事件引數回傳給伺服器。</summary>
        <returns>字串，表示對包含目標控制項 ID 和事件引數之回傳函式的 JavaScript 呼叫。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法需要處理來實作回傳的控制項<xref:System.Web.UI.IPostBackEventHandler>介面。 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>方法。 自訂控制項， `MyControl`，會實作<xref:System.Web.UI.IPostBackEventHandler>介面。 按一下頁面上的 HTML 錨定項目時，<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>叫用自訂控制項的方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 下列程式碼範例具有相同的功能，與前一個，而不是自訂的控制項，只不過<xref:System.Web.UI.Page>類別會實作<xref:System.Web.UI.IPostBackEventHandler>介面。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">用來處理回傳的伺服器控制項。</param>
        <param name="argument">傳遞給伺服器控制項的參數。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 表示註冊回傳事件以進行驗證，<see langword="false" /> 表示不註冊回傳事件以進行驗證。</param>
        <summary>取得可用於用戶端事件中的參考 (其開頭附加了 <see langword="javascript:" />)，針對指定控制項，以指定的事件引數和布林值 (指示是否註冊事件驗證的回傳) 回傳給伺服器。</summary>
        <returns>字串，表示對包含目標控制項 ID 和事件引數之回傳函式的 JavaScript 呼叫。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法需要處理來實作回傳的控制項<xref:System.Web.UI.IPostBackEventHandler>介面。 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回字串，該字串可用於用戶端事件中造成回傳給伺服器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">定義回傳的 <see cref="T:System.Web.UI.PostBackOptions" />。</param>
        <summary>傳回字串，該字串可用於用戶端事件中造成回傳給伺服器。 指定的 <see cref="T:System.Web.UI.PostBackOptions" /> 執行個體會定義參考字串。</summary>
        <returns>視為用戶端上的指令碼時，啟始用戶端回傳的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可以搭配<xref:System.Web.UI.WebControls.Button>控制何時<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性是`false`。 在此案例中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>用戶端回傳事件的方法會傳回<xref:System.Web.UI.WebControls.Button>控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">在伺服器上處理回傳的伺服器 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="argument">傳遞至處理回傳之控制項的選擇性引數字串。</param>
        <summary>傳回字串，該字串可用於用戶端事件中造成回傳給伺服器。 參考字串是由處理回傳的指定控制項和其他事件資訊的字串引數所定義。</summary>
        <returns>視為用戶端上的指令碼時，啟始回傳的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可以搭配<xref:System.Web.UI.WebControls.Button>控制何時<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性是`false`。 在此案例中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>用戶端回傳事件的方法會傳回<xref:System.Web.UI.WebControls.Button>控制項。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法。 自訂控制項， `MyControl`，會實作<xref:System.Web.UI.IPostBackEventHandler>介面。 按一下頁面上的按鈕時，<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>叫用自訂控制項的方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 下列程式碼範例具有相同的功能，與前一個，而不是自訂的控制項，只不過<xref:System.Web.UI.Page>類別會實作<xref:System.Web.UI.IPostBackEventHandler>介面。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">定義回傳的 <see cref="T:System.Web.UI.PostBackOptions" />。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 表示註冊事件參考以進行驗證，否則為 <see langword="false" />。</param>
        <summary>傳回字串，該字串可用於用戶端事件中造成回傳給伺服器。 指定的 <see cref="T:System.Web.UI.PostBackOptions" /> 物件會定義參考字串。 或者，註冊事件參考以進行驗證。</summary>
        <returns>視為用戶端上的指令碼時，啟始用戶端回傳的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>物件，請使用指示詞。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可以搭配<xref:System.Web.UI.WebControls.Button>控制何時<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性是`false`。 在此案例中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>用戶端回傳事件的方法會傳回<xref:System.Web.UI.WebControls.Button>控制項。  
  
 如果`registerForEventValidation`已`true`，則<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>方法呼叫<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>方法，以註冊事件參考以進行驗證，使用唯一的控制項 ID，表示已產生事件的用戶端控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">在伺服器上處理回傳的伺服器 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="argument">要傳遞至 <c>控制項</c> 的選擇性引數字串。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 表示註冊事件參考以進行驗證，否則為 <see langword="false" />。</param>
        <summary>傳回字串，以用於用戶端事件中造成回傳給伺服器。 參考字串是由處理回傳的指定控制項和其他事件資訊的字串引數所定義。 或者，註冊事件參考以進行驗證。</summary>
        <returns>視為用戶端上的指令碼時，啟始回傳的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可以搭配<xref:System.Web.UI.WebControls.Button>控制何時<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性是`false`。 在此案例中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>用戶端回傳事件的方法會傳回<xref:System.Web.UI.WebControls.Button>控制項。  
  
 如果`registerForEventValidation`為 true，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>方法呼叫<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>方法，以註冊事件參考以進行驗證，使用唯一的控制項 ID，表示已產生事件的用戶端控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">資源的型別。</param>
        <param name="resourceName">組件中資源的完整名稱。</param>
        <summary>取得對組件中資源的 URL 參考。</summary>
        <returns>對資源的 URL 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>方法會傳回內嵌於組件中資源的 URL 參考。 傳回的參考不是 URL 編碼。 資源可以是指令碼檔案、 影像或任何靜態檔案。 您指定將用來存取資源的物件為基礎的類型。  
  
 向頁面的 Web 資源是唯一識別由型別和名稱。 一項資源只能與一組指定的型別和名稱組合可以向頁面註冊。 嘗試註冊已註冊的資源不會建立重複的已註冊的資源。  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>方法可搭配<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法來存取資源內嵌於組件。 如需有關如何在應用程式中使用資源的詳細資訊，請參閱[ASP.NET Web Page Resources Overview](http://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd)。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>方法。 *型別*在此範例中的參數設定為包含資源的組件中類別的型別。 `resourceName`參數指定了資源，其中包含預設命名空間的完整路徑。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 下列程式碼範例示範如何以程式設計方式套用<xref:System.Web.UI.WebResourceAttribute>中繼資料屬性來標記將會提供資源的組件。 編譯具有設定為預設命名空間的類別庫中的下列類別`Samples.AspNet.CS.Controls`或`Samples.AspNet.VB.Controls`，取決於您使用何種語言。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 這個範例需要名為的 JavaScript 檔案`Script_include.js`。 .Js 檔案是包含的組件中的內嵌的資源`ClientScriptResourceLabel`物件。 如果您使用 Visual Studio]，在 [類別庫專案的 [屬性] 視窗中，設定**建置動作**要**內嵌資源**選取指令碼檔案時。 如果您正在編譯的程式庫，在命令列，使用切換內嵌資源。  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Web 資源名稱為 <see langword="null" />。  
  
\-或- 
Web 資源名稱長度為零。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷用戶端指令碼區塊是否向 <see cref="T:System.Web.UI.Page" /> 物件註冊過。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜尋的用戶端指令碼區塊索引鍵。</param>
        <summary>判斷用戶端指令碼區塊是否已使用指定的索引鍵，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>如果此用戶端指令碼區塊已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，以避免註冊重複的指令碼。 這是特別重要，如果指令碼需要大量伺服器資源來建立。  
  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法會呼叫多載，兩者`key`並`type`類型的參數設定為<xref:System.Web.UI.Page>物件  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜尋的用戶端指令碼區塊型別。</param>
        <param name="key">要搜尋的用戶端指令碼區塊索引鍵。</param>
        <summary>判斷用戶端指令碼區塊是否已使用指定的索引鍵和型別，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>如果此用戶端指令碼區塊已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，以避免註冊重複的指令碼。 這是特別重要，如果指令碼需要大量伺服器資源來建立。  
  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。 您指定將用來存取資源的物件為基礎的類型。 比方說，使用時`Page`執行個體，以存取資源，您指定`Page`型別。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法。 請注意，是否已移除的邏輯，以檢查是否有現有的用戶端指令碼區塊，則不會兩個重複的用戶端指令碼中呈現之網頁的 HTML 原始碼因為<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法檢查是否有重複的項目。 檢查的優點是減少不必要的計算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端指令碼型別為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷用戶端指令碼 Include 是否向 <see cref="T:System.Web.UI.Page" /> 物件註冊過。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜尋的用戶端指令碼 Include 索引鍵。</param>
        <summary>判斷用戶端指令碼 Include 是否已使用指定的索引鍵，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>如果用戶端指令碼 Include 已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法，以避免註冊重複的指令碼。 這是特別重要，如果指令碼需要大量伺服器資源來建立。  
  
 用戶端指令碼包含可唯一識別其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法會呼叫多載，兩者`key`並`type`類型的參數設定為<xref:System.Web.UI.Page>物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜尋的用戶端指令碼 Include 型別。</param>
        <param name="key">要搜尋的用戶端指令碼 Include 索引鍵。</param>
        <summary>判斷用戶端指令碼 Include 是否已使用指定的索引鍵和型別，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>如果用戶端指令碼 Include 已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>包含方法，以避免註冊重複的用戶端指令碼。 這是特別重要，如果指令碼需要大量伺服器資源來建立。  
  
 用戶端指令碼包含可唯一識別其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。 您指定將用來存取資源的物件為基礎的類型。 比方說，當使用 Page 執行個體來存取資源，您指定`Page`型別。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A>方法。 請注意，是否要檢查是否有現有的用戶端指令碼包含的邏輯會被移除，則不會兩個重複的用戶端指令碼中呈現之網頁的 HTML 原始碼因為<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法檢查是否有重複的項目。 檢查的優點是減少不必要的計算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 這個範例需要名為的 JavaScript 檔案`Script_include.js`，使用下列內容：  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端指令碼 Include 型別為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷 OnSubmit 陳述式是否向 <see cref="T:System.Web.UI.Page" /> 物件註冊過。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜尋的 OnSubmit 陳述式索引鍵。</param>
        <summary>判斷 OnSubmit 陳述式是否已使用指定的索引鍵，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>如果 OnSubmit 陳述式已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法，以避免註冊重複的 OnSubmit 陳述式。 這是特別重要，如果陳述式就需要大量伺服器資源來建立。  
  
 陳述式是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的陳述式會被視為重複。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法會呼叫多載，兩者`key`並`type`類型的參數設定為<xref:System.Web.UI.Page>物件  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜尋的 OnSubmit 陳述式類型。</param>
        <param name="key">要搜尋的 OnSubmit 陳述式索引鍵。</param>
        <summary>判斷 OnSubmit 陳述式是否已使用指定的索引鍵和類型，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>如果 OnSubmit 陳述式已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法，以避免註冊重複的陳述式。 這是特別重要，如果陳述式就需要大量伺服器資源來建立。  
  
 陳述式是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的陳述式會被視為重複。 您指定將用來存取資源的物件為基礎的類型。 比方說，使用時`Page`執行個體，以存取資源，您指定`Page`型別。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法。 名為指令碼`OnSubmitScript`已向<xref:System.Web.UI.Page>使頁面的表單時送出指令碼會叫用。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">OnSubmit 陳述式類型為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷啟始指令碼是否向 <see cref="T:System.Web.UI.Page" /> 物件註冊過。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜尋的啟始指令碼索引鍵。</param>
        <summary>判斷啟始指令碼是否已使用指定的索引鍵，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>如果啟始指令碼已登錄，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，以避免註冊重複的指令碼。 這是特別重要，如果指令碼需要大量伺服器資源來建立。  
  
 啟動指令碼是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法會呼叫採用兩個字串的多載`key`並`type`類型的參數設定為<xref:System.Web.UI.Page>物件  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜尋的啟始指令碼型別。</param>
        <param name="key">要搜尋的啟始指令碼索引鍵。</param>
        <summary>判斷啟始指令碼是否已使用指定的索引鍵和型別，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>如果啟始指令碼已登錄，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前呼叫<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，以避免註冊重複的指令碼。 這是特別重要，如果指令碼需要大量伺服器資源來建立。  
  
 用戶端啟動指令碼是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法。 請注意，是否已移除的邏輯，以檢查是否有現有的啟動指令碼區塊，則不會兩個重複的啟動指令碼中呈現之網頁的 HTML 原始碼因為<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法檢查是否有重複的項目。 檢查的優點是減少不必要的計算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">啟始指令碼型別為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">要註冊的陣列名稱。</param>
        <param name="arrayValue">要註冊的一或多個陣列值。</param>
        <summary>使用陣列名稱和陣列值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊 JavaScript 陣列宣告。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>檢查，以查看已註冊的陣列是否存在具有相同名稱中指定的名稱作為`arrayName`參數，如果是的話，將指定的值`arrayValue`參數。 因為基礎儲存機制根據<xref:System.Collections.ArrayList>，允許重複的項目。 如果具有相同名稱的已註冊陣列`arrayName`參數不存在，則會建立和中的值`arrayValue`加入它的參數。  
  
 如果您想產生 JavaScript 陣列中的字串常值，包含單引號 （'） 或雙引號逸出字元 (\\") 中`arrayValue`參數。 值`arrayValue`參數應該是單一項目。 如果可以加入至陣列需要一個以上的值，請使用多個呼叫<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>和<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法。 這個範例會註冊隱藏的值和陣列，定義`OnClick`事件的`<input>`按鈕來計算兩個值的陣列和隱藏的值的總和。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> 為 <see langword="null" />。</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的用戶端指令碼型別。</param>
        <param name="key">要註冊的用戶端指令碼索引鍵。</param>
        <param name="script">要註冊的用戶端指令碼常值。</param>
        <summary>使用型別、索引鍵和指令碼常值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。 使用指定的型別和金鑰組的只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立重複的指令碼。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法來判斷是否與指定的索引鍵和類型配對的用戶端指令碼是否已經註冊，並避免不必要地嘗試要加入指令碼。  
  
 中的這個多載<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法中，您必須確定提供的指令碼`script`參數會包裝在`<script>`項目區塊。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法會將指令碼區塊加入到所呈現頁面的頂端。 指令碼區塊不保證會在它們所註冊的順序中的輸出。 如果指令碼區塊的順序很重要，使用<xref:System.Text.StringBuilder>物件來收集在單一字串中，指令碼，並再註冊它們全都放在單一用戶端指令碼區塊。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的用戶端指令碼型別。</param>
        <param name="key">要註冊的用戶端指令碼索引鍵。</param>
        <param name="script">要註冊的用戶端指令碼常值。</param>
        <param name="addScriptTags">表示是否加入指令碼標記的布林值。</param>
        <summary>使用型別、索引鍵、指令碼常值，以及表示是否加入指令碼標記的布林值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。 使用指定的型別和金鑰組的只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立重複的指令碼。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法，以判斷是否已註冊的用戶端指令碼，使用指定的索引鍵和類型配對。 這可讓您避免不必要地嘗試要加入指令碼。  
  
 中的這個多載<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法中，您可以指出是否在提供的指令碼`script`參數以包裝`<script>`使用的項目區塊`addScriptTags`參數。 設定`addScriptTags`至`true`指出指令碼標記會自動新增。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法會將指令碼區塊加入到所呈現頁面的頂端。 指令碼區塊不保證會在它們所註冊的順序中的輸出。 如果指令碼區塊的順序很重要，使用<xref:System.Text.StringBuilder>物件來收集在單一字串中，指令碼，並再註冊它們全都放在單一用戶端指令碼區塊。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法。 請注意，`addScriptTags`參數設定為`true`因此開頭和結尾的指令碼標記鼛痡獍旓`script`參數。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端指令碼區塊型別為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼 Include。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要註冊的用戶端指令碼 Include 索引鍵。</param>
        <param name="url">要註冊的用戶端指令碼 Include URL。</param>
        <summary>使用索引鍵和 URL 在 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼，讓您能夠從用戶端呼叫此指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端指令碼包含可唯一識別其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。 使用指定的型別和金鑰組的只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立重複的指令碼。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A>方法，以判斷是否用戶端指令碼包含具有指定索引鍵和類型配對的已註冊，而避免不必要地嘗試要加入指令碼。  
  
> [!NOTE]
>  若要解決用戶端的 URL，請使用<xref:System.Web.UI.Control.ResolveClientUrl%2A>方法。 這個方法會使用的 URL 在其呼叫它來解析路徑的內容。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法會呼叫採用的多載`key`，則`URL`，和`type`參數。  
  
 方法呈現頁面的頂端處新增 指令碼區塊。  
  
   
  
## Examples  
 如需相關資訊，包括語法、 使用方式和範例，請參閱<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的用戶端指令碼 Include 型別。</param>
        <param name="key">要註冊的用戶端指令碼 Include 索引鍵。</param>
        <param name="url">要註冊的用戶端指令碼 Include URL。</param>
        <summary>使用型別、索引鍵和 URL，向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼 Include。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法會採用*金鑰*並*url*參數來識別指令碼，以及`type`包含參數來指定用戶端指令碼的識別。 您指定將用來存取資源的物件為基礎的類型。 比方說，使用時`Page`執行個體，以存取資源，您指定`Page`型別。  
  
> [!NOTE]
>  若要解決用戶端的 URL，請使用<xref:System.Web.UI.Control.ResolveClientUrl%2A>方法。 這個方法會使用的 URL 在其呼叫它來解析路徑的內容。  
  
 這個方法會將指令碼區塊，在呈現頁面的頂端。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法。 請注意，是否已移除的邏輯，以檢查是否有現有的用戶端指令碼 include，仍不會重複的用戶端指令碼在呈現的頁面因為<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法檢查是否有重複的項目。 檢查的優點是減少不必要的計算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 這個範例需要名 Script_include.js 為含有下列內容的 JavaScript 檔案：  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端指令碼 Include 型別為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">URL 為 <see langword="null" />。  
  
\-或- 
URL 是空的。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的用戶端指令碼資源類別。</param>
        <param name="resourceName">要註冊的用戶端指令碼資源名稱。</param>
        <summary>使用型別和資源名稱，向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>從透過 WebResource.axd HTTP 處理常式的組件存取編譯中的資源時，使用方法。 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法註冊的指令碼<xref:System.Web.UI.Page>物件，並可防止重複的指令碼。 這個方法會包裝的內容使用的資源 URL`<script>`項目區塊。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 下列程式碼範例示範如何以程式設計方式套用<xref:System.Web.UI.WebResourceAttribute>中繼資料屬性來標記將會提供資源的組件。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 這個範例需要名為的 JavaScript 檔案`Script_include.js`，使用下列內容：  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 編譯`Script_include.js`檔案中的資源作為`Samples.AspNet.CS.Controls`包含組件`ClientScriptResourceLabel`類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端資源名稱為 <see langword="null" />。  
  
\-或- 
用戶端資源名稱長度為零。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將名稱/值組註冊為指定之控制項的自訂 (Expando) 屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">網頁上包含自訂屬性的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="attributeName">要註冊的自訂屬性名稱。</param>
        <param name="attributeValue">自訂屬性的值。</param>
        <summary>使用控制項 ID、屬性名稱和屬性值，將名稱/值組註冊為指定之控制項的自訂 (Expando) 屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法註冊為指定的自訂 (expando) 屬性的名稱/值組<xref:System.Web.UI.Control>。 Expando 屬性是動態設定從 JavaScript 以保留呈現的控制項標記的 XHTML 相容性。 引號和自訂 (expando) 屬性的值中的反斜線會逸出。 如果您不想要逸出引號和反斜線，呼叫<xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>多載方法，並設定`encode`參數來`false`。  
  
 如果找不到 expando 屬性，或找不到要加入的 expando 屬性的控制項，仍會發出用戶端指令碼，但它不會影響控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">網頁上包含自訂屬性的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="attributeName">要註冊的自訂屬性名稱。</param>
        <param name="attributeValue">自訂屬性的值。</param>
        <param name="encode">表示是否對要註冊之自訂屬性進行編碼的布林值。</param>
        <summary>使用控制項 ID、屬性名稱、屬性值，以及表示是否編碼屬性值的布林值，將名稱/值組註冊為指定之控制項的自訂 (Expando) 屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法註冊為指定的自訂 (expando) 屬性的名稱/值組<xref:System.Web.UI.Control>。 Expando 屬性是動態設定從 JavaScript 以保留呈現的控制項標記的 XHTML 相容性。 設定`encode`參數來`true`如果您需要逸出引號和反斜線 expando 屬性的值。  
  
 如果找不到 expando 屬性，或找不到要加入的 expando 屬性的控制項，仍會發出用戶端指令碼，但它不會影響控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法的<xref:System.Web.UI.ClientScriptManager>類別。 中呈現的網頁設定用戶端指令碼`title`屬性的`<span>`項目。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>註冊事件參考以進行驗證。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">唯一的 ID，表示產生事件的用戶端控制項。</param>
        <summary>使用唯一的控制項 ID (表示產生事件的用戶端控制項) 註冊事件參考以進行驗證。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊和範例，請參閱<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>方法，以註冊驗證，以及如何驗證回呼來自網頁的回呼。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.Web.UI.PostBackOptions" /> 物件，指定產生用戶端 JavaScript 以啟始回傳事件的方式。</param>
        <summary>使用 <see cref="T:System.Web.UI.PostBackOptions" /> 註冊事件參考以進行驗證。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊和範例，請參閱<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">唯一的 ID，表示產生事件的用戶端控制項。</param>
        <param name="argument">隨用戶端事件傳遞的事件引數。</param>
        <summary>使用唯一的控制項 ID 和事件引數 (表示產生事件的用戶端控制項) 註冊事件參考以進行驗證。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>註冊回呼，以進行驗證和驗證回呼來自網頁的方法。 若要改善範例所示的驗證，您可以修改驗證`argument`參數，以包含特定的使用者，例如識別或角色資訊  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>註冊回呼，以進行驗證的方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個方法會在 <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> 方法之前呼叫。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">要註冊的隱藏欄位名稱。</param>
        <param name="hiddenFieldInitialValue">要註冊的欄位初始值。</param>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 物件註冊隱藏值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法會建立隱藏`<input>`轉譯的 HTML 網頁上的項目。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>和<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法。 這個範例會註冊隱藏的值和陣列，定義`OnClick`事件的`<input>`按鈕來計算兩個值的陣列和隱藏的值的總和。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hiddenFieldName" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的 OnSubmit 陳述式類型。</param>
        <param name="key">要註冊的 OnSubmit 陳述式索引鍵。</param>
        <param name="script">要註冊的 OnSubmit 陳述式指令碼常值。</param>
        <summary>使用類型、索引鍵和指令碼常值 (Literal)，向 <see cref="T:System.Web.UI.Page" /> 物件註冊 OnSubmit 陳述式。 當送出 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> 時，會執行該陳述式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 OnSubmit 陳述式是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的陳述式會被視為重複。 使用指定的型別和金鑰組的單獨一個陳述式可以向頁面。 嘗試註冊已註冊的陳述式將不會建立重複的陳述式。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法來判斷是否已經註冊的 OnSubmit 陳述式與指定的索引鍵和類型配對，並避免不必要地嘗試要加入指令碼。  
  
 `script`參數<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法可以包含多個指令碼命令，只要它們是正確使用分號 （;） 分隔。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>將頁面送出，並讓您有機會，若要取消提交之前執行的指令碼。  
  
 如需有關 HTML 表單，`OnSubmit`屬性，請參閱[World Wide Web Consortium (W3C) 網站](http://go.microsoft.com/fwlink/?linkid=37125)。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 物件註冊啟始指令碼。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的啟始指令碼型別。</param>
        <param name="key">要註冊的啟始指令碼索引鍵。</param>
        <param name="script">要註冊的啟始指令碼常值。</param>
        <summary>使用型別、索引鍵和指令碼常值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊啟始指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。 使用指定的型別和金鑰組的只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立重複的指令碼。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法來判斷是否與指定的索引鍵和類型配對的啟動指令碼是否已經註冊，並避免不必要地嘗試要加入指令碼。  
  
 中的這個多載<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法中，您必須確定提供的指令碼`script`參數會包裝與`<script>`項目區塊。  
  
 新增指令碼區塊<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法執行時頁面載入完成後，但頁面之前<xref:System.Web.UI.Control.OnLoad%2A>就會引發事件。 指令碼區塊不保證會在它們所註冊的順序中的輸出。 如果指令碼區塊的順序很重要，使用<xref:System.Text.StringBuilder>物件來收集在單一字串中，指令碼，並再註冊它們全都放在單一用戶端指令碼區塊。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。 請注意，開頭和結尾的指令碼標記會納入`script`參數。 若要讓指令碼標記加入額外的參數設定，請參閱<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的啟始指令碼型別。</param>
        <param name="key">要註冊的啟始指令碼索引鍵。</param>
        <param name="script">要註冊的啟始指令碼常值。</param>
        <param name="addScriptTags">表示是否加入指令碼標記的布林值。</param>
        <summary>使用型別、索引鍵、指令碼常值，以及表示是否加入指令碼標記的布林值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊啟始指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 啟動指令碼是唯一識別由其索引鍵和其類型。 具有相同的索引鍵和類型的指令碼會被視為重複。 使用指定的型別和金鑰組的只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立重複的指令碼。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法來判斷是否與指定的索引鍵和類型配對的啟動指令碼是否已經註冊，並避免不必要地嘗試要加入指令碼。  
  
 中的這個多載<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法中，您可以指出是否在提供的指令碼`script`參數以包裝`<script>`使用的項目區塊`addScriptTags`參數。 設定`addScriptTags`至`true`指出指令碼標記會自動新增。  
  
 新增指令碼區塊<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法執行時頁面載入完成後，但頁面之前<xref:System.Web.UI.Control.OnLoad%2A>就會引發事件。 指令碼區塊不保證會在它們所註冊的順序中的輸出。 如果指令碼區塊的順序很重要，使用<xref:System.Text.StringBuilder>物件來收集在單一字串中，指令碼，並再註冊它們全都放在單一用戶端指令碼區塊。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。 請注意，`addScriptTags`參數設定為`false`因此開頭和結尾的指令碼標記會隨附`script`參數。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>驗證用戶端事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">唯一的 ID，表示產生事件的用戶端控制項。</param>
        <summary>驗證使用 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> 方法註冊以進行事件驗證的用戶端事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">唯一的 ID，表示產生事件的用戶端控制項。</param>
        <param name="argument">隨用戶端事件傳遞的事件引數。</param>
        <summary>驗證使用 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> 方法註冊以進行事件驗證的用戶端事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>註冊回呼，以進行驗證和驗證回呼來自網頁的方法。 若要改善的驗證，如下所示，您可以修改驗證`argument`參數，以包含特定的使用者，例如識別或角色資訊  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uniqueId" /> 為 <see langword="null" /> 或空字串 ("")。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>