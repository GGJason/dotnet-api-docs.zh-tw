<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e19ff5181caa07c458ad6ff38334f4d37a7d0917" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31910618" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>定義用來管理 Web 應用程式中用戶端指令碼的方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager>類別用來管理用戶端指令碼，並將它們加入至 Web 應用程式。 您可以取得的參考<xref:System.Web.UI.ClientScriptManager>類別從<xref:System.Web.UI.Page.ClientScript%2A>屬性<xref:System.Web.UI.Page>物件。  
  
 您可以將用戶端指令碼加入網頁以宣告方式在頁面的 HTML 標記中包含指令碼。 不過，有很多情況下以動態方式加入用戶端指令碼會在需要時。 若要以動態方式加入指令碼，使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法，<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，或<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法，會根據時間和方式想要新增指令碼。 如需詳細資訊，請參閱[如何： 加入用戶端指令碼以動態方式以 ASP.NET Web Pages](http://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666)。  
  
 <xref:System.Web.UI.ClientScriptManager>類別唯一識別指令碼，依索引鍵<xref:System.String>和<xref:System.Type>。 具有相同索引鍵和類型的指令碼會被視為重複。 使用指令碼類型有助於避免混淆類似的指令碼可能會在頁面上的使用中的不同使用者控制項。  
  
 <xref:System.Web.UI.ClientScriptManager>類別可以用來叫用用戶端回呼的情況下，最好從用戶端執行伺服端程式碼，但未執行回傳時。 這被指執行超出訊號範圍回呼伺服器。 在用戶端回呼，用戶端指令碼函式會傳送至 ASP.NET 網頁的非同步要求。 Web 網頁會執行其一般生命週期的修改的版本，以處理回呼。 使用<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法，以取得用戶端函式的參考，叫用時，會起始伺服器事件的用戶端回呼。 如需詳細資訊，請參閱[實作用戶端回呼而不回傳](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)。  
  
> [!NOTE]
>  回呼指令碼將無法用在舊的瀏覽器不支援文件物件模型 (DOM)，以及它們需要 ECMAScript 已啟用用戶端上。 若要檢查瀏覽器是否支援回呼，請使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>屬性，可透過存取<xref:System.Web.HttpRequest.Browser%2A>屬性的內建 ASP.NET<xref:System.Web.HttpContext.Request%2A>物件。  
  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法和<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>方法，以定義用戶端的回傳事件。 這些方法可讓用戶端指令碼函式，當叫用，會導致回傳至網頁伺服器。 用戶端的回傳事件不同的是從用戶端回呼網頁完成一般生命週期，以處理用戶端回傳事件。  
  
> [!NOTE]
>  如果您使用<xref:System.Web.UI.WebControls.Button>控制項和<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性設定為`false`，則您可以使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法以傳回用戶端回傳事件<xref:System.Web.UI.WebControls.Button>控制項。  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A>屬性<xref:System.Web.UI.WebControls.Button>控制項，<xref:System.Web.UI.WebControls.ImageButton>控制項和<xref:System.Web.UI.WebControls.LinkButton>控制項可以用來執行用戶端指令碼。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法<xref:System.Web.UI.ClientScriptManager>類別。 頁中所定義的兩個用戶端指令碼： `PopupScript`，載入頁面時，顯示警示訊息和`ButtonClickScript`，而後者可定義用戶端的處理常式的 HTML 按鈕`onClick`事件。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">處理用戶端回呼的伺服器 <see cref="T:System.Web.UI.Control" />。 控制項必須實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面並提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">從用戶端指令碼傳遞到伺服器的引數  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">會接收成功的伺服器事件結果的用戶端事件處理常式名稱。</param>
        <param name="context">在啟始回呼 (Callback) 之前，於用戶端上評估的用戶端指令碼。 指令碼的結果會傳回給用戶端事件處理常式。</param>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。 這個多載方法的用戶端函式包含指定的控制項、引數、用戶端指令碼和內容。</summary>
        <returns>叫用用戶端回呼的用戶端函式名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29>方法會執行的頻外回呼伺服器頁面的一般生命週期的已修改的版本。 如需詳細資訊，請參閱[實作用戶端回呼而不回傳](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)。  
  
> [!NOTE]
>  Microsoft Internet Explorer （5.0 或更新版本） 瀏覽器時，指令碼回呼機制透過 Microsoft.XmlHttp COM 物件實作，而且需要瀏覽器設為 執行 ActiveX 控制項。 會使用其他瀏覽器，XMLHttpRequest 使用瀏覽器的本機文件物件模型 (DOM)。 若要檢查瀏覽器是否支援用戶端回呼，請使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>屬性。 若要檢查瀏覽器是否支援透過 HTTP 的 XML，請使用<xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A>屬性。 兩個屬性都可透過存取<xref:System.Web.HttpRequest.Browser%2A>屬性的內建 ASP.NET<xref:System.Web.HttpContext.Request%2A>物件。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法會執行以同步方式透過 HTTP 使用 XML 的回呼。 當回呼案例中，以同步方式傳送資料，同步回呼就會立即傳回，而不會封鎖瀏覽器。 同步沒有兩個回呼可以在瀏覽器中同時執行。 如果第二個同步回呼一經引發，而另一個是目前有擱置中，第二個同步回呼取消第一個，並會傳回第二個的回呼。  
  
 若要以非同步方式傳送資料，請使用其中一個多載採用`useAsync`參數，這是布林值，以控制此行為。 在非同步案例中，您可以有多個暫止的回呼。不過，它們傳回的順序不會保證以符合它們初始化的順序。  
  
 此外，這個多載的<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法會指定用戶端函式可處理所產生的錯誤狀況的情況<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法。 若要指定將用戶端錯誤回呼處理常式，請使用其中一個多載採用`clientErrorCallback`參數。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29>方法會採用選擇性字串`argument`參數並傳回字串。 中傳送或接收多個值，串連輸入中的值或字串，會分別傳回。  
  
> [!NOTE]
>  請避免使用指令碼回呼作業期間需要更新的網頁或控制項屬性的實作中的檢視狀態。 如果屬性不受網頁要求，您可以使用工作階段狀態。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用兩個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>遞增整數的用戶端回呼案例中的方法。  
  
 會顯示這兩個回撥機制;它們之間的差異，就是使用`context`參數。 A`ReceiveServerData1`用戶端的回呼函式會使用提供`context`參數。 相反地，`ReceiveServerData2`用戶端的回呼函式定義於`<script>`頁面上的區塊。 A<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法是遞增的值傳遞給它的伺服器處理常式和<xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A>方法會傳回字串形式遞增的值。 如果<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法會傳回錯誤，則`ProcessCallBackError`呼叫用戶端函式。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">處理用戶端回呼的伺服器 <see cref="T:System.Web.UI.Control" />。 控制項必須實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面並提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">從用戶端指令碼傳遞到伺服器的引數  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">會接收成功的伺服器事件結果的用戶端事件處理常式名稱。</param>
        <param name="context">在啟始回呼 (Callback) 之前，於用戶端上評估的用戶端指令碼。 指令碼的結果會傳回給用戶端事件處理常式。</param>
        <param name="useAsync">
          <see langword="true" /> 表示非同步執行回呼，<see langword="false" /> 表示同步執行回呼。</param>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。 這個多載方法的用戶端函式包含指定的控制項、引數、用戶端指令碼、內容和布林值。</summary>
        <returns>叫用用戶端回呼的用戶端函式名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法需要`useAsync`參數，可讓您以非同步方式將值設定為執行用戶端回呼`true`。 這個方法的多載版本，不需要`useAsync`參數將值設為`false`預設。  
  
 如需有關這個方法的詳細資訊，請參閱備註為多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">處理用戶端回呼之伺服器 <see cref="T:System.Web.UI.Control" /> 的名稱。 控制項必須實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面並提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">從用戶端指令碼傳遞到伺服器的引數  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="clientCallback">會接收成功的伺服器事件結果的用戶端事件處理常式名稱。</param>
        <param name="context">在啟始回呼 (Callback) 之前，於用戶端上評估的用戶端指令碼。 指令碼的結果會傳回給用戶端事件處理常式。</param>
        <param name="clientErrorCallback">當伺服器事件處理常式發生錯誤時，接收結果之用戶端事件處理常式的名稱。</param>
        <param name="useAsync">
          <see langword="true" /> 表示非同步執行回呼，<see langword="false" /> 表示同步執行回呼。</param>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。 這個多載方法的用戶端函式包含指定的目標、引數、用戶端指令碼、內容、錯誤處理常式和布林值。</summary>
        <returns>叫用用戶端回呼的用戶端函式名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法會採用`target`字串參數，而不是<xref:System.Web.UI.Control>參數。 當您想要回到以外的字串，包含回呼時，請使用此多載<xref:System.Web.UI.Control.UniqueID%2A>的控制項。  
  
 此外，這個多載的<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法需要`useAsync`和`clientErrorCallback`參數。 `useAsync`參數可讓您以非同步方式將值設定為執行用戶端回呼`true`。 這個方法的多載版本，不需要`useAsync`參數將值設為`false`預設。 `clientErrorCallback`參數可讓您定義時所呼叫的用戶端函式名稱的伺服器處理常式，<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法，這個方法會傳回錯誤。 這個方法的多載版本，不需要`clientErrorCallback`參數將值設定為 null。  
  
 如需有關這個方法的詳細資訊，請參閱備註為多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用兩個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>遞增整數的用戶端回呼案例中的方法。  
  
 會顯示這兩個回撥機制;它們之間的差異，就是使用`context`參數。 A`ReceiveServerData1`用戶端的回呼函式會使用提供`context`參數。 相反地，`ReceiveServerData2`用戶端的回呼函式定義於`<script>`頁面上的區塊。 A<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法是遞增的值傳遞給它的伺服器處理常式和<xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A>方法會傳回字串形式遞增的值。 如果<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法會傳回錯誤，則用戶端函式`ProcessCallBackError`呼叫。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">處理用戶端回呼的伺服器 <see cref="T:System.Web.UI.Control" />。 控制項必須實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面並提供 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法。</param>
        <param name="argument">從用戶端指令碼傳遞到伺服器 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 方法的引數。</param>
        <param name="clientCallback">會接收成功的伺服器事件結果的用戶端事件處理常式名稱。</param>
        <param name="context">在啟始回呼 (Callback) 之前，於用戶端上評估的用戶端指令碼。 指令碼的結果會傳回給用戶端事件處理常式。</param>
        <param name="clientErrorCallback">當伺服器事件處理常式發生錯誤時，接收結果之用戶端事件處理常式的名稱。</param>
        <param name="useAsync">
          <see langword="true" /> 表示非同步執行回呼，<see langword="false" /> 表示同步執行回呼。</param>
        <summary>取得用戶端函式的參考，這個函式會在叫用時，啟始對伺服器事件的用戶端回呼。 這個多載方法的用戶端函式包含指定的控制項、引數、用戶端指令碼、內容、錯誤處理常式和布林值。</summary>
        <returns>叫用用戶端回呼的用戶端函式名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法需要`useAsync`和`clientErrorCallback`參數。 `useAsync`參數可讓您以非同步方式將值設定為執行用戶端回呼`true`。 這個方法的多載版本，不需要`useAsync`參數將值設為`false`預設。 `clientErrorCallback`參數可讓您定義時所呼叫的用戶端函式名稱的伺服器處理常式 (<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>方法) 會傳回錯誤。 這個方法的多載版本，不需要`clientErrorCallback`參數將值設定為 null。  
  
 如需有關這個方法的詳細資訊，請參閱備註為多載<xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="T:System.Web.UI.Control" /> 未實作 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 介面。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得可用於用戶端事件中的參考 (其開頭附加了 <see langword="javascript:" />)，以回傳給伺服器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">用來處理回傳的伺服器控制項。</param>
        <param name="argument">傳遞給伺服器控制項的參數。</param>
        <summary>取得可用於用戶端事件中的參考，並附加 <see langword="javascript:" /> 至其開頭，針對指定控制項並以指定事件引數回傳給伺服器。</summary>
        <returns>字串，表示對包含目標控制項 ID 和事件引數之回傳函式的 JavaScript 呼叫。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法需要處理實作回傳的控制項<xref:System.Web.UI.IPostBackEventHandler>介面。 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>方法。 自訂控制項， `MyControl`，實作<xref:System.Web.UI.IPostBackEventHandler>介面。 按一下頁面上的 HTML 錨定項目時，<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>叫用方法的自訂控制項。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 下列程式碼範例具有相同的功能與前一個，而不是自訂控制項，除了<xref:System.Web.UI.Page>類別會實作<xref:System.Web.UI.IPostBackEventHandler>介面。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">用來處理回傳的伺服器控制項。</param>
        <param name="argument">傳遞給伺服器控制項的參數。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 表示註冊回傳事件以進行驗證，<see langword="false" /> 表示不註冊回傳事件以進行驗證。</param>
        <summary>取得可用於用戶端事件中的參考 (其開頭附加了 <see langword="javascript:" />)，針對指定控制項，以指定的事件引數和布林值 (指示是否註冊事件驗證的回傳) 回傳給伺服器。</summary>
        <returns>字串，表示對包含目標控制項 ID 和事件引數之回傳函式的 JavaScript 呼叫。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法需要處理實作回傳的控制項<xref:System.Web.UI.IPostBackEventHandler>介面。 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回字串，該字串可用於用戶端事件中造成回傳給伺服器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">定義回傳的 <see cref="T:System.Web.UI.PostBackOptions" />。</param>
        <summary>傳回字串，該字串可用於用戶端事件中造成回傳給伺服器。 指定的 <see cref="T:System.Web.UI.PostBackOptions" /> 執行個體會定義參考字串。</summary>
        <returns>視為用戶端上的指令碼時，啟始用戶端回傳的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可以與使用<xref:System.Web.UI.WebControls.Button>負責控制何時<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性是`false`。 在此案例中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法會傳回用戶端回傳事件<xref:System.Web.UI.WebControls.Button>控制項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">在伺服器上處理回傳的伺服器 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="argument">傳遞至處理回傳之控制項的選擇性引數字串。</param>
        <summary>傳回字串，該字串可用於用戶端事件中造成回傳給伺服器。 參考字串是由處理回傳的指定控制項和其他事件資訊的字串引數所定義。</summary>
        <returns>視為用戶端上的指令碼時，啟始回傳的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可以與使用<xref:System.Web.UI.WebControls.Button>負責控制何時<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性是`false`。 在此案例中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法會傳回用戶端回傳事件<xref:System.Web.UI.WebControls.Button>控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法。 自訂控制項， `MyControl`，實作<xref:System.Web.UI.IPostBackEventHandler>介面。 按一下頁面上的按鈕時，<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>叫用方法的自訂控制項。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 下列程式碼範例具有相同的功能與前一個，而不是自訂控制項，除了<xref:System.Web.UI.Page>類別會實作<xref:System.Web.UI.IPostBackEventHandler>介面。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">定義回傳的 <see cref="T:System.Web.UI.PostBackOptions" />。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 表示註冊事件參考以進行驗證，否則為 <see langword="false" />。</param>
        <summary>傳回字串，該字串可用於用戶端事件中造成回傳給伺服器。 指定的 <see cref="T:System.Web.UI.PostBackOptions" /> 物件會定義參考字串。 或者，註冊事件參考以進行驗證。</summary>
        <returns>視為用戶端上的指令碼時，啟始用戶端回傳的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>物件，請使用指示詞。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可以與使用<xref:System.Web.UI.WebControls.Button>負責控制何時<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性是`false`。 在此案例中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法會傳回用戶端回傳事件<xref:System.Web.UI.WebControls.Button>控制項。  
  
 如果`registerForEventValidation`是`true`、<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>方法呼叫<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>方法，使用唯一的控制項 ID 表示已產生事件的用戶端控制項登錄事件參考以進行驗證。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">在伺服器上處理回傳的伺服器 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="argument">要傳遞至 <c>控制項</c> 的選擇性引數字串。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 表示註冊事件參考以進行驗證，否則為 <see langword="false" />。</param>
        <summary>傳回字串，以用於用戶端事件中造成回傳給伺服器。 參考字串是由處理回傳的指定控制項和其他事件資訊的字串引數所定義。 或者，註冊事件參考以進行驗證。</summary>
        <returns>視為用戶端上的指令碼時，啟始回傳的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要實作<xref:System.Web.UI.IPostBackEventHandler>介面<xref:System.Web.UI.Page>，使用指示詞。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法可以與使用<xref:System.Web.UI.WebControls.Button>負責控制何時<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>屬性是`false`。 在此案例中，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>方法會傳回用戶端回傳事件<xref:System.Web.UI.WebControls.Button>控制項。  
  
 如果`registerForEventValidation`為 true，<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>方法呼叫<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>方法，使用唯一的控制項 ID 表示已產生事件的用戶端控制項登錄事件參考以進行驗證。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定的 <see cref="T:System.Web.UI.Control" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">資源的型別。</param>
        <param name="resourceName">組件中資源的完整名稱。</param>
        <summary>取得對組件中資源的 URL 參考。</summary>
        <returns>對資源的 URL 參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>方法傳回其 URL 參考的組件中內嵌資源。 傳回的參考不是 URL 編碼。 資源可以是指令碼檔案、 影像或任何靜態檔案。 您指定將用來存取資源的物件為基礎的類型。  
  
 註冊頁面的 Web 資源是唯一識別由型別和名稱。 使用指定的型別和名稱組合只能有一個資源可以向頁面。 嘗試註冊已註冊的資源不會建立重複的已註冊的資源。  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>方法用於搭配<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法來存取的資源內嵌於組件。 如需有關應用程式中使用的資源的詳細資訊，請參閱[ASP.NET Web 網頁資源概觀](http://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>方法。 *類型*在此範例中的參數設定為包含資源的組件中類別的類型。 `resourceName`參數指定的資源，包括預設命名空間的完整路徑。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 下列程式碼範例示範如何以程式設計的方式套用<xref:System.Web.UI.WebResourceAttribute>中繼資料屬性來標記系統將會處理資源的組件。 編譯類別庫中的下列類別設定為預設命名空間`Samples.AspNet.CS.Controls`或`Samples.AspNet.VB.Controls`，視您使用何種語言。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 這個範例需要名為的 JavaScript 檔案`Script_include.js`。 .Js 檔案是包含的組件中的內嵌的資源`ClientScriptResourceLabel`物件。 如果您使用 Visual Studio]，在 [類別庫專案的 [屬性] 視窗中，設定**建置動作**至**內嵌資源**選取指令碼檔案時。 如果您正在編譯的程式庫，在命令列，請使用參數將內嵌資源。  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Web 資源名稱為 <see langword="null" />。  
  
 \-或-  
  
 Web 資源名稱長度為零。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷用戶端指令碼區塊是否向 <see cref="T:System.Web.UI.Page" /> 物件註冊過。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜尋的用戶端指令碼區塊索引鍵。</param>
        <summary>判斷用戶端指令碼區塊是否已使用指定的索引鍵，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>
          如果此用戶端指令碼區塊已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前先呼叫<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，以避免註冊重複的指令碼。 這是特別重要，此指令碼需要大量伺服器資源用來建立。  
  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同索引鍵和類型的指令碼會被視為重複。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法呼叫的多載，兩者`key`和`type`類型的參數設定為<xref:System.Web.UI.Page>物件  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜尋的用戶端指令碼區塊型別。</param>
        <param name="key">要搜尋的用戶端指令碼區塊索引鍵。</param>
        <summary>判斷用戶端指令碼區塊是否已使用指定的索引鍵和型別，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>
          如果此用戶端指令碼區塊已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前先呼叫<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，以避免註冊重複的指令碼。 這是特別重要，此指令碼需要大量伺服器資源用來建立。  
  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同索引鍵和類型的指令碼會被視為重複。 您指定將用來存取資源的物件為基礎的類型。 比方說，當使用`Page`存取資源，您指定的執行個體`Page`型別。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法。 請注意，是否已移除邏輯，以檢查是否有現有的用戶端指令碼區塊，會不會有兩個重複的用戶端指令碼所呈現頁面的 HTML 原始碼中因為<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法檢查是否有重複的項目。 檢查的好處是減少不必要的計算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端指令碼型別為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷用戶端指令碼 Include 是否向 <see cref="T:System.Web.UI.Page" /> 物件註冊過。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜尋的用戶端指令碼 Include 索引鍵。</param>
        <summary>判斷用戶端指令碼 Include 是否已使用指定的索引鍵，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>
          如果用戶端指令碼 Include 已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前先呼叫<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法，以避免註冊重複的指令碼。 這是特別重要，此指令碼需要大量伺服器資源用來建立。  
  
 用戶端指令碼包含可唯一識別索引鍵和其型別。 具有相同索引鍵和類型的指令碼會被視為重複。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法呼叫的多載，兩者`key`和`type`類型的參數設定為<xref:System.Web.UI.Page>物件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜尋的用戶端指令碼 Include 型別。</param>
        <param name="key">要搜尋的用戶端指令碼 Include 索引鍵。</param>
        <summary>判斷用戶端指令碼 Include 是否已使用指定的索引鍵和型別，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>
          如果用戶端指令碼 Include 已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前先呼叫<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>包含方法，以避免註冊重複的用戶端指令碼。 這是特別重要，此指令碼需要大量伺服器資源用來建立。  
  
 用戶端指令碼包含可唯一識別索引鍵和其型別。 具有相同索引鍵和類型的指令碼會被視為重複。 您指定將用來存取資源的物件為基礎的類型。 比方說，當使用 Page 執行個體來存取資源，您指定`Page`型別。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A>方法。 請注意，邏輯，以檢查是否有現有的用戶端指令碼包含已移除，是否不有兩個重複的用戶端指令碼中所呈現頁面的 HTML 原始碼因為<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法檢查是否有重複的項目。 檢查的好處是減少不必要的計算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 這個範例需要名為的 JavaScript 檔案`Script_include.js`，具有下列內容：  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端指令碼 Include 型別為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷 OnSubmit 陳述式是否向 <see cref="T:System.Web.UI.Page" /> 物件註冊過。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜尋的 OnSubmit 陳述式索引鍵。</param>
        <summary>判斷 OnSubmit 陳述式是否已使用指定的索引鍵，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>
          如果 OnSubmit 陳述式已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前先呼叫<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法，以避免註冊重複 OnSubmit 陳述式。 這是特別重要，如果陳述式就需要大量伺服器資源用來建立。  
  
 陳述式是以其索引鍵和其類型唯一識別。 具有相同索引鍵和類型的陳述式會被視為重複。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法呼叫的多載，兩者`key`和`type`類型的參數設定為<xref:System.Web.UI.Page>物件  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜尋的 OnSubmit 陳述式類型。</param>
        <param name="key">要搜尋的 OnSubmit 陳述式索引鍵。</param>
        <summary>判斷 OnSubmit 陳述式是否已使用指定的索引鍵和類型，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>
          如果 OnSubmit 陳述式已註冊，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前先呼叫<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法，以避免註冊重複的陳述式。 這是特別重要，如果陳述式就需要大量伺服器資源用來建立。  
  
 陳述式是以其索引鍵和其類型唯一識別。 具有相同索引鍵和類型的陳述式會被視為重複。 您指定將用來存取資源的物件為基礎的類型。 比方說，當使用`Page`存取資源，您指定的執行個體`Page`型別。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法。 名為指令碼`OnSubmitScript`已向<xref:System.Web.UI.Page>使頁面的表單時送出指令碼會叫用。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">OnSubmit 陳述式類型為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷啟始指令碼是否向 <see cref="T:System.Web.UI.Page" /> 物件註冊過。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要搜尋的啟始指令碼索引鍵。</param>
        <summary>判斷啟始指令碼是否已使用指定的索引鍵，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>
          如果啟始指令碼已登錄，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前先呼叫<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，以避免註冊重複的指令碼。 這是特別重要，此指令碼需要大量伺服器資源用來建立。  
  
 啟動指令碼是唯一識別由其索引鍵和其類型。 具有相同索引鍵和類型的指令碼會被視為重複。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法呼叫的多載，這兩個字串`key`和`type`類型的參數設定為<xref:System.Web.UI.Page>物件  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要搜尋的啟始指令碼型別。</param>
        <param name="key">要搜尋的啟始指令碼索引鍵。</param>
        <summary>判斷啟始指令碼是否已使用指定的索引鍵和型別，向 <see cref="T:System.Web.UI.Page" /> 物件註冊。</summary>
        <returns>
          如果啟始指令碼已登錄，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法之前先呼叫<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，以避免註冊重複的指令碼。 這是特別重要，此指令碼需要大量伺服器資源用來建立。  
  
 用戶端啟動指令碼是唯一識別由其索引鍵和其類型。 具有相同索引鍵和類型的指令碼會被視為重複。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法。 請注意，是否已移除邏輯，以檢查是否有現有的啟動指令碼區塊，會不會有兩個重複的啟動指令碼所呈現頁面的 HTML 原始碼中因為<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法檢查是否有重複的項目。 檢查的好處是減少不必要的計算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">啟始指令碼型別為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">要註冊的陣列名稱。</param>
        <param name="arrayValue">要註冊的一或多個陣列值。</param>
        <summary>使用陣列名稱和陣列值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊 JavaScript 陣列宣告。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>檢查，以查看是否已註冊的陣列存在中指定的名稱與同名`arrayName`參數，如果是的話，將在指定的值`arrayValue`參數。 因為基礎儲存機制根據<xref:System.Collections.ArrayList>，允許重複的項目。 如果具有相同名稱的已註冊陣列`arrayName`參數不存在，則會建立和中的值`arrayValue`加入它的參數。  
  
 如果您想產生 JavaScript 陣列中的字串常值，包含單引號 （'） 或逸出雙引號內 (\\") 中`arrayValue`參數。 值`arrayValue`參數應該是單一項目。 如果要加入至陣列需要一個以上的值，請使用多個呼叫<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>和<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法。 這個範例會登錄陣列和隱藏的值，定義`OnClick`事件`<input>`按鈕來計算兩個值的陣列和隱藏的值的總和。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> 為 <see langword="null" />。</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的用戶端指令碼型別。</param>
        <param name="key">要註冊的用戶端指令碼索引鍵。</param>
        <param name="script">要註冊的用戶端指令碼常值。</param>
        <summary>使用型別、索引鍵和指令碼常值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同索引鍵和類型的指令碼會被視為重複。 指定的型別和索引鍵組合只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立指令碼的重複。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法來判斷是否已註冊的用戶端指令碼，具有給定索引鍵和類型配對，並避免不必要地嘗試要加入指令碼。  
  
 中的這個多載<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，您必須確定提供的指令碼`script`參數會包裝在`<script>`項目區塊。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法會將指令碼區塊所呈現頁面的頂端。 指令碼區塊並非都能註冊它們的順序輸出。 如果指令碼區塊的順序很重要，使用<xref:System.Text.StringBuilder>来收集在單一字串中，指令碼的物件，然後再將它們登錄單一用戶端指令碼區塊中的所有。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的用戶端指令碼型別。</param>
        <param name="key">要註冊的用戶端指令碼索引鍵。</param>
        <param name="script">要註冊的用戶端指令碼常值。</param>
        <param name="addScriptTags">表示是否加入指令碼標記的布林值。</param>
        <summary>使用型別、索引鍵、指令碼常值，以及表示是否加入指令碼標記的布林值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同索引鍵和類型的指令碼會被視為重複。 指定的型別和索引鍵組合只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立指令碼的重複。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>方法，以判斷是否已註冊的用戶端指令碼，具有給定索引鍵和類型配對。 這可讓您避免不必要地嘗試要加入指令碼。  
  
 中的這個多載<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法，您可以指出是否在指令碼中提供`script`參數會包裝與`<script>`所使用的項目區塊`addScriptTags`參數。 設定`addScriptTags`至`true`表示指令碼標記將會自動加入。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法會將指令碼區塊所呈現頁面的頂端。 指令碼區塊並非都能註冊它們的順序輸出。 如果指令碼區塊的順序很重要，使用<xref:System.Text.StringBuilder>来收集在單一字串中，指令碼的物件，然後再將它們登錄單一用戶端指令碼區塊中的所有。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法。 請注意，`addScriptTags`參數設定為`true`讓的開始和關閉指令碼標記未隨附於`script`參數。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端指令碼區塊型別為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼 Include。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要註冊的用戶端指令碼 Include 索引鍵。</param>
        <param name="url">要註冊的用戶端指令碼 Include URL。</param>
        <summary>使用索引鍵和 URL 在 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼，讓您能夠從用戶端呼叫此指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端指令碼包含可唯一識別索引鍵和其型別。 具有相同索引鍵和類型的指令碼會被視為重複。 指定的型別和索引鍵組合只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立指令碼的重複。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A>方法，以判斷是否包含具有指定索引鍵的用戶端指令碼和已註冊型別組，並避免不必要地嘗試要加入指令碼。  
  
> [!NOTE]
>  若要解決用戶端 URL，請使用<xref:System.Web.UI.Control.ResolveClientUrl%2A>方法。 這個方法會使用內容呼叫它來解析路徑的 URL。  
  
 這個多載<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法呼叫的多載， `key`、 `URL`，和`type`參數。  
  
 方法會將指令碼區塊所呈現頁面的頂端。  
  
   
  
## Examples  
 如需相關資訊，包括語法、 使用方式和範例，請參閱<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的用戶端指令碼 Include 型別。</param>
        <param name="key">要註冊的用戶端指令碼 Include 索引鍵。</param>
        <param name="url">要註冊的用戶端指令碼 Include URL。</param>
        <summary>使用型別、索引鍵和 URL，向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼 Include。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法會採用*金鑰*和*url*參數來識別指令碼，以及`type`包括參數來指定用戶端指令碼的識別。 您指定將用來存取資源的物件為基礎的類型。 比方說，當使用`Page`存取資源，您指定的執行個體`Page`型別。  
  
> [!NOTE]
>  若要解決用戶端 URL，請使用<xref:System.Web.UI.Control.ResolveClientUrl%2A>方法。 這個方法會使用內容呼叫它來解析路徑的 URL。  
  
 這個方法所呈現頁面的頂端加入指令碼區塊。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法。 請注意，是否邏輯，以檢查是否有現有的用戶端指令碼包含已移除，仍不會重複的用戶端指令碼中所呈現頁面因為<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>方法檢查是否有重複的項目。 檢查的好處是減少不必要的計算。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 這個範例需要名 Script_include.js 為具有下列內容的 JavaScript 檔案：  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端指令碼 Include 型別為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">URL 為 <see langword="null" />。  
  
 \-或-  
  
 URL 是空的。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的用戶端指令碼資源類別。</param>
        <param name="resourceName">要註冊的用戶端指令碼資源名稱。</param>
        <summary>使用型別和資源名稱，向 <see cref="T:System.Web.UI.Page" /> 物件註冊用戶端指令碼資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法從透過 WebResource.axd HTTP 處理常式的組件存取編譯中資源時才使用。 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法註冊的指令碼<xref:System.Web.UI.Page>物件，並可防止重複的指令碼。 這個方法會包裝與資源 URL 的內容`<script>`項目區塊。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 下列程式碼範例示範如何以程式設計的方式套用<xref:System.Web.UI.WebResourceAttribute>中繼資料屬性來標記系統將會處理資源的組件。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 這個範例需要名為的 JavaScript 檔案`Script_include.js`，具有下列內容：  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 編譯`Script_include.js`檔案中的資源為`Samples.AspNet.CS.Controls`包含組件`ClientScriptResourceLabel`類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">用戶端資源名稱為 <see langword="null" />。  
  
 \-或-  
  
 用戶端資源名稱長度為零。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將名稱/值組註冊為指定之控制項的自訂 (Expando) 屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">網頁上包含自訂屬性的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="attributeName">要註冊的自訂屬性名稱。</param>
        <param name="attributeValue">自訂屬性的值。</param>
        <summary>使用控制項 ID、屬性名稱和屬性值，將名稱/值組註冊為指定之控制項的自訂 (Expando) 屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法註冊為指定的自訂 (expando) 屬性的名稱/值組<xref:System.Web.UI.Control>。 Expando 屬性設為以動態方式從 JavaScript 保留呈現的控制項的標記的 XHTML 相容性。 引號和自訂 (expando) 屬性的值中的反斜線逸出。 如果您不想要逸出引號和反斜線，呼叫<xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法多載，並設定`encode`參數`false`。  
  
 如果找不到 expando 屬性，或找不到要加入至 expando 屬性的控制項，仍發出用戶端指令碼，但它不會影響的控制項。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">網頁上包含自訂屬性的 <see cref="T:System.Web.UI.Control" />。</param>
        <param name="attributeName">要註冊的自訂屬性名稱。</param>
        <param name="attributeValue">自訂屬性的值。</param>
        <param name="encode">表示是否對要註冊之自訂屬性進行編碼的布林值。</param>
        <summary>使用控制項 ID、屬性名稱、屬性值，以及表示是否編碼屬性值的布林值，將名稱/值組註冊為指定之控制項的自訂 (Expando) 屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法註冊為指定的自訂 (expando) 屬性的名稱/值組<xref:System.Web.UI.Control>。 Expando 屬性設為以動態方式從 JavaScript 保留呈現的控制項的標記的 XHTML 相容性。 設定`encode`參數`true`如果您需要逸出引號和 expando 屬性的值中的反斜線。  
  
 如果找不到 expando 屬性，或找不到要加入至 expando 屬性的控制項，仍發出用戶端指令碼，但它不會影響的控制項。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>方法<xref:System.Web.UI.ClientScriptManager>類別。 在轉譯的頁面集合中的用戶端指令碼`title`屬性`<span>`項目。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>註冊事件參考以進行驗證。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">唯一的 ID，表示產生事件的用戶端控制項。</param>
        <summary>使用唯一的控制項 ID (表示產生事件的用戶端控制項) 註冊事件參考以進行驗證。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊和範例，請參閱<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>方法，以註冊回呼，以進行驗證，而且如何驗證回呼源自頁面。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">
          <see cref="T:System.Web.UI.PostBackOptions" /> 物件，指定產生用戶端 JavaScript 以啟始回傳事件的方式。</param>
        <summary>使用 <see cref="T:System.Web.UI.PostBackOptions" /> 註冊事件參考以進行驗證。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊和範例，請參閱<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">唯一的 ID，表示產生事件的用戶端控制項。</param>
        <param name="argument">隨用戶端事件傳遞的事件引數。</param>
        <summary>使用唯一的控制項 ID 和事件引數 (表示產生事件的用戶端控制項) 註冊事件參考以進行驗證。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>註冊回呼，以進行驗證和驗證回呼源自頁面的方法。 若要改善驗證範例所示，您可以修改驗證`argument`參數，以包含特定的使用者，例如識別或角色資訊  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>註冊回呼，以進行驗證的方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個方法會在 <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> 方法之前呼叫。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">要註冊的隱藏欄位名稱。</param>
        <param name="hiddenFieldInitialValue">要註冊的欄位初始值。</param>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 物件註冊隱藏值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法會建立隱藏`<input>`呈現的 HTML 網頁上的項目。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>和<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法。 這個範例會登錄陣列和隱藏的值，定義`OnClick`事件`<input>`按鈕來計算兩個值的陣列和隱藏的值的總和。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hiddenFieldName" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的 OnSubmit 陳述式類型。</param>
        <param name="key">要註冊的 OnSubmit 陳述式索引鍵。</param>
        <param name="script">要註冊的 OnSubmit 陳述式指令碼常值。</param>
        <summary>使用類型、索引鍵和指令碼常值 (Literal)，向 <see cref="T:System.Web.UI.Page" /> 物件註冊 OnSubmit 陳述式。 當送出 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> 時，會執行該陳述式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 索引鍵和其型別可唯一識別 OnSubmit 陳述式。 具有相同索引鍵和類型的陳述式會被視為重複。 指定的型別和索引鍵組合的單獨一個陳述式可以向頁面。 嘗試註冊已註冊的陳述式不會建立重複的陳述式。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>方法來判斷是否 OnSubmit 陳述式已登錄指定的索引鍵和類型配對，並避免不必要地嘗試要加入指令碼。  
  
 `script`參數<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>，只要它們是以分號 （;） 分隔的正確方法可以包含多個指令碼命令。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>新增指令碼執行時再將頁面送出，而且可讓您有機會取消送出。  
  
 如需有關 HTML 表單和`OnSubmit`屬性，請參閱[World Wide Web Consortium (W3C) 網站](http://go.microsoft.com/fwlink/?linkid=37125)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.Page" /> 物件註冊啟始指令碼。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的啟始指令碼型別。</param>
        <param name="key">要註冊的啟始指令碼索引鍵。</param>
        <param name="script">要註冊的啟始指令碼常值。</param>
        <summary>使用型別、索引鍵和指令碼常值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊啟始指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用戶端指令碼是唯一識別由其索引鍵和其類型。 具有相同索引鍵和類型的指令碼會被視為重複。 指定的型別和索引鍵組合只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立指令碼的重複。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法來判斷是否已註冊啟動指令碼，具有給定索引鍵和類型配對，並避免不必要地嘗試要加入指令碼。  
  
 中的這個多載<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，您必須確定提供的指令碼`script`參數會包裝與`<script>`項目區塊。  
  
 所加入的指令碼區塊<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法執行時在網頁完成載入，但頁面之前<xref:System.Web.UI.Control.OnLoad%2A>就會引發事件。 指令碼區塊並非都能註冊它們的順序輸出。 如果指令碼區塊的順序很重要，使用<xref:System.Text.StringBuilder>来收集在單一字串中，指令碼的物件，然後再將它們登錄單一用戶端指令碼區塊中的所有。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。 請注意，開頭和結尾的指令碼標記包含在`script`參數。 若要將指令碼標記加入根據額外的參數設定，請參閱<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">要註冊的啟始指令碼型別。</param>
        <param name="key">要註冊的啟始指令碼索引鍵。</param>
        <param name="script">要註冊的啟始指令碼常值。</param>
        <param name="addScriptTags">表示是否加入指令碼標記的布林值。</param>
        <summary>使用型別、索引鍵、指令碼常值，以及表示是否加入指令碼標記的布林值，向 <see cref="T:System.Web.UI.Page" /> 物件註冊啟始指令碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 啟動指令碼是唯一識別由其索引鍵和其類型。 具有相同索引鍵和類型的指令碼會被視為重複。 指定的型別和索引鍵組合只有一個指令碼可以向頁面。 嘗試註冊已註冊的指令碼不會建立指令碼的重複。  
  
 呼叫<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>方法來判斷是否已註冊啟動指令碼，具有給定索引鍵和類型配對，並避免不必要地嘗試要加入指令碼。  
  
 中的這個多載<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法，您可以指出是否在指令碼中提供`script`參數會包裝與`<script>`所使用的項目區塊`addScriptTags`參數。 設定`addScriptTags`至`true`表示指令碼標記將會自動加入。  
  
 所加入的指令碼區塊<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法執行時在網頁完成載入，但頁面之前<xref:System.Web.UI.Control.OnLoad%2A>就會引發事件。 指令碼區塊並非都能註冊它們的順序輸出。 如果指令碼區塊的順序很重要，使用<xref:System.Text.StringBuilder>来收集在單一字串中，指令碼的物件，然後再將它們登錄單一用戶端指令碼區塊中的所有。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法。 請注意，`addScriptTags`參數設定為`false`讓的開始和關閉指令碼標記隨附於`script`參數。  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>驗證用戶端事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">唯一的 ID，表示產生事件的用戶端控制項。</param>
        <summary>驗證使用 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> 方法註冊以進行事件驗證的用戶端事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">唯一的 ID，表示產生事件的用戶端控制項。</param>
        <param name="argument">隨用戶端事件傳遞的事件引數。</param>
        <summary>驗證使用 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> 方法註冊以進行事件驗證的用戶端事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>方法和<xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>註冊回呼，以進行驗證和驗證回呼源自頁面的方法。 若要改善的驗證，如下所示，您可以修改驗證`argument`參數，以包含特定的使用者，例如識別或角色資訊  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uniqueId" /> 為 <see langword="null" /> 或空字串 ("")。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>