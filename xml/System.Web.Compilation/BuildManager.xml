<Type Name="BuildManager" FullName="System.Web.Compilation.BuildManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6564ecc5d7eb05d2c62858f7fc9f10f68cee1c45" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57933582" /></Metadata><TypeSignature Language="C#" Value="public sealed class BuildManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BuildManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Compilation.BuildManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BuildManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BuildManager sealed" />
  <TypeSignature Language="F#" Value="type BuildManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一組方法，以協助管理 ASP.NET 應用程式的編譯。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Compilation.BuildManager>類別管理編譯組件和頁面的 應用程式的程序。 它是密封的類別無法被繼承。  
  
 <xref:System.Web.Compilation.BuildManager> 包含提供已編譯的組件的相關資訊的靜態成員。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.Compilation.ClientBuildManager" />
    <altmember cref="T:System.Web.Compilation.BuildProvider" />
    <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
  </Docs>
  <Members>
    <Member MemberName="AddCompilationDependency">
      <MemberSignature Language="C#" Value="public static void AddCompilationDependency (string dependency);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCompilationDependency(string dependency) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddCompilationDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCompilationDependency (dependency As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCompilationDependency(System::String ^ dependency);" />
      <MemberSignature Language="F#" Value="static member AddCompilationDependency : string -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddCompilationDependency dependency" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependency" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dependency">表示相依性的字串。</param>
        <summary>指定字串，表示建置管理員用來協助您判斷是否需要清除組建的相依性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法必須呼叫期間`Application_PreStartInit`階段的應用程式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="dependency" /> 參數是 <see langword="null" /> 或空字串。</exception>
        <exception cref="T:System.InvalidOperationException">在應用程式的 <see langword="Application_PreStartInit" /> 階段之後呼叫這個方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddReferencedAssembly">
      <MemberSignature Language="C#" Value="public static void AddReferencedAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddReferencedAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.AddReferencedAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddReferencedAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member AddReferencedAssembly : System.Reflection.Assembly -&gt; unit" Usage="System.Web.Compilation.BuildManager.AddReferencedAssembly assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="assembly">要加入的組件。</param>
        <summary>將組件加入至應用程式所參考的組件集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法相當於將組件新增至應用程式層級的 Web.config 檔案。 此方法必須呼叫期間`Application_PreStartInit`階段的應用程式。  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A>方法會傳回一組決定從組態檔的組件和使用此方法所加入的任何組件。  
  
 如果嘗試加入已經加入的組件，則會忽略重複的項目。  
  
 之前，必須呼叫此方法`Application_Start`Global.asax 檔案中的事件，就會發生。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 參數是 <see langword="null" /> 或空白。</exception>
        <exception cref="T:System.InvalidOperationException">在發生的 Global.asax 檔中，未在 <see langword="Application_Start" /> 事件之前呼叫該方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchCompilationEnabled">
      <MemberSignature Language="C#" Value="public static Nullable&lt;bool&gt; BatchCompilationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;bool&gt; BatchCompilationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BatchCompilationEnabled As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;bool&gt; BatchCompilationEnabled { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.BatchCompilationEnabled : Nullable&lt;bool&gt; with get, set" Usage="System.Web.Compilation.BuildManager.BatchCompilationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否啟用批次編譯。</summary>
        <value>如果一律啟用批次編譯則為 <see langword="true" />，如果一律不啟用批次編譯則為 <see langword="false" />，如果由組態檔決定編譯設定則為 <see langword="null" />。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性可讓您開啟或關閉的批次編譯以程式設計的方式。 它會對應至`batch`屬性的`compilation`Web.config 檔案中的項目。 如需詳細資訊，請參閱 < [compilation 項目 （ASP.NET 設定結構描述）](https://msdn.microsoft.com/library/7c319582-074a-4d2a-a787-03b9d4541c12)。  
  
 此屬性可以只在設定`PreApplicationStart`方法。 如需 `PreApplicationStart` 方法的詳細資訊，請參閱 <xref:System.Web.PreApplicationStartMethodAttribute>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="PreApplicationStart" /> 方法中未設定該屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="CodeAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.IList CodeAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IList CodeAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CodeAssemblies As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IList ^ CodeAssemblies { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeAssemblies : System.Collections.IList" Usage="System.Web.Compilation.BuildManager.CodeAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得從 App_Code 目錄建置的組件清單。</summary>
        <value><see cref="T:System.Collections.IList" /> 集合，包含從 App_Code 目錄建置的組件。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream CreateCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream CreateCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ CreateCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member CreateCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.CreateCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileName">要建立之檔案的名稱。</param>
        <summary>建立快取的檔案。</summary>
        <returns>新檔案的 <see cref="T:System.IO.Stream" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法和<xref:System.Web.Compilation.BuildManager.ReadCachedFile%2A>方法可讓您執行快取，在部分信任環境中的應用程式網域重新啟動之間仍然存在。 它會使用 MVC framework 的控制器查閱快取結果。  
  
 快取資料，您將寫入<xref:System.IO.Stream>這個方法所傳回的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromVirtualPath">
      <MemberSignature Language="C#" Value="public static object CreateInstanceFromVirtualPath (string virtualPath, Type requiredBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstanceFromVirtualPath(string virtualPath, class System.Type requiredBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFromVirtualPath (virtualPath As String, requiredBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstanceFromVirtualPath(System::String ^ virtualPath, Type ^ requiredBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFromVirtualPath : string * Type -&gt; obj" Usage="System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath (virtualPath, requiredBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="requiredBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="virtualPath">要建立執行個體的檔案之虛擬路徑。</param>
        <param name="requiredBaseType">定義要建立之物件的基底型別 (Base Type)。</param>
        <summary>處理已提供其虛擬路徑的檔案，並且建立其結果的執行個體。</summary>
        <returns><see cref="T:System.Object" />，表示已處理檔案的執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath%2A>方法適用於已編譯且非編譯的頁面。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCachedBuildDependencySet">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從 ASP.NET 快取傳回組建相依性集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="context">要求的內容。</param>
        <param name="virtualPath">用來判斷組建相依性集合的虛擬路徑。</param>
        <summary>傳回虛擬路徑的組建相依性集合 (如果此路徑位於 ASP.NET 快取區)。</summary>
        <returns>存放在快取中的 <see cref="T:System.Web.Compilation.BuildDependencySet" /> 物件，如果無法從快取擷取 <see cref="T:System.Web.Compilation.BuildDependencySet" /> 物件，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildDependencySet" />
        <altmember cref="P:System.Web.Compilation.BuildProvider.VirtualPathDependencies" />
      </Docs>
    </Member>
    <Member MemberName="GetCachedBuildDependencySet">
      <MemberSignature Language="C#" Value="public static System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet (System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Compilation.BuildDependencySet GetCachedBuildDependencySet(class System.Web.HttpContext context, string virtualPath, bool ensureIsUpToDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet(System.Web.HttpContext,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachedBuildDependencySet (context As HttpContext, virtualPath As String, ensureIsUpToDate As Boolean) As BuildDependencySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Compilation::BuildDependencySet ^ GetCachedBuildDependencySet(System::Web::HttpContext ^ context, System::String ^ virtualPath, bool ensureIsUpToDate);" />
      <MemberSignature Language="F#" Value="static member GetCachedBuildDependencySet : System.Web.HttpContext * string * bool -&gt; System.Web.Compilation.BuildDependencySet" Usage="System.Web.Compilation.BuildManager.GetCachedBuildDependencySet (context, virtualPath, ensureIsUpToDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Compilation.BuildDependencySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="virtualPath" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ensureIsUpToDate" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="context">要求的內容。</param>
        <param name="virtualPath">用來判斷組建相依性集合的虛擬路徑。</param>
        <param name="ensureIsUpToDate"><see langword="true" /> 表示指定只有目前的組建相依性集合需要傳回，否則為 <see langword="false" />，表示即使不是最新的內容，任何可用的組建相依性集合都要傳回。 預設為 <see langword="true" />。</param>
        <summary>如果此路徑位於 ASP.NET 快取，則傳回虛擬路徑的組建相依性集合，即使不是最新的內容也要傳回。</summary>
        <returns>存放在快取中的 <see cref="T:System.Web.Compilation.BuildDependencySet" /> 物件，如果無法從快取擷取 <see cref="T:System.Web.Compilation.BuildDependencySet" /> 物件，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`ensureIsUpToDate`參數值設定為`true`，則<xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType>方法多載的行為類似<xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType>方法多載。 這兩個多載會傳回目前的組建相依性，如果有的話，請設定，否則會傳回`null`。  
  
 不過，<xref:System.Web.Compilation.BuildManager.GetCachedBuildDependencySet%2A?displayProperty=nameWithType>方法多載包含選項以傳回任何組建相依性集合，可供使用，甚至是過期的一個。 如果`ensureIsUpToDate`參數值設定為`false`，此方法會傳回任何可用的組建相依性集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompiledAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCompiledAssembly (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCompiledAssembly(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledAssembly (virtualPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCompiledAssembly(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledAssembly : string -&gt; System.Reflection.Assembly" Usage="System.Web.Compilation.BuildManager.GetCompiledAssembly virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">要建置到組件中的虛擬路徑。</param>
        <summary>使用指定的虛擬路徑，將檔案編譯成組件。</summary>
        <returns>從指定虛擬路徑編譯出來的 <see cref="T:System.Reflection.Assembly" /> 物件，這個物件會快取到記憶體或磁碟。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.Compilation.BuildProvider" />
        <altmember cref="T:System.Web.Compilation.AssemblyBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledCustomString">
      <MemberSignature Language="C#" Value="public static string GetCompiledCustomString (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCompiledCustomString(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledCustomString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledCustomString (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCompiledCustomString(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledCustomString : string -&gt; string" Usage="System.Web.Compilation.BuildManager.GetCompiledCustomString virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">要建置之檔案的虛擬路徑。</param>
        <summary>編譯檔案、提供其虛擬路徑，並且傳回組建提供者保留在快取區中的自訂字串。</summary>
        <returns>由 <see cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" /> 方法傳回的字串，它會快取到磁碟或記憶體。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetCustomString(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetCompiledType">
      <MemberSignature Language="C#" Value="public static Type GetCompiledType (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetCompiledType(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetCompiledType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompiledType (virtualPath As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetCompiledType(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetCompiledType : string -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetCompiledType virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">要建置到型別中的虛擬路徑。</param>
        <summary>編譯已提供虛擬路徑的檔案，並且傳回已編譯的型別。</summary>
        <returns><see cref="T:System.Type" /> 物件，表示從編譯虛擬路徑而產生的型別。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">在編譯虛擬路徑時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.Compilation.BuildProvider.GetGeneratedType(System.CodeDom.Compiler.CompilerResults)" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalAsaxType">
      <MemberSignature Language="C#" Value="public static Type GetGlobalAsaxType ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetGlobalAsaxType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetGlobalAsaxType" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalAsaxType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetGlobalAsaxType();" />
      <MemberSignature Language="F#" Value="static member GetGlobalAsaxType : unit -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetGlobalAsaxType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得物件，此物件代表 Global.asax 檔案編譯後的型別。</summary>
        <returns>表示 Global.asax 檔案編譯後型別的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在編譯 Global.asax 檔案之前，會呼叫這個方法，則會擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已在編譯 Global.asax 頁面之前嘗試呼叫這個方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectFactory">
      <MemberSignature Language="C#" Value="public static System.Web.Util.IWebObjectFactory GetObjectFactory (string virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Util.IWebObjectFactory GetObjectFactory(string virtualPath, bool throwIfNotFound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetObjectFactory(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectFactory (virtualPath As String, throwIfNotFound As Boolean) As IWebObjectFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Util::IWebObjectFactory ^ GetObjectFactory(System::String ^ virtualPath, bool throwIfNotFound);" />
      <MemberSignature Language="F#" Value="static member GetObjectFactory : string * bool -&gt; System.Web.Util.IWebObjectFactory" Usage="System.Web.Compilation.BuildManager.GetObjectFactory (virtualPath, throwIfNotFound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Util.IWebObjectFactory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">虛擬路徑。</param>
        <param name="throwIfNotFound"><see langword="true" /> 表示會在虛擬路徑不存在時擲回錯誤，否則為 <see langword="false" />。 如果虛擬路徑不存在且 <paramref name="throwIfNotFound" /> 為 <see langword="false" />，這個方法會傳回 <see langword="null" />。</param>
        <summary>取得指定之虛擬路徑的 Object Factory。</summary>
        <returns>Object Factory。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回物件，可讓您藉由編譯虛擬路徑產生的類型。 它會傳回物件，不論是否已先行編譯網站。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">虛擬路徑不存在。  
  
-或- 
呼叫此方法時，已有較高層級的例外狀況存在。  
  
-或- 
當編譯處理序已建置最上層的檔案時，已呼叫這個方法。  
  
-或- 
這是先行編譯的應用程式，在快取中找不到虛擬路徑。  
  
-或- 
偵測到循環參考。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReferencedAssemblies () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="static member GetReferencedAssemblies : unit -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回組件參考的清單，所有的頁面編譯都必須參考這些組件參考。</summary>
        <returns>組件參考的 <see cref="T:System.Collections.ICollection" /> 集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 從傳回的組件集合<xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A>方法包含其他最上層的資料夾中的 Web.config 檔案的項目中指定的組件、 從 App_Code 目錄，並在目錄中的自訂程式碼所建置的組件和組件。  
  
 <xref:System.Web.Compilation.BuildManager.GetReferencedAssemblies%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱 [.NET Framework 版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在最上層組件中尋找型別，或是在組態中已有定義的組件中尋找型別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最上層的組件參考 Global.asax 檔案中，或在 App_GlobalResources、 App_WebReferences、 App_Code，App_Browsers 目錄中的檔案。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">型別的名稱。</param>
        <param name="throwOnError"><see langword="true" /> 表示在無法為型別名稱產生 <see cref="T:System.Type" /> 物件時要擲回例外狀況，否則為 <see langword="false" />。</param>
        <summary>在最上層組件中尋找型別，或是在組態中已有定義的組件中尋找型別，並且可選擇在失敗時擲回例外狀況。</summary>
        <returns><see cref="T:System.Type" /> 物件，表示要求的 <paramref name="typeName" /> 參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最上層的組件參考 Global.asax 檔案中，或在 App_GlobalResources、 App_WebReferences、 App_Code，App_Browsers 目錄中的檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> 無效。  
  
-或- 
 <paramref name="typeName" /> 模稜兩可。  
  
-或- 
 找不到 <paramref name="typeName" />，且 <paramref name="throwOnError" /> 為 <see langword="true" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Web.Compilation.BuildManager.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">型別的名稱。</param>
        <param name="throwOnError"><see langword="true" /> 表示在無法為型別名稱產生 <see cref="T:System.Type" /> 時要擲回例外狀況，否則為 <see langword="false" />。</param>
        <param name="ignoreCase">如果 <paramref name="typeName" /> 要區分大小寫，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>使用不區分字母大小寫的搜尋，在最上層組件中尋找型別，或是在組態中已有定義的組件中尋找型別，並且可選擇在失敗時擲回例外狀況。</summary>
        <returns><see cref="T:System.Type" /> 物件，表示要求的 <paramref name="typeName" /> 參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最上層的組件參考 Global.asax 檔案中，或在 App_GlobalResources、 App_WebReferences、 App_Code，App_Browsers 目錄中的檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="typeName" /> 無效。  
  
-或- 
 <paramref name="typeName" /> 模稜兩可。  
  
-或- 
 找不到 <paramref name="typeName" />，且 <paramref name="throwOnError" /> 為 <see langword="true" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPathDependencies">
      <MemberSignature Language="C#" Value="public static System.Collections.ICollection GetVirtualPathDependencies (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ICollection GetVirtualPathDependencies(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.GetVirtualPathDependencies(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVirtualPathDependencies (virtualPath As String) As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ICollection ^ GetVirtualPathDependencies(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="static member GetVirtualPathDependencies : string -&gt; System.Collections.ICollection" Usage="System.Web.Compilation.BuildManager.GetVirtualPathDependencies virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">用來判斷相依性的虛擬路徑。</param>
        <summary>提供指定之虛擬路徑的虛擬路徑相依性集合。</summary>
        <returns>檔案的 <see cref="T:System.Collections.ICollection" /> 集合，這些檔案是由虛擬路徑來表示，用來快取虛擬路徑的相依性。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsPrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsPrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsPrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsPrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsPrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值會指定是否預先編譯應用程式。</summary>
        <value>如果應用程式已先行編譯，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpdatablePrecompiledApp">
      <MemberSignature Language="C#" Value="public static bool IsUpdatablePrecompiledApp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsUpdatablePrecompiledApp" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsUpdatablePrecompiledApp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsUpdatablePrecompiledApp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpdatablePrecompiledApp : bool" Usage="System.Web.Compilation.BuildManager.IsUpdatablePrecompiledApp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值會指定是否將應用程式預先編譯為可更新。</summary>
        <value>如果應用程式已先行編譯為可更新的，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCachedFile">
      <MemberSignature Language="C#" Value="public static System.IO.Stream ReadCachedFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream ReadCachedFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Compilation.BuildManager.ReadCachedFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCachedFile (fileName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ ReadCachedFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member ReadCachedFile : string -&gt; System.IO.Stream" Usage="System.Web.Compilation.BuildManager.ReadCachedFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileName">要讀取的檔案名稱。</param>
        <summary>讀取快取的檔案。</summary>
        <returns>檔案的 <see cref="T:System.IO.Stream" /> 物件，如果檔案不存在，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法和<xref:System.Web.Compilation.BuildManager.CreateCachedFile%2A>方法可讓您執行快取，在部分信任環境中的應用程式網域重新啟動之間仍然存在。 它會使用 MVC framework 的控制器查閱快取結果。  
  
 若要擷取快取的資料，請您閱讀從<xref:System.IO.Stream>這個方法所傳回的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetFramework">
      <MemberSignature Language="C#" Value="public static System.Runtime.Versioning.FrameworkName TargetFramework { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Versioning.FrameworkName TargetFramework" />
      <MemberSignature Language="DocId" Value="P:System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFramework As FrameworkName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Versioning::FrameworkName ^ TargetFramework { System::Runtime::Versioning::FrameworkName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetFramework : System.Runtime.Versioning.FrameworkName" Usage="System.Web.Compilation.BuildManager.TargetFramework" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Versioning.FrameworkName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前網站的 .NET Framework 目標版本。</summary>
        <value>目前網站的 .NET Framework 目標版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性支援 ASP.NET 多目標功能，可讓您使用最新版本的 Visual Studio 開發應用程式，將舊版的.NET Framework 用來執行。 組建提供者可以使用這個屬性，藉此確定提供者會產生適用於.NET Framework 的目標版本的程式碼。 比方說，您可能想要產生不同的程式碼取決於是否 Web 站台目標[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]或[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]。 如需有關多目標的詳細資訊，請參閱[ASP.NET Web 專案的.NET Framework 多目標](https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76)。  
  
 如果網站沒有 Web.config 檔案，ASP.NET 會假設目標 framework 版本為 IIS 應用程式集區下執行的站台相關聯的版本。 在 Visual Studio 中執行的檔案系統網站上，預設的 framework 版本是目前版本的.NET framework。  
  
 如果網站具有 Web.config 檔案，ASP.NET 會檢查 Web.config 檔案來判斷目標 framework。  
  
## <a name="web-sites-that-target-the-net-framework-20"></a>.NET Framework 2.0 為目標的 Web Sites  
 Web 應用程式為目標[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]如同目標是編譯[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]。 建置程序不會區別[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]而[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]因為 Web.config 檔案並不表示編譯器版本] 或 [目標 framework，當其中一個版本的目標。 (如[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]，Web.config 檔案指定的編譯器版本，以及[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，Web.config 檔案中指定的目標 framework。)因此，針對 Web 應用程式為目標[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，這個屬性會傳回目標架構 moniker，指出[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]。  
  
 這通常不會造成任何問題。 Visual Studio 會阻止您建立的參考[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]為目標的專案中的功能[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。 例如，Visual Studio 不提供項目範本針對專案中的 WCF 服務[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，因為 WCF 引進[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]和與不相容[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。  
  
 如果您打算部署中的 Web 站台[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]執行階段環境，而且您使用 Visual Studio 以外的工具，都只與相容的參考功能[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]，而不會產生錯誤或警告可能會建置專案。 不過，應用程式可能會產生錯誤的網站上執行時[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>