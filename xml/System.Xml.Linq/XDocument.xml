<Type Name="XDocument" FullName="System.Xml.Linq.XDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d79ed174f5e5f1d678e11f3ea4857185ee811f59" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30721092" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XDocument : System.Xml.Linq.XContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XDocument extends System.Xml.Linq.XContainer" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XDocument&#xA;Inherits XContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XDocument : System::Xml::Linq::XContainer" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>表示 XML 文件。 如需 <see cref="T:System.Xml.Linq.XDocument" /> 物件的元件和用法，請參閱 <see href="http://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467">XDocument 類別概觀</see>。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊的有效內容<xref:System.Xml.Linq.XDocument>，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。  
  
   
  
## Examples  
 下例會建立文件，並將其加入註解和項目它。 然後會組合使用查詢的結果的另一個文件。  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.Linq.XNamespace" />
    <altmember cref="T:System.Xml.Linq.XDeclaration" />
    <altmember cref="T:System.Xml.Linq.XElement" />
    <altmember cref="T:System.Xml.Linq.XNode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.Linq.XDocument" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載建構函式可讓您建立新的空白<xref:System.Xml.Linq.XDocument>; 以建立<xref:System.Xml.Linq.XDocument>某些指定的初始內容，並建立<xref:System.Xml.Linq.XDocument>做為另一個複本<xref:System.Xml.Linq.XDocument>物件。  
  
 需要您建立 <xref:System.Xml.Linq.XDocument> 的案例並不多。 不過，您通常可以使用 <xref:System.Xml.Linq.XElement> 根節點來建立 XML 樹狀結構。 除非您有建立文件的特定需求 (例如，因為您必須在頂層建立處理指示與註解，或者您必須支援文件型別)，否則使用 <xref:System.Xml.Linq.XElement> 做為您的根節點通常更方便。  
  
 如需詳細資訊的有效內容<xref:System.Xml.Linq.XDocument>，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。  
  
   
  
## Examples  
 下例會建立文件，並將其加入註解和項目它。 然後會組合使用查詢的結果的另一個文件。  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.Linq.XDocument" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 需要您建立 <xref:System.Xml.Linq.XDocument> 的案例並不多。 不過，您通常可以使用 <xref:System.Xml.Linq.XElement> 根節點來建立 XML 樹狀結構。 除非您有建立文件的特定需求 (例如，因為您必須在頂層建立處理指示與註解，或者您必須支援文件型別)，否則使用 <xref:System.Xml.Linq.XElement> 做為您的根節點通常更方便。  
  
 如需詳細資訊的有效內容<xref:System.Xml.Linq.XDocument>，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。  
  
   
  
## Examples  
 下列範例會建立新的文件，並將註解和項目給它。  
  
```csharp  
XDocument doc = new XDocument();  
doc.Add(new XComment("This is a comment"));  
doc.Add(new XElement("Root", "content"));  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = New XDocument()  
doc.Add(<!--This is a comment-->)  
doc.Add(<Root>content</Root>)  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<!--This is a comment-->  
<Root>content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">要加入此文件之內容物件的參數清單。</param>
        <summary>使用指定的內容初始化 <see cref="T:System.Xml.Linq.XDocument" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 需要您建立 <xref:System.Xml.Linq.XDocument> 的案例並不多。 不過，您通常可以使用 <xref:System.Xml.Linq.XElement> 根節點來建立 XML 樹狀結構。 除非您有建立文件的特定需求 (例如，因為您必須在頂層建立處理指示與註解，或者您必須支援文件型別)，否則使用 <xref:System.Xml.Linq.XElement> 做為您的根節點通常更方便。  
  
 如需詳細資訊的有效內容<xref:System.Xml.Linq.XDocument>，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。  
  
   
  
## Examples  
 下例會建立文件，並將其加入註解和項目它。 然後會組合使用查詢的結果的另一個文件。  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDocument other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDocument other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDocument ^ other);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XDocument" />
      </Parameters>
      <Docs>
        <param name="other">要複製的 <see cref="T:System.Xml.Linq.XDocument" /> 物件。</param>
        <summary>從現有的 <see cref="T:System.Xml.Linq.XDocument" /> 物件，初始化 <see cref="T:System.Xml.Linq.XDocument" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您使用這個建構函式來進行的深層複本<xref:System.Xml.Linq.XDocument>。  
  
 這個建構函式會周遊所有的節點和屬性中指定的文件中`other`參數，並建立所有節點的複本，因為它會組譯新初始化<xref:System.Xml.Linq.XDocument>。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDeclaration declaration, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDeclaration declaration, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDeclaration,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (declaration As XDeclaration, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDeclaration ^ declaration, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="declaration" Type="System.Xml.Linq.XDeclaration" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="declaration">文件的 <see cref="T:System.Xml.Linq.XDeclaration" />。</param>
        <param name="content">文件的內容。</param>
        <summary>使用指定的 <see cref="T:System.Xml.Linq.XDocument" /> 和內容，初始化 <see cref="T:System.Xml.Linq.XDeclaration" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 需要您建立 <xref:System.Xml.Linq.XDocument> 的案例並不多。 不過，您通常可以使用 <xref:System.Xml.Linq.XElement> 根節點來建立 XML 樹狀結構。 除非您有建立文件的特定需求 (例如，因為您必須在頂層建立處理指示與註解，或者您必須支援文件型別)，否則使用 <xref:System.Xml.Linq.XElement> 做為您的根節點通常更方便。  
  
 如需詳細資訊的有效內容<xref:System.Xml.Linq.XDocument>，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。  
  
   
  
## Examples  
 下列範例會使用這個建構函式建立的文件。  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a new comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
doc.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a new comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
doc.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
<!--This is a new comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName="Declaration">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDeclaration Declaration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDeclaration Declaration" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Declaration" />
      <MemberSignature Language="VB.NET" Value="Public Property Declaration As XDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDeclaration ^ Declaration { System::Xml::Linq::XDeclaration ^ get(); void set(System::Xml::Linq::XDeclaration ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDeclaration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個文件的 XML 宣告。</summary>
        <value>
          <see cref="T:System.Xml.Linq.XDeclaration" />，包含這個文件的 XML 宣告。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有時候，您必須建立文件的 XML 宣告。 如果您想要指出文件是獨立，您必須使用這個屬性。 如果您想要使用的編碼方式 utf-8 比其他編碼文件，您可以指定的編碼方式，透過<xref:System.Xml.Linq.XDeclaration>。 另一種文件的編碼方式是指定的編碼方式<xref:System.Xml.XmlWriter>，您將傳遞至 LINQ to XML 進行寫入。  
  
   
  
## Examples  
 下列範例會使用這個屬性來擷取文件的 XML 宣告。  
  
```csharp  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a comment"),  
    new XElement("Root", "content")  
);  
  
Console.WriteLine(doc.Declaration);  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>content</Root>  
  
Console.WriteLine(doc.Declaration)  
```  
  
 這個範例會產生下列輸出：  
  
```  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentType As XDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDocumentType ^ DocumentType { System::Xml::Linq::XDocumentType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個文件的文件類型定義 (DTD)。</summary>
        <value>
          <see cref="T:System.Xml.Linq.XDocumentType" />，包含這個文件的 DTD。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 提供 Dtd 有限的的支援。  
  
 您可以填入 XML 樹狀結構與 XML 文件包含 DTD。 XML 樹狀結構就會包含<xref:System.Xml.Linq.XDocument.DocumentType%2A>節點。 當您序列化或儲存樹狀目錄時，也會序列化 DTD。 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 將擴充在 DTD 中的任何實體。 當您序列化或儲存的 XML 樹狀結構時，不會儲存實體參考。相反地，節點會儲存與實體參考由實體的文字所取代。  
  
 如果 DTD 包含預設屬性，屬性會建立 XML 樹狀結構中，為一般屬性。  
  
 根據預設，[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]不會驗證其 DTD 為基礎的文件。 若要驗證 DTD 為基礎的文件，建立<xref:System.Xml.XmlReader>，將會驗證根據 DTD、，然後再建立 XML 樹狀結構從<xref:System.Xml.XmlReader>。  
  
   
  
## Examples  
 下列範例會建立包含的文件<xref:System.Xml.Linq.XDocumentType>。  
  
 Visual Basic 不支援 XML 常值中的文件類型。 不過，您可建立包含第一次建立文件使用 XML 常值，然後建立並加入文件類型的文件<xref:System.Xml.Linq.XDocumentType>XML 樹狀結構中的適當位置中的節點。  
  
```csharp  
string internalSubset = @"<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>";  
  
string target = "xml-stylesheet";  
string data = "href='mystyle.css' title='Compact' type='text/css'";  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XProcessingInstruction(target, data),  
    new XDocumentType("Pubs", null, null, internalSubset),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
doc.Declaration = new XDeclaration("1.0", "utf-8", "true");  
Console.WriteLine(doc);  
  
doc.Save("test.xml");  
```  
  
```vb  
Dim internalSubset = _  
        "<!ELEMENT Pubs (Book+)>" & Environment.NewLine & _  
        "<!ELEMENT Book (Title, Author)>" & Environment.NewLine & _  
        "<!ELEMENT Title (#PCDATA)>" & Environment.NewLine & _  
        "<!ELEMENT Author (#PCDATA)>"  
  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
    </Pubs>  
    <!--This is another comment.-->  
  
doc.Nodes().Skip(1).First().AddAfterSelf(New XDocumentType("Pubs", Nothing, Nothing, internalSubset))  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<!--This is a comment.-->  
<?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
<!DOCTYPE Pubs [<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>]>  
<Pubs>  
  <Book>  
    <Title>Artifacts of Roman Civilization</Title>  
    <Author>Moreno, Jordao</Author>  
  </Book>  
  <Book>  
    <Title>Midieval Tools and Implements</Title>  
    <Author>Gazit, Inbar</Author>  
  </Book>  
</Pubs>  
<!--This is another comment.-->  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDocumentType" />
        <altmember cref="P:System.Xml.Linq.XDocument.NodeType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從 URI 指定的檔案、<see cref="T:System.Xml.Linq.XDocument" /> 或 <see cref="T:System.IO.TextReader" />，建立新的 <see cref="T:System.Xml.XmlReader" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用其中一個多載，這個方法，您可以載入<xref:System.Xml.Linq.XDocument>從檔案、 <xref:System.IO.TextReader>，或<xref:System.Xml.XmlReader>。  
  
 若要建立<xref:System.Xml.Linq.XDocument>包含 XML 的字串，從使用<xref:System.Xml.Linq.XDocument.Parse%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">包含 XML 資料的資料流。</param>
        <summary>使用指定的資料流，建立新的 <see cref="T:System.Xml.Linq.XDocument" /> 執行個體。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XDocument" /> 物件，這個物件會讀取資料流中包含的資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您想要控制載入選項，使用<xref:System.Xml.Linq.XDocument.Load%2A>採用多載<xref:System.Xml.Linq.LoadOptions>做為參數。  
  
 LINQ to XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
 如果您需要修改<xref:System.Xml.XmlReaderSettings>，請遵循下列步驟：  
  
1.  建立<xref:System.Xml.XmlReader>透過呼叫其中一個<xref:System.Xml.XmlReader.Create%2A>多載會採用<xref:System.Xml.XmlReaderSettings>做為參數。  
  
2.  傳遞<xref:System.Xml.XmlReader>的其中一個<xref:System.Xml.Linq.XDocument.Load%2A>的多載<xref:System.Xml.Linq.XDocument>採用<xref:System.Xml.XmlReader>做為參數。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader">
          <see cref="T:System.IO.TextReader" />，包含 <see cref="T:System.Xml.Linq.XDocument" /> 的內容。</param>
        <summary>從 <see cref="T:System.Xml.Linq.XDocument" /> 建立新的 <see cref="T:System.IO.TextReader" />。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XDocument" />，包含指定的 <see cref="T:System.IO.TextReader" /> 內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 LINQ XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
   
  
## Examples  
 下列範例會建立文件<xref:System.IO.StringReader>。  
  
```csharp  
TextReader tr = new StringReader("<Root>Content</Root>");  
XDocument doc = XDocument.Load(tr);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim tr As TextReader = New StringReader("<Root>Content</Root>")  
Dim doc As XDocument = XDocument.Load(tr)  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<Root>Content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">參考檔案的 URI 字串會載入至新的 <see cref="T:System.Xml.Linq.XDocument" />。</param>
        <summary>從檔案建立新的 <see cref="T:System.Xml.Linq.XDocument" />。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XDocument" />，包含指定之檔案的內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用基礎<xref:System.Xml.XmlReader>讀入 XML 樹狀結構中的 XML。  
  
 使用<xref:System.Xml.Linq.XDocument.Parse%2A>建立<xref:System.Xml.Linq.XDocument>從包含 XML 的字串。  
  
 LINQ XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
   
  
## Examples  
 下列範例示範如何載入<xref:System.Xml.Linq.XDocument>從檔案。  
  
 此範例使用下列 XML 文件：  
  
 [範例 XML 檔：典型採購訂單 (LINQ to XML)](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)  
  
```csharp  
XDocument doc = XDocument.Load("PurchaseOrder.xml");  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = XDocument.Load("PurchaseOrder.xml")  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```  
<PurchaseOrder PurchaseOrderNumber="99503" OrderDate="1999-10-20">  
  <Address Type="Shipping">  
    <Name>Ellen Adams</Name>  
    <Street>123 Maple Street</Street>  
    <City>Mill Valley</City>  
    <State>CA</State>  
    <Zip>10999</Zip>  
    <Country>USA</Country>  
  </Address>  
  <Address Type="Billing">  
    <Name>Tai Yee</Name>  
    <Street>8 Oak Avenue</Street>  
    <City>Old Town</City>  
    <State>PA</State>  
    <Zip>95819</Zip>  
    <Country>USA</Country>  
  </Address>  
  <DeliveryNotes>Please leave packages in shed by driveway.</DeliveryNotes>  
  <Items>  
    <Item PartNumber="872-AA">  
      <ProductName>Lawnmower</ProductName>  
      <Quantity>1</Quantity>  
      <USPrice>148.95</USPrice>  
      <Comment>Confirm this is electric</Comment>  
    </Item>  
    <Item PartNumber="926-AA">  
      <ProductName>Baby Monitor</ProductName>  
      <Quantity>2</Quantity>  
      <USPrice>39.98</USPrice>  
      <ShipDate>1999-05-21</ShipDate>  
    </Item>  
  </Items>  
</PurchaseOrder>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />，包含 <see cref="T:System.Xml.Linq.XDocument" /> 的內容。</param>
        <summary>從 <see cref="T:System.Xml.Linq.XDocument" /> 建立新的 <see cref="T:System.Xml.XmlReader" />。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XDocument" />，包含指定的 <see cref="T:System.Xml.XmlReader" /> 內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法的其中一個可能的使用是 LINQ to XML 樹狀結構中建立的 DOM 文件複本。 若要這樣做，您建立<xref:System.Xml.XmlNodeReader>從 DOM 文件，然後使用<xref:System.Xml.XmlNodeReader>建立<xref:System.Xml.Linq.XDocument>。  
  
 LINQ XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
   
  
## Examples  
 下列範例會建立 DOM 文件，然後建立<xref:System.Xml.XmlNodeReader>DOM 文件中，從建立<xref:System.Xml.Linq.XDocument>使用<xref:System.Xml.XmlNodeReader>。  
  
```csharp  
// Create a DOM document with some content.  
XmlDocument doc = new XmlDocument();  
XmlElement child = doc.CreateElement("Child");  
child.InnerText = "child contents";  
XmlElement root = doc.CreateElement("Root");  
root.AppendChild(child);  
doc.AppendChild(root);  
  
// create a reader and move to the content  
using (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {  
    // the reader must be in the Interactive state in order to  
    // create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader);  
    Console.WriteLine(xRoot);  
}  
```  
  
```vb  
' Create a DOM document with some content.  
Dim doc As XmlDocument = New XmlDocument()  
Dim child As XmlElement = doc.CreateElement("Child")  
child.InnerText = "child contents"  
Dim root As XmlElement = doc.CreateElement("Root")  
root.AppendChild(child)  
doc.AppendChild(root)  
  
' create a reader and move to the content  
Using nodeReader = New XmlNodeReader(doc)  
    ' the reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader)  
    Console.WriteLine(xRoot)  
End Using  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<Root>  
  <Child>child contents</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="stream">包含 XML 資料的資料流。</param>
        <param name="options">
          <see cref="T:System.Xml.Linq.LoadOptions" />，指定是否要載入基底 URI 和行資訊。</param>
        <summary>使用指定的資料流建立新的 <see cref="T:System.Xml.Linq.XDocument" /> 執行個體，並選擇性地保留空白字元、設定基底 URI，以及保留行資訊。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XDocument" /> 物件，這個物件會讀取資料流中包含的資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 LINQ to XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
 如果您需要修改<xref:System.Xml.XmlReaderSettings>，請遵循下列步驟：  
  
1.  建立<xref:System.Xml.XmlReader>透過呼叫其中一個<xref:System.Xml.XmlReader.Create%2A>多載採用<xref:System.Xml.XmlReaderSettings>做為參數。  
  
2.  傳遞<xref:System.Xml.XmlReader>的其中一個<xref:System.Xml.Linq.XDocument.Load%2A>的多載<xref:System.Xml.Linq.XDocument>採用<xref:System.Xml.XmlReader>做為參數。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="textReader">
          <see cref="T:System.IO.TextReader" />，包含 <see cref="T:System.Xml.Linq.XDocument" /> 的內容。</param>
        <param name="options">
          <see cref="T:System.Xml.Linq.LoadOptions" />，其指定泛空白字元 (White Space) 的行為，以及是否要載入基底 URI 和行資訊。</param>
        <summary>從 <see cref="T:System.Xml.Linq.XDocument" /> 建立新的 <see cref="T:System.IO.TextReader" />，並選擇性地保留泛空白字元、設定基底 URI，以及保留行資訊。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XDocument" />，包含從指定之 <see cref="T:System.IO.TextReader" /> 讀取的 XML。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果來源 XML 縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`會使讀取器讀取來源 XML 中的所有空白字元。 節點類型<xref:System.Xml.Linq.XText>供顯著和不顯著泛空白字元。  
  
 如果來源 XML 縮排，則未設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`導致略過不顯著泛空白字元來源 XML 中的所有讀取器。 建立 XML 樹狀結構沒有任何的無意義的空格的文字節點。  
  
 如果找不到縮排的 XML 的來源，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`沒有任何作用。 顯著泛空白字元仍會保留下來，並沒有無意義的空格可能會導致更多的泛空白字元文字節點建立的合併。  
  
 如需詳細資訊，請參閱[載入或剖析 XML 時保留空白字元](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)和[保留泛空白字元時序列化](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。  
  
 使用<xref:System.Xml.Linq.XDocument.Parse%2A>建立<xref:System.Xml.Linq.XElement>從包含 XML 的字串。  
  
 設定<xref:System.Xml.Linq.LoadOptions.SetBaseUri>無效，無法從載入時<xref:System.IO.TextReader>。  
  
 如果您將會對效能帶來負面影響<xref:System.Xml.Linq.LoadOptions.SetLineInfo>旗標。  
  
 程式行資訊正確無誤之後立即載入 XML 文件。 如果您修改 XML 樹狀結構載入文件之後，行資訊可能會沒有意義。  
  
 LINQ XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
   
  
## Examples  
 下列範例會建立文件<xref:System.IO.StringReader>。  
  
```csharp  
TextReader sr;  
int whiteSpaceNodes;  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree1 = XDocument.Load(sr, LoadOptions.None);  
sr.Close();  
whiteSpaceNodes = xmlTree1  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree2 = XDocument.Load(sr, LoadOptions.PreserveWhitespace);  
sr.Close();  
whiteSpaceNodes = xmlTree2  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
Dim sr As TextReader  
Dim whiteSpaceNodes As Integer  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree1 As XDocument = XDocument.Load(sr, LoadOptions.None)  
sr.Close()  
whiteSpaceNodes = xmlTree1 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree2 As XDocument = XDocument.Load(sr, LoadOptions.PreserveWhitespace)  
sr.Close()  
whiteSpaceNodes = xmlTree2 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 這個範例會產生下列輸出：  
  
```  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="uri">參考檔案的 URI 字串會載入至新的 <see cref="T:System.Xml.Linq.XDocument" />。</param>
        <param name="options">
          <see cref="T:System.Xml.Linq.LoadOptions" />，其指定泛空白字元 (White Space) 的行為，以及是否要載入基底 URI 和行資訊。</param>
        <summary>從檔案建立新的 <see cref="T:System.Xml.Linq.XDocument" />，並選擇性地保留泛空白字元、設定基底 URI，以及保留行資訊。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XDocument" />，包含指定之檔案的內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果來源 XML 縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`會使讀取器讀取來源 XML 中的所有空白字元。 節點類型<xref:System.Xml.Linq.XText>供顯著和不顯著泛空白字元。  
  
 如果來源 XML 縮排，則未設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`導致略過不顯著泛空白字元來源 XML 中的所有讀取器。 建立 XML 樹狀結構沒有任何的無意義的空格的文字節點。  
  
 如果找不到縮排的 XML 的來源，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`沒有任何作用。 顯著泛空白字元仍會保留下來，並沒有無意義的空格可能會導致更多的泛空白字元文字節點建立的合併。  
  
 如需詳細資訊，請參閱[載入或剖析 XML 時保留空白字元](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)和[保留泛空白字元時序列化](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。  
  
 使用<xref:System.Xml.Linq.XDocument.Parse%2A>建立<xref:System.Xml.Linq.XDocument>從包含 XML 的字串。  
  
 如果您將會對效能帶來負面影響<xref:System.Xml.Linq.LoadOptions.SetBaseUri>和<xref:System.Xml.Linq.LoadOptions.SetLineInfo>旗標。  
  
 基底 URI 與行資訊正確後立即載入 XML 文件。 如果您修改 XML 樹狀結構之後載入文件，基底 URI 和行資訊可能會沒有意義。  
  
 LINQ XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
   
  
## Examples  
 下列範例示範如何載入<xref:System.Xml.Linq.XDocument>從檔案。  
  
 此範例使用下列 XML 文件：  
  
 [範例 XML 檔：典型採購訂單 (LINQ to XML)](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)  
  
```csharp  
XDocument doc1 = XDocument.Load("PurchaseOrder.xml", LoadOptions.None);  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count());  
  
XDocument doc2 = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim doc1 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.None)  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count())  
  
Dim doc2 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 這個範例會產生下列輸出：  
  
```  
nodes if not preserving whitespace: 48  
nodes if preserving whitespace: 82  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />，將從中讀取 <see cref="T:System.Xml.Linq.XDocument" /> 的內容。</param>
        <param name="options">
          <see cref="T:System.Xml.Linq.LoadOptions" />，指定是否要載入基底 URI 和行資訊。</param>
        <summary>從 <see cref="T:System.Xml.Linq.XDocument" /> 載入 <see cref="T:System.Xml.XmlReader" />，選擇性地設定基底 URI，並保留行資訊。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XDocument" />，包含從指定之 <see cref="T:System.Xml.XmlReader" /> 讀取的 XML。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由建立<xref:System.Xml.XmlNodeReader>從 DOM 文件，然後將<xref:System.Xml.XmlNodeReader>建立<xref:System.Xml.Linq.XElement>，這個方法可以用來建立 LINQ to XML 樹狀結構中的 DOM 文件的複本。  
  
 使用<xref:System.Xml.Linq.XDocument.Parse%2A>建立<xref:System.Xml.Linq.XDocument>從包含 XML 的字串。  
  
 設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>無效，無法從載入時<xref:System.Xml.XmlReader>。 <xref:System.Xml.XmlReader>或不會設定為其中一個讀取的空白字元。 LINQ to XML 樹狀結構將會填入泛空白字元節點的讀取器介面。 這是不論是否行為<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>或未設定。  
  
 <xref:System.Xml.XmlReader>或不可能有有效的基底 URI。 如果您設定<xref:System.Xml.Linq.LoadOptions.SetBaseUri>，基底 URI 將 XML 樹狀結構中所報告的基底 URI 從<xref:System.Xml.XmlReader>。  
  
 <xref:System.Xml.XmlReader>或不可能有有效的線條資訊。 如果您設定<xref:System.Xml.Linq.LoadOptions.SetLineInfo>，行資訊將 XML 樹狀結構中所報告的行資訊從<xref:System.Xml.XmlReader>。  
  
 如果您將會對效能帶來負面影響<xref:System.Xml.Linq.LoadOptions.SetLineInfo>旗標。  
  
 程式行資訊正確無誤之後立即載入 XML 文件。 如果您修改 XML 樹狀結構載入文件之後，行資訊可能會沒有意義。  
  
 LINQ XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
   
  
## Examples  
 下列範例會載入它從載入的行資訊<xref:System.Xml.XmlReader>。 接著，它會列印行資訊。  
  
```csharp  
string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
// Create a reader and move to the content.  
using (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))  
{  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader, LoadOptions.SetLineInfo);  
    Console.WriteLine("{0}{1}{2}",  
        "Element Name".PadRight(20),  
        "Line".PadRight(5),  
        "Position");  
    Console.WriteLine("{0}{1}{2}",  
        "------------".PadRight(20),  
        "----".PadRight(5),  
        "--------");  
    foreach (XElement e in xRoot.Elements("Root").DescendantsAndSelf())  
        Console.WriteLine("{0}{1}{2}",  
            ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
            ((IXmlLineInfo)e).LinePosition);  
}  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child>" & Environment.NewLine & _  
    "        <GrandChild/>" & Environment.NewLine & _  
    "    </Child>" & Environment.NewLine & _  
    "</Root>"  
  
' Create a reader and move to the content.  
Using nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))  
  
    ' The reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader, LoadOptions.SetLineInfo)  
    Console.WriteLine("{0}{1}{2}", _  
        "Element Name".PadRight(20), _  
        "Line".PadRight(5), _  
        "Position")  
    Console.WriteLine("{0}{1}{2}", _  
        "------------".PadRight(20), _  
        "----".PadRight(5), _  
        "--------")  
    For Each e As XElement In xRoot.Elements("Root").DescendantsAndSelf()  
        Console.WriteLine("{0}{1}{2}", _  
            ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _  
            (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
            (DirectCast(e, IXmlLineInfo)).LinePosition)  
    Next  
End Using  
```  
  
 這個範例會產生下列輸出：  
  
```  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.Stream stream, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.Stream,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.TextReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textReader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.Xml.XmlReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此節點的節點類型。</summary>
        <value>節點類型。 對於 <see cref="T:System.Xml.Linq.XDocument" /> 物件，此值為 <see cref="F:System.Xml.XmlNodeType.Document" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為所有的類別，衍生自<xref:System.Xml.Linq.XObject>包含<xref:System.Xml.Linq.XObject.NodeType%2A>屬性，您可以撰寫程式碼運作的每個型別所在的子類別的物件集合的<xref:System.Xml.Linq.XObject>。 然後您的程式碼可以測試每個物件在集合中的節點型別。  
  
   
  
## Examples  
 下列範例示範如何使用這個屬性。  
  
```csharp  
// Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
XDocument xmlTree = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XElement("Root", "content")  
);  
Console.WriteLine(xmlTree.NodeType);  
```  
  
```vb  
' Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
Dim xmlTree As XDocument = _  
    <?xml version='1.0' encoding='utf-8' standalone='yes'?>  
        <Root>content</Root>  
Console.WriteLine("{0}", xmlTree.NodeType)  
```  
  
 這個範例會產生下列輸出：  
  
```  
Document  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
        <altmember cref="P:System.Xml.Linq.XDocument.DocumentType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從字串建立新的 <see cref="T:System.Xml.Linq.XDocument" />，並選擇性地保留泛空白字元、設定基底 URI，以及保留行資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會剖析字串，然後建立 XML 樹狀結構。  
  
   
  
## Examples  
 下列範例會建立包含 XML 的字串。 然後它會剖析字串插入<xref:System.Xml.Linq.XDocument>。  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">包含 XML 的字串。</param>
        <summary>從字串建立新的 <see cref="T:System.Xml.Linq.XDocument" />。</summary>
        <returns>從包含 XML 的字串填入的 <see cref="T:System.Xml.Linq.XDocument" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會保留泛空白字元。 如果您想要保留 XML 樹狀結構中的空白字元，使用的多載<xref:System.Xml.Linq.XDocument.Parse%2A>採用<xref:System.Xml.Linq.LoadOptions>做為參數。  
  
 如需詳細資訊，請參閱[載入或剖析 XML 時保留空白字元](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)和[保留泛空白字元時序列化](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。  
  
 LINQ XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
   
  
## Examples  
 下列範例會建立包含 XML 的字串。 然後它會剖析字串插入<xref:System.Xml.Linq.XDocument>。  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text, System::Xml::Linq::LoadOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="text">包含 XML 的字串。</param>
        <param name="options">
          <see cref="T:System.Xml.Linq.LoadOptions" />，其指定泛空白字元 (White Space) 的行為，以及是否要載入基底 URI 和行資訊。</param>
        <summary>從字串建立新的 <see cref="T:System.Xml.Linq.XDocument" />，並選擇性地保留泛空白字元、設定基底 URI，以及保留行資訊。</summary>
        <returns>從包含 XML 的字串填入的 <see cref="T:System.Xml.Linq.XDocument" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果來源 XML 縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`會使讀取器讀取來源 XML 中的所有空白字元。 節點類型<xref:System.Xml.Linq.XText>供顯著和不顯著泛空白字元。  
  
 如果來源 XML 縮排，則未設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`導致略過不顯著泛空白字元來源 XML 中的所有讀取器。 建立 XML 樹狀結構沒有任何的無意義的空格的文字節點。  
  
 如果找不到縮排的 XML 的來源，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標`options`沒有任何作用。 顯著泛空白字元仍會保留下來，並沒有無意義的空格可能會導致更多的泛空白字元文字節點建立的合併。  
  
 如需詳細資訊，請參閱[載入或剖析 XML 時保留空白字元](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)和[保留泛空白字元時序列化](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。  
  
 設定<xref:System.Xml.Linq.LoadOptions.SetBaseUri>無效，無法剖析從時<xref:System.String>。  
  
 如果您將會對效能帶來負面影響<xref:System.Xml.Linq.LoadOptions.SetLineInfo>旗標。  
  
 程式行資訊正確無誤之後立即載入 XML 文件。 如果您修改 XML 樹狀結構載入文件之後，行資訊可能會沒有意義。  
  
 LINQ XML 的載入功能建置在<xref:System.Xml.XmlReader>。 因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>讀取和剖析文件的方法。  
  
   
  
## Examples  
 下列範例將字串剖析成<xref:System.Xml.Linq.XDocument>。  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc1 = XDocument.Parse(str, LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count());  
XDocument doc2 = XDocument.Parse(str, LoadOptions.None);  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim str As String = _  
"<?xml version= '1.0'?>" & Environment.NewLine & _  
"<!-- comment at the root level -->" & Environment.NewLine & _  
"<Root>" & Environment.NewLine & _  
"    <Child>Content</Child>"  & Environment.NewLine & _  
"</Root>"  
  
Dim doc1 As XDocument = XDocument.Parse(str, LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count())  
Dim doc2 As XDocument = XDocument.Parse(str, LoadOptions.None)  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 這個範例會產生下列輸出：  
  
```  
nodes when preserving whitespace: 8  
nodes when not preserving whitespace: 4  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XElement Root" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XElement ^ Root { System::Xml::Linq::XElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此文件之 XML 樹狀結構的根項目 (Root Element)。</summary>
        <value>XML 樹狀結構的根 (Root) <see cref="T:System.Xml.Linq.XElement" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性相當實用，當您想要撰寫[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]做為當它們撰寫樹狀目錄的根項目中的同一內容中的查詢<xref:System.Xml.Linq.XElement>。 請參閱[查詢 XDocument 與。查詢 XElement](http://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a)如需詳細資訊。  
  
   
  
## Examples  
 下列範例會使用這個屬性，以取得文件的根項目。  
  
```csharp  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
Console.WriteLine(doc.Root.Name.ToString());  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
        <!--This is another comment.-->  
    </Pubs>  
  
Console.WriteLine(doc.Root.Name.ToString())  
```  
  
 這個範例會產生下列輸出：  
  
```  
Pubs  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為檔案、<see cref="T:System.IO.TextWriter" /> 或 <see cref="T:System.Xml.XmlWriter" />。</summary>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">這個 <see cref="T:System.Xml.Linq.XDocument" /> 輸出的目的資料流。</param>
        <summary>將這個 <see cref="T:System.Xml.Linq.XDocument" /> 輸出到指定的 <see cref="T:System.IO.Stream" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將縮排序列化的 XML。 將會移除所有無意義的空格，並會加入額外的空白字元，如此會適當地縮排的 XML。 這個方法的行為是將不會保留不顯著泛空白字元。  
  
 如果您想要控制空白字元，使用的多載<xref:System.Xml.Linq.XDocument.Save%2A>採用<xref:System.Xml.Linq.SaveOptions>做為參數。 使用<xref:System.Xml.Linq.SaveOptions.DisableFormatting>將未縮排的 XML 儲存選項。 這會導致寫入器寫入所有空白完全 XML 樹狀結構中所示。  
  
 使用<xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>選項，如果您想要移除重複的命名空間宣告。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">向其中寫入 <see cref="T:System.IO.TextWriter" /> 的 <see cref="T:System.Xml.Linq.XDocument" />。</param>
        <summary>將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為 <see cref="T:System.IO.TextWriter" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將縮排序列化的 XML。 將會移除所有無意義的空格，並會加入額外的空白字元，如此會適當地縮排的 XML。 這個方法的行為是將不會保留不顯著泛空白字元。  
  
 如果您想要控制空白字元，使用的多載<xref:System.Xml.Linq.XDocument.Save%2A>採用<xref:System.Xml.Linq.SaveOptions>做為參數。 如需詳細資訊，請參閱[載入或剖析 XML 時保留空白字元](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)和[保留泛空白字元時序列化](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Xml.Linq.XDocument>，將儲存的文件<xref:System.IO.StringWriter>，然後列印到主控台的字串。  
  
```csharp  
StringBuilder sb = new StringBuilder();  
  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
TextWriter tr = new StringWriter(sb);  
doc.Save(tr);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim tr As TextWriter = New StringWriter(sb)  
doc.Save(tr)  
Console.WriteLine(sb.ToString())  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">字串，包含檔案名稱。</param>
        <summary>將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化至檔案，並覆寫現有的檔案 (如果存在)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將縮排序列化的 XML。 將會移除所有無意義的空格，並會加入額外的空白字元，如此會適當地縮排的 XML。 這個方法的行為是將不會保留不顯著泛空白字元。  
  
 如果您想要控制空白字元，使用的多載<xref:System.Xml.Linq.XDocument.Save%2A>採用<xref:System.Xml.Linq.SaveOptions>做為參數。 如需詳細資訊，請參閱[載入或剖析 XML 時保留空白字元](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)和[保留泛空白字元時序列化](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Xml.Linq.XDocument>，將文件儲存至檔案，然後列印到主控台檔案。  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root.xml");  
Console.WriteLine(File.ReadAllText("Root.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root.xml")  
Console.WriteLine(File.ReadAllText("Root.xml"))  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">向其中寫入 <see cref="T:System.Xml.XmlWriter" /> 的 <see cref="T:System.Xml.Linq.XDocument" />。</param>
        <summary>將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為 <see cref="T:System.Xml.XmlWriter" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例顯示如何將 <xref:System.Xml.Linq.XDocument> 儲存為 <xref:System.Xml.XmlWriter>。  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.Save(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.Save(xw)  
  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">這個 <see cref="T:System.Xml.Linq.XDocument" /> 輸出的目的資料流。</param>
        <param name="options">指定格式化行為的 <see cref="T:System.Xml.Linq.SaveOptions" />。</param>
        <summary>將這個 <see cref="T:System.Xml.Linq.XDocument" /> 輸出至指定的 <see cref="T:System.IO.Stream" />，選擇性地指定格式化行為。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設`options`設為<xref:System.Xml.Linq.SaveOptions.None>。 此選項會移除所有多餘的不顯著泛空白字元，並將適當的無效空白字元，因此，XML 適當地縮排。  
  
 如果您想要儲存不縮排的 XML，指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。 這會導致寫入器寫入所有空白完全 XML 樹狀結構中所示。  
  
 使用<xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>選項，如果您想要移除重複的命名空間宣告。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter">做為 XML 之輸出目標的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">指定格式化行為的 <see cref="T:System.Xml.Linq.SaveOptions" />。</param>
        <summary>將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為 <see cref="T:System.IO.TextWriter" />，選擇性地停用格式設定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您想要儲存不縮排的 XML，指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。 這會導致寫入器寫入的所有空白字元完全 XML 樹狀結構中所示。  
  
 如果您想要儲存縮排的 XML，未指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。 這會移除所有多餘的不顯著泛空白字元，並將適當的無效空白字元，因此，XML 適當地縮排。 這是預設行為，以及多載的行為<xref:System.Xml.Linq.XDocument.Save%2A>方法不接受`options`做為參數。  
  
 如需詳細資訊，請參閱[載入或剖析 XML 時保留空白字元](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)和[保留泛空白字元時序列化](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。  
  
   
  
## Examples  
 下列範例會示範這個方法的兩種用法。 第一次使用序列化<xref:System.Xml.Linq.XDocument>格式。 第二個保留泛空白字元。 文件不有任何空格所建構，因為保留泛空白字元輸出沒有縮排的 XML。  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
StringBuilder sb1 = new StringBuilder();  
using (StringWriter sr1 = new StringWriter(sb1)) {  
    doc.Save(sr1, SaveOptions.None);  
    Console.WriteLine(sb1.ToString());  
}  
  
StringBuilder sb2 = new StringBuilder();  
using (StringWriter sr2 = new StringWriter(sb2)) {  
    doc.Save(sr2, SaveOptions.DisableFormatting);  
    Console.WriteLine(sb2.ToString());  
}  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim sb1 As StringBuilder = New StringBuilder()  
  
Using sr1 = New StringWriter(sb1)  
    doc.Save(sr1, SaveOptions.None)  
    Console.WriteLine(sb1.ToString())  
End Using  
  
Dim sb2 As StringBuilder = New StringBuilder()  
  
Using sr2 = New StringWriter(sb2)  
    doc.Save(sr2, SaveOptions.DisableFormatting)  
    Console.WriteLine(sb2.ToString())  
End Using  
```  
  
 這個範例會產生下列輸出：  
  
```  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
<?xml version="1.0" encoding="utf-16"?><Root><Child>content</Child></Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">字串，包含檔案名稱。</param>
        <param name="options">指定格式化行為的 <see cref="T:System.Xml.Linq.SaveOptions" />。</param>
        <summary>將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為檔案，選擇性地停用格式設定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您想要儲存不縮排的 XML，指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。 這會導致寫入器寫入的所有空白字元完全 XML 樹狀結構中所示。  
  
 如果您想要儲存縮排的 XML，未指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。 這會移除所有多餘的不顯著泛空白字元，並將適當的無效空白字元，因此，XML 適當地縮排。 這是預設行為，以及多載的行為<xref:System.Xml.Linq.XDocument.Save%2A>方法不接受`options`做為參數。  
  
 如需詳細資訊，請參閱[載入或剖析 XML 時保留空白字元](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)和[保留泛空白字元時序列化](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。  
  
   
  
## Examples  
 下列範例會示範這個方法的兩種用法。 第一次使用保留泛空白字元。 第二個序列化<xref:System.Xml.Linq.XDocument>與縮排。  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root1.xml", SaveOptions.DisableFormatting);  
Console.WriteLine(File.ReadAllText("Root1.xml"));  
doc.Save("Root2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Root2.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root1.xml", SaveOptions.DisableFormatting)  
Console.WriteLine(File.ReadAllText("Root1.xml"))  
doc.Save("Root2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Root2.xml"))  
```  
  
 這個範例會產生下列輸出：  
  
```  
<?xml version="1.0" encoding="utf-8"?><Root><Child>content</Child></Root>  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.Stream stream, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.Stream,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.TextWriter,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textWriter">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">此方法將寫入其中的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>將此文件寫入 <see cref="T:System.Xml.XmlWriter" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何撰寫<xref:System.Xml.Linq.XDocument>至<xref:System.Xml.XmlWriter>。 請注意此範例並未撰寫 XML 宣告。  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.WriteTo(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.WriteTo(xw)  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 這個範例會產生下列輸出：  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>