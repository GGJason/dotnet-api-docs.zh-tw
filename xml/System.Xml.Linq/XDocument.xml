<Type Name="XDocument" FullName="System.Xml.Linq.XDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="38b16d8102e64916712cbaf7e0ae058e627c4ec5" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51928094" /></Metadata><TypeSignature Language="C#" Value="public class XDocument : System.Xml.Linq.XContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XDocument extends System.Xml.Linq.XContainer" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XDocument&#xA;Inherits XContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XDocument : System::Xml::Linq::XContainer" />
  <TypeSignature Language="F#" Value="type XDocument = class&#xA;    inherit XContainer" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="68e88-101">表示 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-101">Represents an XML document.</span></span> <span data-ttu-id="68e88-102">如需 <see cref="T:System.Xml.Linq.XDocument" /> 物件的元件和用法，請參閱 <see href="https://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467">XDocument 類別概觀</see>。</span><span class="sxs-lookup"><span data-stu-id="68e88-102">For the components and usage of an <see cref="T:System.Xml.Linq.XDocument" /> object, see <see href="https://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467">XDocument Class Overview</see>.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-103">如需詳細資訊的有效的內容<xref:System.Xml.Linq.XDocument>，請參閱 <<c2> [ 有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="68e88-103">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-104">下列範例建立文件，並再將註解和項目加入至它。</span><span class="sxs-lookup"><span data-stu-id="68e88-104">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="68e88-105">它接著會使用的查詢結果的另一個文件來撰寫。</span><span class="sxs-lookup"><span data-stu-id="68e88-105">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-106">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-106">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.Linq.XNamespace" />
    <altmember cref="T:System.Xml.Linq.XDeclaration" />
    <altmember cref="T:System.Xml.Linq.XElement" />
    <altmember cref="T:System.Xml.Linq.XNode" />
    <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-107">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-107">LINQ to XML</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467"><span data-ttu-id="68e88-108">XDocument 類別概觀</span><span class="sxs-lookup"><span data-stu-id="68e88-108">XDocument Class Overview</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="68e88-109">初始化 <see cref="T:System.Xml.Linq.XDocument" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="68e88-109">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-110">多載的建構函式可讓您建立新的空<xref:System.Xml.Linq.XDocument>;，即可建立<xref:System.Xml.Linq.XDocument>某些指定的初始內容; 以及建立<xref:System.Xml.Linq.XDocument>做為另一個複本<xref:System.Xml.Linq.XDocument>物件。</span><span class="sxs-lookup"><span data-stu-id="68e88-110">Overloaded constructors enable you to create a new empty <xref:System.Xml.Linq.XDocument>; to create an <xref:System.Xml.Linq.XDocument> with some specified initial content; and to create an <xref:System.Xml.Linq.XDocument> as a copy of another <xref:System.Xml.Linq.XDocument> object.</span></span>  
  
 <span data-ttu-id="68e88-111">需要您建立 <xref:System.Xml.Linq.XDocument> 的案例並不多。</span><span class="sxs-lookup"><span data-stu-id="68e88-111">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="68e88-112">不過，您通常可以使用 <xref:System.Xml.Linq.XElement> 根節點來建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="68e88-112">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="68e88-113">除非您有建立文件的特定需求 (例如，因為您必須在頂層建立處理指示與註解，或者您必須支援文件型別)，否則使用 <xref:System.Xml.Linq.XElement> 做為您的根節點通常更方便。</span><span class="sxs-lookup"><span data-stu-id="68e88-113">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="68e88-114">如需詳細資訊的有效的內容<xref:System.Xml.Linq.XDocument>，請參閱 <<c2> [ 有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="68e88-114">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-115">下列範例建立文件，並再將註解和項目加入至它。</span><span class="sxs-lookup"><span data-stu-id="68e88-115">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="68e88-116">它接著會使用的查詢結果的另一個文件來撰寫。</span><span class="sxs-lookup"><span data-stu-id="68e88-116">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-117">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-117">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-118">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-118">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467"><span data-ttu-id="68e88-119">XDocument 類別概觀</span><span class="sxs-lookup"><span data-stu-id="68e88-119">XDocument Class Overview</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="68e88-120">初始化 <see cref="T:System.Xml.Linq.XDocument" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="68e88-120">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-121">需要您建立 <xref:System.Xml.Linq.XDocument> 的案例並不多。</span><span class="sxs-lookup"><span data-stu-id="68e88-121">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="68e88-122">不過，您通常可以使用 <xref:System.Xml.Linq.XElement> 根節點來建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="68e88-122">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="68e88-123">除非您有建立文件的特定需求 (例如，因為您必須在頂層建立處理指示與註解，或者您必須支援文件型別)，否則使用 <xref:System.Xml.Linq.XElement> 做為您的根節點通常更方便。</span><span class="sxs-lookup"><span data-stu-id="68e88-123">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="68e88-124">如需詳細資訊的有效的內容<xref:System.Xml.Linq.XDocument>，請參閱 <<c2> [ 有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="68e88-124">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-125">下列範例會建立新的文件，然後將加入其中的 註解和項目。</span><span class="sxs-lookup"><span data-stu-id="68e88-125">The following example creates a new document, and then adds a comment and an element to it.</span></span>  
  
```csharp  
XDocument doc = new XDocument();  
doc.Add(new XComment("This is a comment"));  
doc.Add(new XElement("Root", "content"));  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = New XDocument()  
doc.Add(<!--This is a comment-->)  
doc.Add(<Root>content</Root>)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-126">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-126">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-127">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-127">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467"><span data-ttu-id="68e88-128">XDocument 類別概觀</span><span class="sxs-lookup"><span data-stu-id="68e88-128">XDocument Class Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : obj[] -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument content" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="68e88-129">要加入此文件之內容物件的參數清單。</span><span class="sxs-lookup"><span data-stu-id="68e88-129">A parameter list of content objects to add to this document.</span></span></param>
        <summary><span data-ttu-id="68e88-130">使用指定的內容初始化 <see cref="T:System.Xml.Linq.XDocument" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="68e88-130">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-131">需要您建立 <xref:System.Xml.Linq.XDocument> 的案例並不多。</span><span class="sxs-lookup"><span data-stu-id="68e88-131">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="68e88-132">不過，您通常可以使用 <xref:System.Xml.Linq.XElement> 根節點來建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="68e88-132">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="68e88-133">除非您有建立文件的特定需求 (例如，因為您必須在頂層建立處理指示與註解，或者您必須支援文件型別)，否則使用 <xref:System.Xml.Linq.XElement> 做為您的根節點通常更方便。</span><span class="sxs-lookup"><span data-stu-id="68e88-133">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="68e88-134">如需詳細資訊的有效的內容<xref:System.Xml.Linq.XDocument>，請參閱 <<c2> [ 有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="68e88-134">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-135">下列範例建立文件，並再將註解和項目加入至它。</span><span class="sxs-lookup"><span data-stu-id="68e88-135">The following example creates a document, and then adds a comment and an element to it.</span></span> <span data-ttu-id="68e88-136">它接著會使用的查詢結果的另一個文件來撰寫。</span><span class="sxs-lookup"><span data-stu-id="68e88-136">It then composes another document using the results of a query.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-137">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-137">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-138">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-138">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467"><span data-ttu-id="68e88-139">XDocument 類別概觀</span><span class="sxs-lookup"><span data-stu-id="68e88-139">XDocument Class Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDocument other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDocument other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDocument ^ other);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : System.Xml.Linq.XDocument -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument other" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XDocument" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="68e88-140">要複製的 <see cref="T:System.Xml.Linq.XDocument" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="68e88-140">The <see cref="T:System.Xml.Linq.XDocument" /> object that will be copied.</span></span></param>
        <summary><span data-ttu-id="68e88-141">從現有的 <see cref="T:System.Xml.Linq.XDocument" /> 物件，初始化 <see cref="T:System.Xml.Linq.XDocument" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="68e88-141">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class from an existing <see cref="T:System.Xml.Linq.XDocument" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-142">您可以使用這個建構函式進行的深層複本<xref:System.Xml.Linq.XDocument>。</span><span class="sxs-lookup"><span data-stu-id="68e88-142">You use this constructor to make a deep copy of an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 <span data-ttu-id="68e88-143">所有節點和屬性中指定的文件中，這個建構函式會都周遊`other`參數，並建立所有節點的複本，因為它會組譯新初始化<xref:System.Xml.Linq.XDocument>。</span><span class="sxs-lookup"><span data-stu-id="68e88-143">This constructor traverses all nodes and attributes in the document specified in the `other` parameter, and creates copies of all nodes as it assembles the newly initialized <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-144">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-144">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467"><span data-ttu-id="68e88-145">XDocument 類別概觀</span><span class="sxs-lookup"><span data-stu-id="68e88-145">XDocument Class Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDeclaration declaration, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDeclaration declaration, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDeclaration,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (declaration As XDeclaration, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDeclaration ^ declaration, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : System.Xml.Linq.XDeclaration * obj[] -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument (declaration, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="declaration" Type="System.Xml.Linq.XDeclaration" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="declaration"><span data-ttu-id="68e88-146">文件的 <see cref="T:System.Xml.Linq.XDeclaration" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-146">An <see cref="T:System.Xml.Linq.XDeclaration" /> for the document.</span></span></param>
        <param name="content"><span data-ttu-id="68e88-147">文件的內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-147">The content of the document.</span></span></param>
        <summary><span data-ttu-id="68e88-148">使用指定的 <see cref="T:System.Xml.Linq.XDocument" /> 和內容，初始化 <see cref="T:System.Xml.Linq.XDeclaration" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="68e88-148">Initializes a new instance of the <see cref="T:System.Xml.Linq.XDocument" /> class with the specified <see cref="T:System.Xml.Linq.XDeclaration" /> and content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-149">需要您建立 <xref:System.Xml.Linq.XDocument> 的案例並不多。</span><span class="sxs-lookup"><span data-stu-id="68e88-149">There are not many scenarios that require you to create an <xref:System.Xml.Linq.XDocument>.</span></span> <span data-ttu-id="68e88-150">不過，您通常可以使用 <xref:System.Xml.Linq.XElement> 根節點來建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="68e88-150">Instead, you can usually create your XML trees with an <xref:System.Xml.Linq.XElement> root node.</span></span> <span data-ttu-id="68e88-151">除非您有建立文件的特定需求 (例如，因為您必須在頂層建立處理指示與註解，或者您必須支援文件型別)，否則使用 <xref:System.Xml.Linq.XElement> 做為您的根節點通常更方便。</span><span class="sxs-lookup"><span data-stu-id="68e88-151">Unless you have a specific requirement to create a document (for example, because you have to create processing instructions and comments at the top level, or you have to support document types), it is often more convenient to use <xref:System.Xml.Linq.XElement> as your root node.</span></span>  
  
 <span data-ttu-id="68e88-152">如需詳細資訊的有效的內容<xref:System.Xml.Linq.XDocument>，請參閱 <<c2> [ 有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="68e88-152">For details about the valid content of an <xref:System.Xml.Linq.XDocument>, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-153">下列範例會使用這個建構函式建立的文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-153">The following example uses this constructor to create a document.</span></span>  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a new comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
doc.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a new comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
doc.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 <span data-ttu-id="68e88-154">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-154">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
<!--This is a new comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-155">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-155">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467"><span data-ttu-id="68e88-156">XDocument 類別概觀</span><span class="sxs-lookup"><span data-stu-id="68e88-156">XDocument Class Overview</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Declaration">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDeclaration Declaration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDeclaration Declaration" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Declaration" />
      <MemberSignature Language="VB.NET" Value="Public Property Declaration As XDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDeclaration ^ Declaration { System::Xml::Linq::XDeclaration ^ get(); void set(System::Xml::Linq::XDeclaration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Declaration : System.Xml.Linq.XDeclaration with get, set" Usage="System.Xml.Linq.XDocument.Declaration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDeclaration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e88-157">取得或設定這個文件的 XML 宣告。</span><span class="sxs-lookup"><span data-stu-id="68e88-157">Gets or sets the XML declaration for this document.</span></span></summary>
        <value><span data-ttu-id="68e88-158"><see cref="T:System.Xml.Linq.XDeclaration" />，包含這個文件的 XML 宣告。</span><span class="sxs-lookup"><span data-stu-id="68e88-158">An <see cref="T:System.Xml.Linq.XDeclaration" /> that contains the XML declaration for this document.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-159">有時候，您必須建立文件的 XML 宣告。</span><span class="sxs-lookup"><span data-stu-id="68e88-159">Sometimes you have to create an XML declaration for a document.</span></span> <span data-ttu-id="68e88-160">如果您想要指出文件是獨立，您必須使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="68e88-160">If you want to indicate that a document is standalone, you must use this property.</span></span> <span data-ttu-id="68e88-161">如果您想要使用的編碼方式，而非 utf-8 編碼文件，您可以指定的編碼方式，透過<xref:System.Xml.Linq.XDeclaration>。</span><span class="sxs-lookup"><span data-stu-id="68e88-161">If you want to encode your document with an encoding other than utf-8, you can specify an encoding through the <xref:System.Xml.Linq.XDeclaration>.</span></span> <span data-ttu-id="68e88-162">編碼文件的另一種方法是指定的編碼方式在<xref:System.Xml.XmlWriter>，您將傳遞至 LINQ to XML 進行寫入。</span><span class="sxs-lookup"><span data-stu-id="68e88-162">Another approach for encoding a document is to specify the encoding on an <xref:System.Xml.XmlWriter> that you pass to LINQ to XML for writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-163">下列範例會使用這個屬性來擷取文件的 XML 宣告。</span><span class="sxs-lookup"><span data-stu-id="68e88-163">The following example uses this property to retrieve the XML declaration of a document.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a comment"),  
    new XElement("Root", "content")  
);  
  
Console.WriteLine(doc.Declaration);  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>content</Root>  
  
Console.WriteLine(doc.Declaration)  
```  
  
 <span data-ttu-id="68e88-164">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-164">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDeclaration" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-165">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-165">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/215bcf5b-284b-4d7e-a95a-8d8e241341a9"><span data-ttu-id="68e88-166">如何：讀取和寫入編碼文件</span><span class="sxs-lookup"><span data-stu-id="68e88-166">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentType As XDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDocumentType ^ DocumentType { System::Xml::Linq::XDocumentType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentType : System.Xml.Linq.XDocumentType" Usage="System.Xml.Linq.XDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e88-167">取得這個文件的文件類型定義 (DTD)。</span><span class="sxs-lookup"><span data-stu-id="68e88-167">Gets the Document Type Definition (DTD) for this document.</span></span></summary>
        <value><span data-ttu-id="68e88-168"><see cref="T:System.Xml.Linq.XDocumentType" />，包含這個文件的 DTD。</span><span class="sxs-lookup"><span data-stu-id="68e88-168">A <see cref="T:System.Xml.Linq.XDocumentType" /> that contains the DTD for this document.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="68e88-169">提供 Dtd 有限的的支援。</span><span class="sxs-lookup"><span data-stu-id="68e88-169">provides limited support for DTDs.</span></span>  
  
 <span data-ttu-id="68e88-170">您可以填入 XML 樹狀結構以包含 DTD 的 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-170">You can populate an XML tree with an XML document that contains a DTD.</span></span> <span data-ttu-id="68e88-171">XML 樹狀結構就會包含<xref:System.Xml.Linq.XDocument.DocumentType%2A>節點。</span><span class="sxs-lookup"><span data-stu-id="68e88-171">The XML tree will then contain a <xref:System.Xml.Linq.XDocument.DocumentType%2A> node.</span></span> <span data-ttu-id="68e88-172">當您序列化或儲存樹狀目錄時，將會序列化 DTD。</span><span class="sxs-lookup"><span data-stu-id="68e88-172">When you serialize or save the tree, the DTD will also be serialized.</span></span> [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="68e88-173">將擴充在 DTD 中的任何實體。</span><span class="sxs-lookup"><span data-stu-id="68e88-173">will expand any entities in the DTD.</span></span> <span data-ttu-id="68e88-174">當您序列化或儲存 XML 樹狀結構時，不會儲存實體的參考;相反地，節點會儲存實體參考之實體的文字所取代。</span><span class="sxs-lookup"><span data-stu-id="68e88-174">When you serialize or save the XML tree, the entity references are not saved; instead, the nodes are saved with the entity references replaced by the text of the entity.</span></span>  
  
 <span data-ttu-id="68e88-175">如果 DTD 包含預設屬性，屬性會建立 XML 樹狀結構中，為一般屬性。</span><span class="sxs-lookup"><span data-stu-id="68e88-175">If the DTD contains default attributes, the attributes are created in the XML tree as ordinary attributes.</span></span>  
  
 <span data-ttu-id="68e88-176">根據預設，[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]不會驗證其 DTD 為基礎的文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-176">By default, [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] does not validate a document based on its DTD.</span></span> <span data-ttu-id="68e88-177">若要驗證基礎 DTD 的文件，建立<xref:System.Xml.XmlReader>，將會驗證根據 DTD，，然後再建立 XML 樹狀結構從<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-177">To validate a document based on a DTD, create an <xref:System.Xml.XmlReader> that will validate based on a DTD, and then create an XML tree from the <xref:System.Xml.XmlReader>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-178">下列範例會建立包含的文件<xref:System.Xml.Linq.XDocumentType>。</span><span class="sxs-lookup"><span data-stu-id="68e88-178">The following example creates a document that contains an <xref:System.Xml.Linq.XDocumentType>.</span></span>  
  
 <span data-ttu-id="68e88-179">Visual Basic 不支援 XML 常值內的文件類型。</span><span class="sxs-lookup"><span data-stu-id="68e88-179">Visual Basic does not support document types within XML literals.</span></span> <span data-ttu-id="68e88-180">不過，就可以建立第一次建立文件使用 XML 常值，並接著建立並加入含有文件類型的文件<xref:System.Xml.Linq.XDocumentType>XML 樹狀結構中的適當位置中的節點。</span><span class="sxs-lookup"><span data-stu-id="68e88-180">However, it is possible to create a document that contains a document type by first creating the document using XML literals, and then creating and adding an <xref:System.Xml.Linq.XDocumentType> node in the appropriate place in the XML tree.</span></span>  
  
```csharp  
string internalSubset = @"<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>";  
  
string target = "xml-stylesheet";  
string data = "href='mystyle.css' title='Compact' type='text/css'";  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XProcessingInstruction(target, data),  
    new XDocumentType("Pubs", null, null, internalSubset),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
doc.Declaration = new XDeclaration("1.0", "utf-8", "true");  
Console.WriteLine(doc);  
  
doc.Save("test.xml");  
```  
  
```vb  
Dim internalSubset = _  
        "<!ELEMENT Pubs (Book+)>" & Environment.NewLine & _  
        "<!ELEMENT Book (Title, Author)>" & Environment.NewLine & _  
        "<!ELEMENT Title (#PCDATA)>" & Environment.NewLine & _  
        "<!ELEMENT Author (#PCDATA)>"  
  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
    </Pubs>  
    <!--This is another comment.-->  
  
doc.Nodes().Skip(1).First().AddAfterSelf(New XDocumentType("Pubs", Nothing, Nothing, internalSubset))  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-181">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-181">This example produces the following output:</span></span>  
  
```xml  
<!--This is a comment.-->  
<?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
<!DOCTYPE Pubs [<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>]>  
<Pubs>  
  <Book>  
    <Title>Artifacts of Roman Civilization</Title>  
    <Author>Moreno, Jordao</Author>  
  </Book>  
  <Book>  
    <Title>Midieval Tools and Implements</Title>  
    <Author>Gazit, Inbar</Author>  
  </Book>  
</Pubs>  
<!--This is another comment.-->  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDocumentType" />
        <altmember cref="P:System.Xml.Linq.XDocument.NodeType" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-182">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-182">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="68e88-183">從 URI 指定的檔案、<see cref="T:System.Xml.Linq.XDocument" /> 或 <see cref="T:System.IO.TextReader" />，建立新的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-183">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file specified by a URI, from an <see cref="T:System.IO.TextReader" />, or from an <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-184">使用此方法的多載之一，您可以載入<xref:System.Xml.Linq.XDocument>檔案，從<xref:System.IO.TextReader>，或有<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-184">Using one of the overloads of this method, you can load an <xref:System.Xml.Linq.XDocument> from a file, a <xref:System.IO.TextReader>, or an <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="68e88-185">若要建立<xref:System.Xml.Linq.XDocument>從包含 XML 的字串，使用<xref:System.Xml.Linq.XDocument.Parse%2A>。</span><span class="sxs-lookup"><span data-stu-id="68e88-185">To create an <xref:System.Xml.Linq.XDocument> from a string that contains XML, use <xref:System.Xml.Linq.XDocument.Parse%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-186">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-186">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a"><span data-ttu-id="68e88-187">查詢 XDocument 和查詢 XElement 的比較</span><span class="sxs-lookup"><span data-stu-id="68e88-187">Querying an XDocument vs. Querying an XElement</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="68e88-188">包含 XML 資料的資料流。</span><span class="sxs-lookup"><span data-stu-id="68e88-188">The stream that contains the XML data.</span></span></param>
        <summary><span data-ttu-id="68e88-189">使用指定的資料流，建立新的 <see cref="T:System.Xml.Linq.XDocument" /> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="68e88-189">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> instance by using the specified stream.</span></span></summary>
        <returns><span data-ttu-id="68e88-190"><see cref="T:System.Xml.Linq.XDocument" /> 物件，這個物件會讀取資料流中包含的資料。</span><span class="sxs-lookup"><span data-stu-id="68e88-190">An <see cref="T:System.Xml.Linq.XDocument" /> object that reads the data that is contained in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-191">如果您想要控制載入選項，使用<xref:System.Xml.Linq.XDocument.Load%2A>多載，<xref:System.Xml.Linq.LoadOptions>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-191">If you want to control load options, use the <xref:System.Xml.Linq.XDocument.Load%2A> overload that takes <xref:System.Xml.Linq.LoadOptions> as a parameter.</span></span>  
  
 <span data-ttu-id="68e88-192">LINQ to XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-192">The loading functionality of LINQ to XML is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-193">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-193">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
 <span data-ttu-id="68e88-194">如果您需要修改<xref:System.Xml.XmlReaderSettings>，請遵循下列步驟：</span><span class="sxs-lookup"><span data-stu-id="68e88-194">If you have to modify <xref:System.Xml.XmlReaderSettings>, follow these steps:</span></span>  
  
1.  <span data-ttu-id="68e88-195">建立<xref:System.Xml.XmlReader>藉由呼叫其中一個<xref:System.Xml.XmlReader.Create%2A>多載會採用<xref:System.Xml.XmlReaderSettings>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-195">Create an <xref:System.Xml.XmlReader> by calling one of the <xref:System.Xml.XmlReader.Create%2A> overloads that take <xref:System.Xml.XmlReaderSettings> as a parameter.</span></span>  
  
2.  <span data-ttu-id="68e88-196">傳遞<xref:System.Xml.XmlReader>的其中一個<xref:System.Xml.Linq.XDocument.Load%2A>的多載<xref:System.Xml.Linq.XDocument>採用<xref:System.Xml.XmlReader>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-196">Pass the <xref:System.Xml.XmlReader> to one of the <xref:System.Xml.Linq.XDocument.Load%2A> overloads of <xref:System.Xml.Linq.XDocument> that takes <xref:System.Xml.XmlReader> as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.TextReader -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load textReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader"><span data-ttu-id="68e88-197"><see cref="T:System.IO.TextReader" />，包含 <see cref="T:System.Xml.Linq.XDocument" /> 的內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-197">A <see cref="T:System.IO.TextReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <summary><span data-ttu-id="68e88-198">從 <see cref="T:System.Xml.Linq.XDocument" /> 建立新的 <see cref="T:System.IO.TextReader" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-198">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a <see cref="T:System.IO.TextReader" />.</span></span></summary>
        <returns><span data-ttu-id="68e88-199"><see cref="T:System.Xml.Linq.XDocument" />，包含指定的 <see cref="T:System.IO.TextReader" /> 內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-199">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified <see cref="T:System.IO.TextReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-200">LINQ 到 XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-200">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-201">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-201">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-202">下列範例會建立文件從<xref:System.IO.StringReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-202">The following example creates a document from a <xref:System.IO.StringReader>.</span></span>  
  
```csharp  
TextReader tr = new StringReader("<Root>Content</Root>");  
XDocument doc = XDocument.Load(tr);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim tr As TextReader = New StringReader("<Root>Content</Root>")  
Dim doc As XDocument = XDocument.Load(tr)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-203">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-203">This example produces the following output:</span></span>  
  
```xml  
<Root>Content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-204">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-204">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a"><span data-ttu-id="68e88-205">查詢 XDocument 和查詢 XElement 的比較</span><span class="sxs-lookup"><span data-stu-id="68e88-205">Querying an XDocument vs. Querying an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><span data-ttu-id="68e88-206">參考檔案的 URI 字串會載入至新的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-206">A URI string that references the file to load into a new <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <summary><span data-ttu-id="68e88-207">從檔案建立新的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-207">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file.</span></span></summary>
        <returns><span data-ttu-id="68e88-208"><see cref="T:System.Xml.Linq.XDocument" />，包含指定之檔案的內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-208">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-209">這個方法會使用基礎<xref:System.Xml.XmlReader>讀入 XML 樹狀結構中的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-209">This method uses an underlying <xref:System.Xml.XmlReader> to read the XML into an XML tree.</span></span>  
  
 <span data-ttu-id="68e88-210">使用<xref:System.Xml.Linq.XDocument.Parse%2A>來建立<xref:System.Xml.Linq.XDocument>從包含 XML 的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-210">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="68e88-211">LINQ 到 XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-211">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-212">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-212">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-213">下列範例示範如何載入<xref:System.Xml.Linq.XDocument>從檔案。</span><span class="sxs-lookup"><span data-stu-id="68e88-213">The following example shows how to load an <xref:System.Xml.Linq.XDocument> from a file.</span></span>  
  
 <span data-ttu-id="68e88-214">此範例使用下列 XML 文件：</span><span class="sxs-lookup"><span data-stu-id="68e88-214">This example uses the following XML document:</span></span>  
  
 [<span data-ttu-id="68e88-215">範例 XML 檔：典型採購訂單 (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="68e88-215">Sample XML File: Typical Purchase Order (LINQ to XML)</span></span>](https://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)  
  
```csharp  
XDocument doc = XDocument.Load("PurchaseOrder.xml");  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = XDocument.Load("PurchaseOrder.xml")  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-216">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-216">This example produces the following output:</span></span>  
  
```  
<PurchaseOrder PurchaseOrderNumber="99503" OrderDate="1999-10-20">  
  <Address Type="Shipping">  
    <Name>Ellen Adams</Name>  
    <Street>123 Maple Street</Street>  
    <City>Mill Valley</City>  
    <State>CA</State>  
    <Zip>10999</Zip>  
    <Country>USA</Country>  
  </Address>  
  <Address Type="Billing">  
    <Name>Tai Yee</Name>  
    <Street>8 Oak Avenue</Street>  
    <City>Old Town</City>  
    <State>PA</State>  
    <Zip>95819</Zip>  
    <Country>USA</Country>  
  </Address>  
  <DeliveryNotes>Please leave packages in shed by driveway.</DeliveryNotes>  
  <Items>  
    <Item PartNumber="872-AA">  
      <ProductName>Lawnmower</ProductName>  
      <Quantity>1</Quantity>  
      <USPrice>148.95</USPrice>  
      <Comment>Confirm this is electric</Comment>  
    </Item>  
    <Item PartNumber="926-AA">  
      <ProductName>Baby Monitor</ProductName>  
      <Quantity>2</Quantity>  
      <USPrice>39.98</USPrice>  
      <ShipDate>1999-05-21</ShipDate>  
    </Item>  
  </Items>  
</PurchaseOrder>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-217">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-217">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a"><span data-ttu-id="68e88-218">查詢 XDocument 和查詢 XElement 的比較</span><span class="sxs-lookup"><span data-stu-id="68e88-218">Querying an XDocument vs. Querying an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="68e88-219"><see cref="T:System.Xml.XmlReader" />，包含 <see cref="T:System.Xml.Linq.XDocument" /> 的內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-219">A <see cref="T:System.Xml.XmlReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <summary><span data-ttu-id="68e88-220">從 <see cref="T:System.Xml.Linq.XDocument" /> 建立新的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-220">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from an <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <returns><span data-ttu-id="68e88-221"><see cref="T:System.Xml.Linq.XDocument" />，包含指定的 <see cref="T:System.Xml.XmlReader" /> 內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-221">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified <see cref="T:System.Xml.XmlReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-222">這個方法的可能用法之一是建立 LINQ to XML 樹狀結構中的 DOM 文件的複本。</span><span class="sxs-lookup"><span data-stu-id="68e88-222">One possible use for this method is to create a copy of a DOM document in a LINQ to XML tree.</span></span> <span data-ttu-id="68e88-223">若要這樣做，您建立<xref:System.Xml.XmlNodeReader>從 DOM 文件，然後再使用<xref:System.Xml.XmlNodeReader>建立<xref:System.Xml.Linq.XDocument>。</span><span class="sxs-lookup"><span data-stu-id="68e88-223">To do this, you create an <xref:System.Xml.XmlNodeReader> from a DOM document, and then use the <xref:System.Xml.XmlNodeReader> to create an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
 <span data-ttu-id="68e88-224">LINQ 到 XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-224">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-225">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-225">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-226">下列範例會建立 DOM 文件，然後建立<xref:System.Xml.XmlNodeReader>DOM 文件中，從建立<xref:System.Xml.Linq.XDocument>使用<xref:System.Xml.XmlNodeReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-226">The following example creates a DOM document, creates an <xref:System.Xml.XmlNodeReader> from the DOM document, creates an <xref:System.Xml.Linq.XDocument> using the <xref:System.Xml.XmlNodeReader>.</span></span>  
  
```csharp  
// Create a DOM document with some content.  
XmlDocument doc = new XmlDocument();  
XmlElement child = doc.CreateElement("Child");  
child.InnerText = "child contents";  
XmlElement root = doc.CreateElement("Root");  
root.AppendChild(child);  
doc.AppendChild(root);  
  
// create a reader and move to the content  
using (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {  
    // the reader must be in the Interactive state in order to  
    // create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader);  
    Console.WriteLine(xRoot);  
}  
```  
  
```vb  
' Create a DOM document with some content.  
Dim doc As XmlDocument = New XmlDocument()  
Dim child As XmlElement = doc.CreateElement("Child")  
child.InnerText = "child contents"  
Dim root As XmlElement = doc.CreateElement("Root")  
root.AppendChild(child)  
doc.AppendChild(root)  
  
' create a reader and move to the content  
Using nodeReader = New XmlNodeReader(doc)  
    ' the reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader)  
    Console.WriteLine(xRoot)  
End Using  
```  
  
 <span data-ttu-id="68e88-227">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-227">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>child contents</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-228">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-228">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a"><span data-ttu-id="68e88-229">查詢 XDocument 和查詢 XElement 的比較</span><span class="sxs-lookup"><span data-stu-id="68e88-229">Querying an XDocument vs. Querying an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="68e88-230">包含 XML 資料的資料流。</span><span class="sxs-lookup"><span data-stu-id="68e88-230">The stream containing the XML data.</span></span></param>
        <param name="options"><span data-ttu-id="68e88-231"><see cref="T:System.Xml.Linq.LoadOptions" />，指定是否要載入基底 URI 和行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-231">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="68e88-232">使用指定的資料流建立新的 <see cref="T:System.Xml.Linq.XDocument" /> 執行個體，並選擇性地保留空白字元、設定基底 URI，以及保留行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-232">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> instance by using the specified stream, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="68e88-233"><see cref="T:System.Xml.Linq.XDocument" /> 物件，這個物件會讀取資料流中包含的資料。</span><span class="sxs-lookup"><span data-stu-id="68e88-233">An <see cref="T:System.Xml.Linq.XDocument" /> object that reads the data that is contained in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-234">LINQ to XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-234">The loading functionality of LINQ to XML is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-235">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-235">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
 <span data-ttu-id="68e88-236">如果您需要修改<xref:System.Xml.XmlReaderSettings>，請遵循下列步驟：</span><span class="sxs-lookup"><span data-stu-id="68e88-236">If you have to modify <xref:System.Xml.XmlReaderSettings>, follow these steps:</span></span>  
  
1.  <span data-ttu-id="68e88-237">建立<xref:System.Xml.XmlReader>藉由呼叫其中一個<xref:System.Xml.XmlReader.Create%2A>多載<xref:System.Xml.XmlReaderSettings>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-237">Create an <xref:System.Xml.XmlReader> by calling one of the <xref:System.Xml.XmlReader.Create%2A> overloads that takes <xref:System.Xml.XmlReaderSettings> as a parameter.</span></span>  
  
2.  <span data-ttu-id="68e88-238">傳遞<xref:System.Xml.XmlReader>的其中一個<xref:System.Xml.Linq.XDocument.Load%2A>的多載<xref:System.Xml.Linq.XDocument>採用<xref:System.Xml.XmlReader>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-238">Pass the <xref:System.Xml.XmlReader> to one of the <xref:System.Xml.Linq.XDocument.Load%2A> overloads of <xref:System.Xml.Linq.XDocument> that takes <xref:System.Xml.XmlReader> as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.TextReader * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (textReader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="textReader"><span data-ttu-id="68e88-239"><see cref="T:System.IO.TextReader" />，包含 <see cref="T:System.Xml.Linq.XDocument" /> 的內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-239">A <see cref="T:System.IO.TextReader" /> that contains the content for the <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="68e88-240"><see cref="T:System.Xml.Linq.LoadOptions" />，其指定泛空白字元 (White Space) 的行為，以及是否要載入基底 URI 和行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-240">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="68e88-241">從 <see cref="T:System.Xml.Linq.XDocument" /> 建立新的 <see cref="T:System.IO.TextReader" />，並選擇性地保留泛空白字元、設定基底 URI，以及保留行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-241">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a <see cref="T:System.IO.TextReader" />, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="68e88-242"><see cref="T:System.Xml.Linq.XDocument" />，包含從指定之 <see cref="T:System.IO.TextReader" /> 讀取的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-242">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the XML that was read from the specified <see cref="T:System.IO.TextReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-243">如果來源的 XML 縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`造成讀取器讀取來源 XML 中的所有泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-243">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="68e88-244">類型的節點<xref:System.Xml.Linq.XText>會針對顯著與不顯著泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-244">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="68e88-245">如果來源 XML 縮排，則未設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`會導致要忽略所有來源 XML 中不顯著泛空白字元的讀取器。</span><span class="sxs-lookup"><span data-stu-id="68e88-245">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="68e88-246">沒有任何文字節點，如不顯著泛空白字元，會建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="68e88-246">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="68e88-247">如果來源 XML 不會縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="68e88-247">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="68e88-248">顯著泛空白字元仍會保留下來，並沒有有效的空白字元會導致更多的泛空白字元文字節點建立的合併。</span><span class="sxs-lookup"><span data-stu-id="68e88-248">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="68e88-249">如需詳細資訊，請參閱 <<c0> [ 載入或剖析 XML 時保留空白字元](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)並[保留泛空白字元序列化時](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。</span><span class="sxs-lookup"><span data-stu-id="68e88-249">For more information, see [Preserving White Space while Loading or Parsing XML](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
 <span data-ttu-id="68e88-250">使用<xref:System.Xml.Linq.XDocument.Parse%2A>來建立<xref:System.Xml.Linq.XElement>從包含 XML 的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-250">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XElement> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="68e88-251">設定<xref:System.Xml.Linq.LoadOptions.SetBaseUri>無效，從載入時<xref:System.IO.TextReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-251">Setting <xref:System.Xml.Linq.LoadOptions.SetBaseUri> is not valid when loading from a <xref:System.IO.TextReader>.</span></span>  
  
 <span data-ttu-id="68e88-252">如果您將會對效能帶來負面影響<xref:System.Xml.Linq.LoadOptions.SetLineInfo>旗標。</span><span class="sxs-lookup"><span data-stu-id="68e88-252">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="68e88-253">程式行資訊正確無誤之後立即載入 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-253">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="68e88-254">如果您修改 XML 樹狀結構之後載入文件時，則可能無意義的行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-254">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="68e88-255">LINQ 到 XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-255">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-256">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-256">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-257">下列範例會建立文件從<xref:System.IO.StringReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-257">The following example creates a document from a <xref:System.IO.StringReader>.</span></span>  
  
```csharp  
TextReader sr;  
int whiteSpaceNodes;  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree1 = XDocument.Load(sr, LoadOptions.None);  
sr.Close();  
whiteSpaceNodes = xmlTree1  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree2 = XDocument.Load(sr, LoadOptions.PreserveWhitespace);  
sr.Close();  
whiteSpaceNodes = xmlTree2  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
Dim sr As TextReader  
Dim whiteSpaceNodes As Integer  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree1 As XDocument = XDocument.Load(sr, LoadOptions.None)  
sr.Close()  
whiteSpaceNodes = xmlTree1 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree2 As XDocument = XDocument.Load(sr, LoadOptions.PreserveWhitespace)  
sr.Close()  
whiteSpaceNodes = xmlTree2 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 <span data-ttu-id="68e88-258">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-258">This example produces the following output:</span></span>  
  
```  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-259">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-259">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a"><span data-ttu-id="68e88-260">查詢 XDocument 和查詢 XElement 的比較</span><span class="sxs-lookup"><span data-stu-id="68e88-260">Querying an XDocument vs. Querying an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (uri, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="uri"><span data-ttu-id="68e88-261">參考檔案的 URI 字串會載入至新的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-261">A URI string that references the file to load into a new <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="68e88-262"><see cref="T:System.Xml.Linq.LoadOptions" />，其指定泛空白字元 (White Space) 的行為，以及是否要載入基底 URI 和行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-262">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="68e88-263">從檔案建立新的 <see cref="T:System.Xml.Linq.XDocument" />，並選擇性地保留泛空白字元、設定基底 URI，以及保留行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-263">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a file, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="68e88-264"><see cref="T:System.Xml.Linq.XDocument" />，包含指定之檔案的內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-264">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the contents of the specified file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-265">如果來源的 XML 縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`造成讀取器讀取來源 XML 中的所有泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-265">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="68e88-266">類型的節點<xref:System.Xml.Linq.XText>會針對顯著與不顯著泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-266">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="68e88-267">如果來源 XML 縮排，則未設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`會導致要忽略所有來源 XML 中不顯著泛空白字元的讀取器。</span><span class="sxs-lookup"><span data-stu-id="68e88-267">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="68e88-268">沒有任何文字節點，如不顯著泛空白字元，會建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="68e88-268">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="68e88-269">如果來源 XML 不會縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="68e88-269">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="68e88-270">顯著泛空白字元仍會保留下來，並沒有有效的空白字元會導致更多的泛空白字元文字節點建立的合併。</span><span class="sxs-lookup"><span data-stu-id="68e88-270">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="68e88-271">如需詳細資訊，請參閱 <<c0> [ 載入或剖析 XML 時保留空白字元](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)並[保留泛空白字元序列化時](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。</span><span class="sxs-lookup"><span data-stu-id="68e88-271">For more information, see [Preserving White Space while Loading or Parsing XML](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
 <span data-ttu-id="68e88-272">使用<xref:System.Xml.Linq.XDocument.Parse%2A>來建立<xref:System.Xml.Linq.XDocument>從包含 XML 的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-272">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="68e88-273">如果您將會對效能帶來負面影響<xref:System.Xml.Linq.LoadOptions.SetBaseUri>而<xref:System.Xml.Linq.LoadOptions.SetLineInfo>旗標。</span><span class="sxs-lookup"><span data-stu-id="68e88-273">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetBaseUri> and the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flags.</span></span>  
  
 <span data-ttu-id="68e88-274">之後立即載入 XML 文件中的基底 URI 和行資訊的精確度。</span><span class="sxs-lookup"><span data-stu-id="68e88-274">The base URI and the line information are accurate immediately after loading the XML document.</span></span> <span data-ttu-id="68e88-275">如果您修改 XML 樹狀結構之後載入文件時，則可能無意義的基底 URI 和行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-275">If you modify the XML tree after loading the document, the base URI and line information may become meaningless.</span></span>  
  
 <span data-ttu-id="68e88-276">LINQ 到 XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-276">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-277">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-277">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-278">下列範例示範如何載入<xref:System.Xml.Linq.XDocument>從檔案。</span><span class="sxs-lookup"><span data-stu-id="68e88-278">The following example shows how to load an <xref:System.Xml.Linq.XDocument> from a file.</span></span>  
  
 <span data-ttu-id="68e88-279">此範例使用下列 XML 文件：</span><span class="sxs-lookup"><span data-stu-id="68e88-279">This example uses the following XML document:</span></span>  
  
 [<span data-ttu-id="68e88-280">範例 XML 檔：典型採購訂單 (LINQ to XML)</span><span class="sxs-lookup"><span data-stu-id="68e88-280">Sample XML File: Typical Purchase Order (LINQ to XML)</span></span>](https://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)  
  
```csharp  
XDocument doc1 = XDocument.Load("PurchaseOrder.xml", LoadOptions.None);  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count());  
  
XDocument doc2 = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim doc1 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.None)  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count())  
  
Dim doc2 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 <span data-ttu-id="68e88-281">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-281">This example produces the following output:</span></span>  
  
```  
nodes if not preserving whitespace: 48  
nodes if preserving whitespace: 82  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-282">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-282">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a"><span data-ttu-id="68e88-283">查詢 XDocument 和查詢 XElement 的比較</span><span class="sxs-lookup"><span data-stu-id="68e88-283">Querying an XDocument vs. Querying an XElement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (reader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="68e88-284"><see cref="T:System.Xml.XmlReader" />，將從中讀取 <see cref="T:System.Xml.Linq.XDocument" /> 的內容。</span><span class="sxs-lookup"><span data-stu-id="68e88-284">A <see cref="T:System.Xml.XmlReader" /> that will be read for the content of the <see cref="T:System.Xml.Linq.XDocument" />.</span></span></param>
        <param name="options"><span data-ttu-id="68e88-285"><see cref="T:System.Xml.Linq.LoadOptions" />，指定是否要載入基底 URI 和行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-285">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="68e88-286">從 <see cref="T:System.Xml.Linq.XDocument" /> 載入 <see cref="T:System.Xml.XmlReader" />，選擇性地設定基底 URI，並保留行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-286">Loads an <see cref="T:System.Xml.Linq.XDocument" /> from an <see cref="T:System.Xml.XmlReader" />, optionally setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="68e88-287"><see cref="T:System.Xml.Linq.XDocument" />，包含從指定之 <see cref="T:System.Xml.XmlReader" /> 讀取的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-287">An <see cref="T:System.Xml.Linq.XDocument" /> that contains the XML that was read from the specified <see cref="T:System.Xml.XmlReader" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-288">藉由建立<xref:System.Xml.XmlNodeReader>從 DOM 文件，接著再使用<xref:System.Xml.XmlNodeReader>建立<xref:System.Xml.Linq.XElement>，這個方法可用來建立 LINQ to XML 樹狀結構中的 DOM 文件的複本。</span><span class="sxs-lookup"><span data-stu-id="68e88-288">By creating an <xref:System.Xml.XmlNodeReader> from a DOM document, and then using the <xref:System.Xml.XmlNodeReader> to create an <xref:System.Xml.Linq.XElement>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</span></span>  
  
 <span data-ttu-id="68e88-289">使用<xref:System.Xml.Linq.XDocument.Parse%2A>來建立<xref:System.Xml.Linq.XDocument>從包含 XML 的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-289">Use <xref:System.Xml.Linq.XDocument.Parse%2A> to create an <xref:System.Xml.Linq.XDocument> from a string that contains XML.</span></span>  
  
 <span data-ttu-id="68e88-290">設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>無效，從載入時<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-290">Setting <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> is not valid when loading from a <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-291"><xref:System.Xml.XmlReader>或不會設定為其中一個讀取的空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-291">The <xref:System.Xml.XmlReader> will be configured to either read whitespace or not.</span></span> <span data-ttu-id="68e88-292">LINQ to XML 樹狀結構會填入泛空白字元節點的讀取器介面。</span><span class="sxs-lookup"><span data-stu-id="68e88-292">The LINQ to XML tree will be populated with the whitespace nodes that the reader surfaces.</span></span> <span data-ttu-id="68e88-293">這是不論是否行為<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>或未設定。</span><span class="sxs-lookup"><span data-stu-id="68e88-293">This will be the behavior regardless of whether <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> is set or not.</span></span>  
  
 <span data-ttu-id="68e88-294"><xref:System.Xml.XmlReader>或不可能有有效的基底 URI。</span><span class="sxs-lookup"><span data-stu-id="68e88-294">The <xref:System.Xml.XmlReader> may have a valid base URI or not.</span></span> <span data-ttu-id="68e88-295">如果您設定<xref:System.Xml.Linq.LoadOptions.SetBaseUri>，將 XML 樹狀結構中設定 URI，從所報告的基底 URI 的基底<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-295">If you set <xref:System.Xml.Linq.LoadOptions.SetBaseUri>, the base URI will be set in the XML tree from the base URI that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="68e88-296"><xref:System.Xml.XmlReader>或不可能有有效的行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-296">The <xref:System.Xml.XmlReader> may have a valid line information or not.</span></span> <span data-ttu-id="68e88-297">如果您設定<xref:System.Xml.Linq.LoadOptions.SetLineInfo>，會由所報告的行資訊從 XML 樹狀結構中設定行資訊<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-297">If you set <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, the line information will be set in the XML tree from the line information that is reported by the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="68e88-298">如果您將會對效能帶來負面影響<xref:System.Xml.Linq.LoadOptions.SetLineInfo>旗標。</span><span class="sxs-lookup"><span data-stu-id="68e88-298">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="68e88-299">程式行資訊正確無誤之後立即載入 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-299">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="68e88-300">如果您修改 XML 樹狀結構之後載入文件時，則可能無意義的行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-300">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="68e88-301">LINQ 到 XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-301">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-302">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-302">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-303">下列範例會載入它會從載入的行資訊<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-303">The following example loads the line information that it loads from the <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-304">接著，它會列印行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-304">It then prints the line information.</span></span>  
  
```csharp  
string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
// Create a reader and move to the content.  
using (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))  
{  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader, LoadOptions.SetLineInfo);  
    Console.WriteLine("{0}{1}{2}",  
        "Element Name".PadRight(20),  
        "Line".PadRight(5),  
        "Position");  
    Console.WriteLine("{0}{1}{2}",  
        "------------".PadRight(20),  
        "----".PadRight(5),  
        "--------");  
    foreach (XElement e in xRoot.Elements("Root").DescendantsAndSelf())  
        Console.WriteLine("{0}{1}{2}",  
            ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
            ((IXmlLineInfo)e).LinePosition);  
}  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child>" & Environment.NewLine & _  
    "        <GrandChild/>" & Environment.NewLine & _  
    "    </Child>" & Environment.NewLine & _  
    "</Root>"  
  
' Create a reader and move to the content.  
Using nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))  
  
    ' The reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader, LoadOptions.SetLineInfo)  
    Console.WriteLine("{0}{1}{2}", _  
        "Element Name".PadRight(20), _  
        "Line".PadRight(5), _  
        "Position")  
    Console.WriteLine("{0}{1}{2}", _  
        "------------".PadRight(20), _  
        "----".PadRight(5), _  
        "--------")  
    For Each e As XElement In xRoot.Elements("Root").DescendantsAndSelf()  
        Console.WriteLine("{0}{1}{2}", _  
            ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _  
            (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
            (DirectCast(e, IXmlLineInfo)).LinePosition)  
    Next  
End Using  
```  
  
 <span data-ttu-id="68e88-305">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-305">This example produces the following output:</span></span>  
  
```  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-306">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-306">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/215bcf5b-284b-4d7e-a95a-8d8e241341a9"><span data-ttu-id="68e88-307">如何：讀取和寫入編碼文件</span><span class="sxs-lookup"><span data-stu-id="68e88-307">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.Stream stream, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.Stream,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.IO.Stream * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (stream, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.TextReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.IO.TextReader * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (textReader, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textReader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.Xml.XmlReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.Xml.XmlReader * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (reader, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.Linq.XDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e88-308">取得此節點的節點類型。</span><span class="sxs-lookup"><span data-stu-id="68e88-308">Gets the node type for this node.</span></span></summary>
        <value><span data-ttu-id="68e88-309">節點類型。</span><span class="sxs-lookup"><span data-stu-id="68e88-309">The node type.</span></span> <span data-ttu-id="68e88-310">對於 <see cref="T:System.Xml.Linq.XDocument" /> 物件，此值為 <see cref="F:System.Xml.XmlNodeType.Document" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-310">For <see cref="T:System.Xml.Linq.XDocument" /> objects, this value is <see cref="F:System.Xml.XmlNodeType.Document" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-311">因為所有的類別，衍生自<xref:System.Xml.Linq.XObject>包含<xref:System.Xml.Linq.XObject.NodeType%2A>屬性，您可以撰寫程式碼運作的每個型別所在的子類別的物件的集合<xref:System.Xml.Linq.XObject>。</span><span class="sxs-lookup"><span data-stu-id="68e88-311">Because all classes that derive from <xref:System.Xml.Linq.XObject> contain a <xref:System.Xml.Linq.XObject.NodeType%2A> property, you can write code that operates on collections of objects where the type of each is a subclass of <xref:System.Xml.Linq.XObject>.</span></span> <span data-ttu-id="68e88-312">每個物件在集合中的節點類型可以然後測試您的程式碼。</span><span class="sxs-lookup"><span data-stu-id="68e88-312">Your code can then test for the node type of each object in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-313">下列範例顯示使用此屬性。</span><span class="sxs-lookup"><span data-stu-id="68e88-313">The following example shows the use of this property.</span></span>  
  
```csharp  
// Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
XDocument xmlTree = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XElement("Root", "content")  
);  
Console.WriteLine(xmlTree.NodeType);  
```  
  
```vb  
' Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
Dim xmlTree As XDocument = _  
    <?xml version='1.0' encoding='utf-8' standalone='yes'?>  
        <Root>content</Root>  
Console.WriteLine("{0}", xmlTree.NodeType)  
```  
  
 <span data-ttu-id="68e88-314">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-314">This example produces the following output:</span></span>  
  
```  
Document  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
        <altmember cref="P:System.Xml.Linq.XDocument.DocumentType" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-315">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-315">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="68e88-316">從字串建立新的 <see cref="T:System.Xml.Linq.XDocument" />，並選擇性地保留泛空白字元、設定基底 URI，以及保留行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-316">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-317">這個方法會剖析字串，然後建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="68e88-317">This method parses a string and creates an XML tree.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-318">下列範例會建立包含 XML 的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-318">The following example creates a string that contains XML.</span></span> <span data-ttu-id="68e88-319">然後它會剖析字串<xref:System.Xml.Linq.XDocument>。</span><span class="sxs-lookup"><span data-stu-id="68e88-319">It then parses the string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-320">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-320">This example produces the following output:</span></span>  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-321">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-321">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/8bdfdca0-6738-47a4-af3b-6d36d85e4d28"><span data-ttu-id="68e88-322">剖析 XML</span><span class="sxs-lookup"><span data-stu-id="68e88-322">Parsing XML</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Parse text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="68e88-323">包含 XML 的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-323">A string that contains XML.</span></span></param>
        <summary><span data-ttu-id="68e88-324">從字串建立新的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-324">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string.</span></span></summary>
        <returns><span data-ttu-id="68e88-325">從包含 XML 的字串填入的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-325">An <see cref="T:System.Xml.Linq.XDocument" /> populated from the string that contains XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-326">這個方法不會保留泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-326">This method does not preserve white space.</span></span> <span data-ttu-id="68e88-327">如果您想要保留 XML 樹狀結構中的泛空白字元，使用的多載<xref:System.Xml.Linq.XDocument.Parse%2A>採用<xref:System.Xml.Linq.LoadOptions>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-327">If you want to preserve white space in the XML tree, use the overload of <xref:System.Xml.Linq.XDocument.Parse%2A> that takes <xref:System.Xml.Linq.LoadOptions> as a parameter.</span></span>  
  
 <span data-ttu-id="68e88-328">如需詳細資訊，請參閱 <<c0> [ 載入或剖析 XML 時保留空白字元](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)並[保留泛空白字元序列化時](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。</span><span class="sxs-lookup"><span data-stu-id="68e88-328">For more information, see [Preserving White Space while Loading or Parsing XML](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
 <span data-ttu-id="68e88-329">LINQ 到 XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-329">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-330">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-330">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-331">下列範例會建立包含 XML 的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-331">The following example creates a string that contains XML.</span></span> <span data-ttu-id="68e88-332">然後它會剖析字串<xref:System.Xml.Linq.XDocument>。</span><span class="sxs-lookup"><span data-stu-id="68e88-332">It then parses the string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 <span data-ttu-id="68e88-333">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-333">This example produces the following output:</span></span>  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-334">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-334">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/8bdfdca0-6738-47a4-af3b-6d36d85e4d28"><span data-ttu-id="68e88-335">剖析 XML</span><span class="sxs-lookup"><span data-stu-id="68e88-335">Parsing XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Parse (text, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="68e88-336">包含 XML 的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-336">A string that contains XML.</span></span></param>
        <param name="options"><span data-ttu-id="68e88-337"><see cref="T:System.Xml.Linq.LoadOptions" />，其指定泛空白字元 (White Space) 的行為，以及是否要載入基底 URI 和行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-337">A <see cref="T:System.Xml.Linq.LoadOptions" /> that specifies white space behavior, and whether to load base URI and line information.</span></span></param>
        <summary><span data-ttu-id="68e88-338">從字串建立新的 <see cref="T:System.Xml.Linq.XDocument" />，並選擇性地保留泛空白字元、設定基底 URI，以及保留行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-338">Creates a new <see cref="T:System.Xml.Linq.XDocument" /> from a string, optionally preserving white space, setting the base URI, and retaining line information.</span></span></summary>
        <returns><span data-ttu-id="68e88-339">從包含 XML 的字串填入的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-339">An <see cref="T:System.Xml.Linq.XDocument" /> populated from the string that contains XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-340">如果來源的 XML 縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`造成讀取器讀取來源 XML 中的所有泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-340">If the source XML is indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to read all white space in the source XML.</span></span> <span data-ttu-id="68e88-341">類型的節點<xref:System.Xml.Linq.XText>會針對顯著與不顯著泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-341">Nodes of type <xref:System.Xml.Linq.XText> are created for both significant and insignificant white space.</span></span>  
  
 <span data-ttu-id="68e88-342">如果來源 XML 縮排，則未設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`會導致要忽略所有來源 XML 中不顯著泛空白字元的讀取器。</span><span class="sxs-lookup"><span data-stu-id="68e88-342">If the source XML is indented, not setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` causes the reader to ignore all of the insignificant white space in the source XML.</span></span> <span data-ttu-id="68e88-343">沒有任何文字節點，如不顯著泛空白字元，會建立 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="68e88-343">The XML tree is created without any text nodes for insignificant white space.</span></span>  
  
 <span data-ttu-id="68e88-344">如果來源 XML 不會縮排，則設定<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>加上旗標在`options`沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="68e88-344">If the source XML is not indented, setting the <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> flag in `options` has no effect.</span></span> <span data-ttu-id="68e88-345">顯著泛空白字元仍會保留下來，並沒有有效的空白字元會導致更多的泛空白字元文字節點建立的合併。</span><span class="sxs-lookup"><span data-stu-id="68e88-345">Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</span></span>  
  
 <span data-ttu-id="68e88-346">如需詳細資訊，請參閱 <<c0> [ 載入或剖析 XML 時保留空白字元](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)並[保留泛空白字元序列化時](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。</span><span class="sxs-lookup"><span data-stu-id="68e88-346">For more information, see [Preserving White Space while Loading or Parsing XML](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
 <span data-ttu-id="68e88-347">設定<xref:System.Xml.Linq.LoadOptions.SetBaseUri>無效，無法剖析從時<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="68e88-347">Setting <xref:System.Xml.Linq.LoadOptions.SetBaseUri> is not valid when parsing from a <xref:System.String>.</span></span>  
  
 <span data-ttu-id="68e88-348">如果您將會對效能帶來負面影響<xref:System.Xml.Linq.LoadOptions.SetLineInfo>旗標。</span><span class="sxs-lookup"><span data-stu-id="68e88-348">There is a performance penalty if you set the <xref:System.Xml.Linq.LoadOptions.SetLineInfo> flag.</span></span>  
  
 <span data-ttu-id="68e88-349">程式行資訊正確無誤之後立即載入 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-349">The line information is accurate immediately after loading the XML document.</span></span> <span data-ttu-id="68e88-350">如果您修改 XML 樹狀結構之後載入文件時，則可能無意義的行資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-350">If you modify the XML tree after loading the document, the line information may become meaningless.</span></span>  
  
 <span data-ttu-id="68e88-351">LINQ 到 XML 的載入功能會根據<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="68e88-351">LINQ to XML's loading functionality is built upon <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="68e88-352">因此，您可能會攔截所擲回任何例外狀況<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>多載的方法和<xref:System.Xml.XmlReader>方法來讀取和剖析文件。</span><span class="sxs-lookup"><span data-stu-id="68e88-352">Therefore, you might catch any exceptions that are thrown by the <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> overload methods and the <xref:System.Xml.XmlReader> methods that read and parse the document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-353">下列範例將字串剖析成<xref:System.Xml.Linq.XDocument>。</span><span class="sxs-lookup"><span data-stu-id="68e88-353">The following example parses a string into an <xref:System.Xml.Linq.XDocument>.</span></span>  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc1 = XDocument.Parse(str, LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count());  
XDocument doc2 = XDocument.Parse(str, LoadOptions.None);  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim str As String = _  
"<?xml version= '1.0'?>" & Environment.NewLine & _  
"<!-- comment at the root level -->" & Environment.NewLine & _  
"<Root>" & Environment.NewLine & _  
"    <Child>Content</Child>"  & Environment.NewLine & _  
"</Root>"  
  
Dim doc1 As XDocument = XDocument.Parse(str, LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count())  
Dim doc2 As XDocument = XDocument.Parse(str, LoadOptions.None)  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 <span data-ttu-id="68e88-354">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-354">This example produces the following output:</span></span>  
  
```  
nodes when preserving whitespace: 8  
nodes when not preserving whitespace: 4  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-355">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-355">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/8bdfdca0-6738-47a4-af3b-6d36d85e4d28"><span data-ttu-id="68e88-356">剖析 XML</span><span class="sxs-lookup"><span data-stu-id="68e88-356">Parsing XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XElement Root" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XElement ^ Root { System::Xml::Linq::XElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.Xml.Linq.XElement" Usage="System.Xml.Linq.XDocument.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e88-357">取得此文件之 XML 樹狀結構的根項目 (Root Element)。</span><span class="sxs-lookup"><span data-stu-id="68e88-357">Gets the root element of the XML Tree for this document.</span></span></summary>
        <value><span data-ttu-id="68e88-358">XML 樹狀結構的根 (Root) <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-358">The root <see cref="T:System.Xml.Linq.XElement" /> of the XML tree.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-359">此屬性相當實用，當您想要撰寫[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]中相同之內容時加以組合樹狀結構為基礎的查詢<xref:System.Xml.Linq.XElement>。</span><span class="sxs-lookup"><span data-stu-id="68e88-359">This property is useful when you want to compose [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries in the same context as when composing them for a tree rooted in <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="68e88-360">請參閱[查詢 XDocument 與。查詢 XElement](https://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a)如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="68e88-360">See [Querying an XDocument vs. Querying an XElement](https://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a) for more details.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-361">下列範例會使用這個屬性，以取得文件的根項目。</span><span class="sxs-lookup"><span data-stu-id="68e88-361">The following example uses this property to get the root element of a document.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
Console.WriteLine(doc.Root.Name.ToString());  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
        <!--This is another comment.-->  
    </Pubs>  
  
Console.WriteLine(doc.Root.Name.ToString())  
```  
  
 <span data-ttu-id="68e88-362">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-362">This example produces the following output:</span></span>  
  
```  
Pubs  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-363">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-363">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/69468b03-4f18-4d69-98a4-3fa90d904f08"><span data-ttu-id="68e88-364">如何：在命名空間中尋找所有節點</span><span class="sxs-lookup"><span data-stu-id="68e88-364">How to: Find All Nodes in a Namespace</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="68e88-365">將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為檔案、<see cref="T:System.IO.TextWriter" /> 或 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-365">Serializes this <see cref="T:System.Xml.Linq.XDocument" /> to a file, a <see cref="T:System.IO.TextWriter" />, or an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-366">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-366">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/215bcf5b-284b-4d7e-a95a-8d8e241341a9"><span data-ttu-id="68e88-367">如何：讀取和寫入編碼文件</span><span class="sxs-lookup"><span data-stu-id="68e88-367">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream -&gt; unit" Usage="xDocument.Save stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="68e88-368">這個 <see cref="T:System.Xml.Linq.XDocument" /> 輸出的目的資料流。</span><span class="sxs-lookup"><span data-stu-id="68e88-368">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span></span></param>
        <summary><span data-ttu-id="68e88-369">將這個 <see cref="T:System.Xml.Linq.XDocument" /> 輸出到指定的 <see cref="T:System.IO.Stream" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-369">Outputs this <see cref="T:System.Xml.Linq.XDocument" /> to the specified <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-370">將縮排序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-370">The serialized XML will be indented.</span></span> <span data-ttu-id="68e88-371">將移除所有無意義的空格，並將會加入額外的空白字元，如此會適當地縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-371">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="68e88-372">這個方法的行為是將不會保留不顯著泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-372">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="68e88-373">如果您想要控制空白字元時，使用的多載<xref:System.Xml.Linq.XDocument.Save%2A>採用<xref:System.Xml.Linq.SaveOptions>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-373">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="68e88-374">使用<xref:System.Xml.Linq.SaveOptions.DisableFormatting>將未縮排的 XML 儲存選項。</span><span class="sxs-lookup"><span data-stu-id="68e88-374">Use the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option to save unindented XML.</span></span> <span data-ttu-id="68e88-375">這會導致要寫入所有泛空白字元的空白字元，XML 樹狀結構中所示的寫入器。</span><span class="sxs-lookup"><span data-stu-id="68e88-375">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="68e88-376">使用<xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>選項，如果您想要移除重複的命名空間宣告。</span><span class="sxs-lookup"><span data-stu-id="68e88-376">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="xDocument.Save textWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="68e88-377">向其中寫入 <see cref="T:System.IO.TextWriter" /> 的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-377">A <see cref="T:System.IO.TextWriter" /> that the <see cref="T:System.Xml.Linq.XDocument" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="68e88-378">將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-378">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a <see cref="T:System.IO.TextWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-379">將縮排序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-379">The serialized XML will be indented.</span></span> <span data-ttu-id="68e88-380">將移除所有無意義的空格，並將會加入額外的空白字元，如此會適當地縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-380">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="68e88-381">這個方法的行為是將不會保留不顯著泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-381">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="68e88-382">如果您想要控制空白字元時，使用的多載<xref:System.Xml.Linq.XDocument.Save%2A>採用<xref:System.Xml.Linq.SaveOptions>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-382">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="68e88-383">如需詳細資訊，請參閱 <<c0> [ 載入或剖析 XML 時保留空白字元](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)並[保留泛空白字元序列化時](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。</span><span class="sxs-lookup"><span data-stu-id="68e88-383">For more information, see [Preserving White Space while Loading or Parsing XML](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-384">下列範例會建立<xref:System.Xml.Linq.XDocument>，儲存至文件<xref:System.IO.StringWriter>，然後列印至主控台的字串。</span><span class="sxs-lookup"><span data-stu-id="68e88-384">The following example creates an <xref:System.Xml.Linq.XDocument>, saves the document to a <xref:System.IO.StringWriter>, and then prints the string to the console.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
TextWriter tr = new StringWriter(sb);  
doc.Save(tr);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim tr As TextWriter = New StringWriter(sb)  
doc.Save(tr)  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="68e88-385">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-385">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-386">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-386">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/215bcf5b-284b-4d7e-a95a-8d8e241341a9"><span data-ttu-id="68e88-387">如何：讀取和寫入編碼文件</span><span class="sxs-lookup"><span data-stu-id="68e88-387">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="xDocument.Save fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="68e88-388">字串，包含檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="68e88-388">A string that contains the name of the file.</span></span></param>
        <summary><span data-ttu-id="68e88-389">將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化至檔案，並覆寫現有的檔案 (如果存在)。</span><span class="sxs-lookup"><span data-stu-id="68e88-389">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a file, overwriting an existing file, if it exists.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-390">將縮排序列化的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-390">The serialized XML will be indented.</span></span> <span data-ttu-id="68e88-391">將移除所有無意義的空格，並將會加入額外的空白字元，如此會適當地縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-391">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="68e88-392">這個方法的行為是將不會保留不顯著泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-392">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="68e88-393">如果您想要控制空白字元時，使用的多載<xref:System.Xml.Linq.XDocument.Save%2A>採用<xref:System.Xml.Linq.SaveOptions>做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-393">If you want to control white space, use the overload of <xref:System.Xml.Linq.XDocument.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="68e88-394">如需詳細資訊，請參閱 <<c0> [ 載入或剖析 XML 時保留空白字元](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)並[保留泛空白字元序列化時](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。</span><span class="sxs-lookup"><span data-stu-id="68e88-394">For more information, see [Preserving White Space while Loading or Parsing XML](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-395">下列範例會建立<xref:System.Xml.Linq.XDocument>，將文件儲存至檔案，然後會列印到主控台檔案。</span><span class="sxs-lookup"><span data-stu-id="68e88-395">The following example creates an <xref:System.Xml.Linq.XDocument>, saves the document to a file, and then prints the file to the console.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root.xml");  
Console.WriteLine(File.ReadAllText("Root.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root.xml")  
Console.WriteLine(File.ReadAllText("Root.xml"))  
```  
  
 <span data-ttu-id="68e88-396">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-396">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-397">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-397">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/215bcf5b-284b-4d7e-a95a-8d8e241341a9"><span data-ttu-id="68e88-398">如何：讀取和寫入編碼文件</span><span class="sxs-lookup"><span data-stu-id="68e88-398">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xDocument.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="68e88-399">向其中寫入 <see cref="T:System.Xml.XmlWriter" /> 的 <see cref="T:System.Xml.Linq.XDocument" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-399">A <see cref="T:System.Xml.XmlWriter" /> that the <see cref="T:System.Xml.Linq.XDocument" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="68e88-400">將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-400">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="68e88-401">下列範例顯示如何將 <xref:System.Xml.Linq.XDocument> 儲存為 <xref:System.Xml.XmlWriter>。</span><span class="sxs-lookup"><span data-stu-id="68e88-401">The following example shows how to save an <xref:System.Xml.Linq.XDocument> to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.Save(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.Save(xw)  
  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="68e88-402">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-402">This example produces the following output:</span></span>  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-403">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-403">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/215bcf5b-284b-4d7e-a95a-8d8e241341a9"><span data-ttu-id="68e88-404">如何：讀取和寫入編碼文件</span><span class="sxs-lookup"><span data-stu-id="68e88-404">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="68e88-405">這個 <see cref="T:System.Xml.Linq.XDocument" /> 輸出的目的資料流。</span><span class="sxs-lookup"><span data-stu-id="68e88-405">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span></span></param>
        <param name="options"><span data-ttu-id="68e88-406">指定格式化行為的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-406">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="68e88-407">將這個 <see cref="T:System.Xml.Linq.XDocument" /> 輸出至指定的 <see cref="T:System.IO.Stream" />，選擇性地指定格式化行為。</span><span class="sxs-lookup"><span data-stu-id="68e88-407">Outputs this <see cref="T:System.Xml.Linq.XDocument" /> to the specified <see cref="T:System.IO.Stream" />, optionally specifying formatting behavior.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-408">依預設`options`設定為<xref:System.Xml.Linq.SaveOptions.None>。</span><span class="sxs-lookup"><span data-stu-id="68e88-408">By default the `options` are set to <xref:System.Xml.Linq.SaveOptions.None>.</span></span> <span data-ttu-id="68e88-409">這個選項會移除所有多餘的不顯著泛空白字元，並新增適當的不顯著泛空白字元，以便適當地縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-409">This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span>  
  
 <span data-ttu-id="68e88-410">如果您想要儲存不縮排的 XML，指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。</span><span class="sxs-lookup"><span data-stu-id="68e88-410">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="68e88-411">這會導致要寫入所有泛空白字元的空白字元，XML 樹狀結構中所示的寫入器。</span><span class="sxs-lookup"><span data-stu-id="68e88-411">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="68e88-412">使用<xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces>選項，如果您想要移除重複的命名空間宣告。</span><span class="sxs-lookup"><span data-stu-id="68e88-412">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (textWriter, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="68e88-413">做為 XML 之輸出目標的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-413">The <see cref="T:System.IO.TextWriter" /> to output the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="68e88-414">指定格式化行為的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-414">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="68e88-415">將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為 <see cref="T:System.IO.TextWriter" />，選擇性地停用格式設定。</span><span class="sxs-lookup"><span data-stu-id="68e88-415">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a <see cref="T:System.IO.TextWriter" />, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-416">如果您想要儲存不縮排的 XML，指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。</span><span class="sxs-lookup"><span data-stu-id="68e88-416">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="68e88-417">這會導致要寫入所有泛空白字元的空白字元，XML 樹狀結構中所示的寫入器。</span><span class="sxs-lookup"><span data-stu-id="68e88-417">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="68e88-418">如果您想要儲存縮排的 XML，未指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。</span><span class="sxs-lookup"><span data-stu-id="68e88-418">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="68e88-419">這會移除所有多餘的不顯著泛空白字元，並新增適當的不顯著泛空白字元，以便適當地縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-419">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="68e88-420">這是預設行為，以及多載的行為<xref:System.Xml.Linq.XDocument.Save%2A>方法不接受`options`做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-420">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XDocument.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="68e88-421">如需詳細資訊，請參閱 <<c0> [ 載入或剖析 XML 時保留空白字元](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)並[保留泛空白字元序列化時](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。</span><span class="sxs-lookup"><span data-stu-id="68e88-421">For more information, see [Preserving White Space while Loading or Parsing XML](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-422">下列範例會示範這個方法的兩種用途。</span><span class="sxs-lookup"><span data-stu-id="68e88-422">The following example shows two uses of this method.</span></span> <span data-ttu-id="68e88-423">第一次使用序列化<xref:System.Xml.Linq.XDocument>進行格式化。</span><span class="sxs-lookup"><span data-stu-id="68e88-423">The first use serializes the <xref:System.Xml.Linq.XDocument> with formatting.</span></span> <span data-ttu-id="68e88-424">第二個保留泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-424">The second preserves white space.</span></span> <span data-ttu-id="68e88-425">因為文件不有任何泛空白字元所建構，保留泛空白字元輸出沒有任何縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-425">Because the document has no white space in it as constructed, preserving white space outputs the XML without any indenting.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
StringBuilder sb1 = new StringBuilder();  
using (StringWriter sr1 = new StringWriter(sb1)) {  
    doc.Save(sr1, SaveOptions.None);  
    Console.WriteLine(sb1.ToString());  
}  
  
StringBuilder sb2 = new StringBuilder();  
using (StringWriter sr2 = new StringWriter(sb2)) {  
    doc.Save(sr2, SaveOptions.DisableFormatting);  
    Console.WriteLine(sb2.ToString());  
}  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim sb1 As StringBuilder = New StringBuilder()  
  
Using sr1 = New StringWriter(sb1)  
    doc.Save(sr1, SaveOptions.None)  
    Console.WriteLine(sb1.ToString())  
End Using  
  
Dim sb2 As StringBuilder = New StringBuilder()  
  
Using sr2 = New StringWriter(sb2)  
    doc.Save(sr2, SaveOptions.DisableFormatting)  
    Console.WriteLine(sb2.ToString())  
End Using  
```  
  
 <span data-ttu-id="68e88-426">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-426">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
<?xml version="1.0" encoding="utf-16"?><Root><Child>content</Child></Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-427">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-427">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/215bcf5b-284b-4d7e-a95a-8d8e241341a9"><span data-ttu-id="68e88-428">如何：讀取和寫入編碼文件</span><span class="sxs-lookup"><span data-stu-id="68e88-428">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (fileName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="68e88-429">字串，包含檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="68e88-429">A string that contains the name of the file.</span></span></param>
        <param name="options"><span data-ttu-id="68e88-430">指定格式化行為的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-430">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="68e88-431">將此 <see cref="T:System.Xml.Linq.XDocument" /> 序列化為檔案，選擇性地停用格式設定。</span><span class="sxs-lookup"><span data-stu-id="68e88-431">Serialize this <see cref="T:System.Xml.Linq.XDocument" /> to a file, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e88-432">如果您想要儲存不縮排的 XML，指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。</span><span class="sxs-lookup"><span data-stu-id="68e88-432">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="68e88-433">這會導致要寫入所有泛空白字元的空白字元，XML 樹狀結構中所示的寫入器。</span><span class="sxs-lookup"><span data-stu-id="68e88-433">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="68e88-434">如果您想要儲存縮排的 XML，未指定<xref:System.Xml.Linq.SaveOptions.DisableFormatting>旗標，以`options`。</span><span class="sxs-lookup"><span data-stu-id="68e88-434">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="68e88-435">這會移除所有多餘的不顯著泛空白字元，並新增適當的不顯著泛空白字元，以便適當地縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="68e88-435">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="68e88-436">這是預設行為，以及多載的行為<xref:System.Xml.Linq.XDocument.Save%2A>方法不接受`options`做為參數。</span><span class="sxs-lookup"><span data-stu-id="68e88-436">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XDocument.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="68e88-437">如需詳細資訊，請參閱 <<c0> [ 載入或剖析 XML 時保留空白字元](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d)並[保留泛空白字元序列化時](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)。</span><span class="sxs-lookup"><span data-stu-id="68e88-437">For more information, see [Preserving White Space while Loading or Parsing XML](https://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](https://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e88-438">下列範例會示範這個方法的兩種用途。</span><span class="sxs-lookup"><span data-stu-id="68e88-438">The following example shows two uses of this method.</span></span> <span data-ttu-id="68e88-439">第一次使用保留泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="68e88-439">The first use preserves white space.</span></span> <span data-ttu-id="68e88-440">第二個序列化<xref:System.Xml.Linq.XDocument>與縮排。</span><span class="sxs-lookup"><span data-stu-id="68e88-440">The second one serializes the <xref:System.Xml.Linq.XDocument> with indenting.</span></span>  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root1.xml", SaveOptions.DisableFormatting);  
Console.WriteLine(File.ReadAllText("Root1.xml"));  
doc.Save("Root2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Root2.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root1.xml", SaveOptions.DisableFormatting)  
Console.WriteLine(File.ReadAllText("Root1.xml"))  
doc.Save("Root2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Root2.xml"))  
```  
  
 <span data-ttu-id="68e88-441">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-441">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8"?><Root><Child>content</Child></Root>  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-442">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-442">LINQ to XML</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/215bcf5b-284b-4d7e-a95a-8d8e241341a9"><span data-ttu-id="68e88-443">如何：讀取和寫入編碼文件</span><span class="sxs-lookup"><span data-stu-id="68e88-443">How to: Read and Write an Encoded Document</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.Stream stream, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.Stream,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.IO.Stream * System.Xml.Linq.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (stream, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.TextWriter,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.IO.TextWriter * System.Xml.Linq.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (textWriter, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textWriter">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xDocument.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="68e88-444">此方法將寫入其中的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-444">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span></span></param>
        <summary><span data-ttu-id="68e88-445">將此文件寫入 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="68e88-445">Write this document to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="68e88-446">下列範例示範如何撰寫<xref:System.Xml.Linq.XDocument>至<xref:System.Xml.XmlWriter>。</span><span class="sxs-lookup"><span data-stu-id="68e88-446">The following example shows how to write an <xref:System.Xml.Linq.XDocument> to an <xref:System.Xml.XmlWriter>.</span></span> <span data-ttu-id="68e88-447">請注意，此範例不會撰寫 XML 宣告。</span><span class="sxs-lookup"><span data-stu-id="68e88-447">Note that the example did not write an XML declaration.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.WriteTo(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.WriteTo(xw)  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="68e88-448">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="68e88-448">This example produces the following output:</span></span>  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="68e88-449">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="68e88-449">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.WriteToAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>