<Type Name="XNode" FullName="System.Xml.Linq.XNode">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b28966286bc00bb4e231cc113c0f9fadbbd9cd5c" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52608518" /></Metadata><TypeSignature Language="C#" Value="public abstract class XNode : System.Xml.Linq.XObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XNode extends System.Xml.Linq.XObject" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XNode" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XNode&#xA;Inherits XObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class XNode abstract : System::Xml::Linq::XObject" />
  <TypeSignature Language="F#" Value="type XNode = class&#xA;    inherit XObject" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="57c16-101">表示 XML 樹狀結構中節點 (元素、註解、文件類型、處理指示或文字節點) 的抽象概念。</span><span class="sxs-lookup"><span data-stu-id="57c16-101">Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-102"><xref:System.Xml.Linq.XNode> 是下列類型的抽象通用基底類別：</span><span class="sxs-lookup"><span data-stu-id="57c16-102"><xref:System.Xml.Linq.XNode> is an abstract common base class for the following types:</span></span>  
  
-   <xref:System.Xml.Linq.XComment>  
  
-   <xref:System.Xml.Linq.XContainer>  
  
-   <xref:System.Xml.Linq.XDocumentType>  
  
-   <xref:System.Xml.Linq.XProcessingInstruction>  
  
-   <xref:System.Xml.Linq.XText>  
  
 <span data-ttu-id="57c16-103"><xref:System.Xml.Linq.XContainer> 是下列類型的抽象通用基底類別：</span><span class="sxs-lookup"><span data-stu-id="57c16-103"><xref:System.Xml.Linq.XContainer> is an abstract common base class for the following types:</span></span>  
  
-   <xref:System.Xml.Linq.XDocument>  
  
-   <xref:System.Xml.Linq.XElement>  
  
 <span data-ttu-id="57c16-104">衍生自的類別的物件<xref:System.Xml.Linq.XContainer>可以包含子節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-104">Objects of classes that derive from <xref:System.Xml.Linq.XContainer> can contain child nodes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="57c16-105"><xref:System.Xml.Linq.XAttribute>不是<xref:System.Xml.Linq.XNode>。</span><span class="sxs-lookup"><span data-stu-id="57c16-105">An <xref:System.Xml.Linq.XAttribute> is not an <xref:System.Xml.Linq.XNode>.</span></span> <span data-ttu-id="57c16-106">屬性會保留做為項目上的名稱/值組清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-106">Attributes are maintained as a list of name/value pairs on an element.</span></span>  
  
 <span data-ttu-id="57c16-107">如果您正在撰寫複雜的 XML 應用程式，例如 XML 編輯器或文字處理器，將內容儲存為 XML，您會通常會在節點層級中運作。</span><span class="sxs-lookup"><span data-stu-id="57c16-107">If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level.</span></span> <span data-ttu-id="57c16-108">在節點層級使用時，一般的活動包括將節點新增、 刪除節點，轉換節點，以及逐一查看傳回的節點集合的座標軸。</span><span class="sxs-lookup"><span data-stu-id="57c16-108">Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-109">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-109">LINQ to XML</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57c16-110">將指定的內容加入緊接在此節點後面的位置。</span><span class="sxs-lookup"><span data-stu-id="57c16-110">Adds the specified content immediately after this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-111">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-111">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-112">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>而<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-112">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-113">下列範例會使用 LINQ 查詢來建立<xref:System.Collections.Generic.IEnumerable%601>的<xref:System.Xml.Linq.XElement>，這會接著傳遞給這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-113">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="57c16-114">想要的位置中的樹狀結構，如此就會將查詢的結果。</span><span class="sxs-lookup"><span data-stu-id="57c16-114">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Element1>1</Element1>  
        <Element2>2</Element2>  
        <Element3>3</Element3>  
        <Element4>4</Element4>  
        <Element5>5</Element5>  
    </Root>  
  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
    </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-115">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-115">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-116">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-116">LINQ to XML</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddAfterSelf : obj -&gt; unit" Usage="xNode.AddAfterSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="57c16-117">要在這個節點之後加入的包含簡單內容或內容物件集合的內容物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-117">A content object that contains simple content or a collection of content objects to be added after this node.</span></span></param>
        <summary><span data-ttu-id="57c16-118">將指定的內容加入緊接在此節點後面的位置。</span><span class="sxs-lookup"><span data-stu-id="57c16-118">Adds the specified content immediately after this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-119">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-119">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-120"><xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-120"><xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-121">下列範例會使用這個方法將項目新增至樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="57c16-121">The following example uses this method to add an element into the tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-122">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-122">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <NewChild>10</NewChild>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="57c16-123">該父代為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-123">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-124">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-124">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddAfterSelf : obj[] -&gt; unit" Usage="xNode.AddAfterSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="57c16-125">內容物件的參數清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-125">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="57c16-126">將指定的內容加入緊接在此節點後面的位置。</span><span class="sxs-lookup"><span data-stu-id="57c16-126">Adds the specified content immediately after this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-127">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-127">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-128">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>而<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-128">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-129">下列範例會使用 LINQ 查詢來建立<xref:System.Collections.Generic.IEnumerable%601>的<xref:System.Xml.Linq.XElement>，這會接著傳遞給這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-129">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="57c16-130">想要的位置中的樹狀結構，如此就會將查詢的結果。</span><span class="sxs-lookup"><span data-stu-id="57c16-130">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-131">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-131">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="57c16-132">該父代為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-132">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-133">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-133">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57c16-134">將指定的內容加入緊接在此節點前面的位置。</span><span class="sxs-lookup"><span data-stu-id="57c16-134">Adds the specified content immediately before this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-135">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-135">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-136">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-136">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="57c16-137"><xref:System.Xml.Linq.XContainer>將它的子系資訊儲存為單一連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-137">The <xref:System.Xml.Linq.XContainer> stores its child notes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-138">這表示<xref:System.Xml.Linq.XNode.AddBeforeSelf%2A>方法必須周遊的父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-138">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="57c16-139">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-139">Therefore, using this method might  affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-140">下列範例會使用 LINQ 查詢來建立<xref:System.Collections.Generic.IEnumerable%601>的<xref:System.Xml.Linq.XElement>，這會接著傳遞給這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-140">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="57c16-141">想要的位置中的樹狀結構，如此就會將查詢的結果。</span><span class="sxs-lookup"><span data-stu-id="57c16-141">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
From el In srcTree.Elements() _  
Where CInt(el) > 3 _  
Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-142">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-142">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-143">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-143">LINQ to XML</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddBeforeSelf : obj -&gt; unit" Usage="xNode.AddBeforeSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="57c16-144">要在這個節點之前加入之包含簡單內容或內容物件集合的內容物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-144">A content object that contains simple content or a collection of content objects to be added before this node.</span></span></param>
        <summary><span data-ttu-id="57c16-145">將指定的內容加入緊接在此節點前面的位置。</span><span class="sxs-lookup"><span data-stu-id="57c16-145">Adds the specified content immediately before this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-146">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-146">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-147">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>而<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-147">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="57c16-148"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-148">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-149">這表示<xref:System.Xml.Linq.XNode.AddBeforeSelf%2A>方法必須周遊的父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-149">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="57c16-150">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-150">Therefore, using this method might  affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-151">下列範例會使用這個方法將項目新增至樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="57c16-151">The following example uses this method to add an element into the tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-152">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-152">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <NewChild>10</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="57c16-153">該父代為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-153">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-154">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-154">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddBeforeSelf : obj[] -&gt; unit" Usage="xNode.AddBeforeSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="57c16-155">內容物件的參數清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-155">A parameter list of content objects.</span></span></param>
        <summary><span data-ttu-id="57c16-156">將指定的內容加入緊接在此節點前面的位置。</span><span class="sxs-lookup"><span data-stu-id="57c16-156">Adds the specified content immediately before this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-157">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-157">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-158">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>而<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-158">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="57c16-159"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-159">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-160">這表示<xref:System.Xml.Linq.XNode.AddBeforeSelf%2A>方法必須周遊的父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-160">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="57c16-161">因此，使用此函式可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-161">Therefore, using this function might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-162">下列範例會使用 LINQ 查詢來建立<xref:System.Collections.Generic.IEnumerable%601>的<xref:System.Xml.Linq.XElement>，這會接著傳遞給這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-162">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="57c16-163">想要的位置中的樹狀結構，如此就會將查詢的結果。</span><span class="sxs-lookup"><span data-stu-id="57c16-163">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-164">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-164">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="57c16-165">該父代為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-165">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-166">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-166">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ancestors">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57c16-167">傳回這個節點之上階元素的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-167">Returns a collection of the ancestor elements of this node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-168">（選擇性） 可以指定節點名稱來篩選具有特定名稱的祖系項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-168">Optionally a node name can be specified to filter for ancestor elements with a specific name.</span></span>  
  
 <span data-ttu-id="57c16-169">所傳回集合中之節點的順序為反向文件順序。</span><span class="sxs-lookup"><span data-stu-id="57c16-169">The nodes in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="57c16-170">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-170">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-171">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-171">LINQ to XML</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors();" />
      <MemberSignature Language="F#" Value="member this.Ancestors : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.Ancestors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57c16-172">傳回這個節點之上階元素的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-172">Returns a collection of the ancestor elements of this node.</span></span></summary>
        <returns><span data-ttu-id="57c16-173"><see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之祖系項目的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-173">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the ancestor elements of this node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-174">這個方法不會在結果中傳回本身。</span><span class="sxs-lookup"><span data-stu-id="57c16-174">This method does not return itself in the results.</span></span>  
  
 <span data-ttu-id="57c16-175">所傳回集合中之節點的順序為反向文件順序。</span><span class="sxs-lookup"><span data-stu-id="57c16-175">The nodes in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="57c16-176">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-176">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-177">下列範例會使用這個方法來列舉的祖系節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-177">The following example uses this method to enumerate the ancestors of a node.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors())  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors()  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="57c16-178">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-178">This example produces the following output:</span></span>  
  
```  
Child  
Root  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-179">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-179">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.Ancestors : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.Ancestors name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="57c16-180">要比對的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-180">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="57c16-181">傳回這個節點的上階元素之篩選的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-181">Returns a filtered collection of the ancestor elements of this node.</span></span> <span data-ttu-id="57c16-182">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-182">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="57c16-183"><see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之祖系項目的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-183">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the ancestor elements of this node.</span></span> <span data-ttu-id="57c16-184">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-184">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span>  
  
<span data-ttu-id="57c16-185">所傳回集合中之節點的順序為反向文件順序。</span><span class="sxs-lookup"><span data-stu-id="57c16-185">The nodes in the returned collection are in reverse document order.</span></span>  
  
<span data-ttu-id="57c16-186">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-186">This method uses deferred execution.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-187">這個方法不會傳回本身在結果中。</span><span class="sxs-lookup"><span data-stu-id="57c16-187">This method will not return itself in the results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-188">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-188">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors("Child"))  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors("Child")  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="57c16-189">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-189">This example produces the following output:</span></span>  
  
```  
Child  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-190">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-190">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareDocumentOrder">
      <MemberSignature Language="C#" Value="public static int CompareDocumentOrder (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareDocumentOrder(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareDocumentOrder (n1 As XNode, n2 As XNode) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareDocumentOrder(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberSignature Language="F#" Value="static member CompareDocumentOrder : System.Xml.Linq.XNode * System.Xml.Linq.XNode -&gt; int" Usage="System.Xml.Linq.XNode.CompareDocumentOrder (n1, n2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1"><span data-ttu-id="57c16-191">要比較的第一個 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-191">First <see cref="T:System.Xml.Linq.XNode" /> to compare.</span></span></param>
        <param name="n2"><span data-ttu-id="57c16-192">要比較的第二個 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-192">Second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span></span></param>
        <summary><span data-ttu-id="57c16-193">比較兩個節點，以確定其相對的 XML 文件順序。</span><span class="sxs-lookup"><span data-stu-id="57c16-193">Compares two nodes to determine their relative XML document order.</span></span></summary>
        <returns><span data-ttu-id="57c16-194"><see langword="int" /> 包含 0 表示這兩個節點相等，包含 -1 表示 <paramref name="n1" /> 在 <paramref name="n2" /> 之前，包含 1 則表示 <paramref name="n1" /> 在 <paramref name="n2" /> 之後。</span><span class="sxs-lookup"><span data-stu-id="57c16-194">An <see langword="int" /> containing 0 if the nodes are equal; -1 if <paramref name="n1" /> is before <paramref name="n2" />; 1 if <paramref name="n1" /> is after <paramref name="n2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-195"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-195">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-196">這表示<xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A>方法必須周遊的祖系的兩個節點，直到找到通用的父項目進行比較。</span><span class="sxs-lookup"><span data-stu-id="57c16-196">This means that the <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="57c16-197">然後，它必須周遊常見父系的子節點，以判斷所比較的兩個節點的順序的清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-197">Then it must traverse the list of the common parent's child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="57c16-198">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-198">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-199">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-199">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1", 1),  
        new XElement("GrandChild2", 2),  
        new XElement("GrandChild3", 3)  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild4", 4),  
        new XElement("GrandChild5", 5),  
        new XElement("GrandChild6", 6)  
    )  
);  
XElement el1 = xmlTree.Descendants("GrandChild2").First();  
XElement el2 = xmlTree.Descendants("GrandChild6").First();  
if (XElement.CompareDocumentOrder(el1, el2) == 0)  
    Console.WriteLine("Compared elements are the same element");  
else if (XElement.CompareDocumentOrder(el1, el2) > 0)  
    Console.WriteLine("el1 is after el2");  
else  
    Console.WriteLine("el1 is before el2");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>  
                <GrandChild1>1</GrandChild1>  
                <GrandChild2>2</GrandChild2>  
                <GrandChild3>3</GrandChild3>  
            </Child1>  
            <Child2>  
                <GrandChild4>4</GrandChild4>  
                <GrandChild5>5</GrandChild5>  
                <GrandChild6>6</GrandChild6>  
            </Child2>  
        </Root>  
  
Dim el1 As XElement = xmlTree...<GrandChild2>(0)  
Dim el2 As XElement = xmlTree...<GrandChild6>(0)  
  
If (XElement.CompareDocumentOrder(el1, el2) = 0) Then  
    Console.WriteLine("Compared elements are the same element")  
ElseIf (XElement.CompareDocumentOrder(el1, el2) > 0) Then  
    Console.WriteLine("el1 is after el2")  
Else  
    Console.WriteLine("el1 is before el2")  
End If  
```  
  
 <span data-ttu-id="57c16-200">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-200">This example produces the following output:</span></span>  
  
```  
el1 is before el2  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="57c16-201">這兩個節點不會共用共同的祖系。</span><span class="sxs-lookup"><span data-stu-id="57c16-201">The two nodes do not share a common ancestor.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-202">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-202">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateReader">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57c16-203">建立這個節點的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-203">Creates an <see cref="T:System.Xml.XmlReader" /> for this node.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReader () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader();" />
      <MemberSignature Language="F#" Value="member this.CreateReader : unit -&gt; System.Xml.XmlReader" Usage="xNode.CreateReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57c16-204">建立這個節點的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-204">Creates an <see cref="T:System.Xml.XmlReader" /> for this node.</span></span></summary>
        <returns><span data-ttu-id="57c16-205"><see cref="T:System.Xml.XmlReader" />，可用於讀取這個節點及其子代 (Descendant)。</span><span class="sxs-lookup"><span data-stu-id="57c16-205">An <see cref="T:System.Xml.XmlReader" /> that can be used to read this node and its descendants.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-206">您通常會使用這個方法時您必須提供的另一個元件<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="57c16-206">You typically use this method when you have to supply another component with an <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="57c16-207">例如，您可以建立<xref:System.Xml.XmlReader>從[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]樹狀結構、，然後將傳遞至該讀取器<xref:System.Xml.XmlDocument.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="57c16-207">For example, you can create an <xref:System.Xml.XmlReader> from a [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] tree, and then pass that reader to <xref:System.Xml.XmlDocument.Load%2A>.</span></span>  
  
 <span data-ttu-id="57c16-208">讀取器所傳回的所有<xref:System.Xml.XmlReader.Create%2A>會將正規化的讀取器。</span><span class="sxs-lookup"><span data-stu-id="57c16-208">All of the readers returned by <xref:System.Xml.XmlReader.Create%2A> are normalizing readers.</span></span> <span data-ttu-id="57c16-209">此外，它們一定會執行分行符號正規化和屬性的完整正規化。</span><span class="sxs-lookup"><span data-stu-id="57c16-209">They always perform line break normalization and full normalization of attributes.</span></span> <span data-ttu-id="57c16-210">相反地，<xref:System.Xml.XmlReader>所傳回<xref:System.Xml.Linq.XNode.CreateReader%2A>不正規化的讀取器。</span><span class="sxs-lookup"><span data-stu-id="57c16-210">In contrast, the <xref:System.Xml.XmlReader> returned by <xref:System.Xml.Linq.XNode.CreateReader%2A> is not a normalizing reader.</span></span> <span data-ttu-id="57c16-211">它不會轉換任何泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="57c16-211">It does not transform any white space.</span></span> <span data-ttu-id="57c16-212">已新增的順序，但卻在屬性名稱的順序，它也會傳回屬性。</span><span class="sxs-lookup"><span data-stu-id="57c16-212">It also returns attributes in the order that they were added, not in attribute name order.</span></span>  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] <span data-ttu-id="57c16-213">不會保留屬性是否為預設屬性的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="57c16-213">does not keep information about whether attributes are default attributes.</span></span> <span data-ttu-id="57c16-214"><xref:System.Xml.XmlReader.IsDefault%2A> 一律會傳回 false，不論是否已填入屬性從預設值或不。</span><span class="sxs-lookup"><span data-stu-id="57c16-214"><xref:System.Xml.XmlReader.IsDefault%2A> will always return false regardless of whether the attribute was populated from a default value or not.</span></span>  
  
 <span data-ttu-id="57c16-215">`PUBLIC`並`SYSTEM`上的虛擬屬性<xref:System.Xml.Linq.XDocumentType>不能透過<xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-215">The `PUBLIC` and `SYSTEM` pseudo attributes on <xref:System.Xml.Linq.XDocumentType> are not available through the <xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="57c16-216">它們只可透過<xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType>會做為參數之屬性的限定的名稱的方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-216">They are only available through the <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> method that takes the qualified name of the attribute as a parameter.</span></span> <span data-ttu-id="57c16-217">如果您必須擷取`PUBLIC`或是`SYSTEM`屬性，您應該使用<xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-217">If you have to retrieve the `PUBLIC` or `SYSTEM` attributes, you should use the <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="57c16-218">不支援 Base64 和 BinHex 資料。</span><span class="sxs-lookup"><span data-stu-id="57c16-218">Base64 and BinHex data are not supported.</span></span> <span data-ttu-id="57c16-219">如果您嘗試擷取這些資料型別 (例如，藉由呼叫<xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>)，讀取器將會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="57c16-219">If you attempt to retrieve these types of data (for example, by calling <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>), the reader will throw <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="57c16-220">`xml`宣告不會顯示讀取器。</span><span class="sxs-lookup"><span data-stu-id="57c16-220">The `xml` declaration is not surfaced by the reader.</span></span> <span data-ttu-id="57c16-221">讀取時，不會發生類型的節點<xref:System.Xml.XmlNodeType.XmlDeclaration>。</span><span class="sxs-lookup"><span data-stu-id="57c16-221">While reading, you will not encounter a node of type <xref:System.Xml.XmlNodeType.XmlDeclaration>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-222">下列範例會建立 XML 樹狀結構，然後建立<xref:System.Xml.XmlReader>利用<xref:System.Xml.Linq.XNode.CreateReader%2A>方法，並建立<xref:System.Xml.XmlDocument>使用讀取器。</span><span class="sxs-lookup"><span data-stu-id="57c16-222">The following example creates an XML tree, creates an <xref:System.Xml.XmlReader> by using the <xref:System.Xml.Linq.XNode.CreateReader%2A> method, and creates an <xref:System.Xml.XmlDocument> by using the reader.</span></span>  
  
```csharp  
XDocument xmlTree = new XDocument(  
    new XElement("Root",  
        new XAttribute("Att1", "Attribute Content"),  
        new XElement("Child1", 1),  
        new XElement("Child2", 2)  
    )  
);  
XmlReader reader = xmlTree.CreateReader();  
reader.MoveToContent();  
XmlDocument doc = new XmlDocument();  
XmlNode cd = doc.ReadNode(reader);  
doc.AppendChild(cd);  
Console.WriteLine(doc.OuterXml);  
```  
  
```vb  
Dim xmlTree As XDocument =  _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <Root Att1="Attribute Content">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
        </Root>  
Dim reader As XmlReader = xmlTree.CreateReader()  
reader.MoveToContent()  
Dim doc As XmlDocument = New XmlDocument()  
Dim cd As XmlNode = doc.ReadNode(reader)  
doc.AppendChild(cd)  
Console.WriteLine(doc.OuterXml)  
```  
  
 <span data-ttu-id="57c16-223">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-223">This example produces the following output:</span></span>  
  
```xml  
<Root Att1="Attribute Content"><Child1>1</Child1><Child2>2</Child2></Root>  
```  
  
 <span data-ttu-id="57c16-224">這個方法的另一個用途是執行 XSLT 轉換。</span><span class="sxs-lookup"><span data-stu-id="57c16-224">Another use for this method is to do an XSLT transformation.</span></span> <span data-ttu-id="57c16-225">您可以建立 XML 樹狀結構、從 XML 樹狀結構建立 <xref:System.Xml.XmlReader>、建立新文件，然後建立將寫入新文件中的 <xref:System.Xml.XmlWriter>。</span><span class="sxs-lookup"><span data-stu-id="57c16-225">You can create an XML tree, create an <xref:System.Xml.XmlReader> from the XML tree, create a new document, and create an <xref:System.Xml.XmlWriter> that will write into the new document.</span></span> <span data-ttu-id="57c16-226">然後，您可以叫用 (Invoke) XSLT 轉換，將 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 傳遞至轉換。</span><span class="sxs-lookup"><span data-stu-id="57c16-226">Then, you can invoke the XSLT transformation, passing the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> to the transformation.</span></span> <span data-ttu-id="57c16-227">轉換成功完成後，系統會使用轉換的結果填入新的 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="57c16-227">After the transformation successfully completes, the new XML tree is populated with the results of the transform.</span></span>  
  
```csharp  
string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1>  
            <xsl:value-of select='Child1'/>  
            </C1>  
            <C2>  
            <xsl:value-of select='Child2'/>  
            </C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
Dim xslMarkup As XDocument = _   
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1>  
                    <xsl:value-of select='Child1'/>  
                </C1>  
                <C2>  
                    <xsl:value-of select='Child2'/>  
                </C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XElement = _   
        <Parent>  
            <Child1>Child1 data</Child1>  
            <Child2>Child2 data</Child2>  
        </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 <span data-ttu-id="57c16-228">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-228">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-229">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-229">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader (System.Xml.Linq.ReaderOptions readerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader(valuetype System.Xml.Linq.ReaderOptions readerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader(System::Xml::Linq::ReaderOptions readerOptions);" />
      <MemberSignature Language="F#" Value="member this.CreateReader : System.Xml.Linq.ReaderOptions -&gt; System.Xml.XmlReader" Usage="xNode.CreateReader readerOptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerOptions" Type="System.Xml.Linq.ReaderOptions" />
      </Parameters>
      <Docs>
        <param name="readerOptions"><span data-ttu-id="57c16-230"><see cref="T:System.Xml.Linq.ReaderOptions" /> 物件，指定是否要省略重複的命名空間。</span><span class="sxs-lookup"><span data-stu-id="57c16-230">A <see cref="T:System.Xml.Linq.ReaderOptions" /> object that specifies whether to omit duplicate namespaces.</span></span></param>
        <summary><span data-ttu-id="57c16-231">使用 <paramref name="readerOptions" /> 參數指定的選項建立 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-231">Creates an <see cref="T:System.Xml.XmlReader" /> with the options specified by the <paramref name="readerOptions" /> parameter.</span></span></summary>
        <returns><span data-ttu-id="57c16-232"><see cref="T:System.Xml.XmlReader" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-232">An <see cref="T:System.Xml.XmlReader" /> object.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeepEquals">
      <MemberSignature Language="C#" Value="public static bool DeepEquals (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeepEquals(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeepEquals (n1 As XNode, n2 As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeepEquals(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberSignature Language="F#" Value="static member DeepEquals : System.Xml.Linq.XNode * System.Xml.Linq.XNode -&gt; bool" Usage="System.Xml.Linq.XNode.DeepEquals (n1, n2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1"><span data-ttu-id="57c16-233">要比較的第一個 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-233">The first <see cref="T:System.Xml.Linq.XNode" /> to compare.</span></span></param>
        <param name="n2"><span data-ttu-id="57c16-234">要比較的第二個 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-234">The second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span></span></param>
        <summary><span data-ttu-id="57c16-235">比較兩個節點的值，包括所有子系節點的值。</span><span class="sxs-lookup"><span data-stu-id="57c16-235">Compares the values of two nodes, including the values of all descendant nodes.</span></span></summary>
        <returns><span data-ttu-id="57c16-236">如果兩個節點相等則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-236"><see langword="true" /> if the nodes are equal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-237">下列準則判斷兩個節點是否相等：</span><span class="sxs-lookup"><span data-stu-id="57c16-237">The following criteria determine whether two nodes are equal:</span></span>  
  
-   <span data-ttu-id="57c16-238">A`null`節點是否等於另一個`null`節點，但不相等為非`null`節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-238">A `null` node is equal to another `null` node but unequal to a non-`null` node.</span></span>  
  
-   <span data-ttu-id="57c16-239">兩個<xref:System.Xml.Linq.XNode>不同類型的物件永遠不會相等。</span><span class="sxs-lookup"><span data-stu-id="57c16-239">Two <xref:System.Xml.Linq.XNode> objects of different types are never equal.</span></span>  
  
-   <span data-ttu-id="57c16-240">兩個<xref:System.Xml.Linq.XText>節點是否相等，如果它們包含相同的文字。</span><span class="sxs-lookup"><span data-stu-id="57c16-240">Two <xref:System.Xml.Linq.XText> nodes are equal if they contain the same text.</span></span>  
  
-   <span data-ttu-id="57c16-241">兩個<xref:System.Xml.Linq.XElement>個節點相等，如果有相同的標記名稱，相同的使用相同的值的屬性集，且 （忽略註解和處理指示） 包含兩個長度相同的相等的內容節點的序列。</span><span class="sxs-lookup"><span data-stu-id="57c16-241">Two <xref:System.Xml.Linq.XElement> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.</span></span>  
  
-   <span data-ttu-id="57c16-242">兩個<xref:System.Xml.Linq.XDocument>個節點相等，其根節點是否相等。</span><span class="sxs-lookup"><span data-stu-id="57c16-242">Two <xref:System.Xml.Linq.XDocument> nodes are equal if their root nodes are equal.</span></span>  
  
-   <span data-ttu-id="57c16-243">兩個<xref:System.Xml.Linq.XComment>節點是否相等，如果它們包含相同的註解文字。</span><span class="sxs-lookup"><span data-stu-id="57c16-243">Two <xref:System.Xml.Linq.XComment> nodes are equal if they contain the same comment text.</span></span>  
  
-   <span data-ttu-id="57c16-244">兩個<xref:System.Xml.Linq.XProcessingInstruction>節點是否相等，如果它們有相同的目標和資料。</span><span class="sxs-lookup"><span data-stu-id="57c16-244">Two <xref:System.Xml.Linq.XProcessingInstruction> nodes are equal if they have the same target and data.</span></span>  
  
-   <span data-ttu-id="57c16-245">兩個<xref:System.Xml.Linq.XDocumentType>個節點相等如果具有相同名稱、 公用識別碼、 系統識別碼和內部子集。</span><span class="sxs-lookup"><span data-stu-id="57c16-245">Two <xref:System.Xml.Linq.XDocumentType> nodes are equal if the have the same name, public ID, system ID, and internal subset.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-246">下列範例會使用這個方法來比較兩個 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="57c16-246">The following example uses this method to compare two XML trees.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XElement xmlTree2 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2));  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2))  
```  
  
 <span data-ttu-id="57c16-247">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-247">This example produces the following output:</span></span>  
  
```  
True  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-248">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-248">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DocumentOrderComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.DocumentOrderComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DocumentOrderComparer As XNodeDocumentOrderComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeDocumentOrderComparer ^ DocumentOrderComparer { System::Xml::Linq::XNodeDocumentOrderComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentOrderComparer : System.Xml.Linq.XNodeDocumentOrderComparer" Usage="System.Xml.Linq.XNode.DocumentOrderComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeDocumentOrderComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="57c16-249">取得可比較兩個節點相對位置的比較子 (Comparer)。</span><span class="sxs-lookup"><span data-stu-id="57c16-249">Gets a comparer that can compare the relative position of two nodes.</span></span></summary>
        <value><span data-ttu-id="57c16-250">可比較兩個節點相對位置的 <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-250">An <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /> that can compare the relative position of two nodes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-251">這個屬性主要用於在內部實作<xref:System.Xml.Linq.Extensions.InDocumentOrder%2A>擴充方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-251">This property is primarily used internally for implementing the <xref:System.Xml.Linq.Extensions.InDocumentOrder%2A> extension method.</span></span> <span data-ttu-id="57c16-252">建議的方法是使用該擴充方法，而不是直接使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="57c16-252">The recommended approach is to use that extension method instead of using this property directly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-253">下列範例會建立 XML 樹狀結構，與一些項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-253">The following example creates an XML tree with some elements.</span></span> <span data-ttu-id="57c16-254">然後它會建立<xref:System.Collections.Generic.List%601>的<xref:System.Xml.Linq.XNode>隨機包含從 XML 樹狀結構的某些項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-254">It then creates a <xref:System.Collections.Generic.List%601> of <xref:System.Xml.Linq.XNode> that contains some elements from the XML tree at random.</span></span> <span data-ttu-id="57c16-255">它使用排序的清單，這個屬性來擷取<xref:System.Xml.Linq.XNodeDocumentOrderComparer>，它會實作<xref:System.Collections.IComparer?displayProperty=nameWithType>和<xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType>介面。</span><span class="sxs-lookup"><span data-stu-id="57c16-255">It sorts the list, using this property to retrieve a <xref:System.Xml.Linq.XNodeDocumentOrderComparer>, which implements the <xref:System.Collections.IComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> interfaces.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
List<XNode> nodeList = new List<XNode>();  
nodeList.Add(xmlTree.Element("Child5"));  
nodeList.Add(xmlTree.Element("Child3"));  
nodeList.Add(xmlTree.Element("Child1"));  
  
// Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer);  
  
foreach (XElement el in nodeList)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeList As List(Of XNode) = New List(Of XNode)()  
nodeList.Add(xmlTree.Element("Child5"))  
nodeList.Add(xmlTree.Element("Child3"))  
nodeList.Add(xmlTree.Element("Child1"))  
  
' Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer)  
  
For Each el In nodeList  
    Console.WriteLine(el)  
Next  
```  
  
 <span data-ttu-id="57c16-256">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-256">This example produces the following output:</span></span>  
  
```  
<Child1>1</Child1>  
<Child3>3</Child3>  
<Child5>5</Child5>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-257">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-257">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57c16-258">依照文件順序，傳回這個節點之後同層級項目的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-258">Returns a collection of the sibling elements after this node, in document order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-259">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-259">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-260">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-260">LINQ to XML</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf();" />
      <MemberSignature Language="F#" Value="member this.ElementsAfterSelf : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsAfterSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57c16-261">依照文件順序，傳回這個節點之後同層級項目的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-261">Returns a collection of the sibling elements after this node, in document order.</span></span></summary>
        <returns><span data-ttu-id="57c16-262"><see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之後同層級項目 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-262">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements after this node, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-263">這個方法只會包含在傳回的集合中的同層級項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-263">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="57c16-264">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="57c16-264">It does not include descendants.</span></span>  
  
 <span data-ttu-id="57c16-265">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-265">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-266">下列範例會建立項目有一些複雜的內容。</span><span class="sxs-lookup"><span data-stu-id="57c16-266">The following example creates an element with some complex content.</span></span> <span data-ttu-id="57c16-267">然後，它會使用這個方法來擷取文件順序中的節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-267">It then uses this method to retrieve the nodes in document order.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf()  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="57c16-268">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-268">This example produces the following output:</span></span>  
  
```  
Child4  
Child5  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-269">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-269">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.ElementsAfterSelf : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsAfterSelf name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="57c16-270">要比對的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-270">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="57c16-271">依照文件順序，傳回這個節點之後同層級項目之篩選的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-271">Returns a filtered collection of the sibling elements after this node, in document order.</span></span> <span data-ttu-id="57c16-272">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-272">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="57c16-273"><see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之後同層級項目 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-273">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements after this node, in document order.</span></span> <span data-ttu-id="57c16-274">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-274">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-275">這個方法只會包含在傳回的集合中的同層級項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-275">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="57c16-276">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="57c16-276">It does not include descendants.</span></span>  
  
 <span data-ttu-id="57c16-277">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-277">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-278">下列範例會建立項目有一些複雜的內容。</span><span class="sxs-lookup"><span data-stu-id="57c16-278">The following example creates an element with some complex content.</span></span> <span data-ttu-id="57c16-279">然後，它會使用這個方法來擷取文件順序中的同層級項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-279">It then uses this method to retrieve the sibling elements, in document order.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf("Child4");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf("Child4")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="57c16-280">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-280">This example produces the following output:</span></span>  
  
```  
Child4  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-281">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-281">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57c16-282">依照文件順序，傳回這個節點之前同層級項目的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-282">Returns a collection of the sibling elements before this node, in document order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-283">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-283">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-284">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-284">LINQ to XML</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf();" />
      <MemberSignature Language="F#" Value="member this.ElementsBeforeSelf : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsBeforeSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57c16-285">依照文件順序，傳回這個節點之前同層級項目的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-285">Returns a collection of the sibling elements before this node, in document order.</span></span></summary>
        <returns><span data-ttu-id="57c16-286"><see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之前同層級項目 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-286">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements before this node, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-287">這個方法只會包含在傳回的集合中的同層級項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-287">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="57c16-288">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="57c16-288">It does not include descendants.</span></span>  
  
 <span data-ttu-id="57c16-289">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-289">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-290">下列範例會使用此座標軸方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-290">The following example uses this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf()  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="57c16-291">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-291">This example produces the following output:</span></span>  
  
```  
Child1  
Child2  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-292">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-292">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.ElementsBeforeSelf : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsBeforeSelf name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="57c16-293">要比對的 <see cref="T:System.Xml.Linq.XName" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-293">The <see cref="T:System.Xml.Linq.XName" /> to match.</span></span></param>
        <summary><span data-ttu-id="57c16-294">依照文件順序，傳回這個節點之前同層級項目之篩選的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-294">Returns a filtered collection of the sibling elements before this node, in document order.</span></span> <span data-ttu-id="57c16-295">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-295">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></summary>
        <returns><span data-ttu-id="57c16-296"><see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之前同層級項目 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XElement" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-296">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements before this node, in document order.</span></span> <span data-ttu-id="57c16-297">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-297">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-298">這個方法只會包含在傳回的集合中的同層級項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-298">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="57c16-299">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="57c16-299">It does not include descendants.</span></span>  
  
 <span data-ttu-id="57c16-300">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-300">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-301">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-301">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf("Child2");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf("Child2")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="57c16-302">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-302">This example produces the following output:</span></span>  
  
```  
Child2  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-303">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-303">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EqualityComparer As XNodeEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeEqualityComparer ^ EqualityComparer { System::Xml::Linq::XNodeEqualityComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EqualityComparer : System.Xml.Linq.XNodeEqualityComparer" Usage="System.Xml.Linq.XNode.EqualityComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="57c16-304">取得可比較兩個節點值是否相等的比較子。</span><span class="sxs-lookup"><span data-stu-id="57c16-304">Gets a comparer that can compare two nodes for value equality.</span></span></summary>
        <value><span data-ttu-id="57c16-305">可比較兩個節點值是否相等的 <see cref="T:System.Xml.Linq.XNodeEqualityComparer" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-305">A <see cref="T:System.Xml.Linq.XNodeEqualityComparer" /> that can compare two nodes for value equality.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="57c16-306">下列範例會使用這個屬性來擷取<xref:System.Xml.Linq.XNodeEqualityComparer>，它會實作<xref:System.Collections.IEqualityComparer?displayProperty=nameWithType>和<xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType>介面。</span><span class="sxs-lookup"><span data-stu-id="57c16-306">The following example uses this property to retrieve an <xref:System.Xml.Linq.XNodeEqualityComparer>, which implements the <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType> interfaces.</span></span> <span data-ttu-id="57c16-307">它會建立會使用這個屬性的字典。</span><span class="sxs-lookup"><span data-stu-id="57c16-307">It creates a dictionary that uses this property.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
Dictionary<XNode, string> nodeDictionary = new Dictionary<XNode, string>(XNode.EqualityComparer);  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information");  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information");  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information");  
  
string str = nodeDictionary[xmlTree.Element("Child3")];  
Console.WriteLine(str);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeDictionary As Dictionary(Of XNode, String) = New Dictionary(Of XNode, String)(XNode.EqualityComparer)  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information")  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information")  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information")  
  
Dim str As String = nodeDictionary(xmlTree.Element("Child3"))  
Console.WriteLine(str)  
```  
  
 <span data-ttu-id="57c16-308">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-308">This example produces the following output:</span></span>  
  
```  
Child 3 Information  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-309">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-309">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAfter">
      <MemberSignature Language="C#" Value="public bool IsAfter (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAfter(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAfter (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAfter(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="member this.IsAfter : System.Xml.Linq.XNode -&gt; bool" Usage="xNode.IsAfter node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="57c16-310">要針對文件順序比較的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-310">The <see cref="T:System.Xml.Linq.XNode" /> to compare for document order.</span></span></param>
        <summary><span data-ttu-id="57c16-311">根據文件順序，判斷目前的節點是否出現在指定的節點之後。</span><span class="sxs-lookup"><span data-stu-id="57c16-311">Determines if the current node appears after a specified node in terms of document order.</span></span></summary>
        <returns><span data-ttu-id="57c16-312">如果這個節點出現在指定的節點之後則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-312"><see langword="true" /> if this node appears after the specified node; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-313"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-313">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-314">這表示<xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A>方法必須周遊的祖系的兩個節點，直到找到通用的父項目進行比較。</span><span class="sxs-lookup"><span data-stu-id="57c16-314">This means that the <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="57c16-315">然後，它必須周遊常見父系的子節點，以判斷所比較的兩個節點的順序的清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-315">Then it must traverse the list of the common parent's child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="57c16-316">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-316">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-317">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-317">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsAfter(child3))  
    Console.WriteLine("Child5 is after Child3");  
else  
    Console.WriteLine("Child5 is not after Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsAfter(child3)) Then  
    Console.WriteLine("Child5 is after Child3")  
Else  
    Console.WriteLine("Child5 is not after Child3")  
End If  
```  
  
 <span data-ttu-id="57c16-318">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-318">This example produces the following output:</span></span>  
  
```  
Child5 is after Child3  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-319">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-319">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsBefore">
      <MemberSignature Language="C#" Value="public bool IsBefore (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBefore(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBefore (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBefore(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="member this.IsBefore : System.Xml.Linq.XNode -&gt; bool" Usage="xNode.IsBefore node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node"><span data-ttu-id="57c16-320">要針對文件順序比較的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-320">The <see cref="T:System.Xml.Linq.XNode" /> to compare for document order.</span></span></param>
        <summary><span data-ttu-id="57c16-321">根據文件順序，判斷目前的節點是否出現在指定的節點之前。</span><span class="sxs-lookup"><span data-stu-id="57c16-321">Determines if the current node appears before a specified node in terms of document order.</span></span></summary>
        <returns><span data-ttu-id="57c16-322">如果這個節點出現在指定的節點之前則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-322"><see langword="true" /> if this node appears before the specified node; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-323"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-323">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-324">這表示<xref:System.Xml.Linq.XNode.IsBefore%2A>方法必須周遊的祖系的兩個節點，直到找到通用的父項目進行比較。</span><span class="sxs-lookup"><span data-stu-id="57c16-324">This means that the <xref:System.Xml.Linq.XNode.IsBefore%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="57c16-325">然後，它必須周遊常見父系的子節點，以判斷所比較的兩個節點的順序的清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-325">Then it must traverse the list of the common parent's child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="57c16-326">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-326">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-327">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-327">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsBefore(child3))  
    Console.WriteLine("Child5 is before Child3");  
else  
    Console.WriteLine("Child5 is not before Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsBefore(child3)) Then  
    Console.WriteLine("Child5 is before Child3")  
Else  
    Console.WriteLine("Child5 is not before Child3")  
End If  
```  
  
 <span data-ttu-id="57c16-328">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-328">This example produces the following output:</span></span>  
  
```  
Child5 is not before Child3  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-329">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-329">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="NextNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode NextNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode NextNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.NextNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ NextNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextNode : System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.NextNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="57c16-330">取得這個節點的下一個同層級 (Sibling) 節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-330">Gets the next sibling node of this node.</span></span></summary>
        <value><span data-ttu-id="57c16-331">包含下一個同層級節點的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-331">The <see cref="T:System.Xml.Linq.XNode" /> that contains the next sibling node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-332">如果這個<xref:System.Xml.Linq.XNode>並沒有父代，或如果沒有下一個節點，這個屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="57c16-332">If this <xref:System.Xml.Linq.XNode> does not have a parent, or if there is no next node, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-333">下列範例會使用這個屬性來迴圈節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-333">The following example uses this property to loop through nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.NextNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>Some Text  
            <Child2>2  
                <GrandChild>GrandChild Content</GrandChild>  
            </Child2>  
            <!--a comment-->  
            <Child3>3</Child3>  
        </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.NextNode  
Loop While (Not (node Is Nothing))  
```  
  
 <span data-ttu-id="57c16-334">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-334">This example produces the following output:</span></span>  
  
```  
NodeType: Element   Child2  
NodeType: Comment   a comment  
NodeType: Element   Child3  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-335">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-335">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="NodesAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesAfterSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesAfterSelf();" />
      <MemberSignature Language="F#" Value="member this.NodesAfterSelf : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xNode.NodesAfterSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesAfterSelf&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesAfterSelf&gt;d__21))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57c16-336">依照文件順序，傳回這個節點之後同層級節點的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-336">Returns a collection of the sibling nodes after this node, in document order.</span></span></summary>
        <returns><span data-ttu-id="57c16-337"><see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之後同層級節點 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-337">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> of the sibling nodes after this node, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-338">這個方法只會包含在傳回的集合中的同層級項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-338">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="57c16-339">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="57c16-339">It does not include descendants.</span></span>  
  
 <span data-ttu-id="57c16-340">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-340">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-341">下列範例會建立 XML 樹狀結構，並接著會查詢樹狀目錄中使用此座標軸方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-341">The following example creates an XML tree, and then queries the tree using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesAfterSelf()  
    select node;  
foreach (XNode node in nodes)  
{  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
}  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesAfterSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 <span data-ttu-id="57c16-342">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-342">This example produces the following output:</span></span>  
  
```  
Node type: Text  More text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-343">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-343">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="NodesBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesBeforeSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesBeforeSelf();" />
      <MemberSignature Language="F#" Value="member this.NodesBeforeSelf : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xNode.NodesBeforeSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesBeforeSelf&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XNode/&lt;NodesBeforeSelf&gt;d__22))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57c16-344">依照文件順序，傳回這個節點之前同層級節點的集合。</span><span class="sxs-lookup"><span data-stu-id="57c16-344">Returns a collection of the sibling nodes before this node, in document order.</span></span></summary>
        <returns><span data-ttu-id="57c16-345"><see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之前同層級節點 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-345">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> of the sibling nodes before this node, in document order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-346">這個方法只會包含在傳回的集合中的同層級項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-346">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="57c16-347">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="57c16-347">It does not include descendants.</span></span>  
  
 <span data-ttu-id="57c16-348">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="57c16-348">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-349">下列範例會建立 XML 樹狀結構，並接著會查詢樹狀目錄中使用此座標軸方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-349">The following example creates an XML tree, and then queries the tree using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesBeforeSelf()  
    select node;  
foreach (XNode node in nodes)  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _  
    New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesBeforeSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 <span data-ttu-id="57c16-350">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-350">This example produces the following output:</span></span>  
  
```  
Node type: Text  Text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-351">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-351">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PreviousNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode PreviousNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode PreviousNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.PreviousNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ PreviousNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousNode : System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.PreviousNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="57c16-352">取得這個節點的上一個同層級節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-352">Gets the previous sibling node of this node.</span></span></summary>
        <value><span data-ttu-id="57c16-353">包含上一個同層級節點的 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-353">The <see cref="T:System.Xml.Linq.XNode" /> that contains the previous sibling node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-354">如果這個<xref:System.Xml.Linq.XNode>並沒有父代，或如果沒有上一個節點，這個屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="57c16-354">If this <xref:System.Xml.Linq.XNode> does not have a parent, or if there is no previous node, this property returns `null`.</span></span>  
  
 <span data-ttu-id="57c16-355"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-355">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-356">這表示<xref:System.Xml.Linq.XNode.PreviousNode%2A>屬性都必須周遊的父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-356">This means that the <xref:System.Xml.Linq.XNode.PreviousNode%2A> property must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="57c16-357">因此，使用這個屬性可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-357">Therefore, using this property might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-358">下列範例會使用這個屬性來迴圈節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-358">The following example uses this property to loop through nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.PreviousNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>Some Text<Child2>2  
            <GrandChild>GrandChild Content</GrandChild>  
        </Child2>  
        <!--a comment-->  
        <Child3>3</Child3>  
    </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.PreviousNode  
Loop While (Not (node Is Nothing))  
```  
  
 <span data-ttu-id="57c16-359">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-359">This example produces the following output:</span></span>  
  
```  
NodeType: Element   Child2  
NodeType: Text      Some Text  
NodeType: Element   Child1  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-360">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-360">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadFrom">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNode ReadFrom (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XNode ReadFrom(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadFrom (reader As XmlReader) As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XNode ^ ReadFrom(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member ReadFrom : System.Xml.XmlReader -&gt; System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.ReadFrom reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="57c16-361"><see cref="T:System.Xml.XmlReader" /> 位於節點，以讀入這個 <see cref="T:System.Xml.Linq.XNode" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-361">An <see cref="T:System.Xml.XmlReader" /> positioned at the node to read into this <see cref="T:System.Xml.Linq.XNode" />.</span></span></param>
        <summary><span data-ttu-id="57c16-362">從 <see cref="T:System.Xml.Linq.XNode" /> 建立 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-362">Creates an <see cref="T:System.Xml.Linq.XNode" /> from an <see cref="T:System.Xml.XmlReader" />.</span></span></summary>
        <returns><span data-ttu-id="57c16-363"><see cref="T:System.Xml.Linq.XNode" />，包含從讀取器讀取的節點及其子代節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-363">An <see cref="T:System.Xml.Linq.XNode" /> that contains the node and its descendant nodes that were read from the reader.</span></span> <span data-ttu-id="57c16-364">節點的執行階段型別是由讀取器中遇到的第一個節點的節點型別 (<see cref="P:System.Xml.Linq.XObject.NodeType" />) 決定的。</span><span class="sxs-lookup"><span data-stu-id="57c16-364">The runtime type of the node is determined by the node type (<see cref="P:System.Xml.Linq.XObject.NodeType" />) of the first node encountered in the reader.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-365">您可以使用這個方法來撰寫一個方法，傳回一組節點，從讀取器讀取的節點時，產生每個節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-365">You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader.</span></span> <span data-ttu-id="57c16-366">這個方法可讓您處理任意大的 XML 檔案，具有較少的記憶體耗用量。</span><span class="sxs-lookup"><span data-stu-id="57c16-366">This method enables you to process arbitrarily large XML files with a very small memory footprint.</span></span>  
  
 <span data-ttu-id="57c16-367">您傳遞給此方法的讀取器可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="57c16-367">The reader that you pass to this method might throw exceptions.</span></span> <span data-ttu-id="57c16-368"><xref:System.Xml.Linq.XNode.ReadFrom%2A> 不會攔截所有讀取器時，所擲回例外狀況未處理的例外狀況反昇至呼叫的程式碼<xref:System.Xml.Linq.XNode.ReadFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="57c16-368"><xref:System.Xml.Linq.XNode.ReadFrom%2A> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <xref:System.Xml.Linq.XNode.ReadFrom%2A>.</span></span> <span data-ttu-id="57c16-369">特別是，您的程式碼準備好處理<xref:System.Xml.XmlException>。</span><span class="sxs-lookup"><span data-stu-id="57c16-369">In particular, your code should be prepared to handle <xref:System.Xml.XmlException>.</span></span>  
  
 <span data-ttu-id="57c16-370">如需如何串流更複雜的文件的範例，請參閱 <<c0> [ 如何： Stream XML 片段並存取標頭資訊](https://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)。</span><span class="sxs-lookup"><span data-stu-id="57c16-370">For an example of how to stream a more complex document, see [How to: Stream XML Fragments with Access to Header Information](https://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span></span>  
  
 <span data-ttu-id="57c16-371">特定的標準查詢運算子 (例如，<xref:System.Linq.Enumerable.OrderBy%2A>) 會反覆查看其來源、收集所有資料、排序這些資料，最後產生順序中的第一個項目。</span><span class="sxs-lookup"><span data-stu-id="57c16-371">Certain standard query operators, such as <xref:System.Linq.Enumerable.OrderBy%2A>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</span></span> <span data-ttu-id="57c16-372">如果您使用具體化其來源，然後再產生第一個項目查詢運算子，將不會保留小的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="57c16-372">If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</span></span>  
  
 <span data-ttu-id="57c16-373">如需使用的範例[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]轉換非常大的 XML 文件，同時維護小的記憶體使用量，請參閱[如何： 執行資料流轉換大型 XML 文件的](https://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)。</span><span class="sxs-lookup"><span data-stu-id="57c16-373">For an example of using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] to transform extremely large XML documents while maintaining a small memory footprint, see [How to: Perform Streaming Transform of Large XML Documents](https://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).</span></span>  
  
## Examples

<span data-ttu-id="57c16-374">此範例會使用下列的 XML 檔案，名為*Source.xml*:</span><span class="sxs-lookup"><span data-stu-id="57c16-374">This example uses the following XML file, named *Source.xml*:</span></span>

[!code-xml[Source.xml](~/samples/snippets/csharp/api/system.xml.linq/xnode/readfrom/Source.xml)]

<span data-ttu-id="57c16-375">下列範例會建立使用自訂座標軸方法<xref:System.Xml.Linq.XNode.ReadFrom%2A>，然後進行自訂的座標軸查詢使用 LINQ 查詢：</span><span class="sxs-lookup"><span data-stu-id="57c16-375">The following example creates a custom axis method that uses <xref:System.Xml.Linq.XNode.ReadFrom%2A> and then queries the custom axis by using a LINQ query:</span></span>

[!code-csharp[XNode.ReadFromCS](~/samples/snippets/csharp/api/system.xml.linq/xnode/readfrom/Program.cs)]
[!code-vb[XNode.ReadFromVB](~/samples/snippets/visualbasic/api/system.xml.linq/xnode/readfrom/Program.vb)]

<span data-ttu-id="57c16-376">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-376">This example produces the following output:</span></span>

```  
bbb  
ccc  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="57c16-377"><see cref="T:System.Xml.XmlReader" /> 未位於可識別的節點型別上。</span><span class="sxs-lookup"><span data-stu-id="57c16-377">The <see cref="T:System.Xml.XmlReader" /> is not positioned on a recognized node type.</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="57c16-378">基礎 <see cref="T:System.Xml.XmlReader" /> 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="57c16-378">The underlying <see cref="T:System.Xml.XmlReader" /> throws an exception.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-379">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-379">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadFromAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt; ReadFromAsync (System.Xml.XmlReader reader, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XNode&gt; ReadFromAsync(class System.Xml.XmlReader reader, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFromAsync(System.Xml.XmlReader,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XNode ^&gt; ^ ReadFromAsync(System::Xml::XmlReader ^ reader, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReadFromAsync : System.Xml.XmlReader * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt;" Usage="System.Xml.Linq.XNode.ReadFromAsync (reader, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="xNode.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57c16-380">將這個節點從其父代 (Parent) 移除。</span><span class="sxs-lookup"><span data-stu-id="57c16-380">Removes this node from its parent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-381">在 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]程式設計，您應該不管理或修改一組節點，而您要查詢該集合中的節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-381">In [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set.</span></span> <span data-ttu-id="57c16-382">實際上，這表示您應該不逐一查看一組節點並將它們移除。</span><span class="sxs-lookup"><span data-stu-id="57c16-382">In practical terms, this means that you should not iterate over a set of nodes and remove them.</span></span> <span data-ttu-id="57c16-383">相反地，您應該將這些集合具體化到<xref:System.Collections.Generic.List%601>使用<xref:System.Linq.Enumerable.ToList%2A>擴充方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-383">Instead, you should materialize them into a <xref:System.Collections.Generic.List%601> by using the <xref:System.Linq.Enumerable.ToList%2A> extension method.</span></span> <span data-ttu-id="57c16-384">然後，您可以逐一查看要移除的節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-384">Then, you can iterate over the list to remove the nodes.</span></span> <span data-ttu-id="57c16-385">如需詳細資訊，請參閱 <<c0> [ 混合宣告式程式碼/命令式程式碼 Bug (LINQ to XML)](https://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)。</span><span class="sxs-lookup"><span data-stu-id="57c16-385">For more information, see [Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)](https://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094).</span></span>  
  
 <span data-ttu-id="57c16-386">或者，如果您想要移除的節點集，建議您改用<xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="57c16-386">Alternatively, if you want to remove a set of nodes, it is recommended that you use the <xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="57c16-387">這個方法會將節點複製到清單中，並接著逐一查看要移除的節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-387">This method copies the nodes to a list, and then iterates over the list to remove the nodes.</span></span>  
  
 <span data-ttu-id="57c16-388">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>而<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-388">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="57c16-389"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-389">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-390">這表示<xref:System.Xml.Linq.XNode.Remove%2A>方法必須周遊的父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-390">This means that the <xref:System.Xml.Linq.XNode.Remove%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="57c16-391">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-391">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-392">下列範例會從其父代移除節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-392">The following example removes a node from its parent.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.Remove();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.Remove()  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-393">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-393">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="57c16-394">該父代為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-394">The parent is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-395">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-395">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceWith">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57c16-396">以指定的內容取代這個節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-396">Replaces this node with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-397">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-397">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-398">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>而<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-398">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="57c16-399"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-399">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-400">這表示<xref:System.Xml.Linq.XNode.ReplaceWith%2A>方法必須周遊的父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-400">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must  traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="57c16-401">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-401">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-402">下列範例會使用這個方法，以不同的內容取代節點的內容。</span><span class="sxs-lookup"><span data-stu-id="57c16-402">The following example uses this method to replace the contents of a node with different content.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-403">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-403">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-404">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-404">LINQ to XML</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceWith : obj -&gt; unit" Usage="xNode.ReplaceWith content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="57c16-405">取代這個節點的內容。</span><span class="sxs-lookup"><span data-stu-id="57c16-405">Content that replaces this node.</span></span></param>
        <summary><span data-ttu-id="57c16-406">以指定的內容取代這個節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-406">Replaces this node with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-407">這個方法會從其父代，會先移除此節點，然後將指定的內容新增到這個節點的父代，取代這個節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-407">This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</span></span>  
  
 <span data-ttu-id="57c16-408"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-408">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-409">這表示<xref:System.Xml.Linq.XNode.ReplaceWith%2A>方法必須周遊的父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-409">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="57c16-410">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-410">Therefore, using this method might affect your performance.</span></span>  
  
 <span data-ttu-id="57c16-411">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-411">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-412">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>而<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-412">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-413">下列範例會使用這個方法，以不同的內容取代節點的內容。</span><span class="sxs-lookup"><span data-stu-id="57c16-413">The following example uses this method to replace the contents of a node with different content.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-414">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-414">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-415">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-415">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceWith : obj[] -&gt; unit" Usage="xNode.ReplaceWith content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="57c16-416">新內容的參數清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-416">A parameter list of the new content.</span></span></param>
        <summary><span data-ttu-id="57c16-417">以指定的內容取代這個節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-417">Replaces this node with the specified content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-418">這個方法會從其父代，會先移除此節點，然後將指定的內容新增到這個節點的父代，取代這個節點。</span><span class="sxs-lookup"><span data-stu-id="57c16-418">This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</span></span>  
  
 <span data-ttu-id="57c16-419"><xref:System.Xml.Linq.XContainer>將它的子節點儲存為單向連結清單的<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="57c16-419">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="57c16-420">這表示<xref:System.Xml.Linq.XNode.ReplaceWith%2A>方法必須周遊的父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="57c16-420">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="57c16-421">因此，使用此方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="57c16-421">Therefore, using this method might affect your performance.</span></span>  
  
 <span data-ttu-id="57c16-422">如需有效的內容，可以傳遞至這個方法的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="57c16-422">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](https://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="57c16-423">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>而<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="57c16-423">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-424">下列範例示範使用的結果[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]做為這個方法的輸入查詢。</span><span class="sxs-lookup"><span data-stu-id="57c16-424">The following example shows using the results of a [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] query as the input to this method.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith( _  
    From el In srcTree.Elements() _  
    Where (CInt(el) > 3) _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-425">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-425">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-426">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-426">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="57c16-427">傳回這個節點的 XML (可選擇是否停用格式設定)。</span><span class="sxs-lookup"><span data-stu-id="57c16-427">Returns the XML for this node, optionally disabling formatting.</span></span></summary>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-428">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-428">LINQ to XML</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xNode.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="57c16-429">針對這個節點傳回縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="57c16-429">Returns the indented XML for this node.</span></span></summary>
        <returns><span data-ttu-id="57c16-430"><see cref="T:System.String" />，包含縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="57c16-430">A <see cref="T:System.String" /> containing the indented XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="57c16-431">下列範例會使用這個方法來擷取縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="57c16-431">The following example uses this method to retrieve indented XML.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
        </Root>  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="57c16-432">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-432">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-433">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-433">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="override this.ToString : System.Xml.Linq.SaveOptions -&gt; string" Usage="xNode.ToString options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options"><span data-ttu-id="57c16-434">指定格式化行為的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-434">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="57c16-435">傳回這個節點的 XML (可選擇是否停用格式設定)。</span><span class="sxs-lookup"><span data-stu-id="57c16-435">Returns the XML for this node, optionally disabling formatting.</span></span></summary>
        <returns><span data-ttu-id="57c16-436"><see cref="T:System.String" />，包含 XML。</span><span class="sxs-lookup"><span data-stu-id="57c16-436">A <see cref="T:System.String" /> containing the XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="57c16-437">下列範例會使用這個方法來擷取未格式化和格式化 XML。</span><span class="sxs-lookup"><span data-stu-id="57c16-437">The following example uses this method to retrieve unformatted and formatted XML.</span></span>  
  
```csharp  
XElement root = XElement.Parse("<Root><Child/></Root>");  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("---");  
Console.WriteLine(root.ToString(SaveOptions.None));  
```  
  
```vb  
Dim root As XElement = <Root>  
                           <Child/>  
                       </Root>  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("---")  
Console.WriteLine(root.ToString(SaveOptions.None))  
```  
  
 <span data-ttu-id="57c16-438">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-438">This example produces the following output:</span></span>  
  
```  
<Root><Child /></Root>  
---  
<Root>  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-439">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-439">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public abstract void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xNode.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="57c16-440">此方法將寫入其中的 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-440">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span></span></param>
        <summary><span data-ttu-id="57c16-441">將這個節點寫入 <see cref="T:System.Xml.XmlWriter" />。</span><span class="sxs-lookup"><span data-stu-id="57c16-441">Writes this node to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="57c16-442">您可以使用這個方法來寫入資料流轉換非常大的文件的程式碼。</span><span class="sxs-lookup"><span data-stu-id="57c16-442">You can use this method to write code that does a streaming transform of a very large document.</span></span> <span data-ttu-id="57c16-443">如需詳細資訊，請參閱 <<c0> [ 如何： 執行資料流轉換大型 XML 文件的](https://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)。</span><span class="sxs-lookup"><span data-stu-id="57c16-443">For more information, see [How to: Perform Streaming Transform of Large XML Documents](https://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="57c16-444">下列範例會建立<xref:System.Xml.XmlWriter>寫入<xref:System.Text.StringBuilder>。</span><span class="sxs-lookup"><span data-stu-id="57c16-444">The following example creates an <xref:System.Xml.XmlWriter> that writes to a <xref:System.Text.StringBuilder>.</span></span> <span data-ttu-id="57c16-445">然後，它會使用此方法來寫入至寫入器的兩個 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="57c16-445">It then uses this method to write two XML trees to the writer.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    xw.WriteStartElement("Root");  
    XElement child1 = new XElement("Child",  
        new XElement("GrandChild", "some content")  
    );  
    child1.WriteTo(xw);  
    XElement child2 = new XElement("AnotherChild",  
        new XElement("GrandChild", "different content")  
    );  
    child2.WriteTo(xw);  
    xw.WriteEndElement();  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    xw.WriteStartElement("Root")  
    Dim child1 As XElement = <Child>  
                                 <GrandChild>some content</GrandChild>  
                             </Child>  
    child1.WriteTo(xw)  
    Dim child2 As XElement = <AnotherChild>  
                                 <GrandChild>different content</GrandChild>  
                             </AnotherChild>  
    child2.WriteTo(xw)  
    xw.WriteEndElement()  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="57c16-446">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="57c16-446">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>  
    <GrandChild>some content</GrandChild>  
  </Child>  
  <AnotherChild>  
    <GrandChild>different content</GrandChild>  
  </AnotherChild>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13"><span data-ttu-id="57c16-447">LINQ to XML</span><span class="sxs-lookup"><span data-stu-id="57c16-447">LINQ to XML</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public abstract System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteToAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xNode.WriteToAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>