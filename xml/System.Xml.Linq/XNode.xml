<Type Name="XNode" FullName="System.Xml.Linq.XNode">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f001654247344cf25b9ac07d23e7fb08ac4c201a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XNode : System.Xml.Linq.XObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XNode extends System.Xml.Linq.XObject" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XNode" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XNode&#xA;Inherits XObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class XNode abstract : System::Xml::Linq::XObject" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="f061c-101">表示 XML 樹狀結構中節點 (元素、註解、文件類型、處理指示或文字節點) 的抽象概念。</span>
      <span class="sxs-lookup">
        <span data-stu-id="f061c-101">Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-102"><xref:System.Xml.Linq.XNode> 是下列類型的抽象通用基底類別：</span><span class="sxs-lookup"><span data-stu-id="f061c-102"><xref:System.Xml.Linq.XNode> is an abstract common base class for the following types:</span></span>  
  
-   <xref:System.Xml.Linq.XComment>  
  
-   <xref:System.Xml.Linq.XContainer>  
  
-   <xref:System.Xml.Linq.XDocumentType>  
  
-   <xref:System.Xml.Linq.XProcessingInstruction>  
  
-   <xref:System.Xml.Linq.XText>  
  
 <span data-ttu-id="f061c-103"><xref:System.Xml.Linq.XContainer> 是下列類型的抽象通用基底類別：</span><span class="sxs-lookup"><span data-stu-id="f061c-103"><xref:System.Xml.Linq.XContainer> is an abstract common base class for the following types:</span></span>  
  
-   <xref:System.Xml.Linq.XDocument>  
  
-   <xref:System.Xml.Linq.XElement>  
  
 <span data-ttu-id="f061c-104">物件的類別衍生自<xref:System.Xml.Linq.XContainer>可以包含子節點。</span><span class="sxs-lookup"><span data-stu-id="f061c-104">Objects of classes that derive from <xref:System.Xml.Linq.XContainer> can contain child nodes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f061c-105"><xref:System.Xml.Linq.XAttribute>不<xref:System.Xml.Linq.XNode>。</span><span class="sxs-lookup"><span data-stu-id="f061c-105">An <xref:System.Xml.Linq.XAttribute> is not an <xref:System.Xml.Linq.XNode>.</span></span> <span data-ttu-id="f061c-106">屬性會保留為名稱/值組的項目上的清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-106">Attributes are maintained as a list of name/value pairs on an element.</span></span>  
  
 <span data-ttu-id="f061c-107">如果您要撰寫複雜 XML 應用程式，例如，XML 編輯器或將內容儲存為 XML，文書處理器將通常會在節點層級。</span><span class="sxs-lookup"><span data-stu-id="f061c-107">If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level.</span></span> <span data-ttu-id="f061c-108">在節點層級使用時，一般的活動包括將節點加入、 刪除節點、 轉換節點，以及逐一查看傳回的節點集合的座標軸。</span><span class="sxs-lookup"><span data-stu-id="f061c-108">Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-109">將指定的內容加入緊接在此節點後面的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-109">Adds the specified content immediately after this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-110">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-110">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-111">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-111">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-112">下列範例使用 LINQ 查詢來建立<xref:System.Collections.Generic.IEnumerable%601>的<xref:System.Xml.Linq.XElement>，這會接著傳遞給這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-112">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="f061c-113">這會將查詢的結果加入想要的位置中的樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-113">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Element1>1</Element1>  
        <Element2>2</Element2>  
        <Element3>3</Element3>  
        <Element4>4</Element4>  
        <Element5>5</Element5>  
    </Root>  
  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
    </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-114">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-114">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="f061c-115">要在這個節點之後加入的包含簡單內容或內容物件集合的內容物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-115">A content object that contains simple content or a collection of content objects to be added after this node.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-116">將指定的內容加入緊接在此節點後面的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-116">Adds the specified content immediately after this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-117">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-117">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-118"><xref:System.Xml.Linq.XObject.Changing> 事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-118"><xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-119">下列範例會使用這個方法將項目新增至樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-119">The following example uses this method to add an element into the tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-120">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-120">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <NewChild>10</NewChild>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f061c-121">該父代為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-121">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="f061c-122">內容物件的參數清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-122">A parameter list of content objects.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-123">將指定的內容加入緊接在此節點後面的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-123">Adds the specified content immediately after this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-124">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-124">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-125">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-125">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-126">下列範例使用 LINQ 查詢來建立<xref:System.Collections.Generic.IEnumerable%601>的<xref:System.Xml.Linq.XElement>，這會接著傳遞給這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-126">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="f061c-127">這會將查詢的結果加入想要的位置中的樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-127">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-128">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-128">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f061c-129">該父代為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-129">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-130">將指定的內容加入緊接在此節點前面的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-130">Adds the specified content immediately before this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-131">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-131">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-132">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-132">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="f061c-133"><xref:System.Xml.Linq.XContainer>將其子資訊儲存為單向連結清單<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-133">The <xref:System.Xml.Linq.XContainer> stores its child notes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-134">這表示<xref:System.Xml.Linq.XNode.AddBeforeSelf%2A>方法必須周遊於父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-134">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="f061c-135">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-135">Therefore, using this method might  affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-136">下列範例使用 LINQ 查詢來建立<xref:System.Collections.Generic.IEnumerable%601>的<xref:System.Xml.Linq.XElement>，這會接著傳遞給這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-136">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="f061c-137">這會將查詢的結果加入想要的位置中的樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-137">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
From el In srcTree.Elements() _  
Where CInt(el) > 3 _  
Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-138">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-138">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="f061c-139">要在這個節點之前加入之包含簡單內容或內容物件集合的內容物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-139">A content object that contains simple content or a collection of content objects to be added before this node.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-140">將指定的內容加入緊接在此節點前面的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-140">Adds the specified content immediately before this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-141">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-141">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-142">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-142">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="f061c-143"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-143">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-144">這表示<xref:System.Xml.Linq.XNode.AddBeforeSelf%2A>方法必須周遊於父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-144">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="f061c-145">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-145">Therefore, using this method might  affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-146">下列範例會使用這個方法將項目新增至樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-146">The following example uses this method to add an element into the tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-147">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-147">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <NewChild>10</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f061c-148">該父代為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-148">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="f061c-149">內容物件的參數清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-149">A parameter list of content objects.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-150">將指定的內容加入緊接在此節點前面的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-150">Adds the specified content immediately before this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-151">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-151">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-152">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-152">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="f061c-153"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-153">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-154">這表示<xref:System.Xml.Linq.XNode.AddBeforeSelf%2A>方法必須周遊於父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-154">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="f061c-155">因此，使用這個函式可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-155">Therefore, using this function might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-156">下列範例使用 LINQ 查詢來建立<xref:System.Collections.Generic.IEnumerable%601>的<xref:System.Xml.Linq.XElement>，這會接著傳遞給這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-156">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="f061c-157">這會將查詢的結果加入想要的位置中的樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-157">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-158">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-158">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f061c-159">該父代為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-159">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ancestors">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-160">傳回這個節點之上階元素的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-160">Returns a collection of the ancestor elements of this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-161">選擇性節點名稱可以指定篩選的祖系項目具有特定名稱。</span><span class="sxs-lookup"><span data-stu-id="f061c-161">Optionally a node name can be specified to filter for ancestor elements with a specific name.</span></span>  
  
 <span data-ttu-id="f061c-162">所傳回集合中之節點的順序為反向文件順序。</span><span class="sxs-lookup"><span data-stu-id="f061c-162">The nodes in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="f061c-163">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-163">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f061c-164">傳回這個節點之上階元素的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-164">Returns a collection of the ancestor elements of this node.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-165">
            <see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之祖系項目的 <see cref="T:System.Xml.Linq.XElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-165">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the ancestor elements of this node.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-166">這個方法不會在結果中傳回本身。</span><span class="sxs-lookup"><span data-stu-id="f061c-166">This method does not return itself in the results.</span></span>  
  
 <span data-ttu-id="f061c-167">所傳回集合中之節點的順序為反向文件順序。</span><span class="sxs-lookup"><span data-stu-id="f061c-167">The nodes in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="f061c-168">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-168">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-169">下列範例會使用這個方法來列舉節點上的階。</span><span class="sxs-lookup"><span data-stu-id="f061c-169">The following example uses this method to enumerate the ancestors of a node.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors())  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors()  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="f061c-170">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-170">This example produces the following output:</span></span>  
  
```  
Child  
Root  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f061c-171">要比對的 <see cref="T:System.Xml.Linq.XName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-171">The <see cref="T:System.Xml.Linq.XName" /> to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-172">傳回這個節點的上階元素之篩選的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-172">Returns a filtered collection of the ancestor elements of this node.</span>
          </span>
          <span data-ttu-id="f061c-173">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-173">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-174">
            <see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之祖系項目的 <see cref="T:System.Xml.Linq.XElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-174">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the ancestor elements of this node.</span>
          </span>
          <span data-ttu-id="f061c-175">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-175">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
          <span data-ttu-id="f061c-176">所傳回集合中之節點的順序為反向文件順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-176">The nodes in the returned collection are in reverse document order.</span>
          </span>
          <span data-ttu-id="f061c-177">這個方法會使用延後的執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-177">This method uses deferred execution.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-178">這個方法不會傳回本身在結果中。</span><span class="sxs-lookup"><span data-stu-id="f061c-178">This method will not return itself in the results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-179">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-179">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors("Child"))  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors("Child")  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="f061c-180">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-180">This example produces the following output:</span></span>  
  
```  
Child  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareDocumentOrder">
      <MemberSignature Language="C#" Value="public static int CompareDocumentOrder (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareDocumentOrder(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareDocumentOrder (n1 As XNode, n2 As XNode) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareDocumentOrder(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1">
          <span data-ttu-id="f061c-181">要比較的第一個 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-181">First <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <param name="n2">
          <span data-ttu-id="f061c-182">要比較的第二個 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-182">Second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-183">比較兩個節點，以確定其相對的 XML 文件順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-183">Compares two nodes to determine their relative XML document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-184">
            <see langword="int" /> 包含 0 表示這兩個節點相等，包含 -1 表示 <paramref name="n1" /> 在 <paramref name="n2" /> 之前，包含 1 則表示 <paramref name="n1" /> 在 <paramref name="n2" /> 之後。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-184">An <see langword="int" /> containing 0 if the nodes are equal; -1 if <paramref name="n1" /> is before <paramref name="n2" />; 1 if <paramref name="n1" /> is after <paramref name="n2" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-185"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-185">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-186">這表示<xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A>方法必須周遊直到找到共同的父系所比較的兩個節點的上階。</span><span class="sxs-lookup"><span data-stu-id="f061c-186">This means that the <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="f061c-187">然後，它必須周遊常見父系的子節點，來判斷所比較的兩個節點的順序的清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-187">Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="f061c-188">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-188">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-189">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-189">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1", 1),  
        new XElement("GrandChild2", 2),  
        new XElement("GrandChild3", 3)  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild4", 4),  
        new XElement("GrandChild5", 5),  
        new XElement("GrandChild6", 6)  
    )  
);  
XElement el1 = xmlTree.Descendants("GrandChild2").First();  
XElement el2 = xmlTree.Descendants("GrandChild6").First();  
if (XElement.CompareDocumentOrder(el1, el2) == 0)  
    Console.WriteLine("Compared elements are the same element");  
else if (XElement.CompareDocumentOrder(el1, el2) > 0)  
    Console.WriteLine("el1 is after el2");  
else  
    Console.WriteLine("el1 is before el2");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>  
                <GrandChild1>1</GrandChild1>  
                <GrandChild2>2</GrandChild2>  
                <GrandChild3>3</GrandChild3>  
            </Child1>  
            <Child2>  
                <GrandChild4>4</GrandChild4>  
                <GrandChild5>5</GrandChild5>  
                <GrandChild6>6</GrandChild6>  
            </Child2>  
        </Root>  
  
Dim el1 As XElement = xmlTree...<GrandChild2>(0)  
Dim el2 As XElement = xmlTree...<GrandChild6>(0)  
  
If (XElement.CompareDocumentOrder(el1, el2) = 0) Then  
    Console.WriteLine("Compared elements are the same element")  
ElseIf (XElement.CompareDocumentOrder(el1, el2) > 0) Then  
    Console.WriteLine("el1 is after el2")  
Else  
    Console.WriteLine("el1 is before el2")  
End If  
```  
  
 <span data-ttu-id="f061c-190">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-190">This example produces the following output:</span></span>  
  
```  
el1 is before el2  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f061c-191">這兩個節點不會共用共同的祖系。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-191">The two nodes do not share a common ancestor.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateReader">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-192">建立這個節點的 <see cref="T:System.Xml.XmlReader" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-192">Creates an <see cref="T:System.Xml.XmlReader" /> for this node.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReader () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f061c-193">建立這個節點的 <see cref="T:System.Xml.XmlReader" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-193">Creates an <see cref="T:System.Xml.XmlReader" /> for this node.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-194">
            <see cref="T:System.Xml.XmlReader" />，可用於讀取這個節點及其子代 (Descendant)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-194">An <see cref="T:System.Xml.XmlReader" /> that can be used to read this node and its descendants.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-195">您通常使用這個方法，您必須提供的另一個元件時<xref:System.Xml.XmlReader>。</span><span class="sxs-lookup"><span data-stu-id="f061c-195">You typically use this method when you have to supply another component with an <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="f061c-196">例如，您可以建立<xref:System.Xml.XmlReader>從[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]樹狀結構、，然後將傳遞至該讀取器<xref:System.Xml.XmlDocument.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="f061c-196">For example, you can create an <xref:System.Xml.XmlReader> from a [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] tree, and then pass that reader to <xref:System.Xml.XmlDocument.Load%2A>.</span></span>  
  
 <span data-ttu-id="f061c-197">讀取器所傳回的所有<xref:System.Xml.XmlReader.Create%2A>會正規化讀取器。</span><span class="sxs-lookup"><span data-stu-id="f061c-197">All of the readers returned by <xref:System.Xml.XmlReader.Create%2A> are normalizing readers.</span></span> <span data-ttu-id="f061c-198">此外，它們一定會執行分行符號正規化和屬性的完全正規化。</span><span class="sxs-lookup"><span data-stu-id="f061c-198">They always perform line break normalization and full normalization of attributes.</span></span> <span data-ttu-id="f061c-199">相反地，<xref:System.Xml.XmlReader>傳回<xref:System.Xml.Linq.XNode.CreateReader%2A>不正規化的讀取器。</span><span class="sxs-lookup"><span data-stu-id="f061c-199">In contrast, the <xref:System.Xml.XmlReader> returned by <xref:System.Xml.Linq.XNode.CreateReader%2A> is not a normalizing reader.</span></span> <span data-ttu-id="f061c-200">它不會轉換的任何空白字元。</span><span class="sxs-lookup"><span data-stu-id="f061c-200">It does not transform any white space.</span></span> <span data-ttu-id="f061c-201">它也會傳回屬性而非在屬性名稱順序中所加入的順序。</span><span class="sxs-lookup"><span data-stu-id="f061c-201">It also returns attributes in the order that they were added, not in attribute name order.</span></span>  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]<span data-ttu-id="f061c-202"> 不會保留屬性是否為預設屬性的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="f061c-202"> does not keep information about whether attributes are default attributes.</span></span> <span data-ttu-id="f061c-203"><xref:System.Xml.XmlReader.IsDefault%2A> 一定會傳回 false，不論是否屬性填入預設值或不。</span><span class="sxs-lookup"><span data-stu-id="f061c-203"><xref:System.Xml.XmlReader.IsDefault%2A> will always return false regardless of whether the attribute was populated from a default value or not.</span></span>  
  
 <span data-ttu-id="f061c-204">`PUBLIC`和`SYSTEM`上的虛擬屬性<xref:System.Xml.Linq.XDocumentType>不是可透過<xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-204">The `PUBLIC` and `SYSTEM` pseudo attributes on <xref:System.Xml.Linq.XDocumentType> are not available through the <xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f061c-205">它們只能透過使用而且<xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType>方法會採用做為參數屬性的限定的名稱。</span><span class="sxs-lookup"><span data-stu-id="f061c-205">They are only available through the <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> method that takes the qualified name of the attribute as a parameter.</span></span> <span data-ttu-id="f061c-206">如果您必須擷取`PUBLIC`或`SYSTEM`屬性，您應該使用<xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-206">If you have to retrieve the `PUBLIC` or `SYSTEM` attributes, you should use the <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f061c-207">不支援 Base64 和 BinHex 資料。</span><span class="sxs-lookup"><span data-stu-id="f061c-207">Base64 and BinHex data are not supported.</span></span> <span data-ttu-id="f061c-208">如果您嘗試擷取這些資料型別 (例如，藉由呼叫<xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>)，讀取器將會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f061c-208">If you attempt to retrieve these types of data (for example, by calling <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>), the reader will throw <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f061c-209">`xml`宣告不會顯示讀取器。</span><span class="sxs-lookup"><span data-stu-id="f061c-209">The `xml` declaration is not surfaced by the reader.</span></span> <span data-ttu-id="f061c-210">讀取時不會遇到的型別節點<xref:System.Xml.XmlNodeType.XmlDeclaration>。</span><span class="sxs-lookup"><span data-stu-id="f061c-210">While reading, you will not encounter a node of type <xref:System.Xml.XmlNodeType.XmlDeclaration>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-211">下列範例會建立 XML 樹狀結構，然後建立<xref:System.Xml.XmlReader>使用<xref:System.Xml.Linq.XNode.CreateReader%2A>方法，並建立<xref:System.Xml.XmlDocument>使用讀取器。</span><span class="sxs-lookup"><span data-stu-id="f061c-211">The following example creates an XML tree, creates an <xref:System.Xml.XmlReader> by using the <xref:System.Xml.Linq.XNode.CreateReader%2A> method, and creates an <xref:System.Xml.XmlDocument> by using the reader.</span></span>  
  
```csharp  
XDocument xmlTree = new XDocument(  
    new XElement("Root",  
        new XAttribute("Att1", "Attribute Content"),  
        new XElement("Child1", 1),  
        new XElement("Child2", 2)  
    )  
);  
XmlReader reader = xmlTree.CreateReader();  
reader.MoveToContent();  
XmlDocument doc = new XmlDocument();  
XmlNode cd = doc.ReadNode(reader);  
doc.AppendChild(cd);  
Console.WriteLine(doc.OuterXml);  
```  
  
```vb  
Dim xmlTree As XDocument =  _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <Root Att1="Attribute Content">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
        </Root>  
Dim reader As XmlReader = xmlTree.CreateReader()  
reader.MoveToContent()  
Dim doc As XmlDocument = New XmlDocument()  
Dim cd As XmlNode = doc.ReadNode(reader)  
doc.AppendChild(cd)  
Console.WriteLine(doc.OuterXml)  
```  
  
 <span data-ttu-id="f061c-212">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-212">This example produces the following output:</span></span>  
  
```xml  
<Root Att1="Attribute Content"><Child1>1</Child1><Child2>2</Child2></Root>  
```  
  
 <span data-ttu-id="f061c-213">這個方法的另一個用途是執行 XSLT 轉換。</span><span class="sxs-lookup"><span data-stu-id="f061c-213">Another use for this method is to do an XSLT transformation.</span></span> <span data-ttu-id="f061c-214">您可以建立 XML 樹狀結構、從 XML 樹狀結構建立 <xref:System.Xml.XmlReader>、建立新文件，然後建立將寫入新文件中的 <xref:System.Xml.XmlWriter>。</span><span class="sxs-lookup"><span data-stu-id="f061c-214">You can create an XML tree, create an <xref:System.Xml.XmlReader> from the XML tree, create a new document, and create an <xref:System.Xml.XmlWriter> that will write into the new document.</span></span> <span data-ttu-id="f061c-215">然後，您可以叫用 (Invoke) XSLT 轉換，將 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 傳遞至轉換。</span><span class="sxs-lookup"><span data-stu-id="f061c-215">Then, you can invoke the XSLT transformation, passing the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> to the transformation.</span></span> <span data-ttu-id="f061c-216">轉換成功完成後，系統會使用轉換的結果填入新的 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-216">After the transformation successfully completes, the new XML tree is populated with the results of the transform.</span></span>  
  
```csharp  
string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1>  
            <xsl:value-of select='Child1'/>  
            </C1>  
            <C2>  
            <xsl:value-of select='Child2'/>  
            </C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
Dim xslMarkup As XDocument = _   
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1>  
                    <xsl:value-of select='Child1'/>  
                </C1>  
                <C2>  
                    <xsl:value-of select='Child2'/>  
                </C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XElement = _   
        <Parent>  
            <Child1>Child1 data</Child1>  
            <Child2>Child2 data</Child2>  
        </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 <span data-ttu-id="f061c-217">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-217">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader (System.Xml.Linq.ReaderOptions readerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader(valuetype System.Xml.Linq.ReaderOptions readerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader(System::Xml::Linq::ReaderOptions readerOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerOptions" Type="System.Xml.Linq.ReaderOptions" />
      </Parameters>
      <Docs>
        <param name="readerOptions">
          <span data-ttu-id="f061c-218">
            <see cref="T:System.Xml.Linq.ReaderOptions" /> 物件，指定是否要省略重複的命名空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-218">A <see cref="T:System.Xml.Linq.ReaderOptions" /> object that specifies whether to omit duplicate namespaces.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-219">使用 <paramref name="readerOptions" /> 參數指定的選項建立 <see cref="T:System.Xml.XmlReader" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-219">Creates an <see cref="T:System.Xml.XmlReader" /> with the options specified by the <paramref name="readerOptions" /> parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-220">
            <see cref="T:System.Xml.XmlReader" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-220">An <see cref="T:System.Xml.XmlReader" /> object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeepEquals">
      <MemberSignature Language="C#" Value="public static bool DeepEquals (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeepEquals(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeepEquals (n1 As XNode, n2 As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeepEquals(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1">
          <span data-ttu-id="f061c-221">要比較的第一個 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-221">The first <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <param name="n2">
          <span data-ttu-id="f061c-222">要比較的第二個 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-222">The second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-223">比較兩個節點的值，包括所有子系節點的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-223">Compares the values of two nodes, including the values of all descendant nodes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-224">如果兩個節點相等則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-224">
              <see langword="true" /> if the nodes are equal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-225">下列準則判斷兩個節點是否相等：</span><span class="sxs-lookup"><span data-stu-id="f061c-225">The following criteria determine whether two nodes are equal:</span></span>  
  
-   <span data-ttu-id="f061c-226">A`null`節點是否等於另一個`null`節點但不相等為非`null`節點。</span><span class="sxs-lookup"><span data-stu-id="f061c-226">A `null` node is equal to another `null` node but unequal to a non-`null` node.</span></span>  
  
-   <span data-ttu-id="f061c-227">兩個<xref:System.Xml.Linq.XNode>不同類型的物件是否不相等。</span><span class="sxs-lookup"><span data-stu-id="f061c-227">Two <xref:System.Xml.Linq.XNode> objects of different types are never equal.</span></span>  
  
-   <span data-ttu-id="f061c-228">兩個<xref:System.Xml.Linq.XText>節點是否相等，如果它們包含相同的文字。</span><span class="sxs-lookup"><span data-stu-id="f061c-228">Two <xref:System.Xml.Linq.XText> nodes are equal if they contain the same text.</span></span>  
  
-   <span data-ttu-id="f061c-229">兩個<xref:System.Xml.Linq.XElement>節點相等，如果它們有相同的標記名稱相同的相同的值的屬性集，且 （忽略註解和處理指示） 包含兩個長度相等的相等的內容節點的序列。</span><span class="sxs-lookup"><span data-stu-id="f061c-229">Two <xref:System.Xml.Linq.XElement> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.</span></span>  
  
-   <span data-ttu-id="f061c-230">兩個<xref:System.Xml.Linq.XDocument>節點相等，其根節點是否相等。</span><span class="sxs-lookup"><span data-stu-id="f061c-230">Two <xref:System.Xml.Linq.XDocument> nodes are equal if their root nodes are equal.</span></span>  
  
-   <span data-ttu-id="f061c-231">兩個<xref:System.Xml.Linq.XComment>節點是否相等，如果它們包含相同的註解文字。</span><span class="sxs-lookup"><span data-stu-id="f061c-231">Two <xref:System.Xml.Linq.XComment> nodes are equal if they contain the same comment text.</span></span>  
  
-   <span data-ttu-id="f061c-232">兩個<xref:System.Xml.Linq.XProcessingInstruction>節點是否相等，如果它們有相同的目標和資料。</span><span class="sxs-lookup"><span data-stu-id="f061c-232">Two <xref:System.Xml.Linq.XProcessingInstruction> nodes are equal if they have the same target and data.</span></span>  
  
-   <span data-ttu-id="f061c-233">兩個<xref:System.Xml.Linq.XDocumentType>節點相等如果具有相同名稱、 公用識別碼、 系統識別碼和內部子集。</span><span class="sxs-lookup"><span data-stu-id="f061c-233">Two <xref:System.Xml.Linq.XDocumentType> nodes are equal if the have the same name, public ID, system ID, and internal subset.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-234">下列範例會使用這個方法來比較兩個 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-234">The following example uses this method to compare two XML trees.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XElement xmlTree2 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2));  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2))  
```  
  
 <span data-ttu-id="f061c-235">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-235">This example produces the following output:</span></span>  
  
```  
True  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentOrderComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.DocumentOrderComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DocumentOrderComparer As XNodeDocumentOrderComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeDocumentOrderComparer ^ DocumentOrderComparer { System::Xml::Linq::XNodeDocumentOrderComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeDocumentOrderComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-236">取得可比較兩個節點相對位置的比較子 (Comparer)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-236">Gets a comparer that can compare the relative position of two nodes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f061c-237">可比較兩個節點相對位置的 <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-237">An <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /> that can compare the relative position of two nodes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-238">這個屬性主要用於在內部實作<xref:System.Xml.Linq.Extensions.InDocumentOrder%2A>擴充方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-238">This property is primarily used internally for implementing the <xref:System.Xml.Linq.Extensions.InDocumentOrder%2A> extension method.</span></span> <span data-ttu-id="f061c-239">建議的方法是使用該擴充方法，而不是直接使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="f061c-239">The recommended approach is to use that extension method instead of using this property directly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-240">下列範例會建立 XML 樹狀結構的某些項目。</span><span class="sxs-lookup"><span data-stu-id="f061c-240">The following example creates an XML tree with some elements.</span></span> <span data-ttu-id="f061c-241">然後它會建立<xref:System.Collections.Generic.List%601>的<xref:System.Xml.Linq.XNode>隨機包含從 XML 樹狀結構的某些項目。</span><span class="sxs-lookup"><span data-stu-id="f061c-241">It then creates a <xref:System.Collections.Generic.List%601> of <xref:System.Xml.Linq.XNode> that contains some elements from the XML tree at random.</span></span> <span data-ttu-id="f061c-242">排序清單中，使用這個屬性來擷取<xref:System.Xml.Linq.XNodeDocumentOrderComparer>，它會實作<xref:System.Collections.IComparer?displayProperty=nameWithType>和<xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType>介面。</span><span class="sxs-lookup"><span data-stu-id="f061c-242">It sorts the list, using this property to retrieve a <xref:System.Xml.Linq.XNodeDocumentOrderComparer>, which implements the <xref:System.Collections.IComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> interfaces.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
List<XNode> nodeList = new List<XNode>();  
nodeList.Add(xmlTree.Element("Child5"));  
nodeList.Add(xmlTree.Element("Child3"));  
nodeList.Add(xmlTree.Element("Child1"));  
  
// Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer);  
  
foreach (XElement el in nodeList)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeList As List(Of XNode) = New List(Of XNode)()  
nodeList.Add(xmlTree.Element("Child5"))  
nodeList.Add(xmlTree.Element("Child3"))  
nodeList.Add(xmlTree.Element("Child1"))  
  
' Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer)  
  
For Each el In nodeList  
    Console.WriteLine(el)  
Next  
```  
  
 <span data-ttu-id="f061c-243">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-243">This example produces the following output:</span></span>  
  
```  
<Child1>1</Child1>  
<Child3>3</Child3>  
<Child5>5</Child5>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-244">依照文件順序，傳回這個節點之後同層級項目的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-244">Returns a collection of the sibling elements after this node, in document order.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-245">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-245">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f061c-246">依照文件順序，傳回這個節點之後同層級項目的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-246">Returns a collection of the sibling elements after this node, in document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-247">
            <see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之後同層級項目 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-247">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements after this node, in document order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-248">這個方法只會傳回集合中包含的同層級。</span><span class="sxs-lookup"><span data-stu-id="f061c-248">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="f061c-249">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="f061c-249">It does not include descendants.</span></span>  
  
 <span data-ttu-id="f061c-250">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-250">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-251">下列範例會建立具有某些複雜內容的元素。</span><span class="sxs-lookup"><span data-stu-id="f061c-251">The following example creates an element with some complex content.</span></span> <span data-ttu-id="f061c-252">然後，它會使用這個方法來擷取文件順序中的節點。</span><span class="sxs-lookup"><span data-stu-id="f061c-252">It then uses this method to retrieve the nodes in document order.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf()  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="f061c-253">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-253">This example produces the following output:</span></span>  
  
```  
Child4  
Child5  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f061c-254">要比對的 <see cref="T:System.Xml.Linq.XName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-254">The <see cref="T:System.Xml.Linq.XName" /> to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-255">依照文件順序，傳回這個節點之後同層級項目之篩選的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-255">Returns a filtered collection of the sibling elements after this node, in document order.</span>
          </span>
          <span data-ttu-id="f061c-256">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-256">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-257">
            <see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之後同層級項目 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-257">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements after this node, in document order.</span>
          </span>
          <span data-ttu-id="f061c-258">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-258">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-259">這個方法只會傳回集合中包含的同層級。</span><span class="sxs-lookup"><span data-stu-id="f061c-259">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="f061c-260">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="f061c-260">It does not include descendants.</span></span>  
  
 <span data-ttu-id="f061c-261">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-261">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-262">下列範例會建立具有某些複雜內容的元素。</span><span class="sxs-lookup"><span data-stu-id="f061c-262">The following example creates an element with some complex content.</span></span> <span data-ttu-id="f061c-263">然後，它會使用這個方法來擷取文件順序中的同層級項目。</span><span class="sxs-lookup"><span data-stu-id="f061c-263">It then uses this method to retrieve the sibling elements, in document order.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf("Child4");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf("Child4")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="f061c-264">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-264">This example produces the following output:</span></span>  
  
```  
Child4  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-265">依照文件順序，傳回這個節點之前同層級項目的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-265">Returns a collection of the sibling elements before this node, in document order.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-266">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-266">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f061c-267">依照文件順序，傳回這個節點之前同層級項目的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-267">Returns a collection of the sibling elements before this node, in document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-268">
            <see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之前同層級項目 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-268">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements before this node, in document order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-269">這個方法只會傳回集合中包含的同層級。</span><span class="sxs-lookup"><span data-stu-id="f061c-269">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="f061c-270">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="f061c-270">It does not include descendants.</span></span>  
  
 <span data-ttu-id="f061c-271">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-271">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-272">下列範例會使用此座標軸方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-272">The following example uses this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf()  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="f061c-273">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-273">This example produces the following output:</span></span>  
  
```  
Child1  
Child2  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="f061c-274">要比對的 <see cref="T:System.Xml.Linq.XName" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-274">The <see cref="T:System.Xml.Linq.XName" /> to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-275">依照文件順序，傳回這個節點之前同層級項目之篩選的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-275">Returns a filtered collection of the sibling elements before this node, in document order.</span>
          </span>
          <span data-ttu-id="f061c-276">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-276">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-277">
            <see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之前同層級項目 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XElement" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-277">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements before this node, in document order.</span>
          </span>
          <span data-ttu-id="f061c-278">集合中只會包含具有相符之 <see cref="T:System.Xml.Linq.XName" /> 的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-278">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-279">這個方法只會傳回集合中包含的同層級。</span><span class="sxs-lookup"><span data-stu-id="f061c-279">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="f061c-280">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="f061c-280">It does not include descendants.</span></span>  
  
 <span data-ttu-id="f061c-281">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-281">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-282">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-282">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf("Child2");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf("Child2")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="f061c-283">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-283">This example produces the following output:</span></span>  
  
```  
Child2  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EqualityComparer As XNodeEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeEqualityComparer ^ EqualityComparer { System::Xml::Linq::XNodeEqualityComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-284">取得可比較兩個節點值是否相等的比較子。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-284">Gets a comparer that can compare two nodes for value equality.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f061c-285">可比較兩個節點值是否相等的 <see cref="T:System.Xml.Linq.XNodeEqualityComparer" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-285">A <see cref="T:System.Xml.Linq.XNodeEqualityComparer" /> that can compare two nodes for value equality.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f061c-286">下列範例會使用這個屬性來擷取<xref:System.Xml.Linq.XNodeEqualityComparer>，它會實作<xref:System.Collections.IEqualityComparer?displayProperty=nameWithType>和<xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType>介面。</span><span class="sxs-lookup"><span data-stu-id="f061c-286">The following example uses this property to retrieve an <xref:System.Xml.Linq.XNodeEqualityComparer>, which implements the <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType> interfaces.</span></span> <span data-ttu-id="f061c-287">它會建立字典，其中會使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="f061c-287">It creates a dictionary that uses this property.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
Dictionary<XNode, string> nodeDictionary = new Dictionary<XNode, string>(XNode.EqualityComparer);  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information");  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information");  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information");  
  
string str = nodeDictionary[xmlTree.Element("Child3")];  
Console.WriteLine(str);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeDictionary As Dictionary(Of XNode, String) = New Dictionary(Of XNode, String)(XNode.EqualityComparer)  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information")  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information")  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information")  
  
Dim str As String = nodeDictionary(xmlTree.Element("Child3"))  
Console.WriteLine(str)  
```  
  
 <span data-ttu-id="f061c-288">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-288">This example produces the following output:</span></span>  
  
```  
Child 3 Information  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAfter">
      <MemberSignature Language="C#" Value="public bool IsAfter (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAfter(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAfter (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAfter(System::Xml::Linq::XNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <span data-ttu-id="f061c-289">要針對文件順序比較的 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-289">The <see cref="T:System.Xml.Linq.XNode" /> to compare for document order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-290">根據文件順序，判斷目前的節點是否出現在指定的節點之後。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-290">Determines if the current node appears after a specified node in terms of document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-291">如果這個節點出現在指定的節點之後則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-291">
              <see langword="true" /> if this node appears after the specified node; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-292"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-292">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-293">這表示<xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A>方法必須周遊直到找到共同的父系所比較的兩個節點的上階。</span><span class="sxs-lookup"><span data-stu-id="f061c-293">This means that the <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="f061c-294">然後，它必須周遊常見父系的子節點，來判斷所比較的兩個節點的順序的清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-294">Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="f061c-295">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-295">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-296">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-296">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsAfter(child3))  
    Console.WriteLine("Child5 is after Child3");  
else  
    Console.WriteLine("Child5 is not after Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsAfter(child3)) Then  
    Console.WriteLine("Child5 is after Child3")  
Else  
    Console.WriteLine("Child5 is not after Child3")  
End If  
```  
  
 <span data-ttu-id="f061c-297">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-297">This example produces the following output:</span></span>  
  
```  
Child5 is after Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBefore">
      <MemberSignature Language="C#" Value="public bool IsBefore (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBefore(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBefore (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBefore(System::Xml::Linq::XNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <span data-ttu-id="f061c-298">要針對文件順序比較的 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-298">The <see cref="T:System.Xml.Linq.XNode" /> to compare for document order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-299">根據文件順序，判斷目前的節點是否出現在指定的節點之前。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-299">Determines if the current node appears before a specified node in terms of document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-300">如果這個節點出現在指定的節點之前則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-300">
              <see langword="true" /> if this node appears before the specified node; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-301"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-301">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-302">這表示<xref:System.Xml.Linq.XNode.IsBefore%2A>方法必須周遊直到找到共同的父系所比較的兩個節點的上階。</span><span class="sxs-lookup"><span data-stu-id="f061c-302">This means that the <xref:System.Xml.Linq.XNode.IsBefore%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="f061c-303">然後，它必須周遊常見父系的子節點，來判斷所比較的兩個節點的順序的清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-303">Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="f061c-304">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-304">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-305">下列範例會使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-305">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsBefore(child3))  
    Console.WriteLine("Child5 is before Child3");  
else  
    Console.WriteLine("Child5 is not before Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsBefore(child3)) Then  
    Console.WriteLine("Child5 is before Child3")  
Else  
    Console.WriteLine("Child5 is not before Child3")  
End If  
```  
  
 <span data-ttu-id="f061c-306">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-306">This example produces the following output:</span></span>  
  
```  
Child5 is not before Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode NextNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode NextNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.NextNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ NextNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-307">取得這個節點的下一個同層級 (Sibling) 節點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-307">Gets the next sibling node of this node.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f061c-308">包含下一個同層級節點的 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-308">The <see cref="T:System.Xml.Linq.XNode" /> that contains the next sibling node.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-309">如果這個<xref:System.Xml.Linq.XNode>並沒有父代，或如果沒有下一個節點，此屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="f061c-309">If this <xref:System.Xml.Linq.XNode> does not have a parent, or if there is no next node, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-310">下列範例會使用這個屬性的節點執行迴圈。</span><span class="sxs-lookup"><span data-stu-id="f061c-310">The following example uses this property to loop through nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.NextNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>Some Text  
            <Child2>2  
                <GrandChild>GrandChild Content</GrandChild>  
            </Child2>  
            <!--a comment-->  
            <Child3>3</Child3>  
        </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.NextNode  
Loop While (Not (node Is Nothing))  
```  
  
 <span data-ttu-id="f061c-311">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-311">This example produces the following output:</span></span>  
  
```  
NodeType: Element   Child2  
NodeType: Comment   a comment  
NodeType: Element   Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodesAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesAfterSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesAfterSelf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f061c-312">依照文件順序，傳回這個節點之後同層級節點的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-312">Returns a collection of the sibling nodes after this node, in document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-313">
            <see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之後同層級節點 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-313">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> of the sibling nodes after this node, in document order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-314">這個方法只會傳回集合中包含的同層級。</span><span class="sxs-lookup"><span data-stu-id="f061c-314">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="f061c-315">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="f061c-315">It does not include descendants.</span></span>  
  
 <span data-ttu-id="f061c-316">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-316">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-317">下列範例會建立 XML 樹狀結構，並接著會查詢樹狀目錄中使用此座標軸方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-317">The following example creates an XML tree, and then queries the tree using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesAfterSelf()  
    select node;  
foreach (XNode node in nodes)  
{  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
}  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesAfterSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 <span data-ttu-id="f061c-318">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-318">This example produces the following output:</span></span>  
  
```  
Node type: Text  More text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodesBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesBeforeSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesBeforeSelf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f061c-319">依照文件順序，傳回這個節點之前同層級節點的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-319">Returns a collection of the sibling nodes before this node, in document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-320">
            <see cref="T:System.Collections.Generic.IEnumerable`1" />，屬於這個節點之前同層級節點 (依照文件順序) 的 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-320">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> of the sibling nodes before this node, in document order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-321">這個方法只會傳回集合中包含的同層級。</span><span class="sxs-lookup"><span data-stu-id="f061c-321">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="f061c-322">它不包含子系。</span><span class="sxs-lookup"><span data-stu-id="f061c-322">It does not include descendants.</span></span>  
  
 <span data-ttu-id="f061c-323">這個方法會使用延後的執行。</span><span class="sxs-lookup"><span data-stu-id="f061c-323">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-324">下列範例會建立 XML 樹狀結構，並接著會查詢樹狀目錄中使用此座標軸方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-324">The following example creates an XML tree, and then queries the tree using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesBeforeSelf()  
    select node;  
foreach (XNode node in nodes)  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _  
    New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesBeforeSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 <span data-ttu-id="f061c-325">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-325">This example produces the following output:</span></span>  
  
```  
Node type: Text  Text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode PreviousNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode PreviousNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.PreviousNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ PreviousNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-326">取得這個節點的上一個同層級節點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-326">Gets the previous sibling node of this node.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f061c-327">包含上一個同層級節點的 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-327">The <see cref="T:System.Xml.Linq.XNode" /> that contains the previous sibling node.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-328">如果這個<xref:System.Xml.Linq.XNode>並沒有父代，或如果沒有上一個節點，這個屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="f061c-328">If this <xref:System.Xml.Linq.XNode> does not have a parent, or if there is no previous node, this property returns `null`.</span></span>  
  
 <span data-ttu-id="f061c-329"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-329">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-330">這表示<xref:System.Xml.Linq.XNode.PreviousNode%2A>屬性必須周遊於父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-330">This means that the <xref:System.Xml.Linq.XNode.PreviousNode%2A> property must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="f061c-331">因此，使用這個屬性可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-331">Therefore, using this property might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-332">下列範例會使用這個屬性的節點執行迴圈。</span><span class="sxs-lookup"><span data-stu-id="f061c-332">The following example uses this property to loop through nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.PreviousNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>Some Text<Child2>2  
            <GrandChild>GrandChild Content</GrandChild>  
        </Child2>  
        <!--a comment-->  
        <Child3>3</Child3>  
    </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.PreviousNode  
Loop While (Not (node Is Nothing))  
```  
  
 <span data-ttu-id="f061c-333">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-333">This example produces the following output:</span></span>  
  
```  
NodeType: Element   Child2  
NodeType: Text      Some Text  
NodeType: Element   Child1  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadFrom">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNode ReadFrom (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XNode ReadFrom(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadFrom (reader As XmlReader) As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XNode ^ ReadFrom(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="f061c-334">
            <see cref="T:System.Xml.XmlReader" /> 位於節點，以讀入這個 <see cref="T:System.Xml.Linq.XNode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-334">An <see cref="T:System.Xml.XmlReader" /> positioned at the node to read into this <see cref="T:System.Xml.Linq.XNode" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-335">從 <see cref="T:System.Xml.Linq.XNode" /> 建立 <see cref="T:System.Xml.XmlReader" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-335">Creates an <see cref="T:System.Xml.Linq.XNode" /> from an <see cref="T:System.Xml.XmlReader" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-336">
            <see cref="T:System.Xml.Linq.XNode" />，包含從讀取器讀取的節點及其子代節點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-336">An <see cref="T:System.Xml.Linq.XNode" /> that contains the node and its descendant nodes that were read from the reader.</span>
          </span>
          <span data-ttu-id="f061c-337">節點的執行階段型別是由讀取器中遇到的第一個節點的節點型別 (<see cref="P:System.Xml.Linq.XObject.NodeType" />) 決定的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-337">The runtime type of the node is determined by the node type (<see cref="P:System.Xml.Linq.XObject.NodeType" />) of the first node encountered in the reader.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-338">撰寫方法，這個方法會傳回節點的集合，而產生的每個節點，從讀取器讀取的節點時，您可以使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-338">You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader.</span></span> <span data-ttu-id="f061c-339">這個方法可讓您處理非常大的 XML 檔案，以非常小的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="f061c-339">This method enables you to process arbitrarily large XML files with a very small memory footprint.</span></span>  
  
 <span data-ttu-id="f061c-340">您傳遞給這個方法的讀取器可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f061c-340">The reader that you pass to this method might throw exceptions.</span></span> <span data-ttu-id="f061c-341"><xref:System.Xml.Linq.XNode.ReadFrom%2A> 不會攔截所有的讀取器，所擲回的例外狀況未處理的例外狀況反昇至呼叫的程式碼<xref:System.Xml.Linq.XNode.ReadFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="f061c-341"><xref:System.Xml.Linq.XNode.ReadFrom%2A> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <xref:System.Xml.Linq.XNode.ReadFrom%2A>.</span></span> <span data-ttu-id="f061c-342">特別是，您的程式碼應該準備好處理<xref:System.Xml.XmlException>。</span><span class="sxs-lookup"><span data-stu-id="f061c-342">In particular, your code should be prepared to handle <xref:System.Xml.XmlException>.</span></span>  
  
 <span data-ttu-id="f061c-343">如需如何將串流處理的更複雜的文件的範例，請參閱[How to： 標頭資訊的存取權的資料流 XML 片段](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)。</span><span class="sxs-lookup"><span data-stu-id="f061c-343">For an example of how to stream a more complex document, see [How to: Stream XML Fragments with Access to Header Information](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span></span>  
  
 <span data-ttu-id="f061c-344">特定的標準查詢運算子 (例如，<xref:System.Linq.Enumerable.OrderBy%2A>) 會反覆查看其來源、收集所有資料、排序這些資料，最後產生順序中的第一個項目。</span><span class="sxs-lookup"><span data-stu-id="f061c-344">Certain standard query operators, such as <xref:System.Linq.Enumerable.OrderBy%2A>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</span></span> <span data-ttu-id="f061c-345">如果您使用具體化其來源產生第一個項目前的查詢運算子，將不會保留小的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="f061c-345">If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</span></span>  
  
 <span data-ttu-id="f061c-346">如需使用[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]轉換非常大的 XML 文件，同時維護小的記憶體使用量，請參閱 <<c2> [ 如何： 執行資料流轉換大型 XML 文件的](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)。</span><span class="sxs-lookup"><span data-stu-id="f061c-346">For an example of using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] to transform extremely large XML documents while maintaining a small memory footprint, see [How to: Perform Streaming Transform of Large XML Documents](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-347">這個範例會使用下列的 XML 檔案，名為 Source.xml:</span><span class="sxs-lookup"><span data-stu-id="f061c-347">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 <span data-ttu-id="f061c-348">這個範例會建立使用自訂座標軸方法<xref:System.Xml.Linq.XNode.ReadFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="f061c-348">This example creates a custom axis method that uses <xref:System.Xml.Linq.XNode.ReadFrom%2A>.</span></span> <span data-ttu-id="f061c-349">您可以使用 LINQ 查詢來查詢，自訂座標軸。</span><span class="sxs-lookup"><span data-stu-id="f061c-349">You can query the custom axis by using a LINQ query.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f061c-350">下列範例會使用 yield 傳回建構的 C#。</span><span class="sxs-lookup"><span data-stu-id="f061c-350">The following example uses the yield return construct of C#.</span></span> <span data-ttu-id="f061c-351">在 [!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)] 中沒有同等的功能，因此，只有在 C# 中提供這個範例。</span><span class="sxs-lookup"><span data-stu-id="f061c-351">Because there is no equivalent feature in [!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)], this example is provided only in C#.</span></span>  
  
```csharp  
class Program  
{  
    static IEnumerable<XElement> StreamRootChildDoc(string uri)  
    {  
        using (XmlReader reader = XmlReader.Create(uri))  
        {  
            reader.MoveToContent();  
            // Parse the file and display each of the nodes.  
            while (reader.Read())  
            {  
                switch (reader.NodeType)  
                {  
                    case XmlNodeType.Element:  
                        if (reader.Name == "Child")  
                        {  
                            XElement el = XElement.ReadFrom(reader) as XElement;  
                            if (el != null)  
                                yield return el;  
                        }  
                        break;  
                }  
            }  
        }  
    }  
  
    static void Main(string[] args)  
    {  
        IEnumerable<string> grandChildData =  
            from el in StreamRootChildDoc("Source.xml")  
            where (int)el.Attribute("Key") > 1  
            select (string)el.Element("GrandChild");  
  
        foreach (string str in grandChildData)  
            Console.WriteLine(str);  
    }  
}  
```  
  
 <span data-ttu-id="f061c-352">此範例會產生下列輸出。</span><span class="sxs-lookup"><span data-stu-id="f061c-352">This example produces the following output.</span></span>  
  
```  
bbb  
ccc  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f061c-353">
            <see cref="T:System.Xml.XmlReader" /> 未位於可識別的節點型別上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-353">The <see cref="T:System.Xml.XmlReader" /> is not positioned on a recognized node type.</span>
          </span>
        </exception>
        <exception cref="T:System.Xml.XmlException">
          <span data-ttu-id="f061c-354">基礎 <see cref="T:System.Xml.XmlReader" /> 會擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-354">The underlying <see cref="T:System.Xml.XmlReader" /> throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadFromAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt; ReadFromAsync (System.Xml.XmlReader reader, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XNode&gt; ReadFromAsync(class System.Xml.XmlReader reader, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFromAsync(System.Xml.XmlReader,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XNode ^&gt; ^ ReadFromAsync(System::Xml::XmlReader ^ reader, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f061c-355">將這個節點從其父代 (Parent) 移除。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-355">Removes this node from its parent.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-356">在[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]程式設計，您應該不操作或修改的一組節點，而您要查詢該集中的節點。</span><span class="sxs-lookup"><span data-stu-id="f061c-356">In [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set.</span></span> <span data-ttu-id="f061c-357">實際上，這表示您應該不反覆查看的節點集並將它們移除。</span><span class="sxs-lookup"><span data-stu-id="f061c-357">In practical terms, this means that you should not iterate over a set of nodes and remove them.</span></span> <span data-ttu-id="f061c-358">相反地，您應該將這些集合具體化到<xref:System.Collections.Generic.List%601>使用<xref:System.Linq.Enumerable.ToList%2A>擴充方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-358">Instead, you should materialize them into a <xref:System.Collections.Generic.List%601> by using the <xref:System.Linq.Enumerable.ToList%2A> extension method.</span></span> <span data-ttu-id="f061c-359">然後，您可以逐一查看要移除的節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-359">Then, you can iterate over the list to remove the nodes.</span></span> <span data-ttu-id="f061c-360">如需詳細資訊，請參閱[混合宣告式程式碼/命令式程式碼 Bug (LINQ to XML)](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)。</span><span class="sxs-lookup"><span data-stu-id="f061c-360">For more information, see [Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094).</span></span>  
  
 <span data-ttu-id="f061c-361">或者，如果您想要移除的節點集，建議您使用<xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-361">Alternatively, if you want to remove a set of nodes, it is recommended that you use the <xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f061c-362">這個方法會將節點複製到清單，並接著逐一查看要移除的節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-362">This method copies the nodes to a list, and then iterates over the list to remove the nodes.</span></span>  
  
 <span data-ttu-id="f061c-363">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-363">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="f061c-364"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-364">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-365">這表示<xref:System.Xml.Linq.XNode.Remove%2A>方法必須周遊於父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-365">This means that the <xref:System.Xml.Linq.XNode.Remove%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="f061c-366">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-366">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-367">下列範例會從其父代移除節點。</span><span class="sxs-lookup"><span data-stu-id="f061c-367">The following example removes a node from its parent.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.Remove();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.Remove()  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-368">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-368">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f061c-369">該父代為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-369">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceWith">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-370">以指定的內容取代這個節點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-370">Replaces this node with the specified content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-371">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-371">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-372">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-372">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="f061c-373"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-373">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-374">這表示<xref:System.Xml.Linq.XNode.ReplaceWith%2A>方法必須周遊於父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-374">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must  traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="f061c-375">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-375">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-376">下列範例會使用這個方法，以不同的內容取代節點的內容。</span><span class="sxs-lookup"><span data-stu-id="f061c-376">The following example uses this method to replace the contents of a node with different content.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-377">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-377">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="f061c-378">取代這個節點的內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-378">Content that replaces this node.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-379">以指定的內容取代這個節點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-379">Replaces this node with the specified content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-380">這個方法會先移除此節點從其父代，並將其指定的內容加入這個節點的父代，取代這個節點。</span><span class="sxs-lookup"><span data-stu-id="f061c-380">This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</span></span>  
  
 <span data-ttu-id="f061c-381"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-381">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-382">這表示<xref:System.Xml.Linq.XNode.ReplaceWith%2A>方法必須周遊於父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-382">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="f061c-383">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-383">Therefore, using this method might affect your performance.</span></span>  
  
 <span data-ttu-id="f061c-384">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-384">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-385">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-385">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-386">下列範例會使用這個方法，以不同的內容取代節點的內容。</span><span class="sxs-lookup"><span data-stu-id="f061c-386">The following example uses this method to replace the contents of a node with different content.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-387">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-387">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="f061c-388">新內容的參數清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-388">A parameter list of the new content.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-389">以指定的內容取代這個節點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-389">Replaces this node with the specified content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-390">這個方法會先移除此節點從其父代，並將其指定的內容加入這個節點的父代，取代這個節點。</span><span class="sxs-lookup"><span data-stu-id="f061c-390">This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</span></span>  
  
 <span data-ttu-id="f061c-391"><xref:System.Xml.Linq.XContainer>儲存為單向連結清單的子節點<xref:System.Xml.Linq.XNode>物件。</span><span class="sxs-lookup"><span data-stu-id="f061c-391">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="f061c-392">這表示<xref:System.Xml.Linq.XNode.ReplaceWith%2A>方法必須周遊於父容器下的直接子節點清單。</span><span class="sxs-lookup"><span data-stu-id="f061c-392">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="f061c-393">因此，使用這個方法可能會影響您的效能。</span><span class="sxs-lookup"><span data-stu-id="f061c-393">Therefore, using this method might affect your performance.</span></span>  
  
 <span data-ttu-id="f061c-394">如需可以傳遞至這個方法的有效內容的詳細資訊，請參閱[有效內容的 XElement 和 XDocument 物件](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)。</span><span class="sxs-lookup"><span data-stu-id="f061c-394">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="f061c-395">這個方法會引發<xref:System.Xml.Linq.XObject.Changed>和<xref:System.Xml.Linq.XObject.Changing>事件。</span><span class="sxs-lookup"><span data-stu-id="f061c-395">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-396">下列範例示範如何使用結果[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]做為這個方法的輸入查詢。</span><span class="sxs-lookup"><span data-stu-id="f061c-396">The following example shows using the results of a [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] query as the input to this method.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith( _  
    From el In srcTree.Elements() _  
    Where (CInt(el) > 3) _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-397">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-397">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f061c-398">傳回這個節點的 XML (可選擇是否停用格式設定)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-398">Returns the XML for this node, optionally disabling formatting.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f061c-399">針對這個節點傳回縮排的 XML。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-399">Returns the indented XML for this node.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-400">
            <see cref="T:System.String" />，包含縮排的 XML。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-400">A <see cref="T:System.String" /> containing the indented XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f061c-401">下列範例會使用這個方法來擷取縮排的 XML。</span><span class="sxs-lookup"><span data-stu-id="f061c-401">The following example uses this method to retrieve indented XML.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
        </Root>  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="f061c-402">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-402">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="f061c-403">指定格式化行為的 <see cref="T:System.Xml.Linq.SaveOptions" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-403">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-404">傳回這個節點的 XML (可選擇是否停用格式設定)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-404">Returns the XML for this node, optionally disabling formatting.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f061c-405">
            <see cref="T:System.String" />，包含 XML。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-405">A <see cref="T:System.String" /> containing the XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f061c-406">下列範例會使用這個方法來擷取未格式化和格式化 XML。</span><span class="sxs-lookup"><span data-stu-id="f061c-406">The following example uses this method to retrieve unformatted and formatted XML.</span></span>  
  
```csharp  
XElement root = XElement.Parse("<Root><Child/></Root>");  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("---");  
Console.WriteLine(root.ToString(SaveOptions.None));  
```  
  
```vb  
Dim root As XElement = <Root>  
                           <Child/>  
                       </Root>  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("---")  
Console.WriteLine(root.ToString(SaveOptions.None))  
```  
  
 <span data-ttu-id="f061c-407">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-407">This example produces the following output:</span></span>  
  
```  
<Root><Child /></Root>  
---  
<Root>  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public abstract void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="f061c-408">此方法將寫入其中的 <see cref="T:System.Xml.XmlWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-408">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f061c-409">將這個節點寫入 <see cref="T:System.Xml.XmlWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="f061c-409">Writes this node to an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f061c-410">要寫入資料流轉換非常大的文件的程式碼，您可以使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="f061c-410">You can use this method to write code that does a streaming transform of a very large document.</span></span> <span data-ttu-id="f061c-411">如需詳細資訊，請參閱[如何： 執行資料流轉換大型 XML 文件的](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)。</span><span class="sxs-lookup"><span data-stu-id="f061c-411">For more information, see [How to: Perform Streaming Transform of Large XML Documents](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f061c-412">下列範例會建立<xref:System.Xml.XmlWriter>寫入<xref:System.Text.StringBuilder>。</span><span class="sxs-lookup"><span data-stu-id="f061c-412">The following example creates an <xref:System.Xml.XmlWriter> that writes to a <xref:System.Text.StringBuilder>.</span></span> <span data-ttu-id="f061c-413">然後，它會使用這個方法來寫入至寫入器的兩個 XML 樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="f061c-413">It then uses this method to write two XML trees to the writer.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    xw.WriteStartElement("Root");  
    XElement child1 = new XElement("Child",  
        new XElement("GrandChild", "some content")  
    );  
    child1.WriteTo(xw);  
    XElement child2 = new XElement("AnotherChild",  
        new XElement("GrandChild", "different content")  
    );  
    child2.WriteTo(xw);  
    xw.WriteEndElement();  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    xw.WriteStartElement("Root")  
    Dim child1 As XElement = <Child>  
                                 <GrandChild>some content</GrandChild>  
                             </Child>  
    child1.WriteTo(xw)  
    Dim child2 As XElement = <AnotherChild>  
                                 <GrandChild>different content</GrandChild>  
                             </AnotherChild>  
    child2.WriteTo(xw)  
    xw.WriteEndElement()  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="f061c-414">這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="f061c-414">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>  
    <GrandChild>some content</GrandChild>  
  </Child>  
  <AnotherChild>  
    <GrandChild>different content</GrandChild>  
  </AnotherChild>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public abstract System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>